<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Hyunyoun&#39;s 개발 블로그 on hyunyoun&#39;s Blog</title>
    <link>https://buenhyden.github.io/</link>
    <description>Recent content in Hyunyoun&#39;s 개발 블로그 on hyunyoun&#39;s Blog</description>
    <image>
      <title>hyunyoun&#39;s Blog</title>
      <url>https://buenhyden.github.io/images</url>
      <link>https://buenhyden.github.io/images</link>
    </image>
    <generator>Hugo -- 0.147.7</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Jun 2025 03:02:00 +0000</lastBuildDate>
    <atom:link href="https://buenhyden.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Performance vs Scalability</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/performance-vs-scalability/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/performance-vs-scalability/</guid>
      <description>성능 (Performance) 과 확장성 (Scalability) 은 시스템 설계에서 상호 보완적이면서도 때로는 상충하는 핵심 속성이다.  성능은 단일 작업을 얼마나 빠르게 처리할 수 있는지를 나타내는 반면, 확장성은 부하가 증가할 때 시스템이 이를 효과적으로 처리할 수 있는 능력을 의미한다.  성능이 좋은 시스템이 반드시 확장성이 좋은 것은 아니며, 그 반대도 마찬가지이다. 이 두 특성의 균형을 맞추는 것은 현대 시스템 설계의 핵심 과제로, 분산 시스템, 로드 밸런싱, 캐싱, 데이터베이스 샤딩 등의 기술을 통해 해결할 수 있다.</description>
    </item>
    <item>
      <title>State Representation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/</link>
      <pubDate>Tue, 21 Jan 2025 14:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/state-representation/</guid>
      <description>상태 표현은 문제 해결 과정에서 현재까지의 결정과 남은 선택지를 효과적으로 나타내는 방법이다.</description>
    </item>
    <item>
      <title>가지치기(Pruning)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/pruning/</link>
      <pubDate>Sun, 29 Dec 2024 14:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/pruning/</guid>
      <description>가지치기는 백트래킹 과정에서 더 이상 유망하지 않은(promising하지 않은) 경로를 조기에 차단하는 기법이다.</description>
    </item>
    <item>
      <title>Algorithmic Thinking</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/algorithmic-thinking/</link>
      <pubDate>Fri, 27 Dec 2024 07:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/algorithmic-thinking/</guid>
      <description>알고리즘적 사고란 문제를 일련의 명확하고 실행 가능한 단계들로 분해하여 해결하는 사고 과정.</description>
    </item>
    <item>
      <title>꼬리 재귀(Tail Recursion)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion/</link>
      <pubDate>Mon, 09 Dec 2024 09:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion/</guid>
      <description>Tail Recursion는 재귀 함수의 마지막 연산이 재귀 호출 자체인 특별한 형태의 재귀이다.</description>
    </item>
    <item>
      <title>Preorder Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/preorder-traversal/</guid>
      <description>전위 순회는 트리를 탐색하는 깊이 우선 탐색(Depth-First Search, DFS)의 한 형태로, 재귀적으로 수행되며, 루트 노드부터 시작하여 왼쪽 가지를 따라 깊이 내려간 후 오른쪽 가지로 이동한다. 전위 순회의 이름에서 &amp;#34;전위(Pre)&amp;#34;는 부모 노드를 자식 노드보다 먼저(before) 방문한다는 의미를 담고 있다.</description>
    </item>
    <item>
      <title>ECMAScript</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/es6&#43;/ecmascript/</link>
      <pubDate>Wed, 04 Dec 2024 17:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/es6&#43;/ecmascript/</guid>
      <description>ECMAScript는 자바스크립트의 표준 규격으로, **Ecma International**이 ECMA-262 기술 규격을 통해 정의한 스크립트 프로그래밍 언어이다.</description>
    </item>
    <item>
      <title>Semantic Web</title>
      <link>https://buenhyden.github.io/posts/emerging-technologies/blockchain/fundamentals/semantic-web/</link>
      <pubDate>Wed, 04 Dec 2024 12:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/emerging-technologies/blockchain/fundamentals/semantic-web/</guid>
      <description>시맨틱 웹(Semantic Web)은 웹 데이터에 의미를 부여해 기계가 이해하고 처리할 수 있도록 하는 차세대 웹 기술이다.</description>
    </item>
    <item>
      <title>데이터 레이크 vs 데이터 웨어하우스 vs 데이터 레이크하우스</title>
      <link>https://buenhyden.github.io/posts/data-engineering/data-storage/data-lake-vs-data-warehouse-vs-data-lakehouse/</link>
      <pubDate>Sat, 26 Oct 2024 05:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-engineering/data-storage/data-lake-vs-data-warehouse-vs-data-lakehouse/</guid>
      <description>데이터 레이크(Data Lake)와 데이터 웨어하우스(Data Warehouse), 데이터 레이크하우스(Data Lakehouse)의 특징, 장단점, 활용 사례 비교</description>
    </item>
    <item>
      <title>TCPIP 4 Layers vs. OSI 7 Layers</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/</link>
      <pubDate>Sat, 19 Oct 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/</guid>
      <description>OSI 7계층은 네트워크 통신의 표준 참조 모델이며, TCP/IP 4계층은 이를 바탕으로 구현된 실제 인터넷 통신의 기반이 된다.</description>
    </item>
    <item>
      <title>버블 정렬 (Bubble Sort)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/bubble-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/bubble-sort/</guid>
      <description>버블 정렬(Bubble Sort)은 인접한 요소를 반복적으로 비교하고 교환하여 정렬하는 간단한 알고리즘이다.</description>
    </item>
    <item>
      <title>Native Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/native-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 15:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/native-compiler/</guid>
      <description>Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러</description>
    </item>
    <item>
      <title>논리값 (Boolean)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/boolean/</link>
      <pubDate>Mon, 07 Oct 2024 07:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/boolean/</guid>
      <description>Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.</description>
    </item>
    <item>
      <title>Concurrency and Parallelism</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/__index/</link>
      <pubDate>Sat, 05 Oct 2024 02:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/__index/</guid>
      <description>동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.  동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.</description>
    </item>
    <item>
      <title>Git Flow</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/git-flow/</link>
      <pubDate>Sun, 29 Sep 2024 13:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/git-flow/</guid>
      <description>Git Flow는 Vincent Driessen이 2010년에 제안한 구조화된 브랜치 관리 전략으로, Master, Develop, Feature, Release, Hotfix 등 5가지 브랜치를 활용하여 대규모 협업 환경에서 체계적인 릴리스 관리가 필요할 때 효과적이다. 명확한 워크플로우와 안정적인 릴리즈 관리가 장점이지만, 복잡성과 CI/CD 통합의 어려움으로 인해 2025년 현재 트렁크 기반 개발이나 GitHub Flow로 대체되는 추세이다. GitOps와 AI 기반 자동화 도구의 등장으로 브랜치 관리 패러다임이 급격히 변화하고 있다.</description>
    </item>
    <item>
      <title>Git</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/git-overview/</link>
      <pubDate>Sat, 28 Sep 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/git-overview/</guid>
      <description>Git은 Linus Torvalds가 2005년에 개발한 분산형 버전 관리 시스템으로, 소프트웨어 개발에서 코드 변경 사항을 추적하고 여러 개발자의 효율적인 협업을 지원합니다. 스냅샷 기반 저장 방식, SHA-1 해시를 활용한 콘텐츠 주소 지정, 블롭·트리·커밋·태그로 구성된 객체 모델, 작업 디렉토리·스테이징 영역·저장소의 세 단계 워크플로우가 핵심 특징입니다. Git의 강력한 브랜칭과 병합 기능은 비선형적 개발을 가능하게 하며, GitFlow, GitHub Flow 등 다양한 워크플로우 전략이 실무에 적용됩니다. 2025년 현재 AI 기반 코드 리뷰, GitOps 확산, 실시간 협업 도구 강화 등의 동향이 나타나고 있으며, Git은 단순한 버전 관리 도구를 넘어 개발, 테스트, 배포를 아우르는 DevOps의 핵심 요소로 자리잡고 있습니다.</description>
    </item>
    <item>
      <title>Git Basic Commands</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-basic-commands/</link>
      <pubDate>Sat, 28 Sep 2024 03:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-basic-commands/</guid>
      <description>Git Basic Commands는 버전 관리 시스템 Git의 핵심 명령어들로, init, clone, add, commit, push, pull 등을 포함한다. 이 명령어들은 로컬 저장소 생성부터 원격 저장소와의 동기화까지 모든 기본적인 버전 관리 작업을 가능하게 한다. .gitignore 파일 설정과 Atomic Commit 전략을 통해 효율적인 코드 관리가 가능하다. `add`-`commit`-`push` 기본 흐름을 이해하고, Atomic Commit 원칙을 준수하면 협업 효율성을 극대화할 수 있다. 2025년 현재 AI 통합, 보안 강화, 클라우드 통합 등의 트렌드가 Git 명령어 사용 경험을 향상시키고 있다. 실무에서는 명확한 커밋 메시지 작성, 적절한 브랜치 전략 사용, 정기적인 동기화가 중요하다.</description>
    </item>
    <item>
      <title>Latency vs Throughput</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/latency-vs-throughput/</guid>
      <description>지연시간 (Latency) 은 요청이 시작된 시점부터 응답을 받을 때까지 걸리는 시간을 의미하며, 처리량 (Throughput) 은 시스템이 단위 시간당 처리할 수 있는 작업의 양을 나타낸다. 이 두 개념은 시스템 성능의 핵심 지표로, 서로 상충관계 (trade-off) 를 가지며 시스템 설계에서 균형 있는 최적화가 중요하다. 적절한 지연시간과 처리량 관리는 효율적인 시스템 설계의 기반이 된다.</description>
    </item>
    <item>
      <title>ANSI</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/</guid>
      <description>일반적으로 Windows 운영 체제에서 사용되는 특정 8비트 코드 페이지 집합을 지칭한다.</description>
    </item>
    <item>
      <title>Branching Strategies</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/branching-strategies/</link>
      <pubDate>Tue, 21 Jan 2025 14:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/branching-strategies/</guid>
      <description>분기 전략은 현재 부분 문제를 더 작은 하위 문제로 분할하는 방식을 정의한다. 이 과정에서 해결책 공간은 상호 배타적인 부분 공간으로 나뉘며, 이들을 모두 합치면 원래의 해결책 공간을 완전히 포함한다.</description>
    </item>
    <item>
      <title>Branch and Bound vs. Backtracking</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/branch-and-bound-vs-backtracking/</link>
      <pubDate>Fri, 10 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/branch-and-bound-vs-backtracking/</guid>
      <description>백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.  두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.</description>
    </item>
    <item>
      <title>상태 공간 트리(State Space Tree)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/state-space-tree/</link>
      <pubDate>Sun, 29 Dec 2024 13:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/concepts/state-space-tree/</guid>
      <description>상태 공간 트리는 문제 해결 과정에서 가능한 모든 상태(state)와 그 상태들 간의 전이(transition)를 트리 형태로 표현한 자료구조이다.</description>
    </item>
    <item>
      <title>Javascript vs. Python</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-vs-python/</link>
      <pubDate>Sun, 22 Dec 2024 04:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-vs-python/</guid>
      <description>JavaScript와 Python은 현대 프로그래밍 세계에서 가장 인기 있는 두 언어이다.  두 언어 모두 높은 수준의 프로그래밍 언어이지만, 설계 철학, 사용 사례, 문법 등에서 중요한 차이점이 있다.</description>
    </item>
    <item>
      <title>비꼬리 재귀(Non-tail Recursion)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/</link>
      <pubDate>Mon, 09 Dec 2024 09:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/</guid>
      <description>Non-tail Recursion는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다</description>
    </item>
    <item>
      <title>Inorder Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/</guid>
      <description>왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.</description>
    </item>
    <item>
      <title>Low-Level Virtual Machine</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/</link>
      <pubDate>Thu, 05 Dec 2024 03:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/</guid>
      <description>LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크</description>
    </item>
    <item>
      <title>Functions</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/functions/</link>
      <pubDate>Thu, 05 Dec 2024 01:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/functions/</guid>
      <description>함수는 프로그래밍의 핵심 구성 요소로, 특정 작업을 수행하는 독립적이고 재사용 가능한 코드 블록이다.</description>
    </item>
    <item>
      <title>분산 원장 기술(Distributed Ledger Technology, DLT)</title>
      <link>https://buenhyden.github.io/posts/emerging-technologies/blockchain/fundamentals/distributed-ledger-technology/</link>
      <pubDate>Wed, 04 Dec 2024 07:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/emerging-technologies/blockchain/fundamentals/distributed-ledger-technology/</guid>
      <description>분산 원장 기술(Distributed Ledger Technology, DLT)은 중앙 관리자 없이 네트워크 참여자들이 공동으로 데이터를 기록·검증·관리하는 디지털 시스템이다.</description>
    </item>
    <item>
      <title>Stylesheet</title>
      <link>https://buenhyden.github.io/posts/frontend-development/css-and-styling/stylesheet/</link>
      <pubDate>Sun, 01 Dec 2024 06:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend-development/css-and-styling/stylesheet/</guid>
      <description>웹 개발에서 스타일시트는 웹 페이지의 시각적 표현을 정의하는 중요한 기술</description>
    </item>
    <item>
      <title>Framework vs. Library</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/inversion-of-control/framework-vs.-library/</link>
      <pubDate>Wed, 20 Nov 2024 06:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/inversion-of-control/framework-vs.-library/</guid>
      <description>프레임워크와 라이브러리는 재사용 가능한 코드를 제공하지만, 제어의 주체가 다르다. 라이브러리는 개발자가 직접 호출해 사용하는 반면, 프레임워크는 전체 구조와 흐름을 제어하며 개발자의 코드를 필요할 때 호출한다. 이 차이는 &amp;#39; 할리우드 원칙 &amp;#39;(제어의 역전) 으로 설명된다.</description>
    </item>
    <item>
      <title>Data Pipeline Pattern</title>
      <link>https://buenhyden.github.io/posts/data-engineering/data-pipelines/data-pipeline-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-engineering/data-pipelines/data-pipeline-pattern/</guid>
      <description>데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.</description>
    </item>
    <item>
      <title>선택 정렬 (Selection Sort)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/</guid>
      <description>선택 정렬(Selection Sort)은 간단한 비교 기반 정렬 알고리즘으로, 작은 데이터 세트에서 효율적이며 메모리 사용이 최소화되는 특징을 갖는다.  전체 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 매번 정렬되지 않은 부분에서 최솟값을 선택해 정렬된 부분의 끝에 배치하는 방식으로 동작한다.</description>
    </item>
    <item>
      <title>이진 검색 (Binary Search)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/searching/types/binary-search/</link>
      <pubDate>Tue, 15 Oct 2024 05:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/searching/types/binary-search/</guid>
      <description>리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다</description>
    </item>
    <item>
      <title>Cross Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/cross-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/cross-compiler/</guid>
      <description>크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러</description>
    </item>
    <item>
      <title>문자 (Character)과 문자열 (String)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/character-and-string/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/character-and-string/</guid>
      <description>문자 (Character)는 단일 문자를 표현하는 데이터 타입이고,문자열 (String)은 문자들의 배열 또는 시퀀스</description>
    </item>
    <item>
      <title>Recursion vs. Iteration</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/recursion-vs-iteration/</link>
      <pubDate>Sun, 06 Oct 2024 11:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/recursion-vs-iteration/</guid>
      <description>Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.</description>
    </item>
    <item>
      <title>Syncronization Algorithms</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/methods/</link>
      <pubDate>Sat, 05 Oct 2024 08:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/methods/</guid>
      <description>동기화 알고리즘은 병행 시스템에서 상호 배제(Mutual Exclusion)를 보장하기 위한 핵심 메커니즘이다.</description>
    </item>
    <item>
      <title>GitHub Flow</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/github-flow/</link>
      <pubDate>Sun, 29 Sep 2024 13:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/github-flow/</guid>
      <description>GitHub Flow는 단순한 브랜치 구조와 풀 리퀘스트 기반 협업으로 CI/CD 환경에 적합하다. 2025년 현재 AI 기반 자동화와 트렁크 기반 개발의 확산으로 더욱 간소화되는 추세이며, 소규모 팀의 신속한 배포 요구에 효과적이다. 다만 복잡한 릴리스 관리에는 Git Flow 등의 대안을 고려해야 한다.</description>
    </item>
    <item>
      <title>Repo Templates and Setup</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/repo-hosting-services/repo-templates-and-setup/</link>
      <pubDate>Sun, 29 Sep 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/repo-hosting-services/repo-templates-and-setup/</guid>
      <description>Repo Templates and Setup(저장소 템플릿 및 세팅) 은 표준화된 프로젝트 구조, 설정, 문서, 자동화 워크플로우 등을 여러 신규 저장소에 신속하게 복제해 일관성과 생산성을 높여주는 기능이다.2019 년 도입된 이 기능은 디렉토리 구조, 기본 파일 (README,.gitignore, LICENSE), 이슈/PR 템플릿, 워크플로우 정의 등을 포함하여 반복적인 초기 설정 작업을 최소화한다. 템플릿을 활용하면 반복적인 설정 작업을 줄이고, 팀원 간의 협업을 강화하며, 개발 속도를 향상시킬 수 있다. 또한, GitHub Actions 와 같은 자동화 도구와 통합하여 CI/CD 파이프라인을 구축하고, 권한 관리 기능을 통해 보안을 강화할 수 있다. 2025 년 현재, GitHub 는 템플릿 기능을 지속적으로 개선하고 있으며, 개발자들은 이를 통해 더욱 효율적인 개발 환경을 구축할 수 있다.</description>
    </item>
    <item>
      <title>Git Internals</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/git-internals/</link>
      <pubDate>Sun, 29 Sep 2024 09:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/git-internals/</guid>
      <description>Git Internals는 Git 버전 관리 시스템의 내부 작동 원리와 구조를 설명하는 주제로, 콘텐츠 주소 지정 저장소를 기반으로 한 Git의 객체 모델(Blob, Tree, Commit, Tag)과 SHA-1 해시를 통한 데이터 무결성 보장 메커니즘을 다룬다. 스테이징 영역(인덱스), HEAD, 참조 시스템, 팩 파일 압축, 가비지 컬렉션 등 Git의 핵심 구성 요소들이 어떻게 작동하여 효율적인 버전 관리를 가능하게 하는지 설명한다. Git의 내부 구조를 이해함으로써 개발자는 복잡한 Git 문제를 해결하고, 고급 기능을 효과적으로 활용하며, 맞춤형 워크플로우를 구축할 수 있다. 최근에는 SHA-256으로의 전환, 대규모 저장소를 위한 부분 클론 기능 개선, GitOps와 같은 새로운 방법론, AI 통합 등이 Git의 주요 발전 방향으로 주목받고 있다.</description>
    </item>
    <item>
      <title>MVC pattern vs MVVC pattern vs MVP pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/structural/layered/mvc/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 01:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/structural/layered/mvc/mvc-pattern-vs-mvvc-pattern-vs-mvp-pattern/</guid>
      <description>MVC, MVP, MVVM 아키텍처 패턴은 모두 **관심사 분리(SoC)** 원칙에 기반하며, 각기 다른 방식으로 UI 로직과 비즈니스 로직을 분리한다.</description>
    </item>
    <item>
      <title>1. 계획 (Planning)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/1-planning/</link>
      <pubDate>Fri, 20 Sep 2024 00:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/1-planning/</guid>
      <description>프로젝트의 방향성과 범위를 설정하고, 자원과 일정을 계획하며, 위험 요소를 식별하고 관리 전략을 수립한다.</description>
    </item>
    <item>
      <title>보안 코딩 (Secure Coding)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/web-and-application-security/secure-coding/</link>
      <pubDate>Thu, 19 Sep 2024 01:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/web-and-application-security/secure-coding/</guid>
      <description>Secure Coding은 소프트웨어 개발 과정에서 보안 취약점을 최소화하고 안전한 소프트웨어를 만들기 위한 코딩 기법이다.</description>
    </item>
    <item>
      <title>Availability vs Consistency</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability-vs-consistency/</link>
      <pubDate>Tue, 18 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability-vs-consistency/</guid>
      <description>가용성과 일관성은 분산 시스템 설계에서 핵심적인 특성으로, CAP 정리에 따라 네트워크 분할이 발생할 때 둘 중 하나만 완벽하게 보장할 수 있다. 가용성은 모든 요청이 성공 또는 실패 응답을 받을 수 있도록 하는 특성인 반면, 일관성은 모든 노드가 동일한 시점에 동일한 데이터를 볼 수 있도록 보장한다. 시스템 설계자는 비즈니스 요구사항에 따라 두 특성 간의 균형을 찾아야 하며, 이는 데이터베이스 선택부터 아키텍처 설계까지 전반적인 결정에 영향을 미친다.</description>
    </item>
    <item>
      <title>CP949</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/cp949/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/cp949/</guid>
      <description>CP949(Code Page 949)는 한국어 문자를 표현하기 위해 마이크로소프트가 개발한 문자 인코딩이다.</description>
    </item>
    <item>
      <title>Python vs Javascript vs Typescript vs Java</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python-vs-javascript-vs-typescript-vs-java/</link>
      <pubDate>Sun, 19 Jan 2025 00:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python-vs-javascript-vs-typescript-vs-java/</guid>
      <description>프로그래밍 언어마다 각기 다른 설계 철학과 실행 방식, 개발 생태계 및 목적이 존재한다.</description>
    </item>
    <item>
      <title>Back Tracking vs. Brute Force</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/</link>
      <pubDate>Sun, 29 Dec 2024 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-brute-force/</guid>
      <description>브루트 포스는 구현이 단순하고 모든 가능성을 확인하지만, 문제 크기가 커질수록 비효율적이다. 반면, 백트래킹은 유망성 테스트와 가지치기를 통해 불필요한 탐색을 줄여 효율성을 높이지만, 구현이 더 복잡하다.</description>
    </item>
    <item>
      <title>Network Topologies</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/network-types/network-topologies/</link>
      <pubDate>Mon, 16 Dec 2024 03:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/network-types/network-topologies/</guid>
      <description>네트워크 토폴로지는 컴퓨터 네트워크의 노드 (장치) 와 링크 (연결) 가 배열되고 연결되는 구조와 방식을 의미한다. 버스형, 성형, 링형, 메시형, 트리형 등 다양한 유형이 있으며, 물리적 배치와 논리적 데이터 흐름을 모두 포함한다. 각 토폴로지는 고유한 장단점을 가지며, 네트워크의 성능, 확장성, 신뢰성 및 비용에 직접적인 영향을 미친다.</description>
    </item>
    <item>
      <title>tail Recursion vs. Non-tail Recursion</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion-vs-non-tail-recursion/</link>
      <pubDate>Mon, 09 Dec 2024 00:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/tail-recursion-vs-non-tail-recursion/</guid>
      <description>재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀)과 Non-Tail Recursion(비꼬리 재귀)으로 구분된다.</description>
    </item>
    <item>
      <title>Adjacency Matrix vs Adjacency List</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</link>
      <pubDate>Sat, 07 Dec 2024 15:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/fundamentals/representation/adjacency-matrix/adjacency-matrix-vs-adjacency-list/</guid>
      <description>간선이 적은 희소 그래프의 경우 인접 리스트가 메모리와 성능 면에서 우수하며 간선이 많은 밀집 그래프나 정점 간 연결 여부를 빠르게 확인해야 하는 경우에는 인접 행렬이 적합하다.</description>
    </item>
    <item>
      <title>Postorder Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/postorder-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/postorder-traversal/</guid>
      <description>후위 순회는 자식 노드를 먼저 방문한 후 부모 노드를 방문하는 트리 순회 방법으로, 상향식 처리가 필요한 다양한 문제 해결에 적합하다.</description>
    </item>
    <item>
      <title>LLVM vs 기존 컴파일러 비교</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Thu, 05 Dec 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/</guid>
      <description>LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.  전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.</description>
    </item>
    <item>
      <title>CSR vs SSR</title>
      <link>https://buenhyden.github.io/posts/frontend-development/rendering-strategies/client-side-rendering/csr-vs-ssr/</link>
      <pubDate>Mon, 02 Dec 2024 12:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend-development/rendering-strategies/client-side-rendering/csr-vs-ssr/</guid>
      <description>Client Side Rendering (CSR)은 브라우저에서 JavaScript를 실행하여 콘텐츠를 렌더링하며, Server Side Rendering (SSR)은 서버에서 HTML을 생성하여 클라이언트에 전달한다.</description>
    </item>
    <item>
      <title>Event Brokers</title>
      <link>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/fundamentals/event-brokers/</link>
      <pubDate>Fri, 25 Oct 2024 06:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/fundamentals/event-brokers/</guid>
      <description>Event Broker는 이벤트 생성자(Producer)와 이벤트 소비자(Consumer) 사이에서 중개자 역할을 수행한다.</description>
    </item>
    <item>
      <title>삽입 정렬 (Insertion Sort)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/insertion-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/insertion-sort/</guid>
      <description>삽입 정렬(Insertion Sort)은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누어, 정렬되지 않은 부분의 요소를 하나씩 가져와 정렬된 부분의 적절한 위치에 삽입하는 방식으로 동작하는 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>Ahead-of-Time Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/ahead-of-time-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 18:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/ahead-of-time-compiler/</guid>
      <description>**Ahead-of-Time(AOT) 컴파일러**는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 **네이티브 머신 코드로 미리 변환**하는 기술</description>
    </item>
    <item>
      <title>Callback Hell</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/callback-hell/</link>
      <pubDate>Wed, 09 Oct 2024 05:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/callback-hell/</guid>
      <description>콜백 지옥(Callback Hell)은 JavaScript 등의 비동기 프로그래밍 환경에서 중첩된 콜백 함수가 과도하게 사용되어 코드의 가독성과 유지보수성을 크게 저하시키는 현상을 의미한다.</description>
    </item>
    <item>
      <title>정수(Integer)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/integer/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/integer/</guid>
      <description>정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.</description>
    </item>
    <item>
      <title>Programming Language Control Structures</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/control-structures/programming-language-control-structures/</link>
      <pubDate>Sun, 06 Oct 2024 11:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/syntax-and-semantics/language-syntax/control-structures/programming-language-control-structures/</guid>
      <description>프로그래밍에서 코드의 실행 흐름을 제어하는 핵심적인 구문이다.</description>
    </item>
    <item>
      <title>GitLab Flow</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/gitlab-flow/</link>
      <pubDate>Sun, 29 Sep 2024 13:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/gitlab-flow/</guid>
      <description>GitLab Flow(깃랩 플로우)는 Git Flow(깃 플로우)의 복잡성과 GitHub Flow(깃허브 플로우)의 단순성 사이에서 균형을 찾은 브랜치 전략입니다.운영, 스테이징, 개발 등 환경별 브랜치와 기능 개발 중심의 브랜치, 그리고 이슈 트래킹 시스템과의 연동을 통해 개발 프로세스를 단순화하고 투명하게 만듭니다.또한, CI/CD(지속적 통합/지속적 배포) 파이프라인과의 통합으로 개발 효율성과 코드 품질을 높일 수 있습니다.복잡한 릴리스 관리가 필요한 대규모 프로젝트뿐 아니라, 신속한 배포가 중요한 프로젝트에도 유연하게 적용할 수 있는 워크플로우입니다.</description>
    </item>
    <item>
      <title>Branching and Merging</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branching-and-merging/</link>
      <pubDate>Sat, 28 Sep 2024 09:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branching-and-merging/</guid>
      <description>Branching과 Merging은 Git 기반 협업에서 필수적인 기술로, 병렬 개발과 코드 통합을 지원한다. Git을 중심으로 한 다양한 브랜치 전략(GitFlow, GitHub Flow 등)이 사용되며, merge와 rebase 같은 병합 방식을 상황에 맞게 선택할 수 있다.  전략적으로 브랜치를 관리하고 적절한 머지 방식을 선택함으로써 충돌을 줄이고 배포를 안정화할 수 있다. AI 기반 충돌 해결, 실시간 협업, GitOps 통합 등이 주목받고 있으며, 향후 완전 자동화된 브랜칭 시스템과 컨텍스트 인식 병합 기술이 발전할 것으로 전망된다.</description>
    </item>
    <item>
      <title>SVN Mercurial Overview</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/</link>
      <pubDate>Sat, 28 Sep 2024 04:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/svn-mercurial-overview/</guid>
      <description>SVN과 Mercurial은 각각 중앙 집중식과 분산형 접근 방식을 취하는 중요한 버전 관리 시스템이다. SVN은 중앙 서버에 모든 이력을 저장하고 순차적 정수 리비전 번호를 사용하며, 세밀한 접근 제어와 대용량 바이너리 파일 처리에 강점이 있다. Mercurial은 모든 개발자가 저장소의 전체 복사본을 가지며, SHA-1 해시 기반 식별자와 체인지셋을 통해 변경 사항을 관리하고, 확장 시스템으로 기능을 추가할 수 있다. 2025년 현재 Git이 시장의 90% 이상을 차지하는 가운데, SVN은 제조업과 게임 개발 등 대용량 파일 처리가 중요한 분야에서, Mercurial은 Mozilla 등 소수의 프로젝트에서 사용되고 있으며, 하이브리드 접근법과 AI 통합이 새로운 동향으로 떠오르고 있다.</description>
    </item>
    <item>
      <title>2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/2-requirements-gathering-and-analysis/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/2-requirements-gathering-and-analysis/</guid>
      <description>이해관계자의 요구사항을 수집하고 분석하여 시스템 요구사항을 정의하는 단계</description>
    </item>
    <item>
      <title>EUC-KR</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/euc-kr/</link>
      <pubDate>Fri, 24 Jan 2025 04:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/euc-kr/</guid>
      <description>EUC-KR은 한국어 텍스트를 컴퓨터에서 표현하기 위해 개발된 문자 인코딩 방식이다.</description>
    </item>
    <item>
      <title>Back Tracking vs. Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/</link>
      <pubDate>Mon, 09 Dec 2024 14:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-traversal/</guid>
      <description>백트래킹과 트래버설은 유사한 점이 있지만, 목적, 동작 방식, 응용 분야에서 중요한 차이점을 가지고 있다.</description>
    </item>
    <item>
      <title>Level Order Traversal</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/level-order-traversal/</link>
      <pubDate>Fri, 06 Dec 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/level-order-traversal/</guid>
      <description>레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.</description>
    </item>
    <item>
      <title>Compiler vs Interpreter vs Assembler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler-vs-interpreter-vs-assembler/</link>
      <pubDate>Thu, 05 Dec 2024 03:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler-vs-interpreter-vs-assembler/</guid>
      <description>컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다.</description>
    </item>
    <item>
      <title>의사코드(Pseudocode)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/pseudo-code/</link>
      <pubDate>Thu, 05 Dec 2024 01:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/pseudo-code/</guid>
      <description>의사코드(Pseudocode)는 알고리즘을 설명하기 위한 비공식적이고 고수준의 표현 방식으로, 특정 프로그래밍 언어의 문법에 얽매이지 않고 간단한 텍스트 형태로 작성된다.</description>
    </item>
    <item>
      <title>MSA 패턴 유형별 비교</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/msa-pattern-comparison/</link>
      <pubDate>Tue, 19 Nov 2024 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/msa-pattern-comparison/</guid>
      <description>MSA의 주요 패턴 유형들을 체계적으로 정리한 것.</description>
    </item>
    <item>
      <title>Test</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/test/</link>
      <pubDate>Wed, 30 Oct 2024 06:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/test/</guid>
      <description>주요 이해관계자들에게 시험 대상 제품 또는 서비스의 품질에 관한 정보를 제공하는 조사 과정</description>
    </item>
    <item>
      <title>Quality Control</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-control/</link>
      <pubDate>Tue, 29 Oct 2024 16:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-control/</guid>
      <description>품질관리(Quality Control, QC)는 제품이나 서비스가 일정한 품질 기준을 충족하도록 보장하는 일련의 절차를 의미한다.</description>
    </item>
    <item>
      <title>병합 정렬 (Merge Sort)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/merge-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/merge-sort/</guid>
      <description>병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>Just-In-Time (JIT) Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/just-in-time-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 17:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/just-in-time-compiler/</guid>
      <description>**JIT(Just-In-Time) 컴파일**은 프로그램 실행 시점에 코드를 기계어로 변환하는 기술로, **인터프리터의 유연성**과 **컴파일러의 성능**을 결합한 혁신적인 방식</description>
    </item>
    <item>
      <title>Native Compiler vs Cross Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/native-compiler-vs-cross-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 03:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/native-compiler-vs-cross-compiler/</guid>
      <description>Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.</description>
    </item>
    <item>
      <title>브루트 포스 (Brute Force)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/brute-force/</link>
      <pubDate>Sun, 13 Oct 2024 07:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/brute-force/</guid>
      <description>브루트 포스는 &amp;#34;무식한 힘&amp;#34;이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.</description>
    </item>
    <item>
      <title>부동 소수점 (Float)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/float/</link>
      <pubDate>Mon, 07 Oct 2024 07:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/float/</guid>
      <description>부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.</description>
    </item>
    <item>
      <title>Trunk-based Development</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/trunk-based-development/</link>
      <pubDate>Sun, 29 Sep 2024 13:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/trunk-based-development/</guid>
      <description>Trunk-based Development는 모든 개발자가 단일 메인 브랜치에 작고 빈번한 변경사항을 통합하는 현대적인 개발 방법론으로, 지속적 통합과 배포의 핵심 전제조건이다. 짧은 수명의 브랜치와 강력한 자동화 테스트, 피처 플래그를 활용하여 병합 충돌을 최소화하고 배포 속도를 극대화하며, 대규모 조직에서도 성공적으로 적용되고 있다. 높은 팀 규율과 강력한 테스트 인프라가 필요하지만, 현대 DevOps 환경에서 가장 효율적인 브랜치 전략으로 인정받고 있습니다.</description>
    </item>
    <item>
      <title>Snapshot vs. Delta</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/snapshot-vs-delta/</link>
      <pubDate>Sat, 28 Sep 2024 10:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/snapshot-vs-delta/</guid>
      <description>스냅샷과 델타는 데이터 변화를 추적하고 관리하는 두 가지 핵심 접근 방식입니다. 스냅샷 방식은 특정 시점의 데이터 전체 상태를 저장하여 직접적인 접근과 빠른 복구를 제공하는 반면, 델타 방식은 이전 상태와의 차이점만을 저장하여 저장 공간을 절약합니다. Git이 스냅샷 기반의 분산형 버전 관리 시스템으로 독립적 작업과 빠른 브랜치 전환을 지원하는 반면, SVN 같은 델타 기반 시스템은 중앙 집중식으로 세밀한 변경 추적과 공간 효율성을 제공합니다.</description>
    </item>
    <item>
      <title>Git Submodule</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-submodule/</link>
      <pubDate>Sat, 28 Sep 2024 07:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-submodule/</guid>
      <description>Git Submodule 은 외부 Git 저장소를 현재 프로젝트에 하위 모듈로 포함시켜 관리하는 방식이다. 현대 소프트웨어 개발에서 필수적인 모듈화 도구로 진화했다. 이를 통해 개발자는 코드 재사용, 외부 의존성 관리, 모듈식 개발을 효과적으로 구현할 수 있다. 서브모듈은 부모 저장소에서 자식 저장소의 특정 커밋을 참조하는 방식으로 작동하며, 이를 통해 의존성 버전을 고정하여 안정성을 확보할 수 있다. 코드 재사용, 독립적 이력 관리, 모듈식 구조 등의 장점이 있지만, 복잡한 워크플로우와 추가 학습이 필요하다는 단점도 있다. 최근에는 서브모듈과 모노레포의 장점을 결합한 하이브리드 접근법과 성능 최적화 기술이 발전하고 있으며, 향후 AI 기반의 자동화와 클라우드 환경 최적화가 더욱 진전될 것으로 전망된다.</description>
    </item>
    <item>
      <title>3. 설계 (Design)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/3-design/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/3-design/</guid>
      <description>요구사항을 바탕으로 시스템의 구조와 세부 사항을 설계하는 단계</description>
    </item>
    <item>
      <title>System Design and Architecture</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/system-design/system-design-and-architecture/</link>
      <pubDate>Thu, 19 Sep 2024 21:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/system-design/system-design-and-architecture/</guid>
      <description>시스템 디자인은 복잡한 소프트웨어 시스템의 구조와 구성 요소를 정의하여 안정적이고 확장 가능한 시스템을 구축하는 과정이다. 사용자 요구사항을 분석하고, 구조적 설계를 통해 시스템 구성요소와 인터페이스를 정의하며, 성능, 보안, 유지보수성을 고려하여 최적의 아키텍처를 구축한다. 현대 소프트웨어 개발에서 필수적인 역할을 수행한다.</description>
    </item>
    <item>
      <title>Back Tracking vs. Depth-First Search</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/</link>
      <pubDate>Sun, 29 Dec 2024 13:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/</guid>
      <description>DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.</description>
    </item>
    <item>
      <title>Software Design Patterns</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/design-patterns/software-design-patterns/</link>
      <pubDate>Sat, 21 Dec 2024 05:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/design-patterns/software-design-patterns/</guid>
      <description>소프트웨어 디자인 패턴은 소프트웨어 설계에서 반복적으로 발생하는 문제에 대한 검증된 재사용 가능한 해결책이다. 이는 코드 자체가 아닌 문제 해결을 위한 템플릿이며, 생성 (Creational), 구조 (Structural), 행동 (Behavioral) 패턴으로 분류됩니다. 디자인 패턴은 개발 과정을 가속화하고, 유지보수성을 높이며, 개발자 간 커뮤니케이션을 개선한다.</description>
    </item>
    <item>
      <title>Traversal 방법 비교</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/</link>
      <pubDate>Fri, 06 Dec 2024 11:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/</guid>
      <description>트리 순회(Tree Traversal)는 트리의 노드를 방문하는 방법으로, 트리 구조에서 데이터를 검색하고 처리하는 기본 개념이다.</description>
    </item>
    <item>
      <title>Runtime</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/runtime/</link>
      <pubDate>Thu, 05 Dec 2024 04:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/runtime/</guid>
      <description>컴퓨터 과학에서 **런타임(runtime)** 은 프로그램이 실제로 실행되는 기간과 그 실행 환경 전체를 의미한다.</description>
    </item>
    <item>
      <title>퀵 정렬 (Quick Sort)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/quick-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/quick-sort/</guid>
      <description>퀵 정렬(Quick Sort)은 분할 정복(divide and conquer) 전략을 사용하는 고성능 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>JIT Compiler vs AOT Compiler</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/jit-compiler-vs-aot-compiler/</link>
      <pubDate>Mon, 14 Oct 2024 18:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/jit-compiler-vs-aot-compiler/</guid>
      <description>JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다</description>
    </item>
    <item>
      <title>AOT vs. JIT vs. Interpreter</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/aot-vs-jit-vs-interpreter/</link>
      <pubDate>Mon, 14 Oct 2024 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/programming-language-theory/compilers--interpreters/language-processor/aot-vs-jit-vs-interpreter/</guid>
      <description>AOT, JIT, 그리고 인터프리터는 모두 소스 코드를 실행 가능한 형태로 변환하는 언어 처리 방식이지만, 언제 어떻게 변환이 이루어지는지에 따라 큰 차이가 있다.</description>
    </item>
    <item>
      <title>Availability Patterns</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/availability/availability-patterns/</link>
      <pubDate>Wed, 09 Oct 2024 00:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/availability/availability-patterns/</guid>
      <description>가용성 패턴은 분산 시스템과 클라우드 환경에서 서비스의 안정적인 운영을 보장하기 위한 설계 패턴이다. 이 패턴들은 시스템의 일부가 실패하더라도 전체 시스템의 가용성을 유지하고, 장애에 대한 복원력을 제공하며, 사용자에게 지속적인 서비스를 제공하는 것을 목표로 한다. 서킷 브레이커, 벌크헤드, 헬스 엔드포인트 모니터링 등 다양한 패턴을 포함한다.</description>
    </item>
    <item>
      <title>Git Subtree</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-subtree/</link>
      <pubDate>Sat, 28 Sep 2024 10:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-subtree/</guid>
      <description>Git Subtree 는 여러 독립적인 저장소의 코드를 하나의 저장소에서 통합 관리할 수 있게 해주는 Git 의 고급 기능이다. 상위 저장소에 하위 저장소의 파일을 직접 추가하고 트래킹하는 방식으로 작동하며, 서브모듈과 달리 별도의 메타데이터 파일 없이 일반적인 Git 워크플로우로 관리할 수 있다. 주요 장점으로는 코드 공유 용이성, 직접 수정 가능성, 양방향 동기화 등이 있으며, 단점으로는 명령어 복잡성, 저장소 크기 증가, 접근 제어 제한 등이 있다. 2025 년 현재, Git Subtree 는 모노레포와 결합하여 개발은 단일 저장소에서, 배포는 개별 저장소로 하는 하이브리드 접근법이 인기를 얻고 있으며, CI/CD 파이프라인 통합과 자동화 도구를 통해 복잡한 워크플로우를 단순화하는 추세이다.</description>
    </item>
    <item>
      <title>VCS comparison</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/vcs-comparison/</link>
      <pubDate>Sat, 28 Sep 2024 04:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/vcs-comparison/</guid>
      <description>RCS는 단일 파일 관리에 특화된 로컬 도구이며, CVS와 SVN은 중앙 집중식 협업을 지원합니다. Git과 Mercurial은 분산형 아키텍처로 현대 개발 워크플로우에 적합하며, Git은 생태계 면에서 압도적입니다. . 각 시스템은 고유한 아키텍처, 저장 방식, 장단점을 갖고 있어 프로젝트 특성과 요구사항에 따라 적절한 도구를 선택해야 하며, 최근에는 AI 통합, 모노레포 관리, GitOps 등의 새로운 동향이 등장하고 있습니다.</description>
    </item>
    <item>
      <title>4. 구현 (Implementation)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/4-implementation/</link>
      <pubDate>Fri, 20 Sep 2024 00:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/4-implementation/</guid>
      <description>설계를 바탕으로 실제 코드를 작성하는 단계</description>
    </item>
    <item>
      <title>힙 정렬 (Heap Sort)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/</link>
      <pubDate>Tue, 15 Oct 2024 08:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/heap-sort/</guid>
      <description>힙 정렬(Heap Sort)은 이진 힙(binary heap) 자료 구조를 활용한 비교 기반 정렬 알고리즘이다.</description>
    </item>
    <item>
      <title>Linear Data Structure vs Non-Linear Data Structure</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear-data-structure-vs-non-linear-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear-data-structure-vs-non-linear-data-structure/</guid>
      <description>Linear Data Structure vs. Non-Linear Data Structure</description>
    </item>
    <item>
      <title>Primitive data structure vs Non-Primitive data structure</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive-data-structure-vs-non-primitive-data-structure/</link>
      <pubDate>Sat, 12 Oct 2024 08:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive-data-structure-vs-non-primitive-data-structure/</guid>
      <description>Primitive data structure는 프로그래밍 언어에 내장된 가장 단순하고 기본적인 데이터 타입이며, Non-primitive data structure(비원시 자료구조)는 원시 자료형을 기반으로 만들어진 더 복잡하고 고급화된 자료구조를 의미한다.</description>
    </item>
    <item>
      <title>Background Jobs</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/background-jobs/</link>
      <pubDate>Wed, 09 Oct 2024 04:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/background-jobs/</guid>
      <description>백그라운드 작업 (Background Jobs) 은 사용자 요청 처리 흐름에서 분리되어 비동기적으로 실행되는 작업으로 시스템의 응답성과 확장성을 향상시킨다. 이러한 작업은 대용량 데이터 처리, 장기 실행 워크플로우, 실패 재시도, 이벤트 기반 트리거 등 다양한 시나리오에서 활용된다.</description>
    </item>
    <item>
      <title>Git Submodule vs. Subtree</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-submodule-vs-subtree/</link>
      <pubDate>Sat, 28 Sep 2024 10:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-submodule-vs-subtree/</guid>
      <description>깃 서브모듈 (Git Submodule) 과 서브트리 (Git Subtree) 는 외부 코드를 프로젝트에 통합하는 두 가지 접근 방식으로, 각각 고유한 장단점을 가진다. 서브모듈은 외부 저장소에 대한 참조만 저장하여 명확한 버전 관리와 코드 분리를 제공하지만, 복잡한 설정과 팀원 교육이 필요하다. 반면 서브트리는 외부 코드를 직접 통합하여 사용 편의성과 즉각적인 코드 접근성을 제공하지만, 저장소 크기 증가와 히스토리 복잡성이라는 단점이 있다. 프로젝트의 요구사항, 팀 구성, 개발 워크플로우에 따라 적합한 방식을 선택해야 하며, 최신 트렌드는 두 접근 방식 모두 자동화와 사용성 개선에 초점을 맞추고 있다.</description>
    </item>
    <item>
      <title>5. 테스트 (Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/5-testing/</link>
      <pubDate>Fri, 20 Sep 2024 00:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/5-testing/</guid>
      <description>개발된 소프트웨어의 품질을 검증하고 결함을 식별하는 단계</description>
    </item>
    <item>
      <title>Conflict Resolution</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/conflict-resolution/</link>
      <pubDate>Sat, 28 Sep 2024 09:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/conflict-resolution/</guid>
      <description>Git 충돌 해결은 협업 중 충돌된 코드를 병합하는 과정으로, 효율적인 협업과 안정적인 소스 관리를 위해 필수적이다. 충돌은 Git 이 자동으로 변경사항을 병합할 수 없을 때 발생하며, 개발자의 수동 개입이 필요하다. 효과적인 충돌 해결을 위해서는 충돌 마커 이해, 다양한 병합 전략 활용, 외부 도구 사용, 그리고 체계적인 해결 프로세스가 필요하다. `--ours` 와 `--theirs` 같은 옵션은 충돌 자동 해결에 유용하며, 리베이스와 서브모듈 충돌은 특별한 접근 방식이 요구된다. 2025년 현재, AI 기반 충돌 해결 도구의 등장과 자동화 기술의 발전이 두드러지며, 앞으로는 AI 가 더욱 정교하게 충돌을 자동으로 해결할 것으로 전망된다. 충돌 예방을 위한 작은 커밋, 정기적 동기화, 팀 내 원활한 커뮤니케이션도 효과적인 충돌 관리의 핵심 요소이다.</description>
    </item>
    <item>
      <title>6. 배포 (Deployment)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/6-deployment/</link>
      <pubDate>Fri, 20 Sep 2024 00:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/6-deployment/</guid>
      <description>완성된 소프트웨어를 실제 운영 환경에 설치하고 사용자에게 제공하는 단계</description>
    </item>
    <item>
      <title>Suffix Array vs Suffix Tree vs Trie</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/</link>
      <pubDate>Sat, 12 Oct 2024 15:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/array/suffix-array-vs-suffix-tree-vs-trie/</guid>
      <description>Suffix Array, Suffix Tree, 그리고 Trie는 모두 문자열 처리와 패턴 매칭을 위한 데이터 구조로, 각각 고유한 특성과 용도를 가지고 있다.</description>
    </item>
    <item>
      <title>7. 유지보수 (Maintenance)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/7-maintenance/</link>
      <pubDate>Fri, 20 Sep 2024 00:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/7-maintenance/</guid>
      <description>배포된 소프트웨어를 지속적으로 관리하고 개선하는 단계</description>
    </item>
    <item>
      <title>JSON vs. XML vs. Protobuf vs. MessagePack vs. Parquet</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/</link>
      <pubDate>Sat, 26 Oct 2024 11:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/json-vs-xml-vs-protobuf-vs-messagepack-vs-parquet/</guid>
      <description>데이터 직렬화 형식은 애플리케이션 간 데이터 교환의 핵심 요소이다.</description>
    </item>
    <item>
      <title>Blocking vs Non-Blocking</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/blocking-vs-non-blocking/</link>
      <pubDate>Sun, 06 Oct 2024 12:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/blocking-vs-non-blocking/</guid>
      <description>프로그래밍에서 작업 처리 방식에 따라 프로그램의 실행 흐름이 어떻게 영향을 받는지를 설명하는 개념.</description>
    </item>
    <item>
      <title>Synchronous vs Asynchronous APIs</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/synchronous-vs-asynchronous-apis/</link>
      <pubDate>Sun, 06 Oct 2024 00:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/synchronous-vs-asynchronous-apis/</guid>
      <description>프로그래밍에서 작업을 처리하는 두 가지 주요 방식</description>
    </item>
    <item>
      <title>Interface vs Abstract class</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/paradigm-features/interface-vs-abstract-class/</link>
      <pubDate>Sun, 22 Sep 2024 05:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/paradigm-features/interface-vs-abstract-class/</guid>
      <description>인터페이스는 클래스가 &amp;#39;무엇을 해야 하는지&amp;#39;를 정의하는 계약(contract)과 같은 역할을 하며, 추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.</description>
    </item>
    <item>
      <title>슬라이딩 윈도우 기법 (Sliding Window Technique)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/</link>
      <pubDate>Fri, 24 Jan 2025 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/sliding-window-technique/</guid>
      <description>슬라이딩 윈도우 기법은 배열이나 문자열의 연속적인 부분집합(부분 배열 또는 부분 문자열)을 고정 크기 또는 가변 크기의 윈도우로 표현하고, 이 윈도우를 왼쪽에서 오른쪽으로 &amp;#34;슬라이딩&amp;#34;하면서 문제를 해결한다.</description>
    </item>
    <item>
      <title>Process vs Thread vs Coroutine</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/</link>
      <pubDate>Sun, 06 Oct 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-vs-thread-vs-coroutine/</guid>
      <description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</description>
    </item>
    <item>
      <title>Multithreading vs. Multiprocessing vs Multitasking</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/multithreading/multithreading-vs-multiprocessing-vs-multitasking/</link>
      <pubDate>Sat, 05 Oct 2024 14:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/multithreading/multithreading-vs-multiprocessing-vs-multitasking/</guid>
      <description>Multithreading, Multiprocessing, Multitasking은 컴퓨터 시스템에서 동시성과 병렬성을 구현하는 세 가지 주요 개념이다.</description>
    </item>
    <item>
      <title>Process vs Thread</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/thread-vs-process/process-vs-thread/</link>
      <pubDate>Sat, 05 Oct 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/thread-vs-process/process-vs-thread/</guid>
      <description>Process란 실행 중인 프로그램의 인스턴스를 이야기하며, Thread란 프로세스 내에서 실행되는 더 작은 실행 단위를 말한다.</description>
    </item>
    <item>
      <title>Poetry vs uv vs Rye</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/</link>
      <pubDate>Wed, 27 Nov 2024 06:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/</guid>
      <description>파이썬 프로젝트 관리와 패키지 설치를 위한 도구들</description>
    </item>
    <item>
      <title>Linux Basic Command</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/popular-os/linux/linux-basic-command/</link>
      <pubDate>Tue, 01 Oct 2024 15:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/popular-os/linux/linux-basic-command/</guid>
      <description>Linux에서 자주 사용하는 명령어 모음</description>
    </item>
    <item>
      <title>Linux Permission</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/popular-os/linux/linux-permission/</link>
      <pubDate>Tue, 01 Oct 2024 15:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/popular-os/linux/linux-permission/</guid>
      <description>Linux 권한 설정</description>
    </item>
    <item>
      <title>Event-Driven Pattern vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/pattern-comparison/event-driven-pattern-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</link>
      <pubDate>Tue, 19 Nov 2024 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/pattern-comparison/event-driven-pattern-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/</guid>
      <description>EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일이며, Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. 그리고 Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다.</description>
    </item>
    <item>
      <title>Scenario Testing vs Use Case Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/manual-testing/test-cases-and-scenarios/scenario-testing-vs-use-case-testing/</link>
      <pubDate>Tue, 05 Nov 2024 17:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/manual-testing/test-cases-and-scenarios/scenario-testing-vs-use-case-testing/</guid>
      <description>Scenario Testing과 Use Case Testing은 소프트웨어 테스팅 기법으로, 사용자 관점에서 시스템의 기능과 동작을 검증하는 데 사용된다.</description>
    </item>
    <item>
      <title>Kafka vs RabbitMQ</title>
      <link>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/messaging-systems/event-streaming-platforms/kafka/kafka-vs-rabbitmq/</link>
      <pubDate>Tue, 22 Oct 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/messaging-systems/event-streaming-platforms/kafka/kafka-vs-rabbitmq/</guid>
      <description>Kafka와 RabbitMQ는 각각 고유한 강점을 가진 메시지 브로커 시스템이다. Kafka는 대용량 데이터 스트림 처리와 내구성에 탁월하며, RabbitMQ는 유연한 라우팅과 즉각적인 메시지 전달에 뛰어나다.</description>
    </item>
    <item>
      <title>Paging vs Segmentation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging-vs-segmentation/</link>
      <pubDate>Sat, 05 Oct 2024 08:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging-vs-segmentation/</guid>
      <description>Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.</description>
    </item>
    <item>
      <title>Callback vs Promise vs Async/Await</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback-vs-promise-vs-async-await/</link>
      <pubDate>Sat, 23 Nov 2024 09:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback-vs-promise-vs-async-await/</guid>
      <description>JavaScript의 비동기 처리 방식</description>
    </item>
    <item>
      <title>Streaming vs Polling</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/streaming-vs-polling/</link>
      <pubDate>Sun, 20 Oct 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/streaming-vs-polling/</guid>
      <description>Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술</description>
    </item>
    <item>
      <title>동기(Synchronous) vs. 비동기(Asynchronous) and Blocking vs. Non-Blocking</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/synchronization-and-asynchronization/synchronous-and-asynchronous-and-blocking-and-non-blocking/</link>
      <pubDate>Sun, 06 Oct 2024 12:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/synchronization-and-asynchronization/synchronous-and-asynchronous-and-blocking-and-non-blocking/</guid>
      <description>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</description>
    </item>
    <item>
      <title>Lock and Mutex</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/lock-and-mutex/</link>
      <pubDate>Sat, 05 Oct 2024 11:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/lock-and-mutex/</guid>
      <description>Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.</description>
    </item>
    <item>
      <title>Redis와 Valkey</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/nosql/key-value/redis%EC%99%80-valkey/</link>
      <pubDate>Tue, 22 Oct 2024 01:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/nosql/key-value/redis%EC%99%80-valkey/</guid>
      <description>Redis와 Valkey 모두 인메모리 데이터베이스로, 빠른 읽기/쓰기 성능을 제공하나, Redis의 라이선스 정책 변경으로 인해 Valkey가 fork되어 새로운 프로젝트가 되었다.</description>
    </item>
    <item>
      <title>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/governance-and-management/compliance-and-regulations/cloud-security-assurance-program/</link>
      <pubDate>Thu, 19 Sep 2024 11:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/governance-and-management/compliance-and-regulations/cloud-security-assurance-program/</guid>
      <description>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)은 한국인터넷진흥원(KISA)에서 주관하는 클라우드 서비스의 보안성을 평가하고 인증하는 제도.</description>
    </item>
    <item>
      <title>Server-Sent Events vs. Webhook</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/server-sent-events/server-sent-events-vs-webhook/</link>
      <pubDate>Sat, 08 Mar 2025 06:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/server-sent-events/server-sent-events-vs-webhook/</guid>
      <description>Webhook과 Server-Sent Events(SSE)는 실시간 데이터 전송을 위한 웹 기술이다.</description>
    </item>
    <item>
      <title>E-Commerce Service</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/e-commerce-service/</link>
      <pubDate>Tue, 03 Dec 2024 12:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/e-commerce-service/</guid>
      <description>물품 구매 서비스를 구현하기 위해 필요한 사항들을 정리한다.</description>
    </item>
    <item>
      <title>물류 운송 관리 시스템 (Transportation Management System, TMS)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/transportation-management-system/</link>
      <pubDate>Tue, 03 Dec 2024 06:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/transportation-management-system/</guid>
      <description>물류 운송 관리 시스템으로, 기업의 물류 운송 프로세스를 효율적으로 관리하고 최적화하기 위한 솔루션</description>
    </item>
    <item>
      <title>Enterprise Resource Planning</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/enterprise-resource-planning/</link>
      <pubDate>Tue, 03 Dec 2024 00:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/enterprise-resource-planning/</guid>
      <description>ERP(Enterprise Resource Planning)는 기업의 모든 자원을 통합적으로 관리하고 운영하기 위한 시스템</description>
    </item>
    <item>
      <title>Warehouse Management System</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/warehouse-management-system/</link>
      <pubDate>Tue, 03 Dec 2024 00:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/warehouse-management-system/</guid>
      <description>WMS(Warehouse Management System)는 창고 관리 시스템으로, 창고 내의 물류 프로세스를 최적화하고 효율적으로 관리하기 위한 소프트웨어 애플리케이션을 말한다</description>
    </item>
    <item>
      <title>setup.cfg vs pyproject.toml</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/</link>
      <pubDate>Wed, 27 Nov 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/</guid>
      <description>Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.</description>
    </item>
    <item>
      <title>Cloud vs. On-Premise</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/cloud/cloud-vs-on-premise/</link>
      <pubDate>Sun, 10 Nov 2024 10:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/cloud/cloud-vs-on-premise/</guid>
      <description>Cloud와 On-Premise는 기업의 IT 인프라를 구축하고 관리하는 두 가지 주요 방식을 설명하는 개념이다.</description>
    </item>
    <item>
      <title>CCE vs CVE vs CWE</title>
      <link>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cce-vs-cve-vs-cwe/</link>
      <pubDate>Thu, 07 Nov 2024 07:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cce-vs-cve-vs-cwe/</guid>
      <description>CCE, CVE, CWE는 모두 컴퓨터 시스템과 소프트웨어의 보안 취약점을 식별하고 분류하기 위한 표준화된 체계이다.</description>
    </item>
    <item>
      <title>ETL vs ELT</title>
      <link>https://buenhyden.github.io/posts/data-engineering/etl-and-elt-processes/etl-fundamentals/etl-vs-elt/</link>
      <pubDate>Sat, 26 Oct 2024 07:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/data-engineering/etl-and-elt-processes/etl-fundamentals/etl-vs-elt/</guid>
      <description>데이터 통합 및 처리를 위한 두 가지 주요 접근 방식</description>
    </item>
    <item>
      <title>WCS(Warehouse Control System)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/warehouse-control-system/</link>
      <pubDate>Tue, 03 Dec 2024 06:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/industry-patterns/warehouse-control-system/</guid>
      <description>WCS(Warehouse Control System)는 물류 창고의 자동화 설비를 실시간으로 제어하고 관리하는 시스템</description>
    </item>
    <item>
      <title>Decompose by Business Capability vs Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/</guid>
      <description>Decompose by Business Capability는 조직의 기능적 관점에서 시스템을 구조화할 때 적합하며, 비즈니스와 기술의 연계를 중시하는 경우에 유용하다.  Decompose by Subdomain은 도메인의 문제를 세분화하고 기술적 복잡성을 다루기 위해 설계된 방식으로, 도메인 주도 설계 원칙을 사용하는 프로젝트에 더 적합하다.</description>
    </item>
    <item>
      <title>ER(Entity-Relationship) 모델링</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-modeling/entity-relationship/entity-relationship-modeling/</link>
      <pubDate>Fri, 25 Oct 2024 02:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-modeling/entity-relationship/entity-relationship-modeling/</guid>
      <description>실제 세계의 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 표현하여 데이터베이스를 설계하는 방법</description>
    </item>
    <item>
      <title>Mediator Pattern vs Observer Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/design-patterns/gof/behavioral/mediator-pattern/mediator-pattern-vs-observer-pattern/</link>
      <pubDate>Tue, 24 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/design-patterns/gof/behavioral/mediator-pattern/mediator-pattern-vs-observer-pattern/</guid>
      <description>Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.</description>
    </item>
    <item>
      <title>System Test vs End-to-End Test</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/system-test-vs-end-to-end-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/system-test-vs-end-to-end-test/</guid>
      <description>System Testing과 End-to-End Testing은 소프트웨어 테스팅 과정에서 사용되는 두 가지 중요한 테스트 방법이다. 이 두 방법은 소프트웨어의 품질을 보장하기 위해 사용되지만, 그 범위와 목적에 차이가 있다.</description>
    </item>
    <item>
      <title>동적테스트(Dynamic Test) vs 정적테스트(Static Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/dynamic-test-vs-static-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/dynamic-test-vs-static-test/</guid>
      <description>소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.</description>
    </item>
    <item>
      <title>NodeJS vs. Javascript</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-javascript/</link>
      <pubDate>Sat, 23 Nov 2024 09:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-javascript/</guid>
      <description>JavaScript는 웹 페이지에 동적인 기능을 추가하기 위해 만들어진 프로그래밍 언어이며, Node.js는 JavaScript를 서버 측에서 실행할 수 있게 해주는 런타임 환경이다.</description>
    </item>
    <item>
      <title>import vs require</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/import-vs-require/</link>
      <pubDate>Sat, 23 Nov 2024 03:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/import-vs-require/</guid>
      <description>`require`는 Node.js에서 사용되는 CommonJS 모듈 시스템의 키워드로, 동기적으로 모듈을 로드하며 프로그램의 어느 지점에서나 호출할 수 있다. 반면에 `import`는 ES6에서 도입된 모듈 시스템의 키워드로, 코드 실행 전에 모듈을 미리 로드하며 파일의 시작 부분에서만 사용할 수 있다.</description>
    </item>
    <item>
      <title>Web Application Server (WAS) vs. Web Server</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/system-design/components/web-application-servers/web-application-server-vs-web-server/</link>
      <pubDate>Tue, 22 Oct 2024 07:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/system-design/components/web-application-servers/web-application-server-vs-web-server/</guid>
      <description>Web Application Server와 Web Server 비교 분석한다.</description>
    </item>
    <item>
      <title>Cache Strategy vs Cache Policy</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-strategy-vs-cache-policy/</link>
      <pubDate>Mon, 30 Sep 2024 15:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-strategy-vs-cache-policy/</guid>
      <description>캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.</description>
    </item>
    <item>
      <title>QA vs QC vs Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/quality-assurance-vs-quality-control-vs-testing/</link>
      <pubDate>Tue, 05 Nov 2024 07:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/quality-assurance-vs-quality-control-vs-testing/</guid>
      <description>Quality Assurance (QA)는 제품이나 서비스의 품질을 보장하기 위한 계획적이고 체계적인 활동들의 집합이며, Quality Control (QC)는 개발된 제품이나 서비스가 정해진 품질 기준을 충족하는지 확인하는 활동이고, Testing은 소프트웨어가 예상대로 작동하는지 확인하는 구체적인 실행 활동이다.</description>
    </item>
    <item>
      <title>GRASP vs. SOLID</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/grasp/grasp-vs-solid/</link>
      <pubDate>Tue, 03 Jun 2025 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/grasp/grasp-vs-solid/</guid>
      <description>GRASP 와 SOLID 는 객체지향 설계에서 널리 사용되는 원칙과 패턴이다. GRASP 는 책임 할당과 객체 간 협력에 중점을 두고, SOLID 는 유지보수성과 확장성을 위한 다섯 가지 구체적 원칙을 제시한다. 두 원칙 모두 소프트웨어 품질 향상에 필수적이나, 적용 범위와 구체성이 다르다.</description>
    </item>
    <item>
      <title>Failback vs. Fail Over</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failback-vs-fail-over/</link>
      <pubDate>Sun, 18 May 2025 12:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/quality-attributes/availability/failback-vs-fail-over/</guid>
      <description>Failover 는 주 시스템에 장애 발생 시 대기 시스템으로 자동 전환하여 서비스 연속성을 유지하는 방식이며, Failback 은 주 시스템이 복구된 후 원래 상태로 되돌리는 과정이다. 이 두 메커니즘은 고가용성 시스템에서 다운타임을 최소화하고 비즈니스 연속성을 보장하는 필수적인 재해 복구 전략을 구성한다.</description>
    </item>
    <item>
      <title>Availability in Numbers</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/availability/availability-in-numbers/</link>
      <pubDate>Thu, 15 May 2025 05:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/availability/availability-in-numbers/</guid>
      <description>시스템 설계에서 &amp;#34;Availability in Numbers&amp;#34; 는 시스템이 정상적으로 작동하는 시간의 비율을 수치화하여 가용성을 측정하는 개념이다. 일반적으로 &amp;#39;9 의 개수 &amp;#39; 로 표현되며, 시스템의 중요도에 따라 다양한 가용성 수준 (99%, 99.9%, 99.999% 등) 을 목표로 한다. 이를 달성하기 위해 중복성, 장애 감지 및 복구 메커니즘 등 다양한 패턴과 전략이 적용되며, 비즈니스 요구사항과 비용 사이의 균형을 고려해 설계한다.</description>
    </item>
    <item>
      <title>Event-driven APIs vs. Pub and Sub APIs</title>
      <link>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/</link>
      <pubDate>Fri, 04 Apr 2025 06:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/</guid>
      <description>이벤트 기반 API는 시스템 내에서 발생하는 상태 변화나 중요한 사건(이벤트)을 중심으로 설계된다. Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다.</description>
    </item>
    <item>
      <title>Load Shifting vs. Load Balancing</title>
      <link>https://buenhyden.github.io/posts/backend-development/migration-strategies/load-shifting/load-shifting-vs-load-balancing/</link>
      <pubDate>Fri, 04 Apr 2025 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/migration-strategies/load-shifting/load-shifting-vs-load-balancing/</guid>
      <description>로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.</description>
    </item>
    <item>
      <title>Horizontal vs. Vertical Scaling</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/</link>
      <pubDate>Thu, 03 Apr 2025 15:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/scalability-techniques/horizontal-vs-vertical-scaling/</guid>
      <description>수평적 확장 (Horizontal Scaling) 은 더 많은 서버나 노드를 추가하여 작업 부하를 분산시키는 방식이고, 수직적 확장 (Vertical Scaling) 은 기존 서버의 성능과 용량을 향상시키는 방식이다. 두 접근법은 각각 다른 장단점을 가지며, 적용 시나리오에 따라 선택 기준이 달라집니다. 수평적 확장은 분산 시스템에 적합하고, 수직적 확장은 단일 시스템 성능 향상에 효과적이다.</description>
    </item>
    <item>
      <title>OAuth 2.0 vs. OpenID Connect</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/oauth/oauth-20-vs-openid-connect/</link>
      <pubDate>Thu, 03 Apr 2025 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/oauth/oauth-20-vs-openid-connect/</guid>
      <description>OAuth 2.0과 OpenID Connect(OIDC)는 사용자 인증 및 권한 부여를 처리하는 데 사용되는 프로토콜이지만, 목적과 기능에서 명확한 차이가 있다.</description>
    </item>
    <item>
      <title>JWT vs. OAuth 2.0</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-oauth-20/</link>
      <pubDate>Thu, 03 Apr 2025 07:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-oauth-20/</guid>
      <description>JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 방식이다. 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다.</description>
    </item>
    <item>
      <title>Token Authentication vs. SAML</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-saml/</link>
      <pubDate>Thu, 03 Apr 2025 07:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-saml/</guid>
      <description>토큰 인증은 사용자의 자격 증명(보통 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후 요청에서 인증을 처리하는 방식이다. SAML은 서로 다른 도메인 간에 인증 및 권한 부여 데이터를 교환하기 위한 XML 기반 표준이다.</description>
    </item>
    <item>
      <title>Token Authentication vs. JWT</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/</link>
      <pubDate>Thu, 03 Apr 2025 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/</guid>
      <description>토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다. JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다.</description>
    </item>
    <item>
      <title>Token Authentication vs. OAuth</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-oauth-20/</link>
      <pubDate>Thu, 03 Apr 2025 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-oauth-20/</guid>
      <description>토큰 인증은 사용자의 자격 증명을 한 번만 확인한 후, 서버가 서명된 토큰을 발급하여 클라이언트가 이 토큰을 사용해 자신을 인증하도록 하는 것이다. OAuth 2.0의 핵심 아이디어는 사용자(리소스 소유자)가 비밀번호를 공유하지 않고도 제3자 애플리케이션(클라이언트)에게 자신의 데이터에 대한 특정 접근 권한을 부여할 수 있도록 하는 것이다.</description>
    </item>
    <item>
      <title>Token Authentication vs. OpenID Connect</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-openid-connect/</link>
      <pubDate>Thu, 03 Apr 2025 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-openid-connect/</guid>
      <description>토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다. OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 ID 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있게 하는 인증 프로토콜이다.</description>
    </item>
    <item>
      <title>Token Authentication vs. Cookie-Based Auth</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-cookie-based-auth/</link>
      <pubDate>Thu, 03 Apr 2025 07:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-cookie-based-auth/</guid>
      <description>토큰 인증은 서버가 사용자의 인증 정보를 확인한 후 서명된 토큰을 발급하고, 클라이언트가 이 토큰을 이후의 요청에 포함시켜 자신을 인증하는 방식이다. 쿠키 기반 인증은 서버가 사용자 인증 후 세션 ID를 포함한 쿠키를 클라이언트에 전송하고, 클라이언트가 이 쿠키를 모든 요청에 자동으로 포함시켜 인증하는 방식이다.</description>
    </item>
    <item>
      <title>SAML vs. OpenID Connect</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/saml/saml-vs-openid-connect/</link>
      <pubDate>Thu, 03 Apr 2025 05:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/saml/saml-vs-openid-connect/</guid>
      <description>SAML(Security Assertion Markup Language)과 OpenID Connect는 모두 사용자 인증 및 권한 부여를 위한 프로토콜</description>
    </item>
    <item>
      <title>Load shifting vs. autoscaling</title>
      <link>https://buenhyden.github.io/posts/backend-development/migration-strategies/load-shifting/load-shifting-vs-autoscaling/</link>
      <pubDate>Wed, 02 Apr 2025 15:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/migration-strategies/load-shifting/load-shifting-vs-autoscaling/</guid>
      <description>**Load Shifting**과 **Autoscaling**은 백엔드 시스템에서 리소스를 효율적으로 관리하기 위한 두 가지 전략이다</description>
    </item>
    <item>
      <title>Apache Pulsar vs. Kafka</title>
      <link>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-kafka/</link>
      <pubDate>Wed, 02 Apr 2025 06:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-kafka/</guid>
      <description>Apache Pulsar는 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다. Kafka는 높은 처리량, 내구성, 확장성을 제공하는 로그 기반의 발행-구독(pub-sub) 메시징 시스템이다.</description>
    </item>
    <item>
      <title>Apache Pulsar vs. RabbitMQ</title>
      <link>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/</link>
      <pubDate>Wed, 02 Apr 2025 06:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/messaging-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/</guid>
      <description>Apache Pulsar는 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다. RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다.</description>
    </item>
    <item>
      <title>jwt vs. Basic Authentication</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-basic-authentication/</link>
      <pubDate>Wed, 02 Apr 2025 02:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-basic-authentication/</guid>
      <description>JWT는 JSON 형식의 토큰을 사용하여 사용자 정보와 서명을 포함하는 상태 비저장(stateless) 인증 방식으로 토큰 자체에 모든 인증 정보가 포함된다. Basic Authentication는 사용자 ID와 비밀번호를 Base64로 인코딩하여 HTTP 헤더에 전송하는 상태 비저장 방식으로 매 요청마다 자격 증명을 전송한다.</description>
    </item>
    <item>
      <title>Session-Based Auth vs. Basic Authentication</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/session-based-authentication/session-based-auth-vs-basic-authentication/</link>
      <pubDate>Wed, 02 Apr 2025 02:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/session-based-authentication/session-based-auth-vs-basic-authentication/</guid>
      <description>기본 인증은 HTTP 프로토콜에 내장된 가장 단순한 인증 방식 중 하나이다. 세션 기반 인증은 서버 측에서 사용자의 상태를 유지하는 인증 방식이다.</description>
    </item>
    <item>
      <title>Cookie-Based Auth vs. Basic Authentication</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/cookie-based-authentication/cookie-based-auth-vs-basic-authentication/</link>
      <pubDate>Wed, 02 Apr 2025 02:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/cookie-based-authentication/cookie-based-auth-vs-basic-authentication/</guid>
      <description>웹 애플리케이션에서 사용자 인증을 처리하는 두 가지 주요 방식</description>
    </item>
    <item>
      <title>jwt vs. Cookie-Based Auth</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-cookie-based-auth/</link>
      <pubDate>Wed, 02 Apr 2025 02:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-cookie-based-auth/</guid>
      <description>JWT는 Stateless한 인증이 필요한 경우(예: API 중심 애플리케이션, 마이크로서비스)에 적합하다. Cookie 기반 인증은 전통적인 웹 애플리케이션에서 더 적합하며, 특히 보안 요구 사항이 높은 경우 유리한다.</description>
    </item>
    <item>
      <title>jwt vs. Session-based Auth</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-session-based-auth/</link>
      <pubDate>Wed, 02 Apr 2025 02:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-session-based-auth/</guid>
      <description>JWT는 Stateless가 필요한 API 중심 애플리케이션이나 마이크로서비스에 적합하다. 토큰을 안전하게 저장하려면 HttpOnly 쿠키 사용을 권장한다.세션 기반 인증은 보안이 우선시되는 금융 서비스나 소규모 웹 앱에서 유리하다.  Redis와 같은 인메모리 DB로 세션을 관리하면 확장성을 개선할 수 있다.</description>
    </item>
    <item>
      <title>Token Authentication vs. Session-based Auth</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-session-based-auth/</link>
      <pubDate>Wed, 02 Apr 2025 02:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-session-based-auth/</guid>
      <description>세션 기반 인증은 전통적인 인증 방식으로, 서버가 사용자의 로그인 상태를 세션으로 유지하는 방식이다. 토큰 인증은 클라이언트에게 서명된 토큰을 발급하여 인증하는 방식이다.</description>
    </item>
    <item>
      <title>Backpressure</title>
      <link>https://buenhyden.github.io/posts/backend-development/migration-strategies/backpressure/backpressure/</link>
      <pubDate>Tue, 01 Apr 2025 15:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/migration-strategies/backpressure/backpressure/</guid>
      <description>**Backpressure**는 데이터 처리 시스템에서 수신 측이 송신 측에게 자신의 처리 용량을 알려 데이터 흐름을 제어하는 메커니즘이다.</description>
    </item>
    <item>
      <title>JWT vs. OpenID Connect</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-openid-connect/</link>
      <pubDate>Tue, 01 Apr 2025 14:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-openid-connect/</guid>
      <description>JWT는 당사자 간에 안전하게 정보를 전송하기 위한 개방형 표준(RFC 7519)으로, 컴팩트하고 자체 포함적인 방식으로 정보를 안전하게 전달한다. OpenID Connect는 OAuth 2.0 프로토콜 위에 구축된 인증 계층으로, 클라이언트가 사용자의 신원을 확인하고 기본적인 프로필 정보를 얻을 수 있도록 하는 표준이다.</description>
    </item>
    <item>
      <title>SOAP API vs. SOAP</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/soap/soap-api-vs-soap/</link>
      <pubDate>Tue, 01 Apr 2025 03:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/soap/soap-api-vs-soap/</guid>
      <description>SOAP는 메시지 교환 프로토콜이고, SOAP API는 이 프로토콜을 사용하여 구현된 웹 서비스이다.</description>
    </item>
    <item>
      <title>Domain Name</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/domain-name/</link>
      <pubDate>Tue, 01 Apr 2025 02:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/domain-name/</guid>
      <description>도메인 이름은 인터넷에서 특정 위치를 식별하는 사람이 읽을 수 있는 주소이다.</description>
    </item>
    <item>
      <title>Hosting</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/hosting/</link>
      <pubDate>Mon, 31 Mar 2025 23:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/hosting/</guid>
      <description>호스팅은 API, 웹사이트, 애플리케이션과 같은 디지털 자산을 인터넷을 통해 사용자에게 제공하기 위해 서버 공간과 자원을 제공하는 서비스이다.</description>
    </item>
    <item>
      <title>ReDoc</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/tools/redoc/</link>
      <pubDate>Mon, 31 Mar 2025 09:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/tools/redoc/</guid>
      <description>ReDoc은 OpenAPI(이전의 Swagger) 명세를 기반으로 한 오픈 소스 API 문서 생성 도구이다.</description>
    </item>
    <item>
      <title>Adaptive Polling</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/adaptive-polling/</link>
      <pubDate>Sun, 23 Mar 2025 04:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/adaptive-polling/</guid>
      <description>어댑티브 폴링은 데이터 수집이나 시스템 모니터링 과정에서 폴링(polling) 주기를 상황과 필요에 따라 동적으로 조절하는 기술이다.</description>
    </item>
    <item>
      <title>Smart Polling</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/smart-polling/</link>
      <pubDate>Sun, 23 Mar 2025 04:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/smart-polling/</guid>
      <description>스마트 폴링은 단순히 일정 주기로 데이터를 확인하는 전통적인 폴링과 달리, 다양한 컨텍스트 정보와 알고리즘을 활용하여 &amp;#39;언제&amp;#39;, &amp;#39;무엇을&amp;#39;, &amp;#39;어떻게&amp;#39; 폴링할지 지능적으로 결정한다.</description>
    </item>
    <item>
      <title>LeetCode 221 - Maximal Square</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-221---maximal-square/</link>
      <pubDate>Sat, 22 Mar 2025 12:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-221---maximal-square/</guid>
      <description>0과 1로 이루어진 2D 행렬에서 1로 이루어진 가장 큰 정사각형의 면적을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 33 - Search in Rotated Sorted Array</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-33---search-in-rotated-sorted-array/</link>
      <pubDate>Sat, 22 Mar 2025 12:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-33---search-in-rotated-sorted-array/</guid>
      <description>회전된 정렬 배열에서 특정 값을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 20 - Valid Parentheses</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-20---valid-parentheses/</link>
      <pubDate>Sat, 22 Mar 2025 12:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-20---valid-parentheses/</guid>
      <description>주어진 문자열에 포함된 괄호들이 올바르게 짝지어져 있는지 확인하는 문제</description>
    </item>
    <item>
      <title>Baekjoon 9093 - 단어 뒤집기</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/baekjoon-9093---%EB%8B%A8%EC%96%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/</link>
      <pubDate>Fri, 21 Mar 2025 02:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/baekjoon-9093---%EB%8B%A8%EC%96%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/</guid>
      <description>주어진 문자열을 뒤집는 문제</description>
    </item>
    <item>
      <title>LeetCode 1698 - Number of Distinct Substrings in a String</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1698---number-of-distinct-substrings-in-a-string/</link>
      <pubDate>Fri, 21 Mar 2025 02:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1698---number-of-distinct-substrings-in-a-string/</guid>
      <description>문자열에서 서로 다른 부분 문자열의 개수를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 297 - Serialize and Deserialize Binary Tree</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-297---serialize-and-deserialize-binary-tree/</link>
      <pubDate>Thu, 20 Mar 2025 00:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-297---serialize-and-deserialize-binary-tree/</guid>
      <description>이진 트리를 문자열로 변환한 후, 다시 원래 트리로 복원하는 문제</description>
    </item>
    <item>
      <title>Codeforces 1245D - Shichikuji and Power Grid</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/codeforces-1245d---shichikuji-and-power-grid/</link>
      <pubDate>Wed, 19 Mar 2025 01:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/codeforces-1245d---shichikuji-and-power-grid/</guid>
      <description>주어진 도시 간 도로 비용을 고려하여 최소 비용으로 모든 도시를 연결하는 문제</description>
    </item>
    <item>
      <title>LeetCode 300 - Longest Increasing Subsequence</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-300---longest-increasing-subsequence/</link>
      <pubDate>Wed, 19 Mar 2025 01:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-300---longest-increasing-subsequence/</guid>
      <description>주어진 배열에서 가장 긴 증가하는 부분 수열(LIS)의 길이를 찾는 문제</description>
    </item>
    <item>
      <title>SWEA 1208 - Flatten</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/swea-1208---flatten/</link>
      <pubDate>Wed, 19 Mar 2025 01:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/swea-1208---flatten/</guid>
      <description>주어진 배열에서 두 숫자의 합이 특정 목표값이 되는 쌍을 찾는 문제</description>
    </item>
    <item>
      <title>Baekjoon 11652 - 카드</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/baekjoon-11652---%EC%B9%B4%EB%93%9C/</link>
      <pubDate>Tue, 18 Mar 2025 00:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/baekjoon-11652---%EC%B9%B4%EB%93%9C/</guid>
      <description>주어진 배열에서 가장 자주 등장하는 숫자를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 236 - Lowest Common Ancestor of a Binary Tree</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-236---lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Tue, 18 Mar 2025 00:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-236---lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>두 노드의 가장 가까운 공통 조상을 찾는 문제</description>
    </item>
    <item>
      <title>Codeforces 673A - Valid Parentheses</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/codeforces-673a---valid-parentheses/</link>
      <pubDate>Mon, 17 Mar 2025 00:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/codeforces-673a---valid-parentheses/</guid>
      <description>주어진 괄호 문자열이 올바르게 닫혔는지 확인하는 문제</description>
    </item>
    <item>
      <title>Baekjoon 2696 - 중앙값 구하기</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/baekjoon-2696---%EC%A4%91%EC%95%99%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 17 Mar 2025 00:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/baekjoon-2696---%EC%A4%91%EC%95%99%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/</guid>
      <description>주어진 정수 배열에서 중앙값을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 1007 - Minimum Domino Rotations For Equal Row</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1007---minimum-domino-rotations-for-equal-row/</link>
      <pubDate>Sun, 16 Mar 2025 03:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1007---minimum-domino-rotations-for-equal-row/</guid>
      <description>도미노 두 줄에서 최소 회전 횟수로 한 줄을 같은 숫자로 맞추는 문제</description>
    </item>
    <item>
      <title>Baekjoon 10808 - 알파벳 개수</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/baekjoon-10808---%EC%95%8C%ED%8C%8C%EB%B2%B3-%EA%B0%9C%EC%88%98/</link>
      <pubDate>Sun, 16 Mar 2025 03:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/baekjoon-10808---%EC%95%8C%ED%8C%8C%EB%B2%B3-%EA%B0%9C%EC%88%98/</guid>
      <description>주어진 배열에서 특정 숫자가 몇 번 등장했는지를 효율적으로 찾는 문제</description>
    </item>
    <item>
      <title>AtCoder DP Contest - Problem R (Grid 1)</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/atcoder-dp-contest---problem-r-grid-1/</link>
      <pubDate>Sat, 15 Mar 2025 00:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/atcoder-dp-contest---problem-r-grid-1/</guid>
      <description>두 문자열을 같게 만들기 위해 필요한 삽입, 삭제, 변경 연산의 최소 비용을 계산하는 문제</description>
    </item>
    <item>
      <title>Baekjoon 10807 - 개수 세기</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/baekjoon-10807---%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0/</link>
      <pubDate>Sat, 15 Mar 2025 00:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/baekjoon-10807---%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0/</guid>
      <description>주어진 배열에서 각 요소가 몇 번 등장했는지 계산하는 문제</description>
    </item>
    <item>
      <title>Codeforces 427C - Checkposts</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/codeforces-427c---checkposts/</link>
      <pubDate>Sat, 15 Mar 2025 00:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/codeforces-427c---checkposts/</guid>
      <description>방향 그래프에서 강하게 연결된 컴포넌트(SCC)를 찾는 문제</description>
    </item>
    <item>
      <title>OpenAPI 사양(OpenAPI Specification, OAS)</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/openapi-specification/</link>
      <pubDate>Fri, 14 Mar 2025 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/openapi-specification/</guid>
      <description>OpenAPI 사양(OpenAPI Specification, OAS)은 REST API를 설계, 문서화 및 표준화하기 위한 언어에 구애받지 않는 정의 형식이다.</description>
    </item>
    <item>
      <title>AtCoder DP Contest - Problem O (Matching)</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/atcoder-dp-contest---problem-o-matching/</link>
      <pubDate>Fri, 14 Mar 2025 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/atcoder-dp-contest---problem-o-matching/</guid>
      <description>주어진 키들의 검색 확률이 다를 때, 평균 검색 비용을 최소화하는 이진 검색 트리를 구성하는 문제</description>
    </item>
    <item>
      <title>Codeforces 1619B - Square Difference</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/codeforces-1619b---square-difference/</link>
      <pubDate>Fri, 14 Mar 2025 01:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/codeforces-1619b---square-difference/</guid>
      <description>주어진 배열에서 가장 많이 등장하는 요소를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 1293. Shortest Path in a Grid with Obstacles Elimination</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1293.-shortest-path-in-a-grid-with-obstacles-elimination/</link>
      <pubDate>Thu, 13 Mar 2025 01:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1293.-shortest-path-in-a-grid-with-obstacles-elimination/</guid>
      <description>주어진 2D 격자에서 특정 출발점에서 목표 지점까지 도달하는 최소 이동 횟수를 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 973. K Closest Points to Origin</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-973.-k-closest-points-to-origin/</link>
      <pubDate>Thu, 13 Mar 2025 01:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-973.-k-closest-points-to-origin/</guid>
      <description>주어진 2D 평면에서 가장 가까운 두 점을 찾는 문제</description>
    </item>
    <item>
      <title>UTF-8</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/utf-8/</link>
      <pubDate>Wed, 12 Mar 2025 13:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/utf-8/</guid>
      <description>UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다.</description>
    </item>
    <item>
      <title>LeetCode 1167. Minimum Cost to Connect Sticks</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1167.-minimum-cost-to-connect-sticks/</link>
      <pubDate>Wed, 12 Mar 2025 01:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1167.-minimum-cost-to-connect-sticks/</guid>
      <description>매번 가장 작은 두 개의 막대를 연결하면 최소 비용을 유지할 수 있음</description>
    </item>
    <item>
      <title>LeetCode 443. String Compression</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-443.-string-compression/</link>
      <pubDate>Wed, 12 Mar 2025 01:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-443.-string-compression/</guid>
      <description>연속된 문자의 개수를 세고 압축된 형태로 저장하는 문제</description>
    </item>
    <item>
      <title>LeetCode 532. K-diff Pairs in an Array</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-532.-k-diff-pairs-in-an-array/</link>
      <pubDate>Wed, 12 Mar 2025 01:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-532.-k-diff-pairs-in-an-array/</guid>
      <description>정렬 후 투 포인터를 활용하면 O(N) 또는 O(N log N) 내에 해결 가능</description>
    </item>
    <item>
      <title>SAML vs. OAuth 2.0</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/saml/saml-vs-oauth-20/</link>
      <pubDate>Tue, 11 Mar 2025 13:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/saml/saml-vs-oauth-20/</guid>
      <description>SAML의 주요 목적은 신원 공급자(Identity Provider, IdP)와 서비스 공급자(Service Provider, SP) 사이에 인증 정보를 교환할 수 있는 표준화된 방법을 제공하는 것이고 OAuth 2.0의 주요 목적은 사용자가 자신의 자격 증명을 공유하지 않고도 타사 애플리케이션에 자신의 데이터에 대한 제한된 접근 권한을 부여할 수 있도록 하는 것이다.</description>
    </item>
    <item>
      <title>Session-Based Auth vs. Cookie-Based Auth</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/session-based-authentication/session-based-auth-vs-cookie-based-auth/</link>
      <pubDate>Tue, 11 Mar 2025 13:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/session-based-authentication/session-based-auth-vs-cookie-based-auth/</guid>
      <description>세션 기반 인증은 서버 측에 사용자 상태 정보를 저장하고, 클라이언트에는 세션을 식별하는 고유 ID만 제공하는 방식이다. 쿠키 기반 인증은 HTTP 쿠키를 사용하여 사용자의 인증 상태를 유지하는 방식이다.</description>
    </item>
    <item>
      <title>OpenID Connect</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/openid-connect/</link>
      <pubDate>Tue, 11 Mar 2025 13:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/openid-connect/</guid>
      <description>OpenID Connect(OIDC)는 웹 기반 애플리케이션과 서비스를 위한 현대적인 인증 프로토콜로, OAuth 2.0 프레임워크를 기반으로 구축되었다. 이 프로토콜은 사용자의 신원을 검증하고, 안전하게 정보를 교환하는 표준화된 방법을 제공한다.</description>
    </item>
    <item>
      <title>HTTP basic authentication</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-security/authentication-and-authorization/authentication-methods/http-basic-authentication/basic-authentication/</link>
      <pubDate>Tue, 11 Mar 2025 13:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-security/authentication-and-authorization/authentication-methods/http-basic-authentication/basic-authentication/</guid>
      <description>HTTP 프로토콜에서 가장 단순한 형태의 인증 방식으로, 클라이언트가 서버에 요청을 보낼 때 사용자의 ID와 비밀번호를 Base64로 인코딩하여 전송하는 방식</description>
    </item>
    <item>
      <title>OpenID vs. OpenID Connect</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/openid/openid-vs-openid-connect/</link>
      <pubDate>Tue, 11 Mar 2025 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/openid/openid-vs-openid-connect/</guid>
      <description>OpenID와 OpenID Connect는 사용자 인증을 위한 중요한 표준이다.</description>
    </item>
    <item>
      <title>LeetCode 1000. Minimum Cost to Merge Stones</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1000.-minimum-cost-to-merge-stones/</link>
      <pubDate>Tue, 11 Mar 2025 00:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1000.-minimum-cost-to-merge-stones/</guid>
      <description>주어진 숫자 배열에서 연속된 원소를 병합할 때, 최소 비용을 구하는 문제</description>
    </item>
    <item>
      <title>Postman</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-implementation/postman/</link>
      <pubDate>Mon, 10 Mar 2025 13:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-implementation/postman/</guid>
      <description>Postman은 API(Application Programming Interface) 개발, 테스트, 문서화 및 협업을 위한 종합적인 플랫폼이다.</description>
    </item>
    <item>
      <title>Swagger</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/tools/swagger/</link>
      <pubDate>Mon, 10 Mar 2025 13:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/tools/swagger/</guid>
      <description>Swagger는 RESTful API를 설계, 개발, 문서화, 테스트하기 위한 종합적인 도구 모음이다.</description>
    </item>
    <item>
      <title>Contract Testing</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-testing/contract-testing/</link>
      <pubDate>Mon, 10 Mar 2025 02:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-testing/contract-testing/</guid>
      <description>계약 테스트(Contract Testing)는 서비스 간 상호작용이 명시된 계약을 준수하는지 확인하는 테스트 방법론이다.</description>
    </item>
    <item>
      <title>Load Testing</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-testing/load-testing/</link>
      <pubDate>Mon, 10 Mar 2025 02:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-testing/load-testing/</guid>
      <description>API 부하 테스트는 API가 예상된 사용자 부하와 그 이상의 상황에서 어떻게 동작하는지 검증하는 중요한 성능 테스트 유형이다.</description>
    </item>
    <item>
      <title>LeetCode 188. Best Time to Buy and Sell Stock IV</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-188.-best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Mon, 10 Mar 2025 02:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-188.-best-time-to-buy-and-sell-stock-iv/</guid>
      <description>주어진 최대 거래 횟수 내에서 주식을 사고팔아 최대 이익을 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 225. Implement Stack using Queues</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-225.-implement-stack-using-queues/</link>
      <pubDate>Sun, 09 Mar 2025 06:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-225.-implement-stack-using-queues/</guid>
      <description>큐를 이용하여 스택의 push, pop, top, empty 연산을 구현하는 문제</description>
    </item>
    <item>
      <title>Web Socket vs. Long Polling</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/web-socket-vs-long-polling/</link>
      <pubDate>Sun, 09 Mar 2025 02:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/web-socket-vs-long-polling/</guid>
      <description>WebSocket은 TCP 연결을 통해 전이중(full-duplex) 통신 채널을 제공하는 프로토콜이다. Long Polling은 기존 HTTP 요청-응답 모델을 확장한 기법으로, 클라이언트가 서버에 요청을 보내면 서버는 새로운 정보가 있을 때까지 응답을 보류한다.</description>
    </item>
    <item>
      <title>LeetCode 1631. Path With Minimum Effort</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1631.-path-with-minimum-effort/</link>
      <pubDate>Fri, 07 Mar 2025 01:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1631.-path-with-minimum-effort/</guid>
      <description>2D 행렬에서 출발지에서 목적지까지 이동할 때, 경로 중 가장 큰 높이 차이가 최소가 되는 경로를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 33. Search in Rotated Sorted Array</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-33.-search-in-rotated-sorted-array/</link>
      <pubDate>Fri, 07 Mar 2025 01:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-33.-search-in-rotated-sorted-array/</guid>
      <description>정렬된 배열이 회전된 상태에서 특정 값을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 70. Climbing Stairs</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-70.-climbing-stairs/</link>
      <pubDate>Fri, 07 Mar 2025 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-70.-climbing-stairs/</guid>
      <description>한 번에 1칸 또는 2칸씩 이동할 수 있을 때, n 계단을 오르는 방법의 수를 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 120. Triangle</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-120.-triangle/</link>
      <pubDate>Thu, 06 Mar 2025 00:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-120.-triangle/</guid>
      <description>삼각형 형태의 배열에서 꼭대기부터 바닥까지 이동하며 최소 합을 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 1837. Sum of Digits in Base K</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1837.-sum-of-digits-in-base-k/</link>
      <pubDate>Thu, 06 Mar 2025 00:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1837.-sum-of-digits-in-base-k/</guid>
      <description>숫자를 주어진 K진법으로 변환한 후, 각 자리 숫자의 합을 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 1027. Longest Arithmetic Subsequence</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-1027.-longest-arithmetic-subsequence/</link>
      <pubDate>Wed, 05 Mar 2025 09:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-1027.-longest-arithmetic-subsequence/</guid>
      <description>주어진 배열에서 등차수열을 이루는 가장 긴 부분 수열의 길이를 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 84. Largest Rectangle in Histogram</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-84.-largest-rectangle-in-histogram/</link>
      <pubDate>Wed, 05 Mar 2025 09:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-84.-largest-rectangle-in-histogram/</guid>
      <description>히스토그램이 주어졌을 때, 만들 수 있는 가장 큰 직사각형의 넓이를 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 191. Number of 1 Bits</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-191.-number-of-1-bits/</link>
      <pubDate>Wed, 05 Mar 2025 09:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-191.-number-of-1-bits/</guid>
      <description>주어진 정수를 2진수로 변환했을 때, 1의 개수를 세는 문제</description>
    </item>
    <item>
      <title>LeetCode 76. Minimum Window Substring</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-76.-minimum-window-substring/</link>
      <pubDate>Tue, 04 Mar 2025 00:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-76.-minimum-window-substring/</guid>
      <description>문자열 s에서 문자열 t의 모든 문자를 포함하는 가장 작은 부분 문자열을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 21. Merge Two Sorted Lists</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-21.-merge-two-sorted-lists/</link>
      <pubDate>Tue, 04 Mar 2025 00:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-21.-merge-two-sorted-lists/</guid>
      <description>두 개의 정렬된 연결 리스트를 하나의 정렬된 리스트로 병합하는 문제</description>
    </item>
    <item>
      <title>LeetCode 287. Find the Duplicate Number</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-287.-find-the-duplicate-number/</link>
      <pubDate>Tue, 04 Mar 2025 00:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-287.-find-the-duplicate-number/</guid>
      <description>길이가 𝑛&#43;1인 배열에서 1부터 𝑛까지의 숫자가 하나씩 포함되며, 단 하나의 숫자가 중복</description>
    </item>
    <item>
      <title>Server-sent Events vs. Websocket</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/server-sent-events/server-sent-events-vs-websocket/</link>
      <pubDate>Mon, 03 Mar 2025 05:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/server-sent-events/server-sent-events-vs-websocket/</guid>
      <description>전통적인 HTTP 요청-응답 모델은 실시간 데이터 전송에 최적화되어 있지 않기 때문에, 이를 보완하기 위한 기술로 서버 전송 이벤트(Server-Sent Events, SSE)와 웹소켓(WebSocket)이 등장했다.</description>
    </item>
    <item>
      <title>LeetCode 329. Longest Increasing Path in a Matrix</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-329.-longest-increasing-path-in-a-matrix/</link>
      <pubDate>Mon, 03 Mar 2025 03:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-329.-longest-increasing-path-in-a-matrix/</guid>
      <description>2D 행렬에서 숫자가 증가하는 경로 중 가장 긴 경로의 길이를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 819. Most Common Word</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-819.-most-common-word/</link>
      <pubDate>Mon, 03 Mar 2025 03:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-819.-most-common-word/</guid>
      <description>주어진 문장에서 가장 많이 등장하는 단어를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 14. Longest Common Prefix</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-14.-longest-common-prefix/</link>
      <pubDate>Sun, 02 Mar 2025 03:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-14.-longest-common-prefix/</guid>
      <description>여러 문자열이 주어졌을 때, 가장 긴 공통 접두사를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 232. Implement Queue using Stacks</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-232.-implement-queue-using-stacks/</link>
      <pubDate>Sun, 02 Mar 2025 03:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-232.-implement-queue-using-stacks/</guid>
      <description>두 개의 스택을 사용하여 큐의 enqueue, dequeue 연산을 구현하는 문제</description>
    </item>
    <item>
      <title>LeetCode 301. Remove Invalid Parentheses</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-301.-remove-invalid-parentheses/</link>
      <pubDate>Sun, 02 Mar 2025 03:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-301.-remove-invalid-parentheses/</guid>
      <description>주어진 괄호 문자열에서 올바른 괄호 표현식을 만들기 위해 최소한의 괄호를 제거하는 문제</description>
    </item>
    <item>
      <title>LeetCode 42. Trapping Rain Water</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-42.-trapping-rain-water/</link>
      <pubDate>Sat, 01 Mar 2025 09:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-42.-trapping-rain-water/</guid>
      <description>높이가 다른 블록들 사이에 고일 수 있는 빗물의 양을 계산하는 문제</description>
    </item>
    <item>
      <title>LeetCode 43. Multiply Strings</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-43.-multiply-strings/</link>
      <pubDate>Sat, 01 Mar 2025 09:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-43.-multiply-strings/</guid>
      <description>두 개의 문자열로 표현된 숫자를 곱하는 문제</description>
    </item>
    <item>
      <title>LeetCode 509. Fibonacci Number</title>
      <link>https://buenhyden.github.io/coding-test/2025/03/leetcode-509.-fibonacci-number/</link>
      <pubDate>Sat, 01 Mar 2025 09:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/03/leetcode-509.-fibonacci-number/</guid>
      <description>피보나치 수열의 n번째 값을 구하는 문제</description>
    </item>
    <item>
      <title>RFC 6749</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/oauth/rfc-6749/</link>
      <pubDate>Fri, 28 Feb 2025 11:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/oauth/rfc-6749/</guid>
      <description>RFC 6749는 OAuth 2.0 권한 부여 프레임워크(The OAuth 2.0 Authorization Framework)를 정의하는 인터넷 표준 문서이다.</description>
    </item>
    <item>
      <title>Streaming APIs</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/streaming-apis/</link>
      <pubDate>Fri, 28 Feb 2025 03:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/request-response-cycle/streaming/streaming-apis/</guid>
      <description>스트리밍 API는 서버에서 클라이언트로 데이터를 연속적인 흐름(stream) 형태로 전송하는 인터페이스이다.</description>
    </item>
    <item>
      <title>Event-driven APIs</title>
      <link>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis/</link>
      <pubDate>Fri, 28 Feb 2025 03:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis/</guid>
      <description>이벤트 기반 API(Event-Driven API)는 시스템 내에서 발생하는 상태 변화나 중요 사건을 이벤트로 정의하고, 이러한 이벤트를 중심으로 설계된 API 아키텍처이다</description>
    </item>
    <item>
      <title>Pub/Sub APIs</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/pub-sub-apis/</link>
      <pubDate>Fri, 28 Feb 2025 03:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/pub-sub-apis/</guid>
      <description>Pub/Sub(Publish-Subscribe) 패턴은 메시지 기반 아키텍처의 핵심 패러다임으로, 데이터를 생성하는 발행자(Publisher)와 데이터를 소비하는 구독자(Subscriber) 사이의 느슨한 결합(loose coupling)을 제공한다.</description>
    </item>
    <item>
      <title>Websocket API vs. Websocket</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/websocket-api-vs-websocket/</link>
      <pubDate>Fri, 28 Feb 2025 03:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/event-based-style/websocket/websocket-api-vs-websocket/</guid>
      <description>WebSocket은 통신 프로토콜 자체를 의미하며, 인터넷 상에서 메시지를 주고받는 방식을 정의하며 WebSocket API는 개발자가 웹 애플리케이션에서 WebSocket 프로토콜을 사용할 수 있게 해주는 프로그래밍 인터페이스이다.</description>
    </item>
    <item>
      <title>gRPC API vs. gRPC</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/</link>
      <pubDate>Fri, 28 Feb 2025 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/rpc-based/grpc/grpc-api-vs-grpc/</guid>
      <description>gRPC는 기술적 프레임워크이고, gRPC API는 이 프레임워크를 사용하여 구축된 실제 응용 프로그램 인터페이스이다.</description>
    </item>
    <item>
      <title>LeetCode 871. Minimum Number of Refueling Stops</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-871.-minimum-number-of-refueling-stops/</link>
      <pubDate>Fri, 28 Feb 2025 00:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-871.-minimum-number-of-refueling-stops/</guid>
      <description>주어진 연료 충전소에서 최소한의 충전으로 목적지까지 도달하는 문제</description>
    </item>
    <item>
      <title>LeetCode 9. Palindrome Number</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-9.-palindrome-number/</link>
      <pubDate>Fri, 28 Feb 2025 00:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-9.-palindrome-number/</guid>
      <description>주어진 숫자가 좌우 대칭(팰린드롬)인지 확인하는 문제</description>
    </item>
    <item>
      <title>GraphQL API vs. GraphQL</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/query-style/graphql/graphql-apis/graphql-api-vs-graphql/</link>
      <pubDate>Thu, 27 Feb 2025 11:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/query-style/graphql/graphql-apis/graphql-api-vs-graphql/</guid>
      <description>GraphQL은 페이스북이 2012년에 개발하고 2015년에 오픈소스로 공개한 쿼리 언어와 서버 측 런타임 사양(specification)이다. 반면 GraphQL API는 이 GraphQL 사양을 구현한 실제 API 인터페이스를 의미한다.</description>
    </item>
    <item>
      <title>Pagination</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/pagination/</link>
      <pubDate>Thu, 27 Feb 2025 02:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/pagination/</guid>
      <description>페이지네이션을 통해 서버는 데이터를 작은 &amp;#34;페이지&amp;#34; 단위로 나누어 전달하여 성능, 사용자 경험, 리소스 사용을 모두 최적화할 수 있다.</description>
    </item>
    <item>
      <title>URI Design</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-endpoint-design/uri-design/</link>
      <pubDate>Thu, 27 Feb 2025 02:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-endpoint-design/uri-design/</guid>
      <description>잘 설계된 URI는 API의 직관성을 높이고, 학습 곡선을 완화하며, 리소스의 구조와 관계를 명확히 보여준다.</description>
    </item>
    <item>
      <title>Get-and-Patch</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/get-and-patch/</link>
      <pubDate>Wed, 26 Feb 2025 11:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/get-and-patch/</guid>
      <description>&amp;#34;Get-and-Patch&amp;#34;는 **리소스의 부분적 업데이트를 효율적으로 처리하기 위한 REST API 디자인 패턴**으로, 기존 CRUD(Create, Read, Update, Delete) 방식의 한계를 보완한다.</description>
    </item>
    <item>
      <title>Get-and-Set</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/get-and-set/</link>
      <pubDate>Wed, 26 Feb 2025 11:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/get-and-set/</guid>
      <description>&amp;#34;Get-and-Set&amp;#34;은 전통적인 CRUD(Create, Read, Update, Delete) 방식을 개선한 REST API 디자인 패턴으로, **리소스의 존재 여부와 관계없이 단순화된 작업 흐름**을 제공한다.</description>
    </item>
    <item>
      <title>Timestamp-Checked</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/timestamp-checked/</link>
      <pubDate>Wed, 26 Feb 2025 11:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/handling-crud-operations/timestamp-checked/</guid>
      <description>Timestamp-Checked 방식은 동시성 제어를 위한 중요한 기법 중 하나로, 주로 낙관적 동시성 제어(Optimistic Concurrency Control)의 맥락에서 사용된다.</description>
    </item>
    <item>
      <title>LeetCode 45. Jump Game II</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-45.-jump-game-ii/</link>
      <pubDate>Wed, 26 Feb 2025 01:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-45.-jump-game-ii/</guid>
      <description>각 인덱스에서 점프할 수 있는 최대 거리가 주어질 때, 첫 번째 인덱스에서 마지막 인덱스로 이동하는 최소 점프 횟수를 구하는 문제</description>
    </item>
    <item>
      <title>AI Engineer vs. ML Engineer</title>
      <link>https://buenhyden.github.io/posts/ai/ai-engineering/fundamentals/ai-engineer-vs-ml-engineer/</link>
      <pubDate>Tue, 25 Feb 2025 14:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/ai/ai-engineering/fundamentals/ai-engineer-vs-ml-engineer/</guid>
      <description>AI Engineer는 NLP, Computer Vision 등을 포함한 복합적인 AI 시스템을 개발하고 ML Engineer는 데이터 기반 ML 모델 구축 및 최적화를 수행한다.</description>
    </item>
    <item>
      <title>AI vs. AGI</title>
      <link>https://buenhyden.github.io/posts/ai/fundamentals/ai-vs-agi/</link>
      <pubDate>Tue, 25 Feb 2025 14:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/ai/fundamentals/ai-vs-agi/</guid>
      <description>AI (Artificial Intelligence)는 특정 작업을 수행하기 위해 인간의 지능을 모방하는 기술이며 AGI (Artificial General Intelligence)는 모든 지적 작업에서 인간 수준의 인지 능력을 갖춘 이론적 시스템을 말한다.</description>
    </item>
    <item>
      <title>LeetCode 26. Remove Duplicates from Sorted Array</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-26.-remove-duplicates-from-sorted-array/</link>
      <pubDate>Tue, 25 Feb 2025 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-26.-remove-duplicates-from-sorted-array/</guid>
      <description>정렬된 배열에서 중복된 요소를 제거하고, 유니크한 요소들을 앞쪽으로 배치하는 문제</description>
    </item>
    <item>
      <title>Javascript Engines</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/</link>
      <pubDate>Mon, 24 Feb 2025 09:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/javascript-engines/</guid>
      <description>JavaScript 엔진은 JavaScript 코드를 이해하고 실행하는 프로그램으로, 웹 브라우저나 Node.js와 같은 환경에서 JavaScript 코드를 해석하고 실행하는 핵심 요소이다.</description>
    </item>
    <item>
      <title>LeetCode 132. Palindrome Partitioning II</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-132.-palindrome-partitioning-ii/</link>
      <pubDate>Sat, 22 Feb 2025 01:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-132.-palindrome-partitioning-ii/</guid>
      <description>문자열을 팰린드롬 부분 문자열로 분할할 때, 필요한 최소 분할 횟수를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 1119. Remove Vowels from a String</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-1119.-remove-vowels-from-a-string/</link>
      <pubDate>Sat, 22 Feb 2025 01:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-1119.-remove-vowels-from-a-string/</guid>
      <description>주어진 문자열에서 모든 모음(a, e, i, o, u)을 제거하는 문제</description>
    </item>
    <item>
      <title>LeetCode 516. Longest Palindromic Subsequence</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-516.-longest-palindromic-subsequence/</link>
      <pubDate>Sat, 22 Feb 2025 01:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-516.-longest-palindromic-subsequence/</guid>
      <description>주어진 문자열에서 가장 긴 팰린드롬 부분 수열의 길이를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 55. Jump Game</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-55.-jump-game/</link>
      <pubDate>Sat, 22 Feb 2025 01:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-55.-jump-game/</guid>
      <description>배열의 각 위치에서 점프할 수 있는 최대 범위가 주어질 때, 마지막 인덱스에 도달할 수 있는지 판단하는 문제</description>
    </item>
    <item>
      <title>LeetCode 123. Best Time to Buy and Sell Stock III</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-123.-best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Fri, 21 Feb 2025 01:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-123.-best-time-to-buy-and-sell-stock-iii/</guid>
      <description>주어진 주식 가격 배열에서 최대 두 번의 거래를 통해 얻을 수 있는 최대 이익을 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 560. Subarray Sum Equals K</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-560.-subarray-sum-equals-k/</link>
      <pubDate>Fri, 21 Feb 2025 01:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-560.-subarray-sum-equals-k/</guid>
      <description>연속된 부분 배열의 합이 𝐾가 되는 개수를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 31. Next Permutation</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-31.-next-permutation/</link>
      <pubDate>Thu, 20 Feb 2025 07:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-31.-next-permutation/</guid>
      <description>사전순으로 다음에 오는 순열을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 453. Minimum Moves to Equal Array Elements</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-453.-minimum-moves-to-equal-array-elements/</link>
      <pubDate>Thu, 20 Feb 2025 07:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-453.-minimum-moves-to-equal-array-elements/</guid>
      <description>모든 원소를 동일하게 만들기 위한 최소 이동 횟수를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 797. All Paths From Source to Target</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-797.-all-paths-from-source-to-target/</link>
      <pubDate>Thu, 20 Feb 2025 07:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-797.-all-paths-from-source-to-target/</guid>
      <description>방향 그래프에서 시작점에서 끝점까지 가는 모든 경로를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 134. Gas Station</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-134.-gas-station/</link>
      <pubDate>Wed, 19 Feb 2025 07:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-134.-gas-station/</guid>
      <description>원형 배열 형태로 주유소를 순회하며 특정 지점에서 출발할 때 전체 순환이 가능한지 확인하는 문제</description>
    </item>
    <item>
      <title>LeetCode 273. Integer to English Words</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-273.-integer-to-english-words/</link>
      <pubDate>Wed, 19 Feb 2025 07:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-273.-integer-to-english-words/</guid>
      <description>주어진 정수를 영어 단어로 변환하는 문제</description>
    </item>
    <item>
      <title>LeetCode 238. Product of Array Except Self</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-238.-product-of-array-except-self/</link>
      <pubDate>Wed, 19 Feb 2025 07:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-238.-product-of-array-except-self/</guid>
      <description>자기 자신을 제외한 모든 원소의 곱을 계산하는 문제</description>
    </item>
    <item>
      <title>LeetCode 15. 3Sum</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-15.-3sum/</link>
      <pubDate>Tue, 18 Feb 2025 04:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-15.-3sum/</guid>
      <description>연속된 부분 배열에서 최대 곱을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 323. Number of Connected Components in an Undirected Graph</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-323.-number-of-connected-components-in-an-undirected-graph/</link>
      <pubDate>Mon, 17 Feb 2025 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-323.-number-of-connected-components-in-an-undirected-graph/</guid>
      <description>주어진 무방향 그래프에서 연결된 컴포넌트의 개수를 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 787. Cheapest Flights Within K Stops</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-787.-cheapest-flights-within-k-stops/</link>
      <pubDate>Mon, 17 Feb 2025 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-787.-cheapest-flights-within-k-stops/</guid>
      <description>특정 정점에서 다른 정점까지, 최대 𝐾K개의 경유지 내에서 최소 비용으로 이동하는 경로를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 260. Single Number III</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-260.-single-number-iii/</link>
      <pubDate>Mon, 17 Feb 2025 01:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-260.-single-number-iii/</guid>
      <description>모든 숫자가 두 번씩 등장하는 배열에서 단 한 번만 등장하는 두 개의 숫자를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 53. Maximum Subarray</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-53.-maximum-subarray/</link>
      <pubDate>Sun, 16 Feb 2025 03:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-53.-maximum-subarray/</guid>
      <description>연속된 부분 배열 중 합이 가장 큰 값을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 125. Valid Palindrome</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-125.-valid-palindrome/</link>
      <pubDate>Sun, 16 Feb 2025 03:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-125.-valid-palindrome/</guid>
      <description>대소문자를 무시하고 알파벳과 숫자만 고려하여 팰린드롬 여부를 판단하는 문제</description>
    </item>
    <item>
      <title>LeetCode 240. Search a 2D Matrix II</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-240.-search-a-2d-matrix-ii/</link>
      <pubDate>Sun, 16 Feb 2025 03:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-240.-search-a-2d-matrix-ii/</guid>
      <description>행과 열이 정렬된 2D 행렬에서 특정 숫자를 찾는 문제</description>
    </item>
    <item>
      <title>Types of Real-time APIs</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/real-time-apis/types-of-real-time-apis/</link>
      <pubDate>Sat, 15 Feb 2025 01:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/real-time-apis/types-of-real-time-apis/</guid>
      <description>Real-time API는 클라이언트와 서버 간의 데이터를 거의 즉각적으로 주고받을 수 있는 API로, 실시간 데이터 교환을 가능하게 한다.</description>
    </item>
    <item>
      <title>LeetCode 991. Broken Calculator</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-991.-broken-calculator/</link>
      <pubDate>Sat, 15 Feb 2025 01:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-991.-broken-calculator/</guid>
      <description>주어진 숫자를 특정 연산(&#43;, -, *, /)을 이용해 목표 숫자로 변환하는 최소 연산 횟수를 구하는 문제</description>
    </item>
    <item>
      <title>LeetCode 236. Lowest Common Ancestor of a Binary Tree</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-236.-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Sat, 15 Feb 2025 01:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-236.-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>주어진 이진 트리에서 두 노드의 최소 공통 조상을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 438. Find All Anagrams in a String</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-438.-find-all-anagrams-in-a-string/</link>
      <pubDate>Sat, 15 Feb 2025 01:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-438.-find-all-anagrams-in-a-string/</guid>
      <description>문자열 내에서 특정 패턴의 아나그램이 시작되는 모든 인덱스를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-3.-longest-substring-without-repeating-characters/</link>
      <pubDate>Fri, 14 Feb 2025 05:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-3.-longest-substring-without-repeating-characters/</guid>
      <description>문자열에서 중복 문자가 없는 가장 긴 부분 문자열의 길이를 구하는 문제</description>
    </item>
    <item>
      <title>Monitoring</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/api-monitoring/</link>
      <pubDate>Fri, 14 Feb 2025 01:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/api-monitoring/</guid>
      <description>API 모니터링은 단순한 로그 수집을 넘어서, API 시스템의 건강 상태를 종합적으로 관찰하고 평가하는 프로세스이다.</description>
    </item>
    <item>
      <title>Profiling</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/api-profiling/</link>
      <pubDate>Fri, 14 Feb 2025 01:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/api-profiling/</guid>
      <description>API 프로파일링은 API의 성능, 행동, 리소스 사용 특성을 체계적으로 분석하는 프로세스로, 최적화 기회를 발견하고 성능 문제를 해결하는 데 필수적인 접근법이다</description>
    </item>
    <item>
      <title>Profiling and Monitoring</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/profiling-and-monitoring/</link>
      <pubDate>Fri, 14 Feb 2025 01:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/profiling-and-monitoring/</guid>
      <description>프로파일링은 API의 행동과 성능을 분석하여 최적화할 수 있는 영역을 파악하는 과정이며 모니터링은 API의 상태와 성능을 지속적으로 관찰하고 문제가 발생했을 때 신속하게 대응하는 과정이다.</description>
    </item>
    <item>
      <title>LeetCode 52. N-Queens II</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-52.-n-queens-ii/</link>
      <pubDate>Thu, 13 Feb 2025 05:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-52.-n-queens-ii/</guid>
      <description>N×N 체스판에 𝑁개의 퀸을 배치하는 문제</description>
    </item>
    <item>
      <title>Error Handling and Retries</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/error-handling-and-retries/</link>
      <pubDate>Thu, 13 Feb 2025 01:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/error-handling-and-retries/</guid>
      <description>효과적인 오류 처리와 재시도 메커니즘은 안정적인 API 설계의 핵심 요소이다.</description>
    </item>
    <item>
      <title>Performance Metrics</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/performance-metrics/</link>
      <pubDate>Thu, 13 Feb 2025 01:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-monitoring-and-analytics/performance-metrics/</guid>
      <description>API 성능 메트릭스는 API의 효율성, 안정성, 그리고 전반적인 품질을 측정하는 중요한 지표이다.</description>
    </item>
    <item>
      <title>Optimize API Response</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/optimize-api-response/</link>
      <pubDate>Wed, 12 Feb 2025 01:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-performance/optimize-api-response/</guid>
      <description>API 응답 최적화는 현대 웹 애플리케이션의 성능, 사용자 경험 및 자원 효율성을 크게 향상시키는 핵심 요소이다.</description>
    </item>
    <item>
      <title>Asynchronism</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-performance/asynchronism/</link>
      <pubDate>Wed, 12 Feb 2025 01:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-performance/asynchronism/</guid>
      <description>비동기 처리(Asynchronism)는 시스템의 응답성과 확장성을 크게 향상시킬 수 있다.</description>
    </item>
    <item>
      <title>LeetCode 51. N-Queens</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-51.-n-queens/</link>
      <pubDate>Tue, 11 Feb 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-51.-n-queens/</guid>
      <description>N×N 체스판에 서로 공격하지 않도록 𝑁개의 퀸을 배치하는 문제</description>
    </item>
    <item>
      <title>LeetCode 64. Minimum Path Sum</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-64.-minimum-path-sum/</link>
      <pubDate>Tue, 11 Feb 2025 05:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-64.-minimum-path-sum/</guid>
      <description>2D 격자에서 좌측 상단에서 우측 하단으로 가는 최소 비용 경로를 찾는 문제</description>
    </item>
    <item>
      <title>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/imperative-programming/imperative-programming-vs-declarative-programming/</link>
      <pubDate>Sun, 09 Feb 2025 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/imperative-programming/imperative-programming-vs-declarative-programming/</guid>
      <description>명령형 프로그래밍은 세밀한 제어와 최적화가 필요한 영역에서 강점을 발휘하며, 선언적 프로그래밍은 높은 수준의 추상화와 간결함이 중요한 영역에서 유리하다.</description>
    </item>
    <item>
      <title>select_related</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/web-framework/django/orm/queryset/optimization/select_related/</link>
      <pubDate>Sat, 08 Feb 2025 02:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/web-framework/django/orm/queryset/optimization/select_related/</guid>
      <description>SQL의 JOIN 연산을 활용하여 외래 키(Foreign Key) 관계가 있는 객체를 단일 쿼리로 함께 가져오는 메서드</description>
    </item>
    <item>
      <title>LeetCode 5. Longest Palindromic Substring</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-5.-longest-palindromic-substring/</link>
      <pubDate>Fri, 07 Feb 2025 05:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-5.-longest-palindromic-substring/</guid>
      <description>주어진 문자열에서 가장 긴 팰린드롬 부분 문자열을 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 1. Two Sum</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-1.-two-sum/</link>
      <pubDate>Fri, 07 Feb 2025 05:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-1.-two-sum/</guid>
      <description>배열에서 두 수의 합이 특정 값이 되는 두 인덱스를 찾는 문제</description>
    </item>
    <item>
      <title>LeetCode 72. Edit Distance</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-72.-edit-distance/</link>
      <pubDate>Thu, 06 Feb 2025 05:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-72.-edit-distance/</guid>
      <description>두 문자열을 같게 만들기 위해 필요한 최소 편집(삽입, 삭제, 변경) 횟수를 구하는 문제</description>
    </item>
    <item>
      <title>RFC 7519</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/rfc-7519/</link>
      <pubDate>Thu, 06 Feb 2025 03:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/rfc-7519/</guid>
      <description>2015년 5월에 Internet Engineering Task Force(IETF)에 의해 발행된 이 문서는 JWT의 구조, 형식, 서명 방법, 암호화 방법 등을 상세히 정의하고 있다.</description>
    </item>
    <item>
      <title>LeetCode 20. Valid Parentheses</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-20.-valid-parentheses/</link>
      <pubDate>Wed, 05 Feb 2025 05:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-20.-valid-parentheses/</guid>
      <description>괄호가 올바르게 짝을 이루고 있는지 확인하는 문제</description>
    </item>
    <item>
      <title>LeetCode 48. Rotate Image</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-48.-rotate-image/</link>
      <pubDate>Wed, 05 Feb 2025 05:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-48.-rotate-image/</guid>
      <description>주어진 𝑁×𝑁 행렬을 시계방향으로 90도 회전시키는 문제</description>
    </item>
    <item>
      <title>Hollywood Principle</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/inversion-of-control/hollywood-principle/</link>
      <pubDate>Tue, 04 Feb 2025 14:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/design-principles/inversion-of-control/hollywood-principle/</guid>
      <description>Hollywood Principle 은 &amp;#34;Don&amp;#39;t call us, we&amp;#39;ll call you&amp;#34; 라는 구호로, 저수준 컴포넌트가 고수준 컴포넌트를 직접 호출하지 않고, 고수준 컴포넌트가 필요할 때 저수준 컴포넌트를 호출하도록 제어의 흐름을 역전시키는 설계 원칙이다. 이를 통해 느슨한 결합과 확장성을 확보할 수 있다.</description>
    </item>
    <item>
      <title>LeetCode 88. Merge Sorted Array</title>
      <link>https://buenhyden.github.io/coding-test/2025/02/leetcode-88.-merge-sorted-array/</link>
      <pubDate>Tue, 04 Feb 2025 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/coding-test/2025/02/leetcode-88.-merge-sorted-array/</guid>
      <description>정렬된 두 배열이 주어질 때, 이를 하나의 정렬된 배열로 병합하는 문제</description>
    </item>
    <item>
      <title>API Lifecycle Management</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-lifecycle-management/</link>
      <pubDate>Sun, 02 Feb 2025 03:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-lifecycle-management/</guid>
      <description>API 라이프사이클 관리는 API의 계획 단계부터 폐기 단계까지 전체 수명주기를 체계적으로 관리하는 프로세스이다</description>
    </item>
    <item>
      <title>Short Polling</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/short-polling/</link>
      <pubDate>Sat, 01 Feb 2025 03:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/short-polling/</guid>
      <description>Short polling은 클라이언트가 주기적으로 서버에 HTTP 요청을 보내 새로운 데이터가 있는지 확인하는 방식이다.</description>
    </item>
    <item>
      <title>Long Polling</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/long-polling/</link>
      <pubDate>Sat, 01 Feb 2025 03:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/long-polling/</guid>
      <description>Long polling은 클라이언트가 서버에 HTTP 요청을 보내고, 서버는 새로운 정보가 있을 때까지 응답을 보류하는 방식이다.</description>
    </item>
    <item>
      <title>Divide and Conquer vs. Brute Force</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/</link>
      <pubDate>Fri, 24 Jan 2025 07:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/</guid>
      <description>Divide and Conquer vs. Brute Force 비교 분석</description>
    </item>
    <item>
      <title>Divide and Conquer vs. Branch and Bound</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/</link>
      <pubDate>Fri, 24 Jan 2025 02:16:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/</guid>
      <description>분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.</description>
    </item>
    <item>
      <title>최적 부분 구조(Optimal Substructure)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/</link>
      <pubDate>Wed, 22 Jan 2025 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/</guid>
      <description>최적 부분 구조는 한 문제의 최적해가 그 문제의 하위 문제들의 최적해를 포함하고 있는 특성을 말한다.</description>
    </item>
    <item>
      <title>중복되는 하위 문제(Overlapping Subproblems)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/</link>
      <pubDate>Tue, 21 Jan 2025 14:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/</guid>
      <description>중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.</description>
    </item>
    <item>
      <title>asyncio</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/concurrency/asynchrony/asyncio/</link>
      <pubDate>Sun, 19 Jan 2025 06:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/concurrency/asynchrony/asyncio/</guid>
      <description>Python의 `asyncio`는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, `async/await` 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있다.</description>
    </item>
    <item>
      <title>Greenlet and Gevent</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/concurrency-and-parallel-processing/greenlet-and-gevent/</link>
      <pubDate>Sun, 19 Jan 2025 05:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/concurrency-and-parallel-processing/greenlet-and-gevent/</guid>
      <description>Greenlet과 Gevent는 Python에서 동시성 프로그래밍을 위한 라이브러리이다.</description>
    </item>
    <item>
      <title>Typescript vs. Javascript</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/typescript-vs-javascript/</link>
      <pubDate>Sun, 19 Jan 2025 00:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/typescript-vs-javascript/</guid>
      <description>JavaScript와 TypeScript는 둘 다 웹 및 기타 환경에서 널리 사용되는 프로그래밍 언어이지만, 설계와 사용 목적에 있어 몇 가지 중요한 차이가 있다.</description>
    </item>
    <item>
      <title>Spanning Tree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/types/spanning-tree/</link>
      <pubDate>Sat, 18 Jan 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/types/spanning-tree/</guid>
      <description>스패닝 트리(Spanning Tree) 는 무방향 그래프(Undirected Graph)의 모든 정점을 포함하면서, 사이클 없이 연결된 부분 그래프이다.</description>
    </item>
    <item>
      <title>무방향 그래프(Undirected Graph)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/types/undirected-graph/</link>
      <pubDate>Sat, 18 Jan 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/types/undirected-graph/</guid>
      <description>무방향 그래프(Undirected Graph) 는 각 간선(Edge)에 방향성이 없는 그래프이다.</description>
    </item>
    <item>
      <title>방향 그래프(Directed Graph)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/types/directed-graph/</link>
      <pubDate>Sat, 18 Jan 2025 03:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/graph/types/directed-graph/</guid>
      <description>방향 그래프(Directed Graph, Digraph) 는 각 간선(Edge)에 방향성이 부여된 그래프이다.</description>
    </item>
    <item>
      <title>Modin</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/modin/</link>
      <pubDate>Fri, 17 Jan 2025 07:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/modin/</guid>
      <description>pandas를 대체할 수 있는 고성능 데이터프레임 라이브러리</description>
    </item>
    <item>
      <title>Dask</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/dask/</link>
      <pubDate>Fri, 17 Jan 2025 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/dask/</guid>
      <description>파이썬을 위한 유연한 병렬 컴퓨팅 라이브러리</description>
    </item>
    <item>
      <title>Polars</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/polars/</link>
      <pubDate>Fri, 17 Jan 2025 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/data-analysis/polars/</guid>
      <description>고성능 데이터 처리를 위해 설계된 파이썬 DataFrame 라이브러리</description>
    </item>
    <item>
      <title>Greedy Algorithm vs. Divide and Conquer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/</link>
      <pubDate>Sat, 28 Dec 2024 10:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/</guid>
      <description>분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.</description>
    </item>
    <item>
      <title>Event-Driven Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/event-driven/event-driven-pattern/</link>
      <pubDate>Sat, 28 Dec 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/event-driven/event-driven-pattern/</guid>
      <description>이 패턴은 시스템의 상태 변화를 이벤트로 표현하고, 이를 기반으로 서비스 간 통신을 구현하는 방식이다.</description>
    </item>
    <item>
      <title>Deterministic vs. Nondeterministic computation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/deterministic-vs-nondeterministic-computation/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/deterministic-vs-nondeterministic-computation/</guid>
      <description>결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.</description>
    </item>
    <item>
      <title>P vs NP problem</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/p-vs-np-problem/</link>
      <pubDate>Fri, 27 Dec 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/p-vs-np-problem/</guid>
      <description>P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다</description>
    </item>
    <item>
      <title>Non-deterministic Polynomial Time vs. Polynomial Time</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/</link>
      <pubDate>Fri, 27 Dec 2024 01:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/</guid>
      <description>계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다.</description>
    </item>
    <item>
      <title>NP-Hard vs. NP-Complete</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/</link>
      <pubDate>Fri, 27 Dec 2024 01:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-hard/np-hard-vs-np-complete/</guid>
      <description>NP-Complete는 NP 클래스 내에서 가장 어려운 문제들을 나타내며, NP-Hard는 NP-Complete를 포함하여 더 넓은 범위의 어려운 문제들을 포괄한다.</description>
    </item>
    <item>
      <title>Currying vs. Partial Application</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying-vs-partial-application/</link>
      <pubDate>Thu, 26 Dec 2024 10:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying-vs-partial-application/</guid>
      <description> 커링(Currying)과 부분 적용(Partial Application)은 콜백 함수를 다루는 강력한 패턴으로, 코드의 재사용성과 모듈성을 크게 향상시킨다.</description>
    </item>
    <item>
      <title>Partial Application</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/partial-application/</link>
      <pubDate>Thu, 26 Dec 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/partial-application/</guid>
      <description>부분 적용이란 여러 개의 인자를 받는 함수에 일부 인자를 미리 제공하여, 나머지 인자만 받는 새로운 함수를 생성하는 기법이다.</description>
    </item>
    <item>
      <title>Currying</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying/</link>
      <pubDate>Thu, 26 Dec 2024 07:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback/currying/</guid>
      <description>여러 개의 인자를 받는 함수를 단일 인자를 받는 일련의 함수들로 변환하는 기법이다.</description>
    </item>
    <item>
      <title>Tree Shaking</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/module-bundlers/tree-shaking/</link>
      <pubDate>Thu, 26 Dec 2024 07:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/module-bundlers/tree-shaking/</guid>
      <description>트리 쉐이킹(Tree Shaking)은 사용되지 않는 코드를 최종 번들에서 제거하는 프로세스</description>
    </item>
    <item>
      <title>Temporal Dead Zone</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/temporal-dead-zone/</link>
      <pubDate>Wed, 25 Dec 2024 15:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/temporal-dead-zone/</guid>
      <description>일시적 사각지대(Temporal Dead Zone, TDZ)는 JavaScript에서 변수가 선언되었지만 아직 초기화되지 않은 상태로 존재하는 코드 영역을 의미한다.</description>
    </item>
    <item>
      <title>Block</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/scopes/block/</link>
      <pubDate>Wed, 25 Dec 2024 14:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/scopes/block/</guid>
      <description>JavaScript에서 블록 스코프(Block Scope) 는 중괄호(`{}`)로 감싸진 코드 블록 내에서 선언된 변수나 함수가 해당 블록 내부에서만 유효한 범위를 의미한다</description>
    </item>
    <item>
      <title>Function</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/scopes/function/</link>
      <pubDate>Wed, 25 Dec 2024 14:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/scopes/function/</guid>
      <description>함수 스코프란 함수 내부에 선언된 변수와 함수가 해당 함수 내부에서만 접근 가능하다는 JavaScript의 특성을 의미한다.</description>
    </item>
    <item>
      <title>Global</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/scopes/global/</link>
      <pubDate>Wed, 25 Dec 2024 14:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/scopes/global/</guid>
      <description>자바스크립트에서 글로벌 스코프는 코드 전체에서 접근할 수 있는 가장 넓은 범위를 의미하며, 여기서 선언된 변수나 함수는 프로그램 전반에서 사용이 가능하다.</description>
    </item>
    <item>
      <title>Hoisting</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/hoisting/</link>
      <pubDate>Wed, 25 Dec 2024 14:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/hoisting/</guid>
      <description>JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 &amp;#39;끌어올린다(hoist)&amp;#39;는 의미를 가진다.</description>
    </item>
    <item>
      <title>Variable Declarations</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/variable-declarations/</link>
      <pubDate>Wed, 25 Dec 2024 14:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/variable-declarations/</guid>
      <description>프로그램에서 데이터를 저장하고 참조하는 데 사용되는 중요한 개념이다. 변수 선언 방식에 따라 변수의 **유효 범위(Scope)**와 **재할당 가능 여부** 등이 결정된다.</description>
    </item>
    <item>
      <title>변수 명명 규칙(Variable Naming Rules)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/naming-rules/</link>
      <pubDate>Wed, 25 Dec 2024 14:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/naming-rules/</guid>
      <description>JavaScript의 변수 명명 규칙(Variable Naming Rules)</description>
    </item>
    <item>
      <title>Type Casting</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/data-types/type-casting/</link>
      <pubDate>Tue, 24 Dec 2024 13:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/data-types/type-casting/</guid>
      <description>파이썬에서는 다양한 내장 함수를 사용하여 데이터 타입을 변환할 수 있다.</description>
    </item>
    <item>
      <title>NodeJS vs. FastAPI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-fastapi/</link>
      <pubDate>Sun, 22 Dec 2024 10:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-fastapi/</guid>
      <description>Node.js와 FastAPI는 각각 JavaScript와 Python 생태계에서 인기 있는 백엔드 기술로, 서로 다른 접근 방식과 강점을 가지고 있다.</description>
    </item>
    <item>
      <title>NodeJS vs. Flask</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-flask/</link>
      <pubDate>Sun, 22 Dec 2024 10:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-flask/</guid>
      <description>Node.js와 Flask는 현대 웹 애플리케이션 개발에 널리 사용되는 두 가지 인기 있는 백엔드 기술이다.  이 두 기술은 각각 다른 언어(JavaScript vs Python), 다른 철학, 그리고 서로 다른 접근 방식을 가지고 있다.</description>
    </item>
    <item>
      <title>ES Modules vs. CommonJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/es-modules-vs-commonjs/</link>
      <pubDate>Sun, 22 Dec 2024 04:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/es-modules-vs-commonjs/</guid>
      <description>ES Modules(ESM)과 CommonJS(CJS)는 JavaScript에서 사용되는 두 가지 주요 모듈 시스템이다.</description>
    </item>
    <item>
      <title>NodeJS vs. Django</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-django/</link>
      <pubDate>Sun, 22 Dec 2024 03:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-django/</guid>
      <description>Node.js와 Django는 각각 다른 철학, 접근 방식, 그리고 강점을 가진 인기 있는 두 가지 백엔드 기술이다.</description>
    </item>
    <item>
      <title>BunJS vs. NodeJS</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/bunjs/bunjs-vs-nodejs/</link>
      <pubDate>Sun, 22 Dec 2024 03:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/bunjs/bunjs-vs-nodejs/</guid>
      <description>서버 사이드 JavaScript 런타임인 BunJS와 NodeJS의 비교</description>
    </item>
    <item>
      <title>지연 초기화(Lazy Initialization)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/lazy-initialization/</link>
      <pubDate>Wed, 18 Dec 2024 10:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/lazy-initialization/</guid>
      <description>지연 초기화(Lazy Initialization)는 객체 생성, 값 계산, 또는 기타 비용이 많이 드는 프로세스를 실제로 필요할 때까지 연기하는 프로그래밍 기법</description>
    </item>
    <item>
      <title>RFC 9457</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/error-handling/rfc-9457/</link>
      <pubDate>Sun, 15 Dec 2024 14:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/error-handling/rfc-9457/</guid>
      <description>**RFC 9457**은 그 후속 버전으로, **HTTP API의 오류 응답을 구조화된 형식으로 전달하기 위한 표준**이다.</description>
    </item>
    <item>
      <title>RFC 7807</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/error-handling/rfc-7807/</link>
      <pubDate>Sun, 15 Dec 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/error-handling/rfc-7807/</guid>
      <description>RFC 7807은 HTTP API에서 오류 상황을 일관되고 기계가 처리하기 쉬운 방식으로 전달하기 위한 표준이다.</description>
    </item>
    <item>
      <title>DKIM (DomainKeys Identified Mail)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/dkim/</link>
      <pubDate>Sat, 14 Dec 2024 09:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/dkim/</guid>
      <description>DKIM은 이메일 인증을 위한 중요한 기술로, 이메일이 전송 과정에서 변조되지 않았으며 실제로 발신자가 주장하는 도메인에서 보낸 것임을 확인할 수 있게 해준다.  디지털 서명을 사용하여 이메일의 무결성과 출처를 검증하는 방식으로 작동한다.</description>
    </item>
    <item>
      <title>DMARC (Domain-based Message Authentication, Reporting, and Conformance)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/dmarc/</link>
      <pubDate>Sat, 14 Dec 2024 03:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/dmarc/</guid>
      <description>DMARC는 이메일 인증 프로토콜로, SPF(Sender Policy Framework)와 DKIM(DomainKeys Identified Mail)을 기반으로 작동한다.</description>
    </item>
    <item>
      <title>Domain Keys</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/domain-keys/</link>
      <pubDate>Sat, 14 Dec 2024 03:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/domain-keys/</guid>
      <description>도메인 키(DomainKeys)는 이메일 발신자의 도메인을 확인하고 메시지 무결성을 보장하기 위해 설계된 이메일 인증 방법</description>
    </item>
    <item>
      <title>Sender Policy Framework (SPF)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/spf/</link>
      <pubDate>Sat, 14 Dec 2024 03:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/spf/</guid>
      <description>SPF(Sender Policy Framework)는 이메일 스푸핑과 스팸을 방지하기 위해 설계된 이메일 인증 방법으로 이메일 도메인 소유자가 어떤 메일 서버가 해당 도메인에서 이메일을 보낼 수 있는 권한이 있는지 지정할 수 있게 해주는 중요한 보안 메커니즘이다.</description>
    </item>
    <item>
      <title>이메일 필터링 방식: White Listing vs. Grey Listing</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/white-listing-vs-grey-listing/</link>
      <pubDate>Sat, 14 Dec 2024 03:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/email/security/white-listing-vs-grey-listing/</guid>
      <description>Whitelisting과 Greylisting은 이메일 보안 및 스팸 방지를 위해 사용되는 두 가지 주요 접근 방식</description>
    </item>
    <item>
      <title>Little Endian</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/little-endian/</link>
      <pubDate>Fri, 13 Dec 2024 16:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/little-endian/</guid>
      <description>리틀 엔디안은 낮은 자리의 바이트가 낮은 메모리 주소에 먼저 저장되는 방식이다. 즉, 데이터의 &amp;#34;작은&amp;#34; 부분(Least Significant Byte)이 메모리의 작은 주소에 위치한다.</description>
    </item>
    <item>
      <title>Big Endian</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/big-endian/</link>
      <pubDate>Fri, 13 Dec 2024 16:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/binary-representation/endianness/big-endian/</guid>
      <description>빅 엔디안은 가장 중요한 바이트(Most Significant Byte, MSB)를 먼저 저장하는 방식이다. 즉, 높은 자리의 바이트가 낮은 메모리 주소에 위치한다.</description>
    </item>
    <item>
      <title>Dynamic Programming vs. Divide and Conquer</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/</link>
      <pubDate>Mon, 09 Dec 2024 05:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/</guid>
      <description>Divide and Conquer&amp;#34;와 &amp;#34;Dynamic Programming&amp;#34;은 모두 복잡한 문제를 더 작은 부분으로 나누어 해결하는 전략이지만, 접근 방식과 적용 상황에서 중요한 차이가 있다.</description>
    </item>
    <item>
      <title>Collision resolutions</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/</link>
      <pubDate>Sun, 08 Dec 2024 13:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/hashing/hash-collision/collision-resolutions/</guid>
      <description>해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.  그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다.</description>
    </item>
    <item>
      <title>Stack vs Queue</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/stack/stack-vs-queue/</link>
      <pubDate>Sun, 08 Dec 2024 08:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/stack/stack-vs-queue/</guid>
      <description>스택(Stack)과 큐(Queue)는 컴퓨터 과학에서 널리 사용되는 선형 자료구조로, 데이터의 저장 및 처리 방식에서 차이가 있다.</description>
    </item>
    <item>
      <title>Asymptotic Notation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/asymptotic-notation/</link>
      <pubDate>Fri, 06 Dec 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/asymptotic-notation/</guid>
      <description>점근적 표기법은 알고리즘의 효율성을 수학적으로 표현하는 방법으로, 입력 크기가 무한히 커질 때 알고리즘의 성능이 어떻게 변화하는지를 나타낸다.</description>
    </item>
    <item>
      <title>SEO(Search Engine Optimization)</title>
      <link>https://buenhyden.github.io/posts/frontend-development/fundamentals/html/seo/</link>
      <pubDate>Mon, 02 Dec 2024 12:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend-development/fundamentals/html/seo/</guid>
      <description>검색 엔진 최적화를 의미하며, 웹사이트나 콘텐츠를 검색 엔진의 검색 결과에서 상위에 노출시키기 위한 전략과 기술</description>
    </item>
    <item>
      <title>DOM</title>
      <link>https://buenhyden.github.io/posts/frontend-development/fundamentals/html/dom/</link>
      <pubDate>Mon, 02 Dec 2024 06:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend-development/fundamentals/html/dom/</guid>
      <description>HTML이나 XML 문서의 구조를 표현하는 프로그래밍 인터페이스.</description>
    </item>
    <item>
      <title>HTML tag</title>
      <link>https://buenhyden.github.io/posts/frontend-development/fundamentals/html/html-tag/</link>
      <pubDate>Sun, 01 Dec 2024 03:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/frontend-development/fundamentals/html/html-tag/</guid>
      <description>HTML 태그는 웹 페이지의 구조와 콘텐츠를 정의하는 핵심 요소이다.</description>
    </item>
    <item>
      <title>SQLAlchemy</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/database/sqlalchemy/</link>
      <pubDate>Sat, 30 Nov 2024 09:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/database/sqlalchemy/</guid>
      <description>파이썬에서 사용되는 강력하고 유연한 SQL 툴킷 및 객체 관계 매핑(ORM) 라이브러리</description>
    </item>
    <item>
      <title>daphne</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/daphne/</link>
      <pubDate>Sat, 30 Nov 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/daphne/</guid>
      <description>Daphne는 Django Channels를 위해 개발된 HTTP, HTTP2 및 WebSocket 프로토콜 서버이다.</description>
    </item>
    <item>
      <title>uvicorn</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uvicorn/</link>
      <pubDate>Sat, 30 Nov 2024 08:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uvicorn/</guid>
      <description>Uvicorn은 Python용 ASGI(Asynchronous Server Gateway Interface) 웹 서버 구현체이다.</description>
    </item>
    <item>
      <title>gunicorn</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/gunicorn/</link>
      <pubDate>Sat, 30 Nov 2024 03:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/gunicorn/</guid>
      <description>Gunicorn(Green Unicorn)은 Python WSGI(Web Server Gateway Interface) HTTP 서버로, 파이썬 웹 애플리케이션을 위한 강력하고 효율적인 서버 솔루션이다.</description>
    </item>
    <item>
      <title>UWSGI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uwsgi/</link>
      <pubDate>Sat, 30 Nov 2024 03:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uwsgi/</guid>
      <description>파이썬 웹 애플리케이션을 위한 강력하고 유연한 애플리케이션 서버</description>
    </item>
    <item>
      <title>pydantic</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/library/static-typing/pydantic/</link>
      <pubDate>Sat, 30 Nov 2024 03:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/library/static-typing/pydantic/</guid>
      <description>데이터 검증과 설정 관리를 위한 라이브러리</description>
    </item>
    <item>
      <title>ruff</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/ruff/</link>
      <pubDate>Thu, 28 Nov 2024 08:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/ruff/</guid>
      <description>Python 코드 품질을 개선하기 위한 린터</description>
    </item>
    <item>
      <title>autopep8</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/autopep8/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/autopep8/</guid>
      <description>Python 코드를 PEP 8 스타일 가이드라인에 맞게 자동으로 포맷팅해주는 도구</description>
    </item>
    <item>
      <title>Black</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/black/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/black/</guid>
      <description>파이썬을 위한 강력하고 엄격한 코드 포매터</description>
    </item>
    <item>
      <title>Flake8</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/flake8/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/flake8/</guid>
      <description>파이썬 코드를 위한 강력한 린팅(linting) 도구</description>
    </item>
    <item>
      <title>YAPF(Yet Another Python Formatter)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/yapf/</link>
      <pubDate>Thu, 28 Nov 2024 03:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/yapf/</guid>
      <description>Google에서 개발한 파이썬 코드 포매터.</description>
    </item>
    <item>
      <title>Pylint</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/pylint/</link>
      <pubDate>Thu, 28 Nov 2024 03:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/pylint/</guid>
      <description>파이썬 코드의 품질을 검사하고 개선하는데 도움을 주는 강력한 정적 코드 분석 도구</description>
    </item>
    <item>
      <title>CGI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/gateway-interface/cgi/</link>
      <pubDate>Thu, 28 Nov 2024 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/gateway-interface/cgi/</guid>
      <description>웹 서버와 외부 프로그램 간의 통신을 위한 표준 인터페이스</description>
    </item>
    <item>
      <title>WSGI</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/advanced/gateway-interface/wsgi/</link>
      <pubDate>Thu, 28 Nov 2024 03:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/advanced/gateway-interface/wsgi/</guid>
      <description>파이썬 웹 애플리케이션과 웹 서버 간의 표준 인터페이스를 정의하는 규약</description>
    </item>
    <item>
      <title>setup.cfg</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg/</link>
      <pubDate>Wed, 27 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg/</guid>
      <description>파이썬 프로젝트의 설정을 관리하는 구성 파일</description>
    </item>
    <item>
      <title>Poetry Configuration</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-configuration/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-configuration/</guid>
      <description>`config` 명령어나 `config.toml` 파일을 통해 설정할 수 있다.</description>
    </item>
    <item>
      <title>Poetry Libraries</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-libraries/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-libraries/</guid>
      <description>Poetry는 파이썬 라이브러리를 효율적으로 관리하고 배포할 수 있도록 지원하는 도구로 라이브러리를 설치 가능하게 만들기 위해 다음과 같은 절차를 따를 수 있다.</description>
    </item>
    <item>
      <title>Poetry Managing dependencies</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-managing-dependencies/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-managing-dependencies/</guid>
      <description>Poetry는 의존성을 효율적으로 관리하기 위해 다양한 기능을 제공한다.</description>
    </item>
    <item>
      <title>Poetry Usage</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-usage/</link>
      <pubDate>Wed, 27 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-usage/</guid>
      <description>Python 프로젝트의 의존성 관리와 패키징을 위한 도구</description>
    </item>
    <item>
      <title>The pyproject.toml file</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/the-pyproject.toml-file/</link>
      <pubDate>Wed, 27 Nov 2024 06:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/the-pyproject.toml-file/</guid>
      <description>Python 프로젝트의 구성 정보와 빌드 시스템 요구 사항을 정의하는 표준화된 구성 파일</description>
    </item>
    <item>
      <title>Rye</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/rye/</link>
      <pubDate>Wed, 27 Nov 2024 04:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/rye/</guid>
      <description>Rye는 파이썬 프로젝트와 패키지 관리를 위한 통합 솔루션으로, 2022년 11월에 Pynecone이라는 이름으로 처음 공개되었으나, 2023년 6월에 Rye로 이름이 변경되었다.</description>
    </item>
    <item>
      <title>PEP 20–The Zen of Python</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-20-the-zen-of-python/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-20-the-zen-of-python/</guid>
      <description>파이썬의 철학과 디자인 원칙을 담고 있는 19개의 지침.</description>
    </item>
    <item>
      <title>PEP 257–Docstring Conventions</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-257docstring-conventions/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-257docstring-conventions/</guid>
      <description>Python 코드의 docstring 작성에 대한 규칙과 관례를 정의한 문서</description>
    </item>
    <item>
      <title>PEP 3000–Python 3000</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3000python-3000/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3000python-3000/</guid>
      <description>Python 3000 (Python 3.0 또는 Py3k로도 알려짐) 개발에 대한 가이드라인을 제시하는 문서</description>
    </item>
    <item>
      <title>PEP 3333–Python Web Server Gateway Interface V1.0.1</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3333python-web-server-gateway-interface-v1/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3333python-web-server-gateway-interface-v1/</guid>
      <description>Python Web Server Gateway Interface (WSGI) 버전 1.0.1을 정의하는 문서</description>
    </item>
    <item>
      <title>PEP 484–Type Hints</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-484type-hints/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-484type-hints/</guid>
      <description>Python에 타입 힌트(Type Hints)를 도입하여 함수의 인자와 반환값에 대한 타입을 명시할 수 있도록 하는 표준을 정의</description>
    </item>
    <item>
      <title>PEP 492–Coroutines with Async and Await Syntax</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-492coroutines-with-async-and-await-syntax/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-492coroutines-with-async-and-await-syntax/</guid>
      <description>Python에 비동기 프로그래밍을 위한 async와 await 구문을 도입하여 코루틴(coroutine)을 명시적으로 정의하고 사용하는 방법을 제안</description>
    </item>
    <item>
      <title>PEP 8-Style Guide for Python Code</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-8-style-guide-for-python-code/</link>
      <pubDate>Tue, 26 Nov 2024 13:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/pep/pep-8-style-guide-for-python-code/</guid>
      <description>Python 코드의 스타일 가이드로, 가독성과 일관성을 높이기 위한 다양한 규칙과 권장사항을 제시</description>
    </item>
    <item>
      <title>Python-Special Methods</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/special-methods/</link>
      <pubDate>Mon, 25 Nov 2024 23:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/special-methods/</guid>
      <description>클래스에 특별한 기능을 부여하는 특수한 메소드</description>
    </item>
    <item>
      <title>Python - Iterators</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/iterators/</link>
      <pubDate>Mon, 25 Nov 2024 17:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/iterators/</guid>
      <description>데이터 컬렉션의 요소들을 순차적으로 접근할 수 있게 해주는 객체</description>
    </item>
    <item>
      <title>Structural Pattern Matching</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/conditionals/structural-pattern-matching/</link>
      <pubDate>Mon, 25 Nov 2024 14:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/conditionals/structural-pattern-matching/</guid>
      <description>Python 3.10부터 도입된 **구조적 패턴 매칭(Structural Pattern Matching)** 은 데이터의 구조와 값을 기반으로 코드의 흐름을 제어한다.</description>
    </item>
    <item>
      <title>name mangling</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/name-mangling/</link>
      <pubDate>Mon, 25 Nov 2024 09:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/name-mangling/</guid>
      <description>파이썬에서 &amp;#34;name mangling&amp;#34;은 클래스 내부의 속성이나 메서드의 이름을 변경하는 기능이다.  이 기능은 주로 정보 은닉과 캡슐화를 위해 사용된다.</description>
    </item>
    <item>
      <title>Python Super</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/super/</link>
      <pubDate>Mon, 25 Nov 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/super/</guid>
      <description>super()는 상속 관계에서 부모 클래스의 메서드를 호출하는 데 사용되는 중요한 도구.</description>
    </item>
    <item>
      <title>Method Resolution Order (MRO)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/method-resolution-order/</link>
      <pubDate>Mon, 25 Nov 2024 01:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/classes/method-resolution-order/</guid>
      <description>파이썬에서 클래스의 상속 관계에서 메서드를 찾는 순서를 정의하는 규칙</description>
    </item>
    <item>
      <title>classmethod and staticmethod</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/decorators/classmethod-and-staticmethod/</link>
      <pubDate>Sun, 24 Nov 2024 12:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/decorators/classmethod-and-staticmethod/</guid>
      <description>Python의 클래스에서 사용되는 두 가지 다른 종류의 메서드 데코레이터</description>
    </item>
    <item>
      <title>Generator and Iterator</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/generator-and-iterator/</link>
      <pubDate>Sun, 24 Nov 2024 10:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/generator-and-iterator/</guid>
      <description>이터레이터는 값을 차례대로 반환하는 객체로, `__iter__()`와 `__next__()` 메서드를 구현한다.  제너레이터는 `yield` 키워드를 사용하여 값을 하나씩 반환하는 함수로, 이터레이터를 생성한다.</description>
    </item>
    <item>
      <title>Python - Generators</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/functions/generators/</link>
      <pubDate>Sun, 24 Nov 2024 08:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/functions/generators/</guid>
      <description>반복 가능한 객체를 생성하는 강력한 도구</description>
    </item>
    <item>
      <title>내장 데코레이터 (Built-in Decorator)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/decorators/built-in-decorators/</link>
      <pubDate>Sun, 24 Nov 2024 07:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/decorators/built-in-decorators/</guid>
      <description>파이썬에는 다양한 내장 데코레이터가 있으며, 이들은 코드를 최적화하고 기능을 확장하는 데 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Docstring</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/comments/docstring/</link>
      <pubDate>Sun, 24 Nov 2024 03:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/comments/docstring/</guid>
      <description>python에서 함수, 클래스, 모듈에 대한 문서화를 위해 사용되는 문자열</description>
    </item>
    <item>
      <title>연산자(Operators)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/operations/operators/</link>
      <pubDate>Sun, 24 Nov 2024 00:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/operations/operators/</guid>
      <description>연산자는 프로그래밍의 기본적인 구성 요소로, 데이터를 조작하고 계산하는 데 사용된다.</description>
    </item>
    <item>
      <title>Cypress</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/cypress/</link>
      <pubDate>Fri, 22 Nov 2024 23:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/cypress/</guid>
      <description>Cypress는 JavaScript 기반의 강력한 프론트엔드 테스팅 프레임워크.</description>
    </item>
    <item>
      <title>Playwright</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/playwright/</link>
      <pubDate>Fri, 22 Nov 2024 23:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/playwright/</guid>
      <description>Playwright는 Microsoft에서 개발한 현대적이고 강력한 웹 자동화 및 테스팅 라이브러리</description>
    </item>
    <item>
      <title>Puppeteer</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/puppeteer/</link>
      <pubDate>Fri, 22 Nov 2024 23:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/puppeteer/</guid>
      <description>Google에서 개발한 Node.js 라이브러리로, 프로그래밍을 통해 Chrome 또는 Chromium 브라우저를 제어할 수 있게 해주는 고급 웹 자동화 도구</description>
    </item>
    <item>
      <title>Fastify</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/apis/frameworks/fastify/</link>
      <pubDate>Fri, 22 Nov 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/apis/frameworks/fastify/</guid>
      <description>Fastify는 Node.js를 위한 빠르고 낮은 오버헤드의 웹 프레임워크</description>
    </item>
    <item>
      <title>Koa</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/apis/frameworks/koa/</link>
      <pubDate>Fri, 22 Nov 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/apis/frameworks/koa/</guid>
      <description>Node.js를 위한 경량 웹 프레임워크로, Express.js 팀에 의해 개발되었다. Koa는 더 작고, 더 표현력이 풍부하며, 더 강력한 웹 애플리케이션과 API의 기초를 제공하기 위해 설계되었다.</description>
    </item>
    <item>
      <title>jasmine</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/jasmine/</link>
      <pubDate>Fri, 22 Nov 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/jasmine/</guid>
      <description>Jasmine은 JavaScript 애플리케이션을 위한 행위 주도 개발(BDD) 스타일의 테스팅 프레임워크</description>
    </item>
    <item>
      <title>Karma</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/karma/</link>
      <pubDate>Fri, 22 Nov 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/testing/karma/</guid>
      <description>Karma는 모든 브라우저에서 JavaScript 코드를 테스트할 수 있게 해주는 테스트 러너이다.</description>
    </item>
    <item>
      <title>winston</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/logging/winston/</link>
      <pubDate>Thu, 21 Nov 2024 15:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/logging/winston/</guid>
      <description>Winston은 Node.js 애플리케이션을 위한 다목적 로깅 라이브러리</description>
    </item>
    <item>
      <title>pino</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/logging/pino/</link>
      <pubDate>Thu, 21 Nov 2024 15:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/logging/pino/</guid>
      <description>Node.js를 위한 매우 빠르고 가벼운 로깅 라이브러리</description>
    </item>
    <item>
      <title>Mongoose</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/working-with-dbs/mongoose/</link>
      <pubDate>Thu, 21 Nov 2024 15:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/working-with-dbs/mongoose/</guid>
      <description>MongoDB와 Node.js 애플리케이션을 연결해주는 강력한 Object Document Mapper(ODM) 라이브러리</description>
    </item>
    <item>
      <title>Sequelize</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/working-with-dbs/sequelize/</link>
      <pubDate>Thu, 21 Nov 2024 15:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/working-with-dbs/sequelize/</guid>
      <description>Node.js 환경에서 사용되는 강력한 ORM(Object-Relational Mapping) 라이브러리</description>
    </item>
    <item>
      <title>Biome</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/linter-and-formatter/biome/</link>
      <pubDate>Thu, 21 Nov 2024 15:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/linter-and-formatter/biome/</guid>
      <description>JavaScript, TypeScript, JSX, TSX, JSON, CSS, GraphQL 등 다양한 웹 개발 언어를 위한 빠른 포매터이자 린터</description>
    </item>
    <item>
      <title>eslint</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/linter-and-formatter/eslint/</link>
      <pubDate>Thu, 21 Nov 2024 15:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/linter-and-formatter/eslint/</guid>
      <description>JavaScript 코드 분석 도구로, 코드의 품질을 향상시키고 잠재적인 문제를 미리 발견하는 것이 주요 목적</description>
    </item>
    <item>
      <title>prettier</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/linter-and-formatter/prettier/</link>
      <pubDate>Thu, 21 Nov 2024 15:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-ecosystem/linter-and-formatter/prettier/</guid>
      <description>JavaScript를 포함한 여러 웹 개발 언어를 위한 강력한 코드 포매터</description>
    </item>
    <item>
      <title>pm2</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/keep-app-running/pm2/</link>
      <pubDate>Thu, 21 Nov 2024 12:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/keep-app-running/pm2/</guid>
      <description>PM2는 Node.js 애플리케이션을 위한 고급 프로덕션 프로세스 관리자.</description>
    </item>
    <item>
      <title>jsdoc</title>
      <link>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/documentation/jsdoc/</link>
      <pubDate>Thu, 21 Nov 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/documentation/jsdoc/</guid>
      <description>JSDoc은 JavaScript 소스 코드에 대한 API 문서를 생성하기 위한 마크업 언어.</description>
    </item>
    <item>
      <title>Java Keywords</title>
      <link>https://buenhyden.github.io/posts/programming-languages/java/fundamentals/keywords/</link>
      <pubDate>Wed, 20 Nov 2024 02:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/java/fundamentals/keywords/</guid>
      <description>키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.  변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.</description>
    </item>
    <item>
      <title>Junit</title>
      <link>https://buenhyden.github.io/posts/programming-languages/java/advanced/testing/junit/</link>
      <pubDate>Wed, 20 Nov 2024 00:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/java/advanced/testing/junit/</guid>
      <description>Java 프로그래밍 언어를 위한 가장 널리 사용되는 단위 테스트(Unit Testing) 프레임워크</description>
    </item>
    <item>
      <title>Polling publisher</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/transactional-messaging/polling-publisher/</link>
      <pubDate>Tue, 19 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/transactional-messaging/polling-publisher/</guid>
      <description>Outbox 테이블에 저장된 메시지를 주기적으로 조회(polling)하여 메시지 브로커로 발행한다.  데이터베이스 트랜잭션의 일부로 메시지를 Outbox 테이블에 저장한 후, 별도의 프로세스에서 이를 읽어 발행한다.</description>
    </item>
    <item>
      <title>Transaction log tailing</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/transactional-messaging/transaction-log-tailing/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/transactional-messaging/transaction-log-tailing/</guid>
      <description>데이터베이스의 트랜잭션 로그를 실시간으로 읽어 변경사항을 메시지 브로커에 발행하는 방식이다.</description>
    </item>
    <item>
      <title>Transactional Outbox</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/transactional-messaging/transactional-outbox/</link>
      <pubDate>Tue, 19 Nov 2024 11:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/transactional-messaging/transactional-outbox/</guid>
      <description>Transactional Outbox 패턴은 데이터베이스 업데이트와 메시지 발행을 원자적으로 처리하기 위한 방법으로, 데이터베이스 트랜잭션과 메시지 발행 사이의 일관성을 보장하는 것을 목적으로 한다.</description>
    </item>
    <item>
      <title>Client-side UI composition</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/integration-patterns/ui-integration/client-side-ui-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/integration-patterns/ui-integration/client-side-ui-composition/</guid>
      <description>이 패턴은 각 서비스가 독립적으로 UI 컴포넌트를 제공하고, 클라이언트가 이를 조합하여 최종 화면을 렌더링하는 방식으로 동작한다.</description>
    </item>
    <item>
      <title>Server-side page fragment composition</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/integration-patterns/ui-integration/server-side-page-fragment-composition/</link>
      <pubDate>Tue, 19 Nov 2024 11:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/use-cases/integration-patterns/ui-integration/server-side-page-fragment-composition/</guid>
      <description>마이크로서비스 아키텍처(MSA)에서 여러 서비스로부터 HTML 조각(프래그먼트)을 수집하여 서버에서 최종 웹 페이지를 구성하는 패턴</description>
    </item>
    <item>
      <title>API Key Authentication</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/api-key-authentication/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/api-key-authentication/</guid>
      <description>API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다</description>
    </item>
    <item>
      <title>CORS</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/cors/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/cors/</guid>
      <description>CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Mutual TLS</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/mutual-tls/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/mutual-tls/</guid>
      <description>클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.</description>
    </item>
    <item>
      <title>OAuth2/OIDC (OpenID Connect)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/oauth2-oidc/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/oauth2-oidc/</guid>
      <description>분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Rate Limiting</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/performance-and-rate-limiting/rate-limiting/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/performance-and-rate-limiting/rate-limiting/</guid>
      <description>클라이언트/서비스 간 요청 처리량을 제어하는 메커니즘으로, 특히 API 기반 마이크로서비스 통신에서 중요하다.</description>
    </item>
    <item>
      <title>Secret Management</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/secret-management/</link>
      <pubDate>Mon, 18 Nov 2024 12:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/secret-management/</guid>
      <description>민감한 자격 증명(API 키, 데이터베이스 비밀번호, 토큰 등)을 안전하게 저장, 관리, 배포하는 핵심 보안 메커니즘이다.</description>
    </item>
    <item>
      <title>Access Token</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/access-token/</link>
      <pubDate>Mon, 18 Nov 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/security/access-token/</guid>
      <description>Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다</description>
    </item>
    <item>
      <title>Consumer-side contract test</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/test-and-quality/consumer-side-contract-test/</link>
      <pubDate>Mon, 18 Nov 2024 10:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/test-and-quality/consumer-side-contract-test/</guid>
      <description>테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.</description>
    </item>
    <item>
      <title>Consumer-Driven Contract Testing</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/test-and-quality/consumer-driven-contract-testing/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/test-and-quality/consumer-driven-contract-testing/</guid>
      <description>서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법</description>
    </item>
    <item>
      <title>Service Component Test</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/test-and-quality/service-component-test/</link>
      <pubDate>Mon, 18 Nov 2024 03:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/test-and-quality/service-component-test/</guid>
      <description>개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.</description>
    </item>
    <item>
      <title>Back Pressure</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/asynchronism/back-pressure/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/asynchronism/back-pressure/</guid>
      <description>시스템이 처리할 수 있는 양보다 더 많은 요청이 들어올 때, 이를 제어하는 메커니즘이다.</description>
    </item>
    <item>
      <title>Bulkhead</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/bulkhead/bulkhead/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/bulkhead/bulkhead/</guid>
      <description>Bulkhead 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 복원력과 장애 격리를 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Cache-Aside</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-strategy/cache-aside/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-strategy/cache-aside/</guid>
      <description>애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.</description>
    </item>
    <item>
      <title>Fail Fast</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/performance-and-rate-limiting/fail-fast/</link>
      <pubDate>Sun, 17 Nov 2024 12:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/performance-and-rate-limiting/fail-fast/</guid>
      <description>Fail Fast는 시스템에서 문제가 발생했을 때 즉시 실패를 보고하고 정상 작동을 중지하는 설계 원칙</description>
    </item>
    <item>
      <title>Anti-Corruption Layer</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/other/anti-corruption-layer/</link>
      <pubDate>Sun, 17 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/other/anti-corruption-layer/</guid>
      <description>이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.</description>
    </item>
    <item>
      <title>Circuit Breaker</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/circuit-breaker/circuit-breaker/</link>
      <pubDate>Sun, 17 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/circuit-breaker/circuit-breaker/</guid>
      <description>서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Timeout Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/timeout/</link>
      <pubDate>Sun, 17 Nov 2024 02:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/timeout/</guid>
      <description>서비스가 다른 서비스로부터의 응답을 무한정 기다리지 않도록 하여 시스템의 안정성과 응답성을 향상시킨다.</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/retry/retry/</link>
      <pubDate>Sun, 17 Nov 2024 02:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/retry/retry/</guid>
      <description>Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.</description>
    </item>
    <item>
      <title>Strangler Application</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/other/strangler-application/</link>
      <pubDate>Sun, 17 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/other/strangler-application/</guid>
      <description>Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.</description>
    </item>
    <item>
      <title>API Composition</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/api-composition/</link>
      <pubDate>Sat, 16 Nov 2024 10:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/api-composition/</guid>
      <description>이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.</description>
    </item>
    <item>
      <title>Dead Letter Queue</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/dead-letter-queue/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/dead-letter-queue/</guid>
      <description>Dead Letter Queue는 메시징 시스템에서 정상적으로 처리되지 못한 메시지를 저장하는 특별한 큐</description>
    </item>
    <item>
      <title>Message Broker</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/message-broker/</link>
      <pubDate>Fri, 15 Nov 2024 12:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/message-broker/</guid>
      <description>메시지 브로커(Message Broker)는 마이크로서비스 아키텍처(MSA)에서 중요한 역할을 하는 소프트웨어 컴포넌트로, 서비스 간 메시지를 안전하고 효율적으로 전달하는 중간 역할을 한다. 이를 통해 비동기 통신과 시스템 간의 느슨한 결합(loose coupling)을 가능하게 한다.</description>
    </item>
    <item>
      <title>Competing Consumers</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/competing-consumers/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/competing-consumers/</guid>
      <description>여러 소비자(Consumer)가 동일한 메시지 채널에서 동시에 메시지를 처리하는 방식이다. 이 패턴을 통해 시스템의 처리량을 높이고 확장성과 가용성을 개선할 수 있다.</description>
    </item>
    <item>
      <title>Message Filter</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/message-filter/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/message-filter/</guid>
      <description>Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴</description>
    </item>
    <item>
      <title>Message Router</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/message-router/</link>
      <pubDate>Fri, 15 Nov 2024 12:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/message-router/</guid>
      <description>Message Router는 메시지의 내용이나 메타데이터를 기반으로 메시지를 적절한 목적지로 전달하는 컴포넌트이다. 이는 메시지의 흐름을 제어하고 시스템의 유연성을 높이는 데 중요한 역할을 한다.</description>
    </item>
    <item>
      <title>Idempotent Consumer</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/idempotent-consumer/</link>
      <pubDate>Fri, 15 Nov 2024 11:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/idempotent-consumer/</guid>
      <description>Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다</description>
    </item>
    <item>
      <title>Domain event</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/maintaining-data-consistency/domain-event/</link>
      <pubDate>Fri, 15 Nov 2024 11:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/tradeoffs-and-theorems/maintaining-data-consistency/domain-event/</guid>
      <description>도메인 이벤트는 도메인 내에서 발생한 중요한 상태 변화를 나타내는 객체이다.</description>
    </item>
    <item>
      <title>Saga Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/saga/</link>
      <pubDate>Fri, 15 Nov 2024 10:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/saga/</guid>
      <description>Saga Pattern은 마이크로서비스 아키텍처에서 분산 트랜잭션을 관리하기 위한 디자인 패턴이다.</description>
    </item>
    <item>
      <title>Aggregate Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/aggregate/</link>
      <pubDate>Fri, 15 Nov 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/aggregate/</guid>
      <description>Aggregate 패턴은 도메인 주도 설계(DDD)에서 유래한 개념으로, 관련된 객체들을 하나의 단위로 묶어 데이터 변경 시 일관성을 유지한다.</description>
    </item>
    <item>
      <title>3rd party registration</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/3rd-party-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/3rd-party-registration/</guid>
      <description>이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.</description>
    </item>
    <item>
      <title>Self registration</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/self-registration/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/self-registration/</guid>
      <description>각 마이크로서비스 인스턴스가 자신의 정보를 서비스 레지스트리에 직접 등록하고 관리하는 패턴이다</description>
    </item>
    <item>
      <title>Server-side discovery</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/server-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/server-side-discovery/</guid>
      <description>Server-side Discovery는 클라이언트가 서비스의 위치를 직접 찾지 않고, 중간에 위치한 로드 밸런서나 프록시 서버가 서비스 위치를 찾아 요청을 라우팅하는 방식이다.</description>
    </item>
    <item>
      <title>Service registry</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/service-registry/</link>
      <pubDate>Thu, 14 Nov 2024 11:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/service-registry/</guid>
      <description>각 서비스 인스턴스의 네트워크 위치(IP 주소와 포트)를 저장하고 관리하는 중앙화된 데이터베이스</description>
    </item>
    <item>
      <title>Client-side discovery</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/client-side-discovery/</link>
      <pubDate>Thu, 14 Nov 2024 11:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/service-discovery/client-side-discovery/</guid>
      <description>Client-side Discovery는 서비스 클라이언트가 직접 서비스 레지스트리에 질의하여 필요한 서비스의 위치 정보를 얻고, 그 정보를 바탕으로 서비스를 호출하는 방식이다.</description>
    </item>
    <item>
      <title>Service deployment platform</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/service-deployment-platform/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/service-deployment-platform/</guid>
      <description>마이크로서비스 아키텍처(MSA)에서 서비스를 효율적으로 배포하고 관리하기 위한 플랫폼</description>
    </item>
    <item>
      <title>Service per VM</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/service-per-vm/</link>
      <pubDate>Wed, 13 Nov 2024 11:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/service-per-vm/</guid>
      <description>각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식</description>
    </item>
    <item>
      <title>Multiple Services per Host</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/multiple-services-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/multiple-services-per-host/</guid>
      <description>하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다</description>
    </item>
    <item>
      <title>Service per Container</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/service-per-container/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/service-per-container/</guid>
      <description>각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다</description>
    </item>
    <item>
      <title>Single Service per Host</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/single-service-per-host/</link>
      <pubDate>Wed, 13 Nov 2024 11:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/single-service-per-host/</guid>
      <description>각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식</description>
    </item>
    <item>
      <title>Serverless deployment</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/serverless-deployment/</link>
      <pubDate>Wed, 13 Nov 2024 11:34:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/deployment-and-operations/serverless-deployment/</guid>
      <description>Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다.</description>
    </item>
    <item>
      <title>Self-contained Service</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/self-contained-service/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/self-contained-service/</guid>
      <description>단일 비즈니스 기능을 완전히 독립적으로 구현한 서비스를 의미한다.  이 서비스는 자체적으로 데이터를 저장하고, 비즈니스 로직을 처리하며, 사용자 인터페이스를 제공할 수 있다.</description>
    </item>
    <item>
      <title>Service per team</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/service-per-team/</link>
      <pubDate>Wed, 13 Nov 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/service-per-team/</guid>
      <description>각 마이크로서비스를 개별 팀이 소유하고 관리하는 방식</description>
    </item>
    <item>
      <title>Sidecar Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/sidecar-pattern/sidecar/</link>
      <pubDate>Wed, 13 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/sidecar-pattern/sidecar/</guid>
      <description>Sidecar Pattern은 마치 오토바이의 사이드카처럼, 주 애플리케이션 컨테이너 옆에 보조 컨테이너를 배치하여 추가 기능을 제공한다.</description>
    </item>
    <item>
      <title>Decompose by Business Capability</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/decompose-by-business-capability/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/decompose-by-business-capability/</guid>
      <description>이 패턴은 비즈니스 능력을 기반으로 애플리케이션을 마이크로서비스로 분해하는 방법을 제시한다.</description>
    </item>
    <item>
      <title>Decompose by Subdomain</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/decompose-by-subdomain/</link>
      <pubDate>Wed, 13 Nov 2024 01:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/service-oriented/microservices-architecture/decomposition/decompose-by-subdomain/</guid>
      <description>비즈니스 도메인을 여러 하위 도메인으로 나누어 마이크로서비스를 설계하는 방법</description>
    </item>
    <item>
      <title>Externalized configuration</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/external-configuration-store/externalized-configuration/</link>
      <pubDate>Tue, 12 Nov 2024 11:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/integration/external-configuration-store/externalized-configuration/</guid>
      <description>이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.</description>
    </item>
    <item>
      <title>Database per Service Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/database-per-service/</link>
      <pubDate>Tue, 12 Nov 2024 10:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/database-per-service/</guid>
      <description>Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.  이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>Shared Database</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/shared-database/</link>
      <pubDate>Tue, 12 Nov 2024 07:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/shared-database/</guid>
      <description>여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다</description>
    </item>
    <item>
      <title>Portainer</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/container-management/portainer/</link>
      <pubDate>Mon, 11 Nov 2024 15:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/container-management/portainer/</guid>
      <description>컨테이너 환경을 관리하기 위한 오픈소스 웹 기반 GUI 도구</description>
    </item>
    <item>
      <title>VMware</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/virtualization/softwares/vmware/</link>
      <pubDate>Mon, 11 Nov 2024 12:55:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/virtualization/softwares/vmware/</guid>
      <description>가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구</description>
    </item>
    <item>
      <title>Envoy</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/container-orchestration/kubernetes/envoy/</link>
      <pubDate>Mon, 11 Nov 2024 11:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/container-orchestration/kubernetes/envoy/</guid>
      <description>Kubernetes 환경에서 널리 사용되는 고성능 프록시 서버</description>
    </item>
    <item>
      <title>Istio</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/service-mesh/tools/istio/istio/</link>
      <pubDate>Mon, 11 Nov 2024 06:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/service-mesh/tools/istio/istio/</guid>
      <description>마이크로서비스 아키텍처에서 서비스 간 통신을 관리하고 제어하는 서비스 메시(Service Mesh) 플랫폼</description>
    </item>
    <item>
      <title>Helm</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/container-orchestration/kubernetes/helm/</link>
      <pubDate>Mon, 11 Nov 2024 06:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/container-orchestration/kubernetes/helm/</guid>
      <description>쿠버네티스를 위한 패키지 관리자로, 복잡한 쿠버네티스 애플리케이션의 배포와 관리를 간소화하는 도구</description>
    </item>
    <item>
      <title>VirtualBox</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/virtualization/softwares/virtualbox/</link>
      <pubDate>Mon, 11 Nov 2024 04:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/virtualization/softwares/virtualbox/</guid>
      <description>가상화 소프트웨어로, 물리적 컴퓨터에서 여러 가상 머신(VM)을 실행할 수 있게 해주는 도구</description>
    </item>
    <item>
      <title>IaaS vs. PaaS vs. SaaS</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/cloud/iaas-vs-paas-vs-saas/</link>
      <pubDate>Sun, 10 Nov 2024 06:45:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/infrastructure/cloud/iaas-vs-paas-vs-saas/</guid>
      <description>IaaS, PaaS, SaaS는 클라우드 컴퓨팅의 주요 서비스 모델</description>
    </item>
    <item>
      <title>IDS and IPS</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-security/ids-and-ips/ids-and-ips/</link>
      <pubDate>Fri, 08 Nov 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-security/ids-and-ips/ids-and-ips/</guid>
      <description>IDS(침입 탐지 시스템)와 IPS(침입 방지 시스템)는 네트워크 보안을 위한 중요한 개념이다. 이 두 시스템은 네트워크 상의 악의적인 활동을 탐지하고 대응하는 데 사용된다.</description>
    </item>
    <item>
      <title>CCE(Common Configuration Enumeration)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cce/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cce/</guid>
      <description>CCE(Common Configuration Enumeration)는 시스템의 보안 설정과 관련된 취약점을 식별하고 관리하기 위한 표준화된 명명 체계</description>
    </item>
    <item>
      <title>CVE</title>
      <link>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cve/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cve/</guid>
      <description>CVE(Common Vulnerabilities and Exposures)는 공개적으로 알려진 컴퓨터 보안 취약점을 식별하고 카탈로그화하는 표준화된 시스템</description>
    </item>
    <item>
      <title>CVSS(Common Vulnerability Scoring System)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cvss/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cvss/</guid>
      <description>CVSS(Common Vulnerability Scoring System)는 보안 취약점의 심각도를 평가하고 수치화하는 표준화된 시스템</description>
    </item>
    <item>
      <title>CWE(Common Weakness Enumeration)</title>
      <link>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cwe/</link>
      <pubDate>Thu, 07 Nov 2024 07:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cwe/</guid>
      <description>CWE(Common Weakness Enumeration)는 소프트웨어와 하드웨어의 보안 약점을 체계적으로 분류하고 나열한 표준화된 목록</description>
    </item>
    <item>
      <title>DAC</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/dac/</link>
      <pubDate>Wed, 06 Nov 2024 23:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/dac/</guid>
      <description>리소스의 소유자가 해당 리소스에 대한다른  사용자들의 접근 권한을 직접 제어할 수 있는 접근 제어 방식</description>
    </item>
    <item>
      <title>MAC</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/mac/</link>
      <pubDate>Wed, 06 Nov 2024 23:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/mac/</guid>
      <description>시스템 전체에 걸쳐 중앙에서 정의된 보안 정책에 따라 접근 권한을 강제로 적용하는 접근 제어 방식.</description>
    </item>
    <item>
      <title>PBAC</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/pbac/</link>
      <pubDate>Wed, 06 Nov 2024 23:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/pbac/</guid>
      <description>중앙에서 정의된 정책들을 기반으로 접근 권한을 결정하는 접근 제어 방식.  각 정책은 &amp;#34;누가&amp;#34;, &amp;#34;무엇을&amp;#34;, &amp;#34;어떤 조건에서&amp;#34; 할 수 있는지를 정의하며, 이러한 정책들은 프로그래밍 방식으로 표현되고 평가된다.</description>
    </item>
    <item>
      <title>ABAC</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/abac/</link>
      <pubDate>Wed, 06 Nov 2024 23:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/abac/</guid>
      <description>ABAC는 주체(사용자), 객체(리소스), 작업, 환경 조건의 속성을 조합하여 접근 제어 정책을 정의한다.</description>
    </item>
    <item>
      <title>RBAC</title>
      <link>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/rbac/</link>
      <pubDate>Wed, 06 Nov 2024 23:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/security-engineering/access-control/authorization/authorization-models/rbac/</guid>
      <description>RBAC는 &amp;#34;만약 ~라면 ~할 수 있다&amp;#34;와 같은 형태의 규칙들을 사용하여 접근 권한을 제어한다. 각 규칙은 조건부와 결과부로 구성되며, 시스템은 이러한 규칙들을 순차적으로 평가하여 접근 허용 여부를 결정한다.</description>
    </item>
    <item>
      <title>Black-box Test and White-box Test</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-test-and-white-box-test/</link>
      <pubDate>Tue, 05 Nov 2024 02:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-test-and-white-box-test/</guid>
      <description>Black-box Testing(블랙박스 테스팅)은 소프트웨어의 내부 구조나 동작 원리를 모르는 상태에서 진행하는 테스트 방식이다. 반면 White-box Testing(화이트박스 테스팅)은 소프트웨어의 내부 로직을 알고 있는 상태에서 진행하는 테스트이다.</description>
    </item>
    <item>
      <title>Beta Test</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/acceptance-test/beta-test/</link>
      <pubDate>Mon, 04 Nov 2024 06:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/acceptance-test/beta-test/</guid>
      <description>베타 테스트는 소프트웨어 개발 주기의 마지막 단계에서 수행되는 테스트로, 제품이 일반 대중에게 공개되기 전 최종 단계에서 실제 사용자들이 참여하여 진행하는 테스트이다.</description>
    </item>
    <item>
      <title>Alpha Test</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/acceptance-test/alpha-test/</link>
      <pubDate>Mon, 04 Nov 2024 06:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/acceptance-test/alpha-test/</guid>
      <description>알파 테스트는 소프트웨어 개발 주기의 후반부에 수행되는 중요한 테스트 단계로 개발 중인 소프트웨어를 실제 환경과 유사한 조건에서 테스트하는 과정이다.</description>
    </item>
    <item>
      <title>시스템 테스트 (System test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/system-test/</link>
      <pubDate>Mon, 04 Nov 2024 06:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/system-test/</guid>
      <description>개발된 소프트웨어 시스템 전체를 검사하는 과정으로, 모든 개별 모듈과 구성 요소가 통합된 후 전체 시스템이 예상대로 작동하는지 확인한다.</description>
    </item>
    <item>
      <title>기본 테스팅 (Fundamental Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/fundamental-testing/</link>
      <pubDate>Mon, 04 Nov 2024 04:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/fundamental-testing/</guid>
      <description>소프트웨어 테스팅의 기본적인 프로세스와 원칙을 의미한다.</description>
    </item>
    <item>
      <title>통합 테스트 (Integration Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/integration-test/</link>
      <pubDate>Mon, 04 Nov 2024 02:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/integration-test/</guid>
      <description>통합 테스트는 소프트웨어 개발 과정에서 개별적으로 테스트된 모듈들을 결합하여 전체 시스템으로서의 상호작용을 검증하는 과정이다</description>
    </item>
    <item>
      <title>단위 테스트 (Unit Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/unit-test/</link>
      <pubDate>Mon, 04 Nov 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/unit-test/</guid>
      <description>단위 테스트는 소프트웨어의 가장 작은 단위인 개별 모듈이나 컴포넌트를 독립적으로 테스트하는 과정이다.</description>
    </item>
    <item>
      <title>회귀 테스트 (Regression Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/regression-test/</link>
      <pubDate>Sun, 03 Nov 2024 14:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/regression-test/</guid>
      <description>회귀 테스트는 소프트웨어의 변경이나 수정 후에 기존 기능이 여전히 올바르게 작동하는지 확인하는 테스트이다.</description>
    </item>
    <item>
      <title>사용성 테스트 (Usability Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/usability-test/</link>
      <pubDate>Sun, 03 Nov 2024 14:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/usability-test/</guid>
      <description>사용성 테스트는 제품이나 서비스를 실제 사용자가 사용해보면서 그 과정을 관찰하고 분석하는 테스트 방법이다.</description>
    </item>
    <item>
      <title>부하 테스트(Load Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/load-testing/</link>
      <pubDate>Sun, 03 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/load-testing/</guid>
      <description>부하 테스트는 소프트웨어 시스템이 예상되는 사용자 부하 하에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>스트레스 테스트 (Stress Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/stress-testing/</link>
      <pubDate>Sun, 03 Nov 2024 14:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/stress-testing/</guid>
      <description>스트레스 테스트는 소프트웨어 시스템을 극한의 조건에서 테스트하여 그 한계를 파악하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>보안 테스트 (Security Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/security-test/security-test/</link>
      <pubDate>Sun, 03 Nov 2024 05:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/security-test/security-test/</guid>
      <description>소프트웨어 시스템의 보안성을 평가하기 위한 일련의 활동</description>
    </item>
    <item>
      <title>전문화된 테스팅 (Specialized Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/specialized-testing/</link>
      <pubDate>Sun, 03 Nov 2024 04:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/specialized-testing/</guid>
      <description>Specialized Testing은 소프트웨어 테스팅의 한 분야로, 특정 영역이나 기능에 초점을 맞춘 심층적인 테스트 방식이다.</description>
    </item>
    <item>
      <title>호환성 테스트 (Compatibility Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/manual-testing/compatibility/compatibility-test/</link>
      <pubDate>Sun, 03 Nov 2024 03:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/manual-testing/compatibility/compatibility-test/</guid>
      <description>호환성 테스트는 소프트웨어가 다양한 하드웨어, 운영체제, 네트워크 환경 등에서 올바르게 작동하는지 확인하기 위해 수행되는 테스트이다.</description>
    </item>
    <item>
      <title>용량 테스트 (Volume Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/volume-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/volume-test/</guid>
      <description>용량 테스트는 소프트웨어 시스템이 대량의 데이터를 처리할 때 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>확장성 테스트 (Scalability Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/scalability-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/scalability-test/</guid>
      <description>확장성 테스트는 소프트웨어 시스템이 증가하는 부하나 규모에 얼마나 잘 대응할 수 있는지를 평가하는 성능 테스트의 한 유형이다</description>
    </item>
    <item>
      <title>스모크 테스트 (Smoke Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/smoke-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/functional-testing/smoke-test/</guid>
      <description>스모크 테스트는 소프트웨어의 가장 중요한 기능이 제대로 작동하는지 빠르게 확인하는 예비 테스트이다</description>
    </item>
    <item>
      <title>엔드투엔드 테스트(End-to-End Test, E2E Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/end-to-end-test/</link>
      <pubDate>Sun, 03 Nov 2024 02:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/end-to-end-test/</guid>
      <description>이는 사용자의 관점에서 전체 애플리케이션의 흐름을 테스트하여 모든 구성 요소가 올바르게 작동하는지 확인한다.</description>
    </item>
    <item>
      <title>스파이크 테스트(Spike Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/spike-test/</link>
      <pubDate>Sun, 03 Nov 2024 01:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/spike-test/</guid>
      <description>스파이크 테스트는 시스템에 갑작스럽고 극단적인 부하를 주어 시스템의 반응을 측정하는 성능 테스트의 한 유형이다.</description>
    </item>
    <item>
      <title>지속성 테스트(Endurance Test)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/endurance-test/</link>
      <pubDate>Sun, 03 Nov 2024 01:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-techniques/non-functional-testing/performance-test/endurance-test/</guid>
      <description>지속성 테스트는 소프트웨어 시스템이 장기간 동안 지속적인 부하 상태에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다</description>
    </item>
    <item>
      <title>Use Case Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/use-case-testing/</link>
      <pubDate>Sat, 02 Nov 2024 17:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/use-case-testing/</guid>
      <description>유즈케이스 테스팅은 유즈케이스나 비즈니스 시나리오를 기반으로 테스트를 명세화하는 블랙박스 테스트 설계 기법</description>
    </item>
    <item>
      <title>Requirements-based Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/requirements-based-testing/</link>
      <pubDate>Sat, 02 Nov 2024 10:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/requirements-based-testing/</guid>
      <description>시스템의 요구사항을 기반으로 테스트 케이스를 설계하고 수행하는 방법</description>
    </item>
    <item>
      <title>Metamorphic Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/metamorphic-testing/</link>
      <pubDate>Sat, 02 Nov 2024 10:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/metamorphic-testing/</guid>
      <description>메타모픽 테스팅은 소프트웨어의 의도된 기능에 대한 필수적인 속성인 메타모픽 관계(Metamorphic Relations, MRs)를 활용하여 테스트를 수행</description>
    </item>
    <item>
      <title>Boundary Value Analysis</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/boundary-value-analysis/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/boundary-value-analysis/</guid>
      <description>경계값 분석은 입력 또는 출력 범위의 경계 근처에서 결함이 발생할 가능성이 높다는 경험적 관찰에 기반한 테스트 기법</description>
    </item>
    <item>
      <title>Cause-Effect Graphing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/cause-effect-graphing/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/cause-effect-graphing/</guid>
      <description>원인-결과 그래프 검사(Cause-Effect Graph Testing)는 블랙박스 테스트 기법 중 하나로, 입력 조건(원인)과 출력 결과(결과) 사이의 관계를 체계적으로 분석하고 모델링하여 효과적인 테스트 케이스를 도출하는 방법.</description>
    </item>
    <item>
      <title>Decision Table Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/decision-table-testing/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/decision-table-testing/</guid>
      <description>여러 조건(conditions)과 그에 따른 행동(actions)의 모든 가능한 조합을 표 형태로 정리하여 테스트 케이스를 도출하는 기법</description>
    </item>
    <item>
      <title>State Transition Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/state-transition-testing/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/state-transition-testing/</guid>
      <description>상태 전이 테스트는 시스템이나 객체의 상태 변화를 모델링하고, 이벤트에 따른 상태 전이와 그 결과를 검증하는 기법이다.</description>
    </item>
    <item>
      <title>분류 트리 방법 (Classification Tree Method)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/classification-tree-method/</link>
      <pubDate>Sat, 02 Nov 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/classification-tree-method/</guid>
      <description>CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.</description>
    </item>
    <item>
      <title>Equivalence Partitioning</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/equivalence-partitioning/</link>
      <pubDate>Sat, 02 Nov 2024 09:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/equivalence-partitioning/</guid>
      <description>동등 분할은 입력 또는 출력 데이터를 의미 있는 그룹으로 나누어 테스트하는 기법으로 핵심 아이디어는 같은 그룹에 속한 데이터는 프로그램에서 동일한 방식으로 처리될 것이라는 가정에 기반한다.</description>
    </item>
    <item>
      <title>Scenario Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/scenario-testing/</link>
      <pubDate>Sat, 02 Nov 2024 09:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/scenario-testing/</guid>
      <description>시나리오 테스팅은 실제 상황을 시뮬레이션하여 소프트웨어를 검증하는 강력한 기술이다. 개별 기능에 초점을 맞춘 기존 테스트 케이스와 달리 시나리오 테스트에서는 일련의 이벤트나 상호 작용이 발생할 때 시스템이 어떻게 작동하는지 검사한다.</description>
    </item>
    <item>
      <title>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/combinatorial-test-design-techniques/</link>
      <pubDate>Sat, 02 Nov 2024 09:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/combinatorial-test-design-techniques/</guid>
      <description>조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.</description>
    </item>
    <item>
      <title>랜덤 테스팅(Random Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/random-testing/</link>
      <pubDate>Sat, 02 Nov 2024 07:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/random-testing/</guid>
      <description>임의로 생성된 입력 데이터를 사용하여 프로그램을 테스트하는 방법</description>
    </item>
    <item>
      <title>페어와이즈 테스팅(Pairwise Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/pairwise-testing/</link>
      <pubDate>Sat, 02 Nov 2024 07:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/pairwise-testing/</guid>
      <description>페어와이즈 테스팅은 모든 가능한 입력 값 조합을 테스트하는 대신, 입력 매개변수의 모든 쌍(pair)을 최소한 한 번씩 테스트하는 기법이다.</description>
    </item>
    <item>
      <title>비교 검사(Comparison Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/comparison-testing/</link>
      <pubDate>Sat, 02 Nov 2024 00:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/specification-based-test/comparison-testing/</guid>
      <description>비교 검사는 블랙박스 테스팅 기법 중 하나로, 동일한 기능을 수행하는 여러 버전의 소프트웨어나 시스템을 비교하여 테스트하는 방법으로 동일한 입력값을 여러 버전의 소프트웨어에 제공하고, 그 출력값을 비교하는 방식으로 진행된다.</description>
    </item>
    <item>
      <title>Fakes</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/fakes/</link>
      <pubDate>Fri, 01 Nov 2024 21:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/fakes/</guid>
      <description>실제 객체의 간단한 구현을 제공하는 테스트용 객체</description>
    </item>
    <item>
      <title>Dummy Objects</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/dummy-objects/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/dummy-objects/</guid>
      <description>테스트 과정에서 실제로는 사용되지 않지만 메서드의 파라미터를 채우기 위해 전달되는 객체</description>
    </item>
    <item>
      <title>Spies</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/spies/</link>
      <pubDate>Fri, 01 Nov 2024 21:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/spies/</guid>
      <description>실제 객체의 메서드 호출을 추적하고 기록하는 데 사용</description>
    </item>
    <item>
      <title>Path Coverage</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/path-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/path-coverage/</guid>
      <description>프로그램의 모든 가능한 실행 경로를 최소한 한 번씩 테스트하는 것을 목표로 한다.</description>
    </item>
    <item>
      <title>조건 커버리지 (Condition Coverage)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/condition-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/condition-coverage/</guid>
      <description>조건 커버리지는 결정 포인트 내의 각 개별 조건식이 참(true)과 거짓(false)의 결과를 최소한 한 번씩 갖도록 테스트하는 기법</description>
    </item>
    <item>
      <title>Decision Coverage</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/decision-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/decision-coverage/</guid>
      <description>결정 커버리지는 프로그램의 모든 결정 포인트(조건문)에서 전체 조건식이 최소한 한 번씩 참(True)과 거짓(False)의 결과를 가지도록 테스트하는 방법</description>
    </item>
    <item>
      <title>Statement Coverage</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/statement-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 15:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/statement-coverage/</guid>
      <description>프로그램을 구성하는 모든 문장들이 최소한 한 번은 실행될 수 있는 입력 데이터를 테스트 데이터로 선정하는 기준</description>
    </item>
    <item>
      <title>Function Coverage</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/function-coverage/</link>
      <pubDate>Fri, 01 Nov 2024 10:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/function-coverage/</guid>
      <description>함수 커버리지는 프로그램 내의 모든 함수가 테스트 중에 최소한 한 번 이상 호출되었는지를 측정하는 지표이다.</description>
    </item>
    <item>
      <title>다중 조건 테스팅 (Branch Condition Combination Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/branch-condition-combination-testing/</link>
      <pubDate>Fri, 01 Nov 2024 10:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/branch-condition-combination-testing/</guid>
      <description>다중 조건 테스팅(Branch Condition Combination Testing)은 화이트박스 테스트 기법 중 하나로, 조건문 내의 모든 가능한 조건 조합을 테스트하는 방법이다</description>
    </item>
    <item>
      <title>Data Flow Testing</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/data-flow-testing/</link>
      <pubDate>Fri, 01 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/data-flow-testing/</guid>
      <description>데이터 흐름 테스팅(Data Flow Testing)은 소프트웨어 테스트 기법 중 하나로, 프로그램 내에서 데이터의 정의와 사용에 초점을 맞춰 테스트를 수행하는 방법</description>
    </item>
    <item>
      <title>변경 조건/결정 커버리지 테스팅 (Modified Condition/Decision Coverage Testing, MC/DC)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/modified-condition-decision-coverage-testing/</link>
      <pubDate>Fri, 01 Nov 2024 10:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/modified-condition-decision-coverage-testing/</guid>
      <description>MC/DC는 결정문 내의 각 조건이 독립적으로 결정의 결과에 영향을 미치는지 확인하는 테스트 기법</description>
    </item>
    <item>
      <title>Stubs</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/test-double/stubs/</link>
      <pubDate>Fri, 01 Nov 2024 09:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/test-double/stubs/</guid>
      <description>테스트에서 사용되는 기법으로, 실제 객체나 아직 구현되지 않은 코드를 대신하여 미리 정의된 응답을 제공하는 메커니즘</description>
    </item>
    <item>
      <title>구문 테스팅(Syntax Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/syntax-testing/</link>
      <pubDate>Fri, 01 Nov 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/white-box-testing/syntax-testing/</guid>
      <description>구문 테스팅(Syntax Testing)은 화이트박스 테스트 기법 중 하나로, 소프트웨어의 내부 구조와 코드를 검증하는 방법</description>
    </item>
    <item>
      <title>Security Vulnerability Scanning</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/security-vulnerability-scanning/</link>
      <pubDate>Tue, 29 Oct 2024 16:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/security-vulnerability-scanning/</guid>
      <description>보안 취약점 스캔은 자동화된 도구를 사용하여 시스템과 소프트웨어의 보안 약점을 찾아내는 과정으로, 시스템, 네트워크, 소프트웨어의 보안 취약점을 식별하고 분석하는 프로세스이다</description>
    </item>
    <item>
      <title>성능 프로파일링 (Performance Profiling)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/performance-profiling/</link>
      <pubDate>Tue, 29 Oct 2024 16:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/performance-profiling/</guid>
      <description>성능 프로파일링(Performance Profiling)은 소프트웨어의 실행 동작을 분석하여 성능을 측정하고 개선하는 기술이다</description>
    </item>
    <item>
      <title>Desk Check</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/desk-check/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/desk-check/</guid>
      <description>데스크 체크는 가장 기본적인 비형식 리뷰 방법 중 하나로, 개발자가 자신의 코드를 스스로 검토하는 과정</description>
    </item>
    <item>
      <title>워크스루(Walkthrough)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/walkthrough/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/walkthrough/</guid>
      <description>워크스루는 코드 작성자가 다른 개발자들에게 코드를 단계별로 설명하며 진행하는 비형식적 리뷰 방식</description>
    </item>
    <item>
      <title>코드 리뷰 (Code Review)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/code-review/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/code-review/</guid>
      <description>코드 리뷰는 개발자가 작성한 코드를 다른 개발자들이 검토하고 피드백을 제공하는 과정이다.</description>
    </item>
    <item>
      <title>패스 어라운드(Pass Around)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/pass-around/</link>
      <pubDate>Tue, 29 Oct 2024 07:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/pass-around/</guid>
      <description>패스 어라운드는 비형식적 코드 리뷰의 한 형태로, 코드가 여러 리뷰어들 사이를 &amp;#34;돌아다니며&amp;#34; 검토되는 방식을 말한다.</description>
    </item>
    <item>
      <title>감사(Audit)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/audit/</link>
      <pubDate>Tue, 29 Oct 2024 07:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/audit/</guid>
      <description>독립적인 검토자들이 소프트웨어 산출물과 프로세스를 체계적으로 검사하고 평가하는 공식적인 검토 과정이다.</description>
    </item>
    <item>
      <title>페어 프로그래밍(Pair Programming)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/pair-programming/</link>
      <pubDate>Tue, 29 Oct 2024 07:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/informal-review/pair-programming/</guid>
      <description>페어 프로그래밍은 두 명의 개발자가 하나의 컴퓨터에서 함께 작업하는 협력적인 개발 방식</description>
    </item>
    <item>
      <title>Inspection</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/inspection/</link>
      <pubDate>Tue, 29 Oct 2024 07:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/inspection/</guid>
      <description>인스펙션은 FTR(Formal Technical Review)라고도 불리며, 정형화된 절차와 체크리스트를 사용하여 소프트웨어 산출물의 결함을 찾아내는 방법이다.</description>
    </item>
    <item>
      <title>관리 검토(Management Review)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/management-review/</link>
      <pubDate>Tue, 29 Oct 2024 07:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/management-review/</guid>
      <description>관리 검토는 소프트웨어 개발 프로젝트의 진행 상황, 목표 달성도, 리스크 등을 경영진과 프로젝트 관리자가 검토하는 공식적인 프로세스</description>
    </item>
    <item>
      <title>기술 검토(Technical Review)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/technical-review/</link>
      <pubDate>Tue, 29 Oct 2024 07:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/peer-review/formal-review/technical-review/</guid>
      <description>기술 검토는 소프트웨어의 기술적 측면을 전문가들이 체계적으로 평가하는 공식적인 검토 프로세스이다.</description>
    </item>
    <item>
      <title>정적 코드 분석 (Static Code analysis)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/static-code-analysis/</link>
      <pubDate>Tue, 29 Oct 2024 06:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/verification-and-validation/verification/static-code-analysis/</guid>
      <description>정적 코드 분석은 프로그램을 실행하지 않고 소스 코드를 분석하여 잠재적인 결함, 취약점, 코딩 표준 위반 등을 찾아내는 기술이다</description>
    </item>
    <item>
      <title>Git Hooks</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-hooks/</link>
      <pubDate>Mon, 28 Oct 2024 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-hooks/</guid>
      <description>Git Hooks 는 Git 워크플로우의 특정 이벤트가 발생할 때 자동으로 실행되는 사용자 정의 스크립트로, 개발 프로세스 자동화와 코드 품질 향상에 역할을 한다. 클라이언트 측 (pre-commit, commit-msg, pre-push 등) 과 서버 측 (pre-receive, update, post-receive 등) 훅으로 나뉘며, 코드 린팅, 테스트 자동화, 커밋 메시지 표준화, 보안 검사, 배포 자동화 등 다양한 용도로 활용된다. 최근에는 AI 기반 코드 검증, GitOps 통합, 클라우드 네이티브 환경 지원 등으로 발전하고 있으며, Husky 와 pre-commit 같은 관리 도구를 통해 팀 전체에서 일관된 훅 설정을 공유할 수 있다. Git Hooks 는 개발 생산성 향상, 코드 품질 보장, 오류 감소, 워크플로우 표준화의 장점이 있지만, 초기 설정 복잡성, 팀 공유의 어려움, 유지보수 부담 등의 단점도 존재한다.</description>
    </item>
    <item>
      <title>코드 크기 메트릭(Lines of Code, LOC)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/lines-of-code/</link>
      <pubDate>Mon, 28 Oct 2024 10:01:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/lines-of-code/</guid>
      <description>이 메트릭은 프로그램의 크기를 코드 라인 수로 표현하며, 소프트웨어 개발 프로젝트의 규모 추정, 생산성 측정, 품질 관리 등에 활용된다</description>
    </item>
    <item>
      <title>유지보수성 지수 (Maintainability Index)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/maintainability-index/</link>
      <pubDate>Mon, 28 Oct 2024 09:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/maintainability-index/</guid>
      <description>유지보수성 지수는 코드를 얼마나 쉽게 유지보수할 수 있는지를 나타내는 0에서 100 사이의 수치로 높을수록 코드의 유지보수가 더 쉽다는 것을 의미한다.</description>
    </item>
    <item>
      <title>응집도(Cohesion)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cohesion/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cohesion/</guid>
      <description>하나의 모듈이 얼마나 단일한 목적에 집중되어 있는지를 나타낸다.</description>
    </item>
    <item>
      <title>코드 중복도 (Code Duplication)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/code-duplication/</link>
      <pubDate>Mon, 28 Oct 2024 09:58:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/code-duplication/</guid>
      <description>코드 중복도는 소프트웨어 내에서 동일하거나 유사한 코드가 반복되는 정도를 나타낸다</description>
    </item>
    <item>
      <title>결합도 (Coupling)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/coupling/</link>
      <pubDate>Mon, 28 Oct 2024 09:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/coupling/</guid>
      <description>서로 다른 모듈 간의 상호 의존성이나 연관성을 측정하는 지표</description>
    </item>
    <item>
      <title>테스트 커버리지 (Test Coverage)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/test-coverage/</link>
      <pubDate>Mon, 28 Oct 2024 09:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/test-coverage/</guid>
      <description>테스트 커버리지는 테스트 대상 시스템이나 소프트웨어에 대해 얼마나 충분한 테스트가 수행되었는지를 나타내는 척도</description>
    </item>
    <item>
      <title>Halstead Complexity</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/halstead-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 09:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/halstead-complexity/</guid>
      <description>프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다</description>
    </item>
    <item>
      <title>순환 복잡도 (Cyclomatic Complexity)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cyclomatic-complexity/</link>
      <pubDate>Mon, 28 Oct 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/qa-fundamentals/quality-metric/cyclomatic-complexity/</guid>
      <description>프로그램의 논리적 복잡성을 정량적으로 측정하는 지표</description>
    </item>
    <item>
      <title>체크리스트 기반 테스팅 (Checklist-based Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/experience-based-test/checklist-based-testing/</link>
      <pubDate>Sun, 27 Oct 2024 08:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/experience-based-test/checklist-based-testing/</guid>
      <description>Checklist-based Testing은 소프트웨어 테스팅 기법 중 하나로, 미리 정의된 체크리스트를 사용하여 체계적으로 테스트를 수행하는 방법</description>
    </item>
    <item>
      <title>탐색적 테스팅(Exploratory Testing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/experience-based-test/exploratory-testing/</link>
      <pubDate>Sun, 27 Oct 2024 07:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/experience-based-test/exploratory-testing/</guid>
      <description>탐색적 테스팅(Exploratory Testing)은 소프트웨어 테스팅의 한 접근 방식으로, 테스터의 창의성, 경험, 직관을 활용하여 소프트웨어를 자유롭게 탐색하며 결함을 발견하는 과정</description>
    </item>
    <item>
      <title>오류 예측 검사(Error Guessing)</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/experience-based-test/error-guessing/</link>
      <pubDate>Sun, 27 Oct 2024 00:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/testing-approaches/black-box-testing/experience-based-test/error-guessing/</guid>
      <description>오류 예측 검사(Error Guessing)는 블랙박스 테스트 기법 중 하나로, 테스터의 **경험, 지식, 직관**을 활용하여 소프트웨어에서 발생할 가능성이 높은 오류를 예측하고 이를 기반으로 테스트 케이스를 설계하는 방법</description>
    </item>
    <item>
      <title>YAML vs. JSON vs. XML</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/yaml/yaml-vs-json-vs-xml/</link>
      <pubDate>Sat, 26 Oct 2024 09:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/format/text-based/yaml/yaml-vs-json-vs-xml/</guid>
      <description>데이터 교환과 구성 파일 형식으로 YAML, JSON, XML은 현대 소프트웨어 개발에서 가장 널리 사용되는 세 가지 형식이다.</description>
    </item>
    <item>
      <title>Serialization and Deserialization</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/serialization-and-deserialization/</link>
      <pubDate>Sat, 26 Oct 2024 09:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-fundamentals/data-exchange/serialization-and-deserialization/</guid>
      <description>직렬화(Serialization)는 데이터 구조나 객체 상태를 저장하거나 전송할 수 있는 형식으로 변환하는 과정이다. 역직렬화(Deserialization)는 직렬화의 반대 과정으로, 저장되거나 전송된 바이트 스트림이나 텍스트를 원래의 객체 구조로 다시 변환하는 작업이다.</description>
    </item>
    <item>
      <title>P2P and Hybrid VCS</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/advanced-topics/p2p-and-hybrid-vcs/</link>
      <pubDate>Sat, 26 Oct 2024 06:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/advanced-topics/p2p-and-hybrid-vcs/</guid>
      <description>P2P VCS 는 중앙 서버 없이 **분산 네트워크 기반 코드 협업**을 구현하며, 하이브리드 방식은 중앙집중식과 P2P 장점을 결합한다. 코드 협업을 위한 분산 네트워크 구조를 제공하면서도 중앙 서버에 대한 의존성을 줄이고, 오프라인 작업, 분기 및 병합 기능, 보안성을 향상시키며 사용자 간 효율적인 코드 공유를 가능하게 한다.</description>
    </item>
    <item>
      <title>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/scaling-databases/database-clustering-and-replication/</link>
      <pubDate>Fri, 25 Oct 2024 15:42:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/scaling-databases/database-clustering-and-replication/</guid>
      <description>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)은 데이터베이스의 가용성과 성능을 향상시키는 전략으로, 각각의 목적과 구현 방식에서 차이가 있다.</description>
    </item>
    <item>
      <title>데이터 불일치 (Data Inconsistency)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-inconsistency/</link>
      <pubDate>Fri, 25 Oct 2024 07:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/data-inconsistency/</guid>
      <description>동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황</description>
    </item>
    <item>
      <title>GitOps and IaC</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/advanced-topics/gitops-and-iac/</link>
      <pubDate>Fri, 25 Oct 2024 06:15:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/advanced-topics/gitops-and-iac/</guid>
      <description>GitOps 와 IaC(Infrastructure as Code) 는 현대적인 인프라스트럭처와 애플리케이션 관리 방법론으로, Git 을 단일 진실 공급원으로 활용하여 선언적이고 자동화된 방식으로 시스템을 관리한다. GitOps 는 Git 워크플로우를 통해 인프라 변경을 제안, 검토, 승인하고, 자동화된 에이전트가 실제 시스템 상태를 원하는 상태와 지속적으로 동기화한다. 이를 통해 인프라 관리의 일관성, 투명성, 감사 가능성이 향상되고, 변경 사항의 추적과 롤백이 용이해진다. 2025 년 기준으로 AI/ML 통합, 멀티클러스터 관리, 보안 중심 GitOps 등이 주요 동향으로 나타나고 있다.</description>
    </item>
    <item>
      <title>ACID</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/database-concepts/acid-properties/acid/</link>
      <pubDate>Thu, 24 Oct 2024 13:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/database-concepts/acid-properties/acid/</guid>
      <description>트랜잭션의 신뢰성과 일관성을 정의하는 네 가지 주요 특성</description>
    </item>
    <item>
      <title>프로시저 (Procedure)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/rdbms/sql/sql-advanced/stored-procedures-and-functions/procedure/</link>
      <pubDate>Thu, 24 Oct 2024 09:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/rdbms/sql/sql-advanced/stored-procedures-and-functions/procedure/</guid>
      <description>데이터베이스 프로시저(Database Procedure)는 데이터베이스 내에 저장되고 실행되는 일련의 SQL 문들의 집합이다.</description>
    </item>
    <item>
      <title>keyword</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/rdbms/sql/syntax/keywords/</link>
      <pubDate>Thu, 24 Oct 2024 07:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/rdbms/sql/syntax/keywords/</guid>
      <description>SQL(Structured Query Language)는 데이터베이스를 관리하고 조작하기 위한 표준 언어로, 다양한 **키워드**를 통해 데이터 정의, 조작, 제어, 트랜잭션 관리 등을 수행한다.</description>
    </item>
    <item>
      <title>Cardinality</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/cardinality/</link>
      <pubDate>Tue, 22 Oct 2024 15:08:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/cardinality/</guid>
      <description>두 엔티티 간의 최대 연관성 혹은 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.</description>
    </item>
    <item>
      <title>분산 쿼리 (distributed query)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/distributed-database/distributed-query/</link>
      <pubDate>Tue, 22 Oct 2024 09:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/distributed-database/distributed-query/</guid>
      <description>여러 노드에 분산된 데이터를 대상으로 쿼리를 실행하고 결과를 얻는 과정</description>
    </item>
    <item>
      <title>분산 트랜잭션 (Distributed transaction)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/transactions/distributed-transaction/</link>
      <pubDate>Tue, 22 Oct 2024 09:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/database-fundamentals/transactions/distributed-transaction/</guid>
      <description>여러 분산된 데이터베이스 노드에서 수행되는 하나의 논리적 작업 단위를 의미한다</description>
    </item>
    <item>
      <title>데이터베이스 캐싱 (Database Caching)</title>
      <link>https://buenhyden.github.io/posts/backend-development/backend-performance/caching/server-side/database-caching/</link>
      <pubDate>Tue, 22 Oct 2024 06:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/backend-performance/caching/server-side/database-caching/</guid>
      <description>자주 사용되는 데이터를 빠르게 접근할 수 있는 메모리에 임시로 저장하는 기술</description>
    </item>
    <item>
      <title>쿼리 최적화 (Query Optimization)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/performance/query-optimization/query-optimization/</link>
      <pubDate>Tue, 22 Oct 2024 06:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/performance/query-optimization/query-optimization/</guid>
      <description>데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 중요한 프로세스</description>
    </item>
    <item>
      <title>데이터베이스 인덱싱 (Database Indexing)</title>
      <link>https://buenhyden.github.io/posts/backend-development/databases/indexing/database-indexing/</link>
      <pubDate>Tue, 22 Oct 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/databases/indexing/database-indexing/</guid>
      <description>인덱스는 테이블의 특정 컬럼에 대한 검색을 빠르게 수행할 수 있도록 도와주는 자료 구조</description>
    </item>
    <item>
      <title>Cloud Networking</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/cloud-networking/</link>
      <pubDate>Sun, 20 Oct 2024 17:39:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/cloud-networking/</guid>
      <description>클라우드 네트워킹은 클라우드 컴퓨팅 환경에서 리소스들을 연결하고 통신할 수 있게 해주는 인프라를 의미한다.</description>
    </item>
    <item>
      <title>네트워크 기능 가상화(Network Functions Virtualization, NFV)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/network-functions-virtualization/</link>
      <pubDate>Sun, 20 Oct 2024 02:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/network-functions-virtualization/</guid>
      <description>NFV는 전통적으로 전용 하드웨어 장비에서 실행되던 네트워크 기능들을 가상화하여 소프트웨어로 구현하는 네트워크 아키텍처 개념이다.</description>
    </item>
    <item>
      <title>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/software-defined-networking/</link>
      <pubDate>Sun, 20 Oct 2024 02:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/software-defined-networking/</guid>
      <description>네트워크의 제어 기능을 네트워크 장비에서 분리하여 소프트웨어 기반 컨트롤러로 중앙집중화하는 네트워크 아키텍처.</description>
    </item>
    <item>
      <title>RDMA</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/rdma/</link>
      <pubDate>Sun, 20 Oct 2024 01:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/rdma/</guid>
      <description>네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술</description>
    </item>
    <item>
      <title>HATEOAS (Hypermedia As The Engine Of Application State)</title>
      <link>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/hypermedia-style/hateoas/</link>
      <pubDate>Sat, 19 Oct 2024 07:35:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/hypermedia-style/hateoas/</guid>
      <description>RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.</description>
    </item>
    <item>
      <title>멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/web-service/http/methods/idempotency-and-safe-methods/</link>
      <pubDate>Sat, 19 Oct 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/web-service/http/methods/idempotency-and-safe-methods/</guid>
      <description>멱등성과 안전한 메서드는 HTTP 메서드의 중요한 특성으로, 서버의 상태 변화와 관련이 있다.</description>
    </item>
    <item>
      <title>안전한 메서드 (Safe Methods)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/web-service/http/methods/safe-methods/</link>
      <pubDate>Fri, 18 Oct 2024 16:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/web-service/http/methods/safe-methods/</guid>
      <description>서버의 상태를 변경하지 않는 HTTP 메서드</description>
    </item>
    <item>
      <title>Cookies</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/web-service/http/cookies/</link>
      <pubDate>Fri, 18 Oct 2024 07:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/web-service/http/cookies/</guid>
      <description>웹사이트가 사용자의 브라우저에 저장하는 작은 텍스트 파일</description>
    </item>
    <item>
      <title>서브넷팅 (Subnetting)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/subnetting/</link>
      <pubDate>Thu, 17 Oct 2024 13:09:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/subnetting/</guid>
      <description>서브넷팅(Subnetting)은 네트워크를 더 작은 단위의 네트워크로 분할하는 기술로 IP 주소의 효율적인 사용과 네트워크 관리를 개선하기 위해 사용된다.</description>
    </item>
    <item>
      <title>네트워크 주소 변환 (NAT, Network Address Translation)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/nat/</link>
      <pubDate>Thu, 17 Oct 2024 13:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/nat/</guid>
      <description>네트워크 주소 변환(NAT, Network Address Translation)은 IP 패킷의 TCP/UDP 포트 번호와 소스 및 목적지의 IP 주소를 재기록하면서 라우터를 통해 네트워크 트래픽을 주고받는 기술이다.</description>
    </item>
    <item>
      <title>CIDR (Classless Inter-Domain Routing)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/cidr/</link>
      <pubDate>Thu, 17 Oct 2024 11:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/cidr/</guid>
      <description>CIDR는 도메인 간 라우팅에 사용되는 인터넷 주소를 기존의 IP 주소 클래스 체계보다 더 유연하게 할당하고 지정하는 방식</description>
    </item>
    <item>
      <title>IP Delivery Modes</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/ip-delivery-modes/</link>
      <pubDate>Thu, 17 Oct 2024 07:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/network-layer/ip/ip-delivery-modes/</guid>
      <description>네트워크에서 데이터를 전송하는 다양한 방식.</description>
    </item>
    <item>
      <title>DNS 캐싱 (DNS Caching)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/name-resolution/domain-name-system/dns-caching/</link>
      <pubDate>Thu, 17 Oct 2024 07:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/name-resolution/domain-name-system/dns-caching/</guid>
      <description>DNS 캐싱은 이전에 조회한 도메인 이름과 IP 주소의 매핑 정보를 임시로 저장하는 메커니즘이다.</description>
    </item>
    <item>
      <title>DNS Records</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/name-resolution/domain-name-system/dns-records/</link>
      <pubDate>Thu, 17 Oct 2024 07:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/name-resolution/domain-name-system/dns-records/</guid>
      <description>DNS Records는 도메인 이름 시스템(DNS)에서 사용되는 데이터 구조로, 도메인과 관련된 다양한 정보를 저장한다.</description>
    </item>
    <item>
      <title>Domain</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/name-resolution/domain-name-system/domain/</link>
      <pubDate>Thu, 17 Oct 2024 02:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/network-protocols/application-layer/name-resolution/domain-name-system/domain/</guid>
      <description>도메인(Domain)은 인터넷 상의 계층적 주소 체계로, 사용자가 이해하기 쉬운 형태의 웹사이트 주소를 제공한다.</description>
    </item>
    <item>
      <title>Media Access Control Address (MAC Address)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/cross-layer-functions/addressing-schemes/physical/mac-address/</link>
      <pubDate>Wed, 16 Oct 2024 12:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/cross-layer-functions/addressing-schemes/physical/mac-address/</guid>
      <description>네트워크 장비를 식별하기 위한 고유한 하드웨어 주소</description>
    </item>
    <item>
      <title>Packet</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/packet/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/packet/</guid>
      <description>패킷(Packet)은 네트워크를 통해 전송되는 데이터의 기본 단위</description>
    </item>
    <item>
      <title>Routing</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/routing/</link>
      <pubDate>Wed, 16 Oct 2024 10:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/routing/</guid>
      <description>데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.</description>
    </item>
    <item>
      <title>Network Hop</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/network-hop/</link>
      <pubDate>Wed, 16 Oct 2024 09:19:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/network-hop/</guid>
      <description>네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.</description>
    </item>
    <item>
      <title>프래그먼테이션 (Fragmentation)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/fragmentation/</link>
      <pubDate>Wed, 16 Oct 2024 02:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/osi-7layers/network-layer/fragmentation/</guid>
      <description>Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.</description>
    </item>
    <item>
      <title>환원 가능성 (Reducibility)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/reducibility/</link>
      <pubDate>Sun, 13 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/reducibility/</guid>
      <description>환원 가능성은 하나의 문제를 다른 문제로 &amp;#34;변환&amp;#34;할 수 있는 능력을 의미한다.</description>
    </item>
    <item>
      <title>메모이제이션 (Memoization)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/approaches/top-down-approach/memoization/</link>
      <pubDate>Sun, 13 Oct 2024 11:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/approaches/top-down-approach/memoization/</guid>
      <description>메모이제이션(Memoization)은 컴퓨터 프로그래밍에서 사용되는 최적화 기법으로, 함수의 호출 결과를 저장해두고 재사용함으로써 프로그램의 실행 속도를 향상시키는 방법이다.</description>
    </item>
    <item>
      <title>테이블레이션(Tabulation)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/approaches/bottom-up-approach/tabulation/</link>
      <pubDate>Sun, 13 Oct 2024 11:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/approaches/bottom-up-approach/tabulation/</guid>
      <description>Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.</description>
    </item>
    <item>
      <title>비결정성 (Non-determinism)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/non-determinism/</link>
      <pubDate>Sun, 13 Oct 2024 09:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/computational-theory/non-determinism/</guid>
      <description>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성</description>
    </item>
    <item>
      <title>비결정성 (Non-determinism)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/non-determinism/</link>
      <pubDate>Sun, 13 Oct 2024 09:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/non-determinism/</guid>
      <description>알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성</description>
    </item>
    <item>
      <title>Octree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/octree/</link>
      <pubDate>Fri, 11 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/octree/</guid>
      <description>Octree는 3차원 공간을 재귀적으로 분할하여 표현하는 트리 기반의 데이터 구조로, 3차원 공간을 8개의 동일한 크기의 정육면체(옥탄트)로 재귀적으로 분할하는 트리 구조이다.</description>
    </item>
    <item>
      <title>BK-tree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/special-purpose/bk-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/special-purpose/bk-tree/</guid>
      <description>BK-Tree(Burkhard-Keller Tree)는 메트릭 공간(metric space)에서 효율적인 근사 검색을 위해 설계된 트리 기반 데이터 구조이다.  주로 레벤슈타인 거리(Levenshtein Distance)를 활용한 문자열 유사성 검색, 맞춤법 검사, DNA 시퀀스 분석에 활용된다.</description>
    </item>
    <item>
      <title>BSP Tree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/bsp-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/bsp-tree/</guid>
      <description>BSP Tree는 공간을 재귀적으로 분할하여 표현하는 트리 구조의 데이터 구조로, 유클리드 공간을 초평면(hyperplane)을 기준으로 재귀적으로 분할하여 볼록 집합으로 나누는 기법을 트리 구조로 표현한 것</description>
    </item>
    <item>
      <title>K-d Tree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/k-d-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/k-d-tree/</guid>
      <description>K-d Tree는 k차원 공간에서 점들을 효율적으로 저장하고 검색하기 위한 이진 트리 기반의 공간 분할 데이터 구조로, K-d Tree는 k차원 공간을 재귀적으로 분할하여 표현하는 이진 트리이다.</description>
    </item>
    <item>
      <title>Merkle Tree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/tries-and-string/merkle-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/tries-and-string/merkle-tree/</guid>
      <description>머클 트리(Merkle Tree)는 암호화된 해시 값을 기반으로 데이터 무결성을 효율적으로 검증하는 트리 구조이다.  블록체인, 분산 시스템, 파일 전송 프로토콜 등에서 널리 활용되며, 데이터 변조 탐지와 검증 효율성이 핵심 강점이다.</description>
    </item>
    <item>
      <title>Quad Tree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/quad-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/spatial-partitioning/quad-tree/</guid>
      <description>Quad Tree는 2차원 공간을 재귀적으로 4개의 영역으로 분할하여 표현하는 트리 기반의 데이터 구조로, 각 노드가 정확히 4개의 자식 노드를 갖는 트리 구조이다.</description>
    </item>
    <item>
      <title>Rope</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/special-purpose/rope/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/special-purpose/rope/</guid>
      <description>Rope는 대규모 문자열을 효율적으로 저장하고 조작하기 위해 설계된 트리 기반의 데이터 구조</description>
    </item>
    <item>
      <title>Suffix Tree</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/tries-and-string/suffix-tree/</link>
      <pubDate>Fri, 11 Oct 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/tries-and-string/suffix-tree/</guid>
      <description>Suffix Tree는 문자열의 모든 접미사를 효율적으로 저장하고 검색하는 특수한 트리 구조로, 문자열 처리와 패턴 매칭을 위해 사용되는 고급 데이터 구조이다.</description>
    </item>
    <item>
      <title>디스조인트 셋 (Disjoint-Set)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/special-purpose/disjoint-set/</link>
      <pubDate>Fri, 11 Oct 2024 07:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/non-linear/tree/types/special-purpose/disjoint-set/</guid>
      <description>디스조인트 셋은 서로 겹치지 않는(disjoint) 부분 집합들로 나누어진 요소들의 집합을 표현하고 조작하는 데이터 구조이다.</description>
    </item>
    <item>
      <title>Hash Map</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/hash-table/types/hash-map/</link>
      <pubDate>Wed, 09 Oct 2024 14:29:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/hash-table/types/hash-map/</guid>
      <description>HashMap은 해시 함수를 사용하여 키를 배열의 인덱스로 변환하고, 해당 인덱스에 값을 저장하는 데이터 구조이다.</description>
    </item>
    <item>
      <title>Lock-free Stack</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/lock-free-stack/</link>
      <pubDate>Wed, 09 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/lock-free-stack/</guid>
      <description>Lock-free Stack은 락(lock)을 사용하지 않고 동시성을 제공하는 LIFO(Last-In-First-Out) 자료구조.</description>
    </item>
    <item>
      <title>Concurrent Hash Map</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/concurrent-hash-map/</link>
      <pubDate>Wed, 09 Oct 2024 13:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/concurrent-hash-map/</guid>
      <description>여러 스레드가 동시에 데이터를 안전하게 접근하고 수정할 수 있도록 설계된 스레드 안전(thread-safe)한 해시 맵 구현체</description>
    </item>
    <item>
      <title>Cuckoo Hash Table</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/hash-table/types/cuckoo-hash-table/</link>
      <pubDate>Wed, 09 Oct 2024 12:57:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/hash-table/types/cuckoo-hash-table/</guid>
      <description>Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.</description>
    </item>
    <item>
      <title>Bloom filter</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/hash-table/types/bloom-filter/</link>
      <pubDate>Wed, 09 Oct 2024 12:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/hash-table/types/bloom-filter/</guid>
      <description>블룸 필터(Bloom Filter)는 **공간 효율적인 확률적 데이터 구조**로, 원소가 집합에 속하는지 여부를 빠르게 확인하는 데 사용된다.</description>
    </item>
    <item>
      <title>Concurrent Skip List</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/concurrent-skip-list/</link>
      <pubDate>Tue, 08 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/concurrent-skip-list/</guid>
      <description>Concurrent Skip List는 Skip List 자료구조를 기반으로 하여 멀티스레드 환경에서 동시에 삽입, 삭제, 검색 작업을 수행할 수 있도록 구현된 동시성 자료구조이다.</description>
    </item>
    <item>
      <title>Read-Copy-Update List</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/read-copy-update-list/</link>
      <pubDate>Tue, 08 Oct 2024 13:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/read-copy-update-list/</guid>
      <description>RCU List는 Read-Copy-Update 메커니즘을 사용하여 구현된 동시성 연결 리스트로 읽기 작업에 대해 락을 사용하지 않으면서도 동시에 업데이트를 수행할 수 있게 해준다.</description>
    </item>
    <item>
      <title>Lock-free Queue</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/lock-free-queue/</link>
      <pubDate>Tue, 08 Oct 2024 13:21:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/concurrent-data-structures/lock-free-queue/</guid>
      <description>Lock-free Queue는 락(lock)을 사용하지 않고 동시성을 제공하는 FIFO(First-In-First-Out) 자료구조이다.</description>
    </item>
    <item>
      <title>Circular Linked List</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/types/circular-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/types/circular-linked-list/</guid>
      <description>Circular Linked List(원형 연결 리스트)는 마지막 노드가 첫 번째 노드를 가리키는 연결 리스트의 변형이다.</description>
    </item>
    <item>
      <title>Circular Queue</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/queue/types/circular-queue/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/queue/types/circular-queue/</guid>
      <description>Circular Queue는 마지막 요소가 첫 번째 요소와 연결되어 원형 구조를 형성하는 큐 데이터 구조이다.</description>
    </item>
    <item>
      <title>Doubly Linked List</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/types/doubly-linked-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/types/doubly-linked-list/</guid>
      <description>Doubly Linked List는 노드들이 양방향으로 연결된 선형 데이터 구조로, 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 포함하고 있다.</description>
    </item>
    <item>
      <title>Skip List</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/variants/skip-list/</link>
      <pubDate>Tue, 08 Oct 2024 12:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/variants/skip-list/</guid>
      <description>Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다</description>
    </item>
    <item>
      <title>Linked List vs. Array</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/linked-list-vs-array/</link>
      <pubDate>Mon, 07 Oct 2024 16:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/linear/linked-list/linked-list-vs-array/</guid>
      <description>배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.  반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.</description>
    </item>
    <item>
      <title>메모리 보호와 안전 (Memory Protection and Safety)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-protection-and-safety/</link>
      <pubDate>Sat, 05 Oct 2024 08:06:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-protection-and-safety/</guid>
      <description>메모리 보호는 컴퓨터 시스템에서 프로세스가 허가되지 않은 메모리 영역에 접근하는 것을 방지하는 메커니즘이다.</description>
    </item>
    <item>
      <title>코루틴(Coroutine)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/threads/coroutine/</link>
      <pubDate>Sat, 05 Oct 2024 06:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/threads/coroutine/</guid>
      <description>코루틴은 &amp;#34;협력적인 루틴&amp;#34;이라는 의미로, 여러 작업이 협력하여 실행되는 방식을 말한다. 일반 함수와 달리, 코루틴은 실행 중간에 일시 중단되었다가 나중에 다시 재개될 수 있다.</description>
    </item>
    <item>
      <title>Thread</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/threads/threads/</link>
      <pubDate>Fri, 04 Oct 2024 23:32:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/threads/threads/</guid>
      <description>Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.</description>
    </item>
    <item>
      <title>Multithreading</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/multithreading/__index/</link>
      <pubDate>Fri, 04 Oct 2024 14:33:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/multithreading/__index/</guid>
      <description>Multithreading은 운영 체제에서 프로그램이 여러 작업을 동시에 수행할 수 있게 해주는 기능이다.  즉, 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 의미하며, 각 스레드는 프로세스의 자원을 공유하면서도 독립적인 실행 경로를 가진다.</description>
    </item>
    <item>
      <title>Mutex</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/mutex/</link>
      <pubDate>Fri, 04 Oct 2024 11:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/mutex/</guid>
      <description>Mutex(Mutual Exclusion)는 공유 자원에 대한 접근을 동기화하는 객체.</description>
    </item>
    <item>
      <title>조건 변수 (Condition Variable)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/condition-synchronization/condition-variable/</link>
      <pubDate>Fri, 04 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/condition-synchronization/condition-variable/</guid>
      <description>조건 변수(Condition Variables)는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.</description>
    </item>
    <item>
      <title>원자적 연산 (Atomic Operation)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/atomic-operation/</link>
      <pubDate>Fri, 04 Oct 2024 10:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/atomic-operation/</guid>
      <description>원자적 연산이란, 더 이상 쪼개질 수 없는 최소 단위의 연산을 의미하는데 중단되거나 간섭받지 않고 완전히 실행되는 연산을 말한다.</description>
    </item>
    <item>
      <title>상호 배제 (Mutual Exclusion)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/__index/</link>
      <pubDate>Fri, 04 Oct 2024 07:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/__index/</guid>
      <description>여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 메커니즘</description>
    </item>
    <item>
      <title>임계 영역 (Critical Section)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/critical-section/__index/</link>
      <pubDate>Fri, 04 Oct 2024 07:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/critical-section/__index/</guid>
      <description>여러 프로세스 또는 스레드가 공유하는 자원에 접근하는 코드 영역</description>
    </item>
    <item>
      <title>동시성 (Concurrency)</title>
      <link>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/concurrency/</link>
      <pubDate>Fri, 04 Oct 2024 06:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency-control/concurrency/</guid>
      <description>동시성 (Concurrency)은 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 매우 빠르게 작업 간 전환을 하면서 처리하는 방식이다.</description>
    </item>
    <item>
      <title>교착상태 (Deadlock)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/deadlock/__index/</link>
      <pubDate>Thu, 03 Oct 2024 23:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/deadlock/__index/</guid>
      <description>둘 이상의 프로세스가 서로가 가진 자원을 기다리며 더 이상 진행할 수 없는 상태</description>
    </item>
    <item>
      <title>Race Condition</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/race-condition/__index/</link>
      <pubDate>Thu, 03 Oct 2024 23:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/race-condition/__index/</guid>
      <description>여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때, 접근의 타이밍이나 순서에 따라 결과가 달라질 수 있는 상황</description>
    </item>
    <item>
      <title>Monitor</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/monitor/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/monitor/</guid>
      <description>모니터는 공유 데이터와 해당 데이터를 조작하는 연산을 하나의 모듈로 캡슐화하여, 다중 스레드 환경에서의 경쟁 조건(Race Condition)을 방지한다.</description>
    </item>
    <item>
      <title>Semaphore</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/semaphore/</link>
      <pubDate>Thu, 03 Oct 2024 10:54:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/semaphore/</guid>
      <description>멀티스레딩 환경에서 공유 자원에 대한 접근을 제어하는 동기화 도구</description>
    </item>
    <item>
      <title>데커 알고리즘 (Dekker&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/dekkers-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/dekkers-algorithm/</guid>
      <description>데커 알고리즘(Dekker&amp;#39;s Algorithm)은 두 프로세스 간 상호 배제(Mutual Exclusion)를 보장하기 위해 1965년 네덜란드의 수학자 Theodorus Dekker가 개발한 최초의 소프트웨어 상호 배제(mutual exclusion) 알고리즘이다.</description>
    </item>
    <item>
      <title>램포트의 빵집 알고리즘 (Lamport&#39;s Bakery Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/</guid>
      <description>N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다</description>
    </item>
    <item>
      <title>피터슨 알고리즘 (Peterson&#39;s Algorithm)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/petersons-algorithm/</link>
      <pubDate>Thu, 03 Oct 2024 10:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/petersons-algorithm/</guid>
      <description>피터슨 알고리즘(Peterson&amp;#39;s Algorithm)은 두 프로세스의 상호 배제(Mutual Exclusion)를 보장하기 위한 소프트웨어 기반 동기화 알고리즘이다.</description>
    </item>
    <item>
      <title>라이브락 (Livelock)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/livelock/__index/</link>
      <pubDate>Thu, 03 Oct 2024 09:17:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/livelock/__index/</guid>
      <description>멀티스레딩 환경에서 발생할 수 있는 문제 상황으로, 프로세스나 스레드가 계속 실행 중이지만 실제로는 유용한 작업을 수행하지 못하는 상태</description>
    </item>
    <item>
      <title>Starvation</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/starvation/__index/</link>
      <pubDate>Thu, 03 Oct 2024 07:52:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/concurrency-problems/starvation/__index/</guid>
      <description>운영 체제 및 동시성 프로그래밍에서 중요한 문제로, 특정 프로세스가 필요한 자원을 지속적으로 얻지 못해 실행되지 못하는 상황</description>
    </item>
    <item>
      <title>Process Synchronization</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/process-synchronization/</link>
      <pubDate>Thu, 03 Oct 2024 06:22:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/process-synchronization/</guid>
      <description>여러 프로세스가 공유하는 자원의 일관성을 유지하기 위한 메커니즘</description>
    </item>
    <item>
      <title>소켓(Socket)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_socket/</link>
      <pubDate>Wed, 02 Oct 2024 16:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_socket/</guid>
      <description>네트워크 상에서 두 프로그램이 데이터를 주고받을 수 있도록 하는 양방향 통신의 종착점이다.</description>
    </item>
    <item>
      <title>Message Queue</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_message-queue/</link>
      <pubDate>Wed, 02 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_message-queue/</guid>
      <description>프로세스 간 통신(IPC)의 메시지 큐(Message Queue)는 프로세스 간에 데이터를 교환하는 메커니즘이다.</description>
    </item>
    <item>
      <title>Shared Memory</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_shared-memory/</link>
      <pubDate>Wed, 02 Oct 2024 12:03:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_shared-memory/</guid>
      <description>공유 메모리(Shared Memory)는 운영체제의 프로세스 간 통신(IPC) 기법 중 하나로, 여러 프로세스가 동시에 접근할 수 있는 메모리 영역이며, 커널에 의해 생성되고 관리되는 공통 메모리 공간이다.</description>
    </item>
    <item>
      <title>Pipe</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_pipe/</link>
      <pubDate>Wed, 02 Oct 2024 12:02:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_pipe/</guid>
      <description>파이프(Pipe)는 프로세스 간 통신(IPC)의 한 방법으로, 단방향 데이터 흐름을 제공하는 가장 오래된 IPC(프로세스 간 통신) 메커니즘 중 하나이다. 파이프는 한쪽 끝에서 데이터를 쓰고 다른 쪽 끝에서 데이터를 읽을 수 있게 해준다.</description>
    </item>
    <item>
      <title>프로세스 제어 블록(Process Control Block, PCB)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-control-block/</link>
      <pubDate>Wed, 02 Oct 2024 06:59:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-control-block/</guid>
      <description>프로세스 제어 블록(Process Control Block, PCB)은 운영 체제에서 프로세스를 관리하기 위해 사용하는 핵심적인 데이터 구조이다. PCB는 각 프로세스에 대한 중요한 정보를 저장하고 관리하며, 운영 체제가 프로세스를 효율적으로 제어하고 실행할 수 있게 한다.</description>
    </item>
    <item>
      <title>프로세스 간 통신 (Inter-Process Communication, IPC)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/</link>
      <pubDate>Wed, 02 Oct 2024 06:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/</guid>
      <description>서로 독립적으로 실행되는 프로세스들이 데이터를 교환하고 상호작용하기 위한 메커니즘</description>
    </item>
    <item>
      <title>CI/CD Principles</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-cd-principles/</link>
      <pubDate>Wed, 02 Oct 2024 04:24:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-cd-principles/</guid>
      <description>CI/CD 원칙은 현대 소프트웨어 개발의 핵심으로, 자동화 우선, 피드백 루프, 테스트 좌측 이동, 작은 배치 변경이라는 네 가지 핵심 원칙이 중심을 이룬다.  이러한 원칙은 코드 품질 향상, 개발 속도 가속화, 배포 위험 감소, 팀 협업 강화 등 다양한 이점을 제공한다. AI 기반 파이프라인 최적화, DevSecOps 주류화, 내부 개발자 플랫폼 확산이 주요 동향으로 부상하고 있으며, 향후에는 자가 최적화 파이프라인, End-to-End 자동화, 적응형 CI/CD 시스템으로 발전할 전망이다. CI/CD 원칙을 효과적으로 적용하기 위해서는 기술적 측면뿐만 아니라 조직 문화, 팀 구조, 프로세스 변화를 포괄하는 통합적 접근이 필요하다.</description>
    </item>
    <item>
      <title>Gitlab CI</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-tools-and-platforms/gitlab-ci/</link>
      <pubDate>Wed, 02 Oct 2024 03:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-tools-and-platforms/gitlab-ci/</guid>
      <description>Gitlab에서 각각 제공하는 CI/CD(Continuous Integration and Continuous Deployment) 도구</description>
    </item>
    <item>
      <title>CI vs. CD vs. CD</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/</link>
      <pubDate>Wed, 02 Oct 2024 01:43:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/ci-vs-cd-vs-cd/</guid>
      <description>CI/CD 는 현대 소프트웨어 개발의 핵심 요소로, 자동화를 통해 소프트웨어 품질을 향상시키고 개발 및 배포 속도를 높인다. CI(지속적 통합) 는 개발자의 코드 변경을 자주 통합하고 검증하는 과정에 중점을 두며, CD(지속적 전달) 는 소프트웨어가 언제든 배포 가능한 상태를 유지하도록 자동화하고, CD(지속적 배포) 는 검증된 변경사항을 자동으로 프로덕션에 배포한다. 이 세 가지 접근법의 주요 차이점은 자동화 수준과 사람의 개입 정도에 있다.2025 년 트렌드로는 AI 통합, GitOps, DevSecOps, 클라우드 네이티브 접근법이 주목받고 있으며, 효과적인 CI/CD 구현을 위해서는 적절한 도구 선택, 테스트 자동화, 안전한 배포 전략, 팀 문화 변화가 필수적이다.</description>
    </item>
    <item>
      <title>Context Switching</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/context-switching/</link>
      <pubDate>Wed, 02 Oct 2024 01:00:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/context-switching/</guid>
      <description>Context Switching은 운영 체제에서 매우 중요한 개념으로, 여러 프로세스나 스레드가 단일 CPU 자원을 공유하여 효율적으로 실행될 수 있게 하는 메커니즘으로, CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드의 상태를 불러와 실행을 재개하는 과정을 말한다.  이를 통해 여러 작업이 동시에 실행되는 것처럼 보이게 된다.</description>
    </item>
    <item>
      <title>History and Evolution of CI/CD</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/</link>
      <pubDate>Wed, 02 Oct 2024 00:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/ci-cd-fundamentals/history-and-evolution-of-ci-cd/</guid>
      <description>1990 년대 후반 익스트림 프로그래밍 (XP) 에서 처음 등장한 지속적 통합 개념은 워터폴 모델의 한계를 극복하기 위해 발전했으며, 2000 년대 중반 젠킨스 (이전의 허드슨) 의 등장으로 대중화되었다. 이후 클라우드 컴퓨팅, 컨테이너 기술의 발전과 함께 GitLab CI, CircleCI, GitHub Actions 등 다양한 CI/CD 도구가 등장했다. CI/CD 는 코드 통합 문제 조기 발견, 출시 주기 단축, 품질 향상 등 다양한 이점을 제공하며, 현재는 AI/ML 통합, GitOps, DevSecOps 등의 최신 트렌드와 함께 계속 진화하고 있다.</description>
    </item>
    <item>
      <title>세그먼테이션 (Segmentation)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/segmentation/</link>
      <pubDate>Tue, 01 Oct 2024 13:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/segmentation/</guid>
      <description>세그먼테이션(Segmentation)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 논리적 단위인 세그먼트로 나누어 관리하는 방식이다.</description>
    </item>
    <item>
      <title>페이징 (Paging)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging/</link>
      <pubDate>Tue, 01 Oct 2024 13:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/memory-management/paging/</guid>
      <description>페이징(Paging)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 고정 크기의 페이지로 나누고 물리적 메모리를 같은 크기의 프레임으로 나누어 관리하는 방식이다.</description>
    </item>
    <item>
      <title>Code Review Best Practices</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/code-review-best-practices/</link>
      <pubDate>Tue, 01 Oct 2024 09:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/code-review-best-practices/</guid>
      <description>코드 리뷰 모범 사례는 소프트웨어 개발 과정에서 코드 품질과 팀 협업을 향상시키는 핵심 요소이다. 효과적인 코드 리뷰는 버그 감소, 지식 공유, 코드 표준화를 촉진하며, 건설적인 피드백과 명확한 커뮤니케이션을 기반으로 한다. 핵심 원칙인 작은 단위 검토와 명확한 피드백을 기반으로, GitHub Copilot 등의 도구로 기본 검사를 자동화하고 팀은 아키텍처 검증에 집중하는 협업 모델이 주류이다. 지속적 통합 (CI) 파이프라인과의 결합으로 품질 관리를 선제적으로 수행하는 것이 핵심 경쟁력으로 부상했다.</description>
    </item>
    <item>
      <title>Release Management</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/release-management/</link>
      <pubDate>Tue, 01 Oct 2024 09:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/release-management/</guid>
      <description>버전 관리 시스템 (VCS) 에서의 릴리스 관리는 소프트웨어 변경사항을 개발 환경에서 프로덕션 환경으로 안전하고 체계적으로 배포하는 전체 프로세스를 관리하는 방법론이다.  시맨틱 버저닝, 릴리스 브랜치, 태그 시스템을 활용하여 코드 버전을 체계적으로 관리하고, CI/CD 파이프라인을 통해 빌드, 테스트, 배포 과정을 자동화한다. 효과적인 릴리스 관리는 반복성, 자동화, 투명성, 롤백 준비 등의 핵심 원칙을 따르며, 다양한 배포 전략 (블루 - 그린, 카나리, 롤링 배포 등) 을 통해 배포 위험을 최소화한다.</description>
    </item>
    <item>
      <title>Open Source Contribution</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/open-source-contribution/</link>
      <pubDate>Tue, 01 Oct 2024 06:07:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/open-source-contribution/</guid>
      <description>버전 관리 시스템에서의 오픈소스 기여는 소프트웨어 개발 생태계의 핵심 협업 방식으로, Fork-Clone- 수정 -Pull Request 의 워크플로우를 통해 이루어진다. 이는 단순한 코드 공유를 넘어 지식 확산, 개발자 성장, 기술 혁신의 원동력이 되고 있다. 2025 년 기준 오픈소스 생태계는 기여자 다변화, 기업 참여 확대, AI 기반 도구 통합 등 새로운 변화를 맞이하고 있으며, 진입 장벽 완화와 기여 중심 학습 모델로 더욱 넓은 참여를 이끌어내고 있다.</description>
    </item>
    <item>
      <title>Pull Request Flow</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/pull-request-flow/</link>
      <pubDate>Tue, 01 Oct 2024 02:11:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/pull-request-flow/</guid>
      <description>Pull Request Flow는 현대 소프트웨어 개발의 핵심 협업 메커니즘으로, 코드 변경사항을 메인 코드베이스에 병합하기 전에 체계적인 검토를 가능하게 한다. 독립적인 브랜치에서 작업한 후 리뷰 요청, 피드백 교환, 자동화된 검증을 거쳐 최종 병합하는 이 과정은 코드 품질 향상, 지식 공유, 버그 감소, 팀 협업 강화에 기여한다. 작은 단위의 PR 유지, 명확한 설명 작성, 자동화 도구 활용, 긍정적인 피드백 문화 조성이 성공적인 PR 플로우의 핵심 요소이다. 최근에는 AI 기반 코드 리뷰, 지속적 병합, 통합 개발 환경 등이 발전하고 있다.</description>
    </item>
    <item>
      <title>Byte Addressable Memory vs Word Addressable Memory</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/</link>
      <pubDate>Mon, 30 Sep 2024 11:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/</guid>
      <description>컴퓨터 메모리의 주소 지정 방식을 설명하는 개념</description>
    </item>
    <item>
      <title>Allocation Policy</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/allocation-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/allocation-policy/</guid>
      <description>Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.</description>
    </item>
    <item>
      <title>Prefetch Policy</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/prefetch-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/prefetch-policy/</guid>
      <description>**Prefetch Policy**는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략</description>
    </item>
    <item>
      <title>Replacement Policy</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/replacement-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:53:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/replacement-policy/</guid>
      <description>Cache Replacement Policy(캐시 교체 정책)는 캐시 메모리에서 새로운 데이터를 저장하기 위해 기존의 데이터를 교체할 때 어떤 데이터를 제거할지를 결정하는 규칙이다.</description>
    </item>
    <item>
      <title>Placement Policy</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/placement-policy/</link>
      <pubDate>Mon, 30 Sep 2024 10:50:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-policy/placement-policy/</guid>
      <description>Cache Placement Policy는 캐시 메모리에서 특정 메모리 블록이 캐시에 저장될 위치를 결정하는 규칙을 의미한다.</description>
    </item>
    <item>
      <title>메모리 접근 방법 (Memory Access Methods)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/access-methods/memory-access-methods/</link>
      <pubDate>Mon, 30 Sep 2024 08:05:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/access-methods/memory-access-methods/</guid>
      <description>메모리 접근 방식 (Memory Access Methods)은 컴퓨터 시스템에서 메모리에 접근하는 방식을 말한다.</description>
    </item>
    <item>
      <title>메모리 주소 지정 방식 (Memory Address Modes)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/address-modes/memory-address-modes/</link>
      <pubDate>Mon, 30 Sep 2024 08:04:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/address-modes/memory-address-modes/</guid>
      <description>메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.</description>
    </item>
    <item>
      <title>Large-scale Management</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/enterprise-usage/large-scale-management/</link>
      <pubDate>Mon, 30 Sep 2024 06:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/enterprise-usage/large-scale-management/</guid>
      <description>대규모 버전 관리 시스템은 수천 명의 개발자와 수백만 라인의 코드를 효율적으로 관리하기 위한 핵심 인프라이다. 분산 아키텍처, 고급 브랜칭 전략, 성능 최적화 기술을 통해 대규모 협업을 가능하게 한다. Partial Clone 과 Shallow Clone 같은 기술은 대용량 리포지토리 처리 성능을 크게 향상시키며, 서브모듈과 CODEOWNERS 를 활용한 구조화된 접근법은 복잡성을 관리한다. 팀 규모와 프로젝트 특성에 맞는 브랜칭 전략 선택이 중요하며, AI 기반 자동화와 코드 리뷰, 분산 저장 최적화 등이 미래 발전 방향으로 주목받고 있다. 효율적인 대규모 버전 관리는 단순한 도구를 넘어 조직의 소프트웨어 개발 문화와 프로세스의 핵심 요소로 자리잡고 있다.</description>
    </item>
    <item>
      <title>MonoRepo vs. MultiRepo</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/enterprise-usage/monorepo-vs-multirepo/</link>
      <pubDate>Mon, 30 Sep 2024 06:18:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/enterprise-usage/monorepo-vs-multirepo/</guid>
      <description>모노레포와 멀티레포는 소스 코드 관리를 위한 두 가지 주요 접근법으로, 각각 고유한 장단점을 가지고 있다. 모노레포는 여러 프로젝트를 단일 저장소에서 관리하여 코드 공유, 원자적 변경, 통합 테스트 등의 이점을 제공하지만, 저장소 크기 증가와 접근 제어 제한 등의 단점이 있다. 반면 멀티레포는 각 프로젝트를 독립적인 저장소에서 관리하여 팀 자율성, 세밀한 접근 제어, 독립적 배포 등의 이점을 제공하지만, 코드 재사용 어려움과 의존성 관리 복잡성 등의 단점이 있다. 최근에는 Bazel, Nx, Turborepo 같은 도구의 발전으로 두 접근법의 한계가 완화되고 있으며, 하이브리드 접근법도 증가하고 있다. 프로젝트 특성, 팀 구조, 기술 스택에 따라 적합한 접근법이 달라지므로, 각 조직은 자신의 상황에 맞는 최적의 저장소 전략을 선택해야 한다.</description>
    </item>
    <item>
      <title>Cache Coherence</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/</link>
      <pubDate>Mon, 30 Sep 2024 03:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/</guid>
      <description>Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.</description>
    </item>
    <item>
      <title>Caching Techniques</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/types/caching-techniques/</link>
      <pubDate>Mon, 30 Sep 2024 02:37:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/types/caching-techniques/</guid>
      <description>캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.</description>
    </item>
    <item>
      <title>CPU</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/cpu/</link>
      <pubDate>Sun, 29 Sep 2024 16:44:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/cpu/</guid>
      <description>컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.</description>
    </item>
    <item>
      <title>파이프라이닝 (Pipelining)</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/processor-architecture/microarchitecture/pipelining/</link>
      <pubDate>Sun, 29 Sep 2024 02:20:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/processor-architecture/microarchitecture/pipelining/</guid>
      <description>파이프라이닝은 여러 명령어의 실행 단계를 중첩시켜 전체적인 처리량을 향상시키는 기술로, 여러 단계를 동시에 처리함으로써 효율성을 높인다.</description>
    </item>
    <item>
      <title>Harvard Architecture</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/harvard-architecture/</link>
      <pubDate>Sun, 29 Sep 2024 01:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/harvard-architecture/</guid>
      <description>하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.</description>
    </item>
    <item>
      <title>Von Neumann architecture</title>
      <link>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/von-neumann-architecture/</link>
      <pubDate>Sun, 29 Sep 2024 01:51:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/von-neumann-architecture/</guid>
      <description>Von Neumann architecture는 1945년 John von Neumann이 제안한 컴퓨터 아키텍처로, 현대 대부분의 컴퓨터 시스템의 기본이 되는 설계이다.</description>
    </item>
    <item>
      <title>Observability vs. Monitoring</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/observability-vs-monitoring/</link>
      <pubDate>Sat, 28 Sep 2024 08:23:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/observability-vs-monitoring/</guid>
      <description>Observability는 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력을 말하고, Monitoring은 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동을 말한다.</description>
    </item>
    <item>
      <title>Metric</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/metrics/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/metrics/</guid>
      <description>Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값</description>
    </item>
    <item>
      <title>Trace</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/tracing/</link>
      <pubDate>Sat, 28 Sep 2024 02:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/tracing/</guid>
      <description>분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것</description>
    </item>
    <item>
      <title>Log</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/logging/</link>
      <pubDate>Sat, 28 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/logging/</guid>
      <description>Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.</description>
    </item>
    <item>
      <title>Rate Limiting Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/performance-and-rate-limiting/rate-limiting-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/performance-and-rate-limiting/rate-limiting-pattern/</guid>
      <description>Rate Limiting은 특정 시간 동안 클라이언트나 서비스가 보낼 수 있는 요청 수를 제한하는 메커니즘이다.</description>
    </item>
    <item>
      <title>Serverless Architecture</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/serverless/serverless-architecture/</link>
      <pubDate>Fri, 27 Sep 2024 11:41:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/cloud-native-platforms/serverless/serverless-architecture/</guid>
      <description>Serverless Architecture는 개발자가 서버 관리 없이 애플리케이션 로직에 집중할 수 있도록 설계된 클라우드 컴퓨팅 모델로, 이벤트 기반의 자동 확장성과 사용한 만큼만 비용을 지불하는 구조가 핵심이다.</description>
    </item>
    <item>
      <title>Publisher-Subscriber Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/publisher-subscriber/publisher-subscriber-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:40:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/publisher-subscriber/publisher-subscriber-pattern/</guid>
      <description>이 패턴은 메시지를 보내는 발행자(Publisher)와 메시지를 받는 구독자(Subscriber) 사이의 느슨한 결합(Loose Coupling)을 제공하는 메시징 패턴으로, 발행자는 메시지를 특정 주제(Topic)나 채널로 발행하고, 해당 주제를 구독하는 모든 구독자들이 그 메시지를 받게 된다.</description>
    </item>
    <item>
      <title>Retry Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/retry/retry-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:31:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/retry/retry-pattern/</guid>
      <description>분산 시스템이나 마이크로서비스 아키텍처에서 일시적인 오류(Transient Failure)를 처리하기 위한 핵심 설계 패턴이다.</description>
    </item>
    <item>
      <title>Model-View-ViewModel Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/structural/layered/mvc/model-view-viewmodel-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 11:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/structural/layered/mvc/model-view-viewmodel-pattern/</guid>
      <description>MVVM(Model-View-ViewModel) 패턴은 소프트웨어 아키텍처 패턴 중 하나로, 사용자 인터페이스(UI)와 비즈니스 로직을 효과적으로 분리하여 코드의 유지보수성과 재사용성을 향상시키는 데 중점을 둔다.</description>
    </item>
    <item>
      <title>Model–view–presenter Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/structural/layered/mvc/model-view-presenter-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 09:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/structural/layered/mvc/model-view-presenter-pattern/</guid>
      <description>Model-View-Presenter(MVP) 패턴은 사용자 인터페이스 개발을 위한 아키텍처 패턴으로, **관심사 분리** 원칙에 기반해 UI 로직과 비즈니스 로직을 분리한다.</description>
    </item>
    <item>
      <title>Master-Slave Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/master-slave-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/master-slave-pattern/</guid>
      <description>하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다</description>
    </item>
    <item>
      <title>Pipe-Filter Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/pipes-and-filters/pipe-filter-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/pipes-and-filters/pipe-filter-pattern/</guid>
      <description>데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Producer-Consumer Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/producer-consumer-pattern/</link>
      <pubDate>Fri, 27 Sep 2024 01:12:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/producer-consumer-pattern/</guid>
      <description>이 패턴은 데이터를 생성하는 프로듀서(Producer)와 데이터를 소비하는 컨슈머(Consumer) 사이의 작업을 분리하여 효율적인 데이터 처리를 가능하게 한다.</description>
    </item>
    <item>
      <title>Domain-Driven Design</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/modeling/domain-modeling/domain-driven-design/</link>
      <pubDate>Thu, 26 Sep 2024 08:30:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/modeling/domain-modeling/domain-driven-design/</guid>
      <description>복잡한 소프트웨어 시스템을 개발하기 위한 접근 방식으로, 비즈니스 도메인을 중심으로 소프트웨어를 설계하고 개발하는 방법론</description>
    </item>
    <item>
      <title>Event-Bus Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/event-bus-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:28:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/messaging/event-bus-pattern/</guid>
      <description>소프트웨어 시스템의 컴포넌트 간 통신을 단순화하고 유연성을 높이는 아키텍처 패턴</description>
    </item>
    <item>
      <title>Client-Server Pattern</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/distributed/client-server/client-server-pattern/</link>
      <pubDate>Thu, 26 Sep 2024 08:27:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-styles/distributed/client-server/client-server-pattern/</guid>
      <description>서비스를 제공하는 서버와 서비스를 요청하는 클라이언트로 구성되는 소프트웨어 아키텍처 패턴</description>
    </item>
    <item>
      <title>Shadow Deployment</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/shadow-deployment/</link>
      <pubDate>Mon, 23 Sep 2024 12:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/shadow-deployment/</guid>
      <description>Shadow Deployment는 새로운 버전의 애플리케이션을 프로덕션 환경에 배포하고 실제 트래픽을 복제하여 새 버전으로 전송하지만, 그 결과는 사용자에게 반환하지 않는 방식이다.</description>
    </item>
    <item>
      <title>Feature Flags</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/feature-flags/</link>
      <pubDate>Mon, 23 Sep 2024 12:36:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/feature-flags/</guid>
      <description>Feature flags는 조건문을 사용하여 코드의 특정 부분을 동적으로 제어하는 소프트웨어 개발 기법</description>
    </item>
    <item>
      <title>Access Modifiers</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/components/access-modifiers/</link>
      <pubDate>Mon, 23 Sep 2024 04:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/components/access-modifiers/</guid>
      <description>객체지향 프로그래밍(OOP)에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 중요한 개념이다.</description>
    </item>
    <item>
      <title>A/B Testing</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/a-b-testing/</link>
      <pubDate>Mon, 23 Sep 2024 02:14:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/a-b-testing/</guid>
      <description>A/B Testing은 소프트웨어 배포 전략 중 하나로, 두 가지 이상의 버전을 사용자에게 제공하여 어떤 버전이 더 효과적인지 비교하는 방법이다.</description>
    </item>
    <item>
      <title>Blue-Green Deployment</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/blue-green-deployment/</link>
      <pubDate>Mon, 23 Sep 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/blue-green-deployment/</guid>
      <description>Blue-Green Deployment Pattern은 무중단 배포 전략 중 하나로, 애플리케이션의 새 버전을 안전하고 효율적으로 배포하는 방법이다.</description>
    </item>
    <item>
      <title>Canary Deployment</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/canary-deployment/</link>
      <pubDate>Mon, 23 Sep 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/canary-deployment/</guid>
      <description>카나리 배포(Canary Deployment) 패턴은 새로운 버전의 애플리케이션을 점진적으로 배포하는 전략이다.</description>
    </item>
    <item>
      <title>Rolling Deployment</title>
      <link>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/rolling-deployment/</link>
      <pubDate>Mon, 23 Sep 2024 02:13:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/devops-and-infrastructure/ci-cd/deployment-strategies/rolling-deployment/</guid>
      <description>Rolling Deployment는 애플리케이션의 새 버전을 점진적으로 배포하는 무중단 배포 전략이다.</description>
    </item>
    <item>
      <title>Class and Instance</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/components/class/class-and-instance/</link>
      <pubDate>Sun, 22 Sep 2024 12:38:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/components/class/class-and-instance/</guid>
      <description>클래스란 객체를 생성하기 위한 템플릿 또는 청사진이고, 인스턴스는 클래스를 기반으로 생성된 실제 객체</description>
    </item>
    <item>
      <title>다형성 (Polymorphism)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/polymorphism/</link>
      <pubDate>Sun, 22 Sep 2024 10:25:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/polymorphism/</guid>
      <description>다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 특징 중 하나로, &amp;#34;여러 가지 형태를 가질 수 있는 능력&amp;#34;을 의미한다</description>
    </item>
    <item>
      <title>상속 (Inheritance)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/inheritance/</link>
      <pubDate>Sun, 22 Sep 2024 10:10:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/inheritance/</guid>
      <description>상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 기존 클래스의 특성을 다른 클래스가 물려받아 재사용하고 확장할 수 있게 해주는 메커니즘</description>
    </item>
    <item>
      <title>추상화 (Abstraction)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/abstraction/</link>
      <pubDate>Sun, 22 Sep 2024 06:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/abstraction/</guid>
      <description>프로그래밍에서 핵심적인 개념으로, 복잡한 시스템이나 데이터를 단순화하여 필수적인 특징만을 강조하는 과정</description>
    </item>
    <item>
      <title>Abstract Classes</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/paradigm-features/abstract-classes/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/paradigm-features/abstract-classes/</guid>
      <description>추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스이다. 추상 메서드는 선언만 되고 구현되지 않은 메서드를 말한다.</description>
    </item>
    <item>
      <title>Interfaces</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/paradigm-features/interfaces/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/paradigm-features/interfaces/</guid>
      <description>소프트웨어나 애플리케이션에서 인터페이스(Interface)는 두 개의 시스템, 프로그램, 장치 또는 구성 요소 간의 상호 작용을 가능하게 하는 연결점 또는 접점을 의미한다.</description>
    </item>
    <item>
      <title>오버라이딩(Overriding)과 오버로딩(Overloading)</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/overriding-and-overloading/</link>
      <pubDate>Sun, 22 Sep 2024 04:56:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/overriding-and-overloading/</guid>
      <description>오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 알아보고 비교 분석해보자.</description>
    </item>
    <item>
      <title>Encapsulation</title>
      <link>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/encapsulation/</link>
      <pubDate>Sun, 22 Sep 2024 02:26:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/system-and-software-architecture/principles/programming-paradigms/object-oriented-programming/primary-principles/encapsulation/</guid>
      <description>캡슐화는 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶고, 외부로부터 접근을 제한하는 것을 의미한다.</description>
    </item>
    <item>
      <title>Concurrent Engineering Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/concurrent-engineering-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/concurrent-engineering-model/</guid>
      <description>소프트웨어 개발 프로세스를 최적화하고 효율성을 높이기 위한 접근 방식</description>
    </item>
    <item>
      <title>Domain-Driven Development</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/domain-driven-development/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/domain-driven-development/</guid>
      <description>복잡한 소프트웨어를 개발할 때 비즈니스 도메인을 중심으로 설계와 개발을 진행하는 방법론</description>
    </item>
    <item>
      <title>Formal Methods Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/formal-methods-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/formal-methods-model/</guid>
      <description>소프트웨어 개발에서 수학적 기법을 사용하여 시스템을 명세, 개발, 분석 및 검증하는 엄격한 접근 방식</description>
    </item>
    <item>
      <title>Incremental Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/incremental-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:49:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/incremental-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분(증분)으로 나누어 순차적으로 개발하고 제공하는 접근 방식.</description>
    </item>
    <item>
      <title>DevOps Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/devops-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/devops-model/</guid>
      <description>소프트웨어 개발(Development)과 IT 운영(Operations)을 통합하는 방법론으로, 소프트웨어 개발 프로세스를 개선하고 더 빠르고 안정적인 제품 배포를 가능하게 한다.</description>
    </item>
    <item>
      <title>Prototyping Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/prototyping-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/prototyping-model/</guid>
      <description>최종 제품의 초기 버전 또는 모형을 만들어 사용자의 피드백을 받고 요구사항을 명확히 하는 방법.</description>
    </item>
    <item>
      <title>Rapid Application Development</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/rapid-application-development/</link>
      <pubDate>Sat, 21 Sep 2024 00:48:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/rapid-application-development/</guid>
      <description>빠른 프로토타이핑과 반복적인 개발을 통해 신속하게 애플리케이션을 구축하는 접근 방식</description>
    </item>
    <item>
      <title>Iterative Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/iterative-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/iterative-model/</guid>
      <description>전체 시스템을 여러 개의 작은 부분으로 나누어 반복적으로 개발하고 개선하는 방법</description>
    </item>
    <item>
      <title>Spiral Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/spiral-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/spiral-model/</guid>
      <description>위험 분석을 중심으로 반복적인 개발을 수행하며, 각 반복 주기마다 위험 요소를 평가하고 대응한다.</description>
    </item>
    <item>
      <title>V Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/v-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:47:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/v-model/</guid>
      <description>개발 단계와 테스트 단계를 병행하여 진행하는 검증(Verification)과 확인(Validation) 중심의 접근 방식이다.</description>
    </item>
    <item>
      <title>Waterfall Model</title>
      <link>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/waterfall-model/</link>
      <pubDate>Sat, 21 Sep 2024 00:46:00 +0000</pubDate>
      <guid>https://buenhyden.github.io/posts/quality-assurance/sdlc/software-development-model/waterfall-model/</guid>
      <description>각 단계를 순차적으로 진행하며, 이전 단계가 완료되어야 다음 단계로 넘어가는 전통적인 모델.</description>
    </item>
  </channel>
</rss>
