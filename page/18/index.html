<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.143.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Domain-specific</h2></header><div class=entry-content><p>Domain-specific Domain-specific 프로토콜은 특정 도메인이나 비즈니스 영역에 특화된 통신 프로토콜을 의미한다.
이 프로토콜은 일반적인 통신 프로토콜보다 해당 도메인의 특성과 요구사항에 더 적합하게 설계되어 있다.
주요 특징 도메인 주도 설계(DDD)와의 연계: 도메인 주도 설계는 복잡한 소프트웨어를 개발할 때 도메인 모델을 중심으로 설계하는 접근 방식이다. MSA에서 도메인별 통신 스타일을 적용하면, 각 도메인의 비즈니스 로직과 데이터가 해당 서비스 내에서 캡슐화되어 독립성을 유지할 수 있다.
통신 프로토콜의 선택: 각 도메인의 특성에 따라 적합한 통신 프로토콜을 선택한다. 예를 들어, 실시간성이 중요한 도메인에서는 gRPC나 GraphQL과 같은 프로토콜을, 비동기 처리가 적합한 도메인에서는 Kafka나 AMQP와 같은 메시징 프로토콜을 사용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 11:22:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;333 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain-specific" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/domain-specific/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Remote-Procedure</h2></header><div class=entry-content><p>Remote-Procedure Remote Procedure Call은 분산 컴퓨팅 환경에서 한 프로그램이 다른 주소 공간(일반적으로 다른 컴퓨터)에 있는 프로시저나 함수를 마치 로컬 함수처럼 호출할 수 있게 해주는 프로토콜이다.
RPC의 작동 원리 클라이언트가 로컬 프로시저를 호출한다. 클라이언트 스텁이 파라미터를 마샬링(marshaling)하여 메시지로 패킹한다. 클라이언트의 운영체제가 메시지를 서버 머신으로 전송한다. 서버의 운영체제가 수신된 패킷을 서버 스텁으로 전달한다. 서버 스텁이 파라미터를 언마샬링(unmarshalling)한다. 서버 스텁이 서버 프로시저를 호출한다. RPC의 특징 투명성: 분산 컴퓨팅을 중앙 집중식 컴퓨팅처럼 보이게 만든다. 높은 수준의 프로토콜: 소켓 통신보다 더 높은 수준의 추상화를 제공한다. 위치 및 구현 언어에 대한 투명성 제공: 클라이언트-서버 통신에 대한 투명성을 제공한다. RPI 패턴의 주요 구성 요소 통신 프로토콜: HTTP/REST가 가장 일반적이지만, gRPC나 GraphQL도 사용될 수 있습니다. 각 프로토콜은 자신만의 장단점이 있다. 예를 들어, REST는 간단하고 이해하기 쉽지만, gRPC는 더 높은 성능을 제공한다. 서비스 인터페이스: API 계약은 매우 중요하다. 버저닝, 문서화, 그리고 하위 호환성을 고려해야 한다. 예를 들어, Swagger나 OpenAPI를 사용하여 API를 문서화하고 관리할 수 있다. 오류 처리: 네트워크 오류, 타임아웃, 서비스 불가용 등 다양한 실패 케이스를 고려해야 한다. Circuit Breaker 패턴을 사용하여 연쇄 실패를 방지할 수 있다. 보안: 인증, 인가, 데이터 암호화 등 보안 측면을 고려해야 한다. OAuth2나 JWT를 사용하여 서비스 간 인증을 구현할 수 있다. RPC의 장점 효율성: 도메인 특화 기능으로 통신 효율성이 높아진다. 구현 용이성: REST나 gRPC와 같은 잘 알려진 RPC 기술을 사용하여 쉽게 구현할 수 있다. 직관적인 프로그래밍 모델: 개발자가 분산 시스템을 로컬 시스템처럼 프로그래밍할 수 있게 해준다. RPC의 단점 네트워크 문제로 인한 실패 가능성: 예측할 수 없는 네트워크 문제로 인해 원격 호출이 실패할 수 있다. 복잡성: 로컬 호출과 달리 네트워크 지연, 오류 처리 등 추가적인 복잡성이 발생한다. 호환성 문제: 다른 시스템과의 통합이 어려울 수 있다. RPI 패턴 구현 시 고려해야 할 사항 성능 최적화: 네트워크 지연을 최소화하고, 캐싱을 활용하며, 배치 처리를 고려해야 한다. 예를 들어, 여러 개의 작은 요청 대신 하나의 큰 요청으로 처리하는 것이 효율적일 수 있다. 확장성: 서비스 디스커버리, 로드 밸런싱, 그리고 자동 스케일링을 구현해야 한다. Eureka나 Consul과 같은 서비스 디스커버리 도구를 활용할 수 있다. 모니터링: 요청/응답 시간, 오류율, 처리량 등을 모니터링해야 한다. Prometheus나 Grafana와 같은 도구를 사용하여 메트릭스를 수집하고 시각화할 수 있다. MSA에서의 RPC 활용 마이크로서비스 아키텍처에서 RPC는 서비스 간 통신을 위한 효과적인 방법 중 하나이다. 특히 동기식, 저지연 상호작용이 필요한 경우에 적합하다. REST, gRPC, Apache Thrift 등의 기술을 활용하여 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 11:22:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;386 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Remote-Procedure" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/remote-procedure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Messaging</h2></header><div class=entry-content><p>Messaging 마이크로서비스 아키텍처(MSA)에서 Messaging은 중요한 Communication style 중 하나이다.
Messaging은 서비스 간 비동기 통신을 가능하게 하며, 시스템의 확장성과 유연성을 향상시킨다.
Messaging은 서비스들이 메시지를 통해 비동기적으로 통신하는 방식이다. 서비스들은 메시지 브로커를 통해 메시지를 주고받으며, 이를 통해 느슨한 결합(loose coupling)을 실현한다.
주요 특징 비동기 통신: 서비스는 메시지를 보내고 즉시 다른 작업을 수행할 수 있다. 느슨한 결합: 서비스들은 직접적인 연결 없이 메시지를 통해 통신한다. 메시지 구조: 메시지는 일반적으로 헤더(header)와 바디(message body)로 구성된다. 채널 기반 통신: 메시지는 채널을 통해 전달된다. point-to-point 채널과 publish-subscribe 채널이 있다. Messaging 패턴 Request/Response: 서비스가 요청 메시지를 보내고 응답을 기다린다. Notifications: 서비스가 메시지를 보내지만 응답을 기대하지 않는다. Publish/Subscribe: 서비스가 메시지를 발행하면 여러 수신자가 구독할 수 있다. Event-Driven: 서비스가 이벤트를 발행하고 다른 서비스들이 이에 반응한다. Messaging 패턴의 주요 구성 요소 메시지 구조:
...</p></div><footer class=entry-footer><span title='2024-11-12 11:21:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Messaging" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication-style/messaging/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Externalized configuration</h2></header><div class=entry-content><p>Externalized Configuration Externalized Configuration 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 애플리케이션의 구성 정보를 코드와 분리하여 외부에서 관리하는 방식을 말한다.
이 패턴은 애플리케이션의 구성 정보를 외부 저장소에 보관하고, 런타임에 이를 읽어오는 방식으로 동작한다.
구성 정보는 데이터베이스, 파일 시스템, 환경 변수 등 다양한 외부 저장소에 보관될 수 있다.
이를 통해 각 환경(개발, 테스트, 운영 등)에 따라 다른 설정을 적용할 수 있으며, 설정 변경 시 애플리케이션을 재배포하지 않아도 된다.
Externalized Configuration 패턴은 마이크로서비스 아키텍처에서 구성 관리의 복잡성을 줄이고, 시스템의 유연성과 확장성을 높이는 데 크게 기여한다. 이 패턴을 효과적으로 사용하면 다양한 환경에서 애플리케이션을 쉽게 배포하고 관리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 11:10:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Externalized configuration" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/externalized-configuration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Microservice Chassis</h2></header><div class=entry-content><p>Microservice Chassis Microservice Chassis는 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 패턴이다.
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 프레임워크나 라이브러리 형태로 제공한다.
Microservice Chassis는 마이크로서비스 개발에 필요한 공통 기능을 제공하는 기본 프레임워크이다.
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.
주요 특징 공통 기능의 추상화: 인증 및 권한 부여, 로깅, 설정 관리, 헬스 체크, 메트릭 수집, 분산 추적 등 여러 서비스에 걸쳐 공통적으로 필요한 기능들을 섀시에서 제공하여 코드 중복을 최소화한다. 일관된 빌드 및 배포 프로세스: 빌드 로직과 배포 설정을 섀시에서 관리하여, 모든 서비스가 일관된 방식으로 빌드되고 배포될 수 있도록 지원한다. 확장성: 새로운 서비스 개발 시 섀시를 기반으로 빠르게 시작할 수 있으며, 공통 기능의 변경이 필요할 경우 섀시를 업데이트하여 모든 서비스에 적용할 수 있다. 주요 기능 Microservice Chassis는 다음과 같은 Cross-Cutting Concern을 처리한다:
...</p></div><footer class=entry-footer><span title='2024-11-12 11:10:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;556 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Microservice Chassis" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/microservice-chassis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service Template</h2></header><div class=entry-content><p>Service Template Service Template 패턴은 마이크로서비스 아키텍처(MSA)에서 Cross-Cutting Concern을 효과적으로 관리하기 위한 중요한 패턴이다.
이 패턴은 여러 마이크로서비스에서 공통적으로 필요한 기능들을 재사용 가능한 템플릿 형태로 제공한다.
Service Template은 마이크로서비스 개발에 필요한 공통 기능과 구조를 제공하는 기본 템플릿이다.
이는 각 서비스의 개발자가 비즈니스 로직에 집중할 수 있도록 인프라 관련 문제를 추상화한다.
주요 특징 재사용 가능한 코드 기반: 서비스 템플릿은 빌드 로직, 공통 설정, 크로스커팅 관심사(예: 로깅, 보안, 설정 관리 등)를 포함한 실행 가능한 간단한 서비스를 제공한다. 이를 통해 새로운 서비스를 시작할 때 필요한 기본 구조를 빠르게 구축할 수 있다. 일관성 유지: 모든 서비스가 동일한 템플릿을 기반으로 생성되므로, 코드 구조와 설정이 일관되어 유지보수성과 가독성이 향상된다. 주요 기능 Service Template은 다음과 같은 Cross-Cutting Concern을 처리한다:
...</p></div><footer class=entry-footer><span title='2024-11-12 11:09:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;324 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Template" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/cross-cutting-concern/service-template/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Database per Service Pattern</h2></header><div class=entry-content><p>Database per Service Pattern “Database per Service Pattern"은 마이크로서비스 아키텍처에서 중요한 디자인 패턴 중 하나이다.
Database per Service Pattern은 각 마이크로서비스가 자체적인 독립된 데이터베이스를 가지는 구조를 말한다.
이는 서비스 간의 느슨한 결합을 촉진하고, 각 서비스의 자율성을 높이는 것을 목표로 한다.
주요 특징:
각 서비스는 자신만의 전용 데이터베이스를 가짐 서비스 간 데이터 접근은 API를 통해서만 가능 각 서비스는 자신의 요구사항에 가장 적합한 데이터베이스 기술을 선택할 수 있음 Database per Service Pattern은 마이크로서비스 아키텍처에서 서비스 간 독립성과 확장성을 높인다.
하지만 이를 효과적으로 구현하기 위해서는 신중한 설계와 다양한 기술적 도전을 해결해야 한다.
각 서비스의 특성과 전체 시스템의 요구사항을 고려하여 이 패턴의 적용 여부를 결정해야 하며, 필요에 따라 다른 패턴들과 조합하여 사용하는 것이 좋다.
...</p></div><footer class=entry-footer><span title='2024-11-12 10:05:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;416 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Database per Service Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/database-per-service/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shared Database</h2></header><div class=entry-content><p>Shared Database 마이크로서비스 아키텍처(MSA)에서 “Shared Database” 패턴은 여러 마이크로서비스가 단일 데이터베이스를 공유하는 접근 방식이다.
Shared Database 패턴은 여러 마이크로서비스가 동일한 데이터베이스 인스턴스를 사용하여 데이터를 저장하고 접근하는 방식이다. 각 서비스는 자유롭게 다른 서비스가 소유한 데이터에 접근할 수 있으며, 로컬 ACID 트랜잭션을 사용하여 데이터 일관성을 유지한다.
Shared Database 패턴은 마이크로서비스 아키텍처의 일반적인 원칙과는 다소 배치되지만, 특정 상황에서는 유용할 수 있다. 그러나 장기적으로는 서비스 간 결합도를 낮추고 확장성을 높이기 위해 Database per Service 패턴으로의 전환을 고려해야 할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 07:39:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;272 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Database" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Docker</h2></header><div class=entry-content><p>Docker 애플리케이션과 그 실행 환경을 컨테이너라는 독립된 단위로 패키징하여 어디서나 일관되게 실행할 수 있게 해주는 플랫폼.
컨테이너는 애플리케이션 코드, 런타임, 시스템 도구, 라이브러리 등 필요한 모든 것을 포함하는 경량화된 가상화 환경.
Source: &lt;https://www.docker.com/resources/what-container/
특징 포터빌리티: Docker 컨테이너는 어떤 환경에서도 동일하게 실행될 수 있어 개발, 테스트, 운영 환경 간 일관성을 제공합니다. 경량화: 컨테이너는 호스트 OS의 커널을 공유하여 가상 머신보다 더 가볍고 효율적입니다. 격리: 각 컨테이너는 독립적으로 실행되어 다른 컨테이너나 호스트 시스템에 영향을 주지 않습니다. 버전 관리: Docker 이미지는 버전 관리가 가능하며, Docker Hub를 통해 쉽게 공유할 수 있습니다. 장점 일관된 개발 환경: 개발자들이 동일한 환경에서 작업할 수 있어 “내 컴퓨터에서는 작동합니다” 문제를 해결합니다. 빠른 배포: 컨테이너화된 애플리케이션은 빠르게 배포되고 확장될 수 있습니다. 리소스 효율성: 컨테이너는 가상 머신보다 적은 리소스를 사용합니다. 마이크로서비스 아키텍처 지원: Docker는 독립적인 서비스 구현에 이상적입니다. 단점 보안 이슈: 컨테이너 간 격리가 완벽하지 않아 보안 취약점이 발생할 수 있습니다. 복잡성: Docker의 학습 곡선이 가파를 수 있으며, 관리가 복잡해질 수 있습니다. 제한된 오케스트레이션: 다중 컨테이너 관리를 위해서는 추가 도구가 필요할 수 있습니다. 역할 개발 환경 표준화: 모든 개발자가 동일한 환경에서 작업할 수 있게 합니다. 애플리케이션 격리: 각 애플리케이션을 독립적인 환경에서 실행합니다. CI/CD 파이프라인 지원: 지속적 통합 및 배포 프로세스를 간소화합니다. 마이크로서비스 구현: 복잡한 애플리케이션을 작은 독립 서비스로 분리하는 데 도움을 줍니다. 주요 명령어 이미지 관리:
...</p></div><footer class=entry-footer><span title='2024-11-11 15:43:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;367 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Docker" href=https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/docker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Portainer</h2></header><div class=entry-content><p>Portainer란? 컨테이너 환경을 관리하기 위한 오픈소스 웹 기반 GUI 도구
개요 Docker, Kubernetes 등 다양한 컨테이너 플랫폼을 지원하는 범용 컨테이너 관리 솔루션 직관적인 웹 인터페이스를 통해 컨테이너 환경의 복잡성을 단순화 100만 명 이상의 사용자와 30,000개 이상의 GitHub 스타를 보유한 인기 있는 도구 주요 특징과 기능 컨테이너 관리: 컨테이너의 배포, 시작, 중지, 로그 확인 등을 GUI로 수행 스택 배포: Docker Compose를 사용한 멀티 컨테이너 애플리케이션 배포 지원 볼륨 및 네트워크 관리: 데이터 저장소와 네트워크 구성 관리 이미지 관리: Docker 레지스트리 연동 및 이미지 관리 리소스 모니터링: CPU, 메모리 사용량 등 컨테이너 성능 모니터링 템플릿: 미리 정의된 애플리케이션 템플릿을 통한 간편한 배포 장점 사용 편의성: 명령줄 지식 없이도 컨테이너 관리 가능 중앙 집중식 관리: 여러 Docker 환경을 단일 인터페이스에서 관리 보안 강화: 사용자 및 팀 단위의 접근 제어 기능 제공 확장성: 소규모 프로젝트부터 대규모 엔터프라이즈 환경까지 지원 버전 Community Edition (CE): 무료 오픈소스 버전 Business Edition (BE): 기업용 고급 기능(보안, 감사 등) 제공 버전 Portainer 설치 Host간 볼륨 매칭을 위한 디렉토리 생성 1 mkdir -p /kubernetes/portainer_data Portainerdmf docker run 명령어를 통해 docker에 설치
위에서 생성한 폴더와 마운트 1 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /kubernetes/portainer_data:/data portainer/portainer-ce:latest Portainer 로그인
웹브라우저 Portainer 서버(예: http://서버IP:9000)에 접근
[처음 접속시]
username과 password 입력
Source: hyunyoun
...</p></div><footer class=entry-footer><span title='2024-11-11 15:43:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;247 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Portainer" href=https://buenhyden.github.io/posts/system-design/infrastructure/virtualization/container/portainer/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/17/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/19/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>