<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.7"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hosting</h2></header><div class=entry-content><p>Hosting 호스팅은 API 설계와 배포에 있어 핵심적인 요소이다. 잘 설계된 API 도 적절한 호스팅 환경이 없다면 사용자에게 안정적으로 서비스를 제공할 수 없다.
호스팅의 기본 개념 호스팅이란 무엇인가? 호스팅은 API, 웹사이트, 애플리케이션과 같은 디지털 자산을 인터넷을 통해 사용자에게 제공하기 위해 서버 공간과 자원을 제공하는 서비스이다. API 호스팅은 API 가 24 시간 내내 접근 가능하고, 안정적으로 요청을 처리하며, 적절한 보안과 성능을 유지할 수 있도록 한다.
호스팅 서비스는 다음과 같은 기본 요소를 제공한다:
...</p></div><footer class=entry-footer><span title='2025-03-31 23:50:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;55 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hosting" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/hosting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ReDoc</h2></header><div class=entry-content><p>ReDoc ReDoc은 OpenAPI(이전의 Swagger) 명세를 기반으로 한 오픈 소스 API 문서 생성 도구이다. 2016년에 Rebilly에 의해 개발된 이 도구는 단일 HTML 파일로 깔끔하고 반응형 있는 API 문서를 생성하는 데 특화되어 있다.
ReDoc의 핵심 가치는 세 가지이다:
개발자 친화적 인터페이스: 사용하기 쉽고 탐색하기 쉬운 문서 제공 시각적 매력: 미학적으로 세련된 문서 생성 유연성과 맞춤화: 다양한 요구에 맞게 조정 가능 ReDoc의 주요 기능 단일 페이지 디자인 ReDoc은 단일 페이지 애플리케이션(SPA) 접근 방식을 취한다. 이는 사용자가 페이지를 전환하지 않고도 모든 API 문서에 접근할 수 있음을 의미한다.
...</p></div><footer class=entry-footer><span title='2025-03-31 09:04:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ReDoc" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/tools/redoc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Adaptive Polling</h2></header><div class=entry-content><p>Adaptive Polling 어댑티브 폴링은 데이터 수집이나 시스템 모니터링 과정에서 폴링(polling) 주기를 상황과 필요에 따라 동적으로 조절하는 기술이다. 전통적인 고정 주기 폴링과 달리, 시스템의 상태와 환경 변화에 따라 폴링 빈도를 지능적으로 조절함으로써 리소스 사용 효율성을 극대화한다.
작동 원리 어댑티브 폴링은 다음과 같은 핵심 메커니즘을 기반으로 작동한다:
상태 감지(State Detection): 시스템은 현재 상태, 데이터 변화율, 이벤트 발생 빈도 등을 지속적으로 모니터링한다. 알고리즘 기반 의사결정(Algorithm-based Decision Making): 수집된 정보를 바탕으로 최적의 폴링 주기를 결정하는 알고리즘을 실행한다. 동적 조정(Dynamic Adjustment): 폴링 주기는 실시간으로 조정되며, 시스템 활동이 활발할 때는 주기가 짧아지고 비활성 상태에서는 주기가 길어진다. 예를 들어, 네트워크 트래픽이 갑자기 증가하면 시스템은 폴링 빈도를 높여 상황을 더 세밀하게 모니터링하고, 트래픽이 안정되면 폴링 빈도를 낮추어 리소스를 절약한다.
...</p></div><footer class=entry-footer><span title='2025-03-23 04:10:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adaptive Polling" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/adaptive-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Smart Polling</h2></header><div class=entry-content><p>Smart Polling 스마트 폴링은 시스템이 데이터를 효율적으로 수집하고 모니터링하는 첨단 기술로, 전통적인 폴링 방식의 한계를 극복하기 위해 발전되었다. 이 기술은 폴링 과정에 지능적 의사결정 요소를 통합하여 리소스 사용 최적화와 시스템 성능 향상을 동시에 추구한다.
스마트 폴링의 기본 개념 스마트 폴링은 단순히 일정 주기로 데이터를 확인하는 전통적인 폴링과 달리, 다양한 컨텍스트 정보와 알고리즘을 활용하여 ‘언제’, ‘무엇을’, ‘어떻게’ 폴링할지 지능적으로 결정한다.
이는 다음과 같은 핵심 원칙에 기반한다:
컨텍스트 인식(Context Awareness): 시스템 상태, 네트워크 조건, 사용자 행동 패턴 등의 컨텍스트 정보를 고려한다. 적응형 의사결정(Adaptive Decision Making): 수집된 데이터와 상황에 따라 폴링 전략을 실시간으로 조정한다. 우선순위 기반 처리(Priority-based Processing): 중요도에 따라 데이터 수집 우선순위를 설정한다. 리소스 최적화(Resource Optimization): 필요한 정보만 필요한 시점에 수집하여 시스템 리소스를 효율적으로 사용한다. 스마트 폴링의 주요 기술 요소 이벤트 기반 폴링(Event-driven Polling) 특정 조건이나 트리거가 발생할 때만 폴링을 수행하는 방식이다.
...</p></div><footer class=entry-footer><span title='2025-03-23 04:10:00 +0000 UTC'>March 23, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Smart Polling" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/smart-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenAPI 사양(OpenAPI Specification, OAS)</h2></header><div class=entry-content><p>OpenAPI 사양(OpenAPI Specification, OAS) OpenAPI 사양(OpenAPI Specification, OAS)은 REST API를 설계, 문서화 및 표준화하기 위한 언어에 구애받지 않는 정의 형식이다.
Swagger와 OpenAPI의 개념과 역사 Swagger의 탄생 Swagger는 2010년 Tony Tam에 의해 시작된 프로젝트로, RESTful API를 설계, 구축, 문서화, 소비하기 위한 오픈 소스 프레임워크이다. 초기에는 Wordnik이라는 온라인 사전 API를 문서화하기 위해 개발되었으나, 빠르게 API 개발 커뮤니티 내에서 인기를 얻었다.
OpenAPI로의 전환 2015년, Swagger 사양은 Linux Foundation 산하의 OpenAPI Initiative(OAI)에 기부되었고, Swagger 사양은 “OpenAPI 사양(OpenAPI Specification, OAS)“이라는 새로운 이름을 갖게 되었다. 이러한 전환은 사양을 더 중립적이고 산업 표준으로 발전시키기 위한 움직임이었다.
...</p></div><footer class=entry-footer><span title='2025-03-14 11:21:00 +0000 UTC'>March 14, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OpenAPI 사양(OpenAPI Specification, OAS)" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-fundamentals/api-documentation/openapi-specification/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>UTF-8</h2></header><div class=entry-content><p>UTF-8 UTF-8은 현대 컴퓨팅 환경에서 가장 널리 사용되는 문자 인코딩 방식으로, 전 세계의 모든 문자를 표현할 수 있는 유니코드를 효율적으로 저장하고 전송하기 위해 설계되었다. 웹 페이지의 95% 이상이 UTF-8로 인코딩되어 있을 만큼 인터넷의 표준이 되었으며, 현대 소프트웨어 개발에서 필수적인 요소로 자리잡았다.
역사적 배경과 개발 동기 문자 인코딩의 역사적 진화 컴퓨터는 기본적으로 숫자만 처리할 수 있으므로, 텍스트를 저장하고 표시하기 위해서는 각 문자를 숫자로 매핑하는 인코딩 시스템이 필요했다. 초기에는 ASCII(American Standard Code for Information Interchange)가 영어 알파벳과 기본 기호를 7비트(0-127)로 표현했지만, 영어 외 언어를 처리하기에는 충분하지 않았다.
...</p></div><footer class=entry-footer><span title='2025-03-12 13:16:00 +0000 UTC'>March 12, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UTF-8" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/unicode/utf-8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SAML vs. OAuth 2.0</h2></header><div class=entry-content><p>SAML vs. OAuth 2.0 인증(Authentication)과 권한 부여(Authorization)는 현대 웹 애플리케이션과 시스템에서 핵심적인 보안 구성 요소이다. SAML(Security Assertion Markup Language)과 OAuth 2.0은 이러한 기능을 제공하는 두 가지 주요 프로토콜이지만, 설계 철학, 사용 사례 및 기술적 구현에서 상당한 차이가 있다.
기본 개념 및 역사 SAML (Security Assertion Markup Language) SAML은 2002년 OASIS(Organization for the Advancement of Structured Information Standards)에 의해 개발된 XML 기반 개방형 표준으로, 당시 기업들이 직면한 단일 인증 문제를 해결하기 위해 설계되었다. 현재 가장 널리 사용되는 버전은 2005년에 발표된 SAML 2.0이다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:31:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SAML vs. OAuth 2.0" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/saml/saml-vs-oauth-20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Session-Based Auth vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Session-Based Auth vs. Cookie-Based Auth 웹 애플리케이션에서 사용자 인증은 보안의 핵심 요소이다. 인증 시스템은 사용자의 신원을 확인하고, 인증된 사용자에게 적절한 권한을 부여하는 중요한 역할을 한다. 세션 기반 인증과 쿠키 기반 인증은 가장 널리 사용되는 두 가지 인증 메커니즘으로, 많은 사람들이 이 두 용어를 혼동하는 경우가 있다. 이 두 방식은 밀접하게 연관되어 있지만, 구현 방식과 보안 특성에서 중요한 차이점이 있다.
기본 개념 이해 쿠키(Cookie)란? 쿠키는 웹 서버가 사용자의 브라우저에 저장하는 작은 텍스트 파일이다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:29:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session-Based Auth vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/session-based-authentication/session-based-auth-vs-cookie-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OpenID Connect</h2></header><div class=entry-content><p>OpenID Connect (OIDC) OpenID Connect(OIDC)는 웹 기반 애플리케이션과 서비스를 위한 현대적인 인증 프로토콜로, OAuth 2.0 프레임워크를 기반으로 구축되었다. 이 프로토콜은 사용자의 신원을 검증하고, 안전하게 정보를 교환하는 표준화된 방법을 제공한다.
OIDC의 역사와 배경 OpenID Connect는 기존 OpenID 2.0의 한계를 극복하기 위해 2014년에 공식적으로 출시되었다. OpenID Foundation이 개발한 이 프로토콜은 인증(Authentication)에 중점을 두고, OAuth 2.0의 권한 부여(Authorization) 기능을 보완한다.
초기 웹에서는 각 서비스마다 독립적인 사용자 계정과 인증 시스템이 필요했다. 이러한 분산된 접근 방식은 사용자에게 불편함을 주고, 보안 위험을 증가시켰다. OpenID Connect는 이러한 문제를 해결하기 위해 등장했으며, 현재 Google, Microsoft, Facebook 등 주요 기술 기업들이 이 표준을 채택하고 있다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:28:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OpenID Connect" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/protocols/openid-connect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HTTP basic authentication</h2></header><div class=entry-content><p>HTTP basic authentication 기본 인증(Basic Authentication)은 웹 애플리케이션과 API에서 사용되는 가장 단순하고 오래된 HTTP 인증 방식 중 하나이다. 이 인증 방식은 1996년에 발표된 HTTP/1.0 명세의 일부로 처음 소개되었으며, 현재까지도 많은 시스템에서 활용되고 있다. 간단한 구조와 광범위한 지원으로 인해 여전히 중요한 인증 메커니즘으로 남아 있다.
기본 인증의 작동 원리 기본 인증은 매우 직관적인 프로세스를 따른다:
요청 시도: 클라이언트가 보호된 리소스에 접근을 시도한다.
인증 요구: 서버는 리소스가 보호되어 있음을 인식하고 상태 코드 401 (Unauthorized)와 함께 응답한다. 이 응답에는 다음과 같은 헤더가 포함된다.
...</p></div><footer class=entry-footer><span title='2025-03-11 13:01:00 +0000 UTC'>March 11, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HTTP basic authentication" href=https://buenhyden.github.io/posts/backend-development/backend-security/authentication-and-authorization/authentication-methods/http-basic-authentication/basic-authentication/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/17/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/19/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>