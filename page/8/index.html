<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAML (YAML Ain't Markup Language)</h2></header><div class=entry-content><p>YAML (YAML Ain’t Markup Language) 데이터를 구조화하고 표현하기 위한 간단한 문법을 가진 데이터 직렬화 언어
XML이나 JSON과 유사한 목적으로 사용되지만, 더 간결하고 사람이 읽기 쉽게 설계
특징 가독성: 들여쓰기를 사용하여 데이터의 계층 구조를 표현하며, 불필요한 괄호와 태그를 사용하지 않아 직관적이다. 구조적 표현: 들여쓰기를 기반으로 데이터의 계층을 표현한다. 다양한 자료형 지원: 문자열, 숫자, 리스트, 딕셔너리, 부울값 등 다양한 기본 자료형을 지원한다. 언어 독립적: 다양한 프로그래밍 언어에서 지원된다. JSON 호환성: JSON과 호환이 가능하며, JSON 형식의 데이터를 YAML로 변환할 수 있다. 장점 간결한 문법으로 가독성이 높다.
...</p></div><footer class=entry-footer><span title='2024-10-26 11:42:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1853 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAML (YAML Ain't Markup Language)" href=https://buenhyden.github.io/posts/data/format/yaml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터 교환 형식</h2></header><div class=entry-content><p>데이터 교환 형식 서로 다른 시스템이나 프로그램 간에 데이터를 주고받을 때 사용하는 표준화된 형식
중요성 상호운용성: 서로 다른 시스템 간의 원활한 통신을 가능하게 한다. 효율성: 데이터를 구조화하고 압축하여 전송 효율을 높인다. 확장성: 새로운 데이터 필드나 구조를 쉽게 추가할 수 있다. 표준화: 공통된 형식을 사용함으로써 개발 및 통합 과정을 단순화한다. 발전 방향 바이너리 형식의 증가: 더 빠른 처리와 작은 데이터 크기 요구 스키마 지원 강화: 데이터 유효성 검증의 중요성 증가 하이브리드 접근: 여러 형식의 장점을 결합한 새로운 형식 등장 실시간 처리 지원: 스트리밍 데이터 처리를 위한 최적화 종류 특성 JSON XML Protocol Buffers 가독성 높음 (중첩된 구조에서는 다소 복잡) 보통 (태그로 인해 장황) 낮음 (바이너리 형식) 파일 크기 보통 큼 (태그로 인한 오버헤드) 매우 작음 (바이너리 인코딩) 파싱 속도 빠름 느림 매우 빠름 데이터 검증 제한적 (스키마 없음) 가능 (XSD/DTD) 강력함 (스키마 필수) 언어 지원 거의 모든 언어 거의 모든 언어 주요 언어 지원 학습 곡선 낮음 보통 높음 주요 용도 웹 API, 설정 파일 문서 교환, SOAP API 마이크로서비스 통신, 대용량 데이터 데이터 타입 기본 타입만 지원 확장 가능한 타입 상세한 타입 시스템 스키마 정의 선택적 (JSON Schema) 가능 (XSD) 필수 (proto 파일) 버전 관리 제한적 가능 우수 (하위 호환성) 인코딩 텍스트 텍스트 바이너리 주석 지원 미지원 지원 proto 파일에서만 지원 에러 처리 파싱 에러만 감지 문법과 스키마 검증 컴파일 시점 타입 체크 보안 기본적인 보안 XML 보안 취약점 주의 높은 보안성 확장성 제한적 매우 높음 매우 높음 Json (JavaScript Object Notation) Javascript 객체 문법으로 구조화된 데이터를 표현하기 위한 문자 기반의 표준 포맷.
프로그래밍 언어와 플랫폼에 독립적이며, 데이터를 저장하고 전송하는 데 널리 사용된다.
사람이 읽고 쓰기 쉽고 기계가 파싱(해석)하고 생성하기 쉽게 고안되었다.
JavaScript에서 객체를 표현하는 방식에서 파생되었지만, 현재는 언어 독립적인 텍스트 형식으로 발전.
...</p></div><footer class=entry-footer><span title='2024-10-26 11:42:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2458 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터 교환 형식" href=https://buenhyden.github.io/posts/data/format/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%90%ED%99%98-%ED%98%95%EC%8B%9D/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Encoding and Decoding</h2></header><div class=entry-content><p>인코딩 (Encoding)과 디코딩 (Decoding) 인코딩과 디코딩은 데이터를 변환하고 처리하는 데 중요한 역할을 한다.
이 두 과정은 서로 반대되는 개념으로, 데이터의 효율적인 저장, 전송, 처리를 가능하게 한다.
인코딩(Encoding)은 데이터를 특정 형식으로 변환하는 과정.
예를 들어, 우리가 사용하는 텍스트를 컴퓨터가 이해할 수 있는 이진 데이터로 변환하거나, 특수문자가 포함된 문자열을 웹에서 안전하게 전송할 수 있는 형식으로 변환하는 것을 말한다.
디코딩(Decoding)은 인코딩의 반대 과정으로, 변환된 데이터를 원래의 형식으로 되돌리는 과정이다.
예를 들어, 이진 데이터를 다시 사람이 읽을 수 있는 텍스트로 변환하는 것.
...</p></div><footer class=entry-footer><span title='2024-10-26 07:05:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;519 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Encoding and Decoding" href=https://buenhyden.github.io/posts/data/encoding-and-decoding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Blocking vs Non-Blocking</h2></header><div class=entry-content><p>Blocking and Non-Blocking Blocking과 Non-Blocking은 프로그램의 제어 흐름을 다루는 두 가지 주요 방식이다.
이 개념들은 I/O 작업, 프로세스 간 통신, 네트워크 통신 등 다양한 컴퓨팅 상황에서 중요한 역할을 한다.
Blocking과 Non-Blocking의 주요 차이점은 제어권의 반환 시점이다.
Blocking은 작업이 완료될 때까지 제어권을 반환하지 않지만, Non-Blocking은 즉시 제어권을 반환한다.
Blocking Blocking은 특정 작업이 완료될 때까지 프로그램의 제어권을 붙잡고 있는 상태를 의미한다.
해당 작업이 완료되기 전까지는 다음 작업으로 진행할 수 없다.
동작 방식 프로세스가 특정 작업을 요청한다. 해당 작업이 완료될 때까지 프로세스는 대기 상태에 들어간다. 작업이 완료되면 프로세스는 다시 실행 상태로 전환된다. 그동안 다른 작업은 수행될 수 없다. 특징 프로그램의 실행 흐름이 순차적이고 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 응답을 즉시 받을 수 있다. 프로그램 구조가 단순하고 직관적이다. 실제 예시 1 2 3 4 5 6 // Blocking I/O의 예시 File file = new File("example.txt"); FileInputStream input = new FileInputStream(file); byte[] buffer = new byte[1024]; int bytesRead = input.read(buffer); // 이 지점에서 Blocking 발생 // 파일 읽기가 완료될 때까지 다음 코드로 진행하지 않음 성능 측면 단일 작업의 처리 시간이 예측 가능하다. 리소스 사용이 일시적으로 중단된다. 대기 시간이 발생한다. 구현 복잡도 구현이 단순하다. 디버깅이 쉽다. 코드 흐름이 직관적이다. 적합한 사례 간단한 스크립트 작성 순차적 데이터 처리 즉각적인 응답이 필요한 경우 작은 규모의 애플리케이션 Non-Blocking Non-Blocking은 작업의 완료 여부와 관계없이 프로그램이 계속 실행될 수 있는 상태를 의미한다.
작업의 완료를 기다리는 동안에도 다른 작업을 수행할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-06 12:36:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;801 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blocking vs Non-Blocking" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/blocking-vs-non-blocking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Memoization vs Tabulation</h2></header><div class=entry-content><p>Memoization Vs Tabulation Memoization과 Tabulation은 동적 프로그래밍(Dynamic Programming)에서 사용되는 두 가지 주요 최적화 기법이다.
Memoization(메모이제이션)은 “하향식(Top-down)” 접근 방식이다.
이는 재귀적으로 문제를 해결하면서, 계산된 결과를 캐시(보통 배열이나 해시 맵)에 저장하여 나중에 같은 입력이 들어왔을 때 재계산하지 않고 저장된 결과를 반환하는 방식이다.
Tabulation(타뷸레이션)은 “상향식(Bottom-up)” 접근 방식이다.
가장 작은 하위 문제부터 시작하여 더 큰 문제의 해답을 테이블에 순차적으로 채워나가는 방식이다.
특성 Tabulation Memoization 접근 방식 Bottom-up (상향식) Top-down (하향식) 구현 방법 반복문 (Iterative) 재귀 (Recursive) 메모리 사용 문제 크기만큼 고정 필요한 만큼 동적 할당 실행 순서 순차적으로 모든 하위 문제 해결 필요한 하위 문제만 해결 공간 효율성 예측 가능하고 일정함 재귀 호출로 인한 스택 공간 필요 시간 효율성 모든 경우를 계산 필요한 경우만 계산 코드 복잡도 일반적으로 더 단순 일반적으로 더 복잡 캐시 활용 배열/테이블 형태 해시 테이블/맵 형태 구현 예시 비교 피보나치 수열 계산의 경우 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Tabulation 방식 def fib_tabulation(n): # 테이블 초기화 table = [0] * (n + 1) table[1] = 1 # 순차적으로 값 채우기 for i in range(2, n + 1): table[i] = table[i-1] + table[i-2] return table[n] # Memoization 방식 def fib_memoization(n, memo={}): # 이미 계산된 값이면 반환 if n in memo: return memo[n] # 기본 케이스 if n &lt;= 1: return n # 결과 저장 및 반환 memo[n] = fib_memoization(n-1, memo) + fib_memoization(n-2, memo) return memo[n] 세부 특성 Tabulation Memoization 적합한 상황 모든 하위 문제의 결과가 필요한 경우 일부 하위 문제의 결과만 필요한 경우 디버깅 난이도 상대적으로 쉬움 재귀로 인해 더 어려움 최적화 가능성 공간 최적화 쉬움 재귀 깊이 제한으로 인한 제약 병렬화 가능성 쉬움 (독립적인 계산) 어려움 (의존성 있는 호출) 초기화 오버헤드 더 큼 (전체 테이블) 더 작음 (필요시 할당) 메모리 예측성 높음 낮음 (실행 중 변동) 성능 특성 Tabulation Memoization 시간 복잡도 O(n) - 모든 경우 O(n) - 최악의 경우 공간 복잡도 O(n) - 테이블 크기 O(n) - 캐시 + 스택 캐시 적중률 100% (모든 값 계산) 상황에 따라 다름 초기 지연 시간 더 김 (테이블 초기화) 더 짧음 (즉시 시작) 메모리 사용량 예측 가능 변동적 이러한 차이점을 이해하고 상황에 맞는 적절한 방법을 선택하는 것이 중요하다.
일반적으로:
...</p></div><footer class=entry-footer><span title='2024-10-13 11:25:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;389 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memoization vs Tabulation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/memoization-vs-tabulation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Interface vs Abstract class</h2></header><div class=entry-content><p>Interface Vs Abstract Class 인터페이스는 클래스가 ‘무엇을 해야 하는지’를 정의하는 계약(contract)과 같은 역할을 한다.
모든 메서드가 추상 메서드로 이루어져 있으며, 구현부가 없는 메서드 선언만을 포함한다.
이는 마치 설계 명세서와 같아서, 클래스가 반드시 구현해야 하는 기능들을 정의한다.
추상 클래스(Abstract Class)는 하나 이상의 추상 메서드를 포함하는 클래스이다.
일반 메서드와 추상 메서드를 모두 가질 수 있으며, 관련된 클래스들의 공통적인 특성과 행위를 정의한다. 이는 마치 미완성된 설계도와 같아서, 기본적인 구조는 제공하지만 일부 세부사항은 하위 클래스에서 완성해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 05:39:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;419 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interface vs Abstract class" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/interface-vs-abstract-class/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process vs Thread vs Coroutine</h2></header><div class=entry-content><p>Process Vs Thread Vs Coroutine Process, Thread, Coroutine은 모두 프로그램 실행의 단위이지만, 각각 다른 특성과 용도를 가지고 있다.
Process:
독립적인 실행 단위로, 자체 메모리 공간과 시스템 자원을 가진다. 다른 프로세스와 완전히 격리되어 있어 안정성이 높다. 생성과 전환에 많은 비용이 든다. Thread:
프로세스 내부의 실행 단위로, 같은 프로세스의 다른 스레드와 메모리를 공유한다. 프로세스보다 가볍고, 생성과 전환 비용이 적다. 동시성을 제공하지만, 동기화 문제에 주의해야 한다. Coroutine:
경량 스레드라고도 불리며, 스레드 내에서 실행되는 협력적 멀티태스킹 단위. 매우 가볍고, 생성과 전환 비용이 매우 적다. 비동기 프로그래밍을 단순화하고, 동시성을 효율적으로 관리한다. Process, Thread, Coroutine의 관계는 다음과 같이 계층적으로 표현할 수 있다:
CPU > Core > Process > Thread > Coroutine
...</p></div><footer class=entry-footer><span title='2024-10-06 08:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process vs Thread vs Coroutine" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/process-vs-thread-vs-coroutine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Poetry vs uv vs Rye</h2></header><div class=entry-content><p>Poetry Vs Uv Vs Rye Poetry, uv, Rye는 모두 파이썬 프로젝트 관리와 패키지 설치를 위한 도구들이다.
각각의 도구는 고유한 특징과 장단점을 가지고 있어 개발자들의 다양한 요구사항을 충족시키고 있다.
Poetry는 파이썬 프로젝트의 의존성 관리와 패키징을 위한 도구로, 2018년에 출시되었다.
주요 특징으로는 의존성 해결, 가상 환경 관리, 프로젝트 패키징 등이 있다.
uv는 Rust로 작성된 초고속 파이썬 패키지 설치 및 의존성 해결 도구이다. pip와 pip-tools의 대체제로 설계되었으며, 속도와 효율성에 중점을 두고 있다.
Rye는 Flask의 개발자인 Armin Ronacher가 개발한 올인원 파이썬 프로젝트 관리 도구이다.
파이썬 버전 관리, 의존성 관리, 가상 환경 생성 등 다양한 기능을 제공한다.
Poetry, uv, Rye에 대한 비교를 요청하신 카테고리별로 표로 정리했습니다. 각 도구의 특징을 비교하여 살펴볼 수 있도록 구성했습니다.
...</p></div><footer class=entry-footer><span title='2024-11-27 06:41:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;577 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Poetry vs uv vs Rye" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry-vs-uv-vs-rye/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux Basic Command</h2></header><div class=entry-content><p>Linux Command Command Description 1 pwd 현재 위치 출력 2 ls 현재 디렉터리 내의 파일과 디렉터리 출력 3 cd 디렉터리 이동 4 mkdir 디렉터리 생성 5 cp 파일 또는 디렉터리 복사 6 mv 파일 또는 디렉터리 이동 7 rm 파일 또는 디렉터리 삭제 8 cat 파일 내용을 확인 9 touch 빈 파일을 생성 10 echo 문자열 화면에 표시 11 ip addr/ifconfig IP 정보 확인 12 ss 네트워크 상태 확인 13 nc 서버의 포트 확인 14 which, whereis, locate 명령어 위치 확인 15 tail 파일의 마지막 부분 확인하기 16 find 파일이나 디렉터리 찾기 17 ps 현재 실행 중인 프로세스 목록과 상태 확인 18 grep 주어진 입력값에서 패턴에 맞는 값 출력 19 kill 프로세스 종료 20 alias 명령어 별칭 만들기 21 vi / vim 편집기 Pwd work directory의 약자로 작업 중인 디렉터리를 보여줌 1 2 $ pwd /Users/hyden Ls list segments의 약자로 현재 디렉터리의 파일과 디렉터리를 보여준다. 보통 단독으로 잘 사용하지 않고 a,l 등의 옵션과 함께 사용 Option Description ls -l 파일들의 상세 정보를 보여줌 ls -a 숨김 파일 표시 ls -t 최신 파일부터 표시 ls -rt 오래된 파일부터 표시 ls -F 파일을 표시할 때 파일의 타입을 나타내는 문자열을 표시(/ 디렉터리, * 실행파일, @심볼릭 링크) ls -R 하위 디렉터리의 내용까지 표시 보통은 위 옵셥들을 조합해 ls -al, ls -alt, ls -altF 등으로 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 $ ls -altF total 95340 drwxr-x--- 28 hyden hyden 4096 Oct 29 12:34 ./ -rw------- 1 hyden hyden 326035 Oct 29 12:34 .zsh_history drwx------ 8 hyden hyden 4096 Oct 29 12:34 .cache/ -rw------- 1 hyden hyden 33 Oct 27 16:40 .lesshst -rw------- 1 hyden hyden 25052 Oct 27 16:39 .bash_history -rw------- 1 hyden hyden 38160 Oct 27 16:32 .viminfo drwx------ 6 hyden hyden 4096 Oct 27 15:50 .config/ drwx------ 2 hyden hyden 4096 Oct 27 15:36 .ssh/ -rw-rw-r-- 1 hyden hyden 287 Oct 27 13:34 .wget-hsts -r--r--r-- 1 hyden hyden 117120 Oct 27 12:31 .zcompdump-devserver-5.8.1.zwc -rw-rw-r-- 1 hyden hyden 50720 Oct 27 12:31 .zcompdump-devserver-5.8.1 -rw-rw-r-- 1 hyden hyden 49203 Oct 27 12:31 .zcompdump drwxr-x--- 6 hyden hyden 4096 Oct 26 16:20 istio-1.18.2/ drwxr-xr-x 12 hyden hyden 4096 Oct 26 14:30 .oh-my-zsh/ -rw-r--r-- 1 hyden hyden 4789 Oct 26 14:30 .zshrc drwxr-xr-x 9 hyden hyden 4096 Oct 23 13:01 .minikube/ -rw-r--r-- 1 hyden hyden 3919 Oct 20 17:47 .bashrc -rw------- 1 hyden hyden 2313 Oct 5 12:49 kubeconfig.yaml drwxrwxr-x 2 hyden hyden 4096 Sep 19 12:52 lang_test/ drwxrwxr-x 2 hyden hyden 4096 Sep 18 20:27 .ncloud/ drwxr-xr-x 5 hyden hyden 4096 Sep 11 19:06 pybind11/ drwxrwxr-x 2 hyden hyden 4096 Sep 8 16:25 data/ -rw------- 1 hyden hyden 151 Sep 8 15:59 .python_history -rw-rw-r-- 1 hyden hyden 1452216 Sep 7 18:59 libboost_regex.so.1.58.0 drwxrwxr-x 2 hyden hyden 4096 Sep 6 14:35 test/ drwxrwxr-x 4 hyden hyden 4096 Sep 6 14:28 ffmpeg/ drwxrwxr-x 2 hyden hyden 4096 Aug 30 16:00 dockerbuild/ drwxr-xr-x 8 root root 4096 Aug 30 10:50 ../ -rw-rw-r-- 1 hyden hyden 435 Aug 3 17:05 default-user-config.yaml drwxr-x--- 3 hyden hyden 4096 Aug 3 15:30 .kube/ drwxrwxr-x 5 hyden hyden 4096 Aug 3 14:47 manage_kubernetes/ -rw-rw-r-- 1 hyden hyden 84 Aug 2 18:54 .bash_profile -rw-rw-r-- 1 hyden hyden 508 Aug 2 18:53 ncp-iam-authenticator.sha256 -rwxrwxr-x 1 hyden hyden 11665408 Aug 2 18:53 ncp-iam-authenticator* -rwx------ 1 hyden hyden 11345 Aug 2 10:13 get_helm.sh* 심볼릭 링크(symbolic link): 원본 파일을 가리키도록 링크만 연결. 윈도우의 바로가기 링크와 같은 개념 Cd change directory의 약자로 디렉터리 이동시 사용하는 명령어 Option Description cd ~ 홈 디렉터리로 이동 cd.. 상위 디렉터리로 이동. cd../../ 같은 식으로 여러 단계를 한 번에 이동 가능 cd /dir 절대 경로를 지정해 이동 가능 cd - 바로 전의 디렉터리로 이동 Mkdir make directory의 약자로 디렉터리를 만들 때 사용 1 2 # &lt;이름>의 디렉터리를 현재 디렉터리에 만든다 $ mkdir &lt;이름> 절대 경로를 지정하여 만들 수도 있다. 1 2 # &lt;이름>의 디렉터리를 절대 경로의 디렉터리에 만든다 $ mkdir /home/hyden/&lt;이름> -p 옵션으로 하위 디렉터리까지 한 번에 생성할 수 있다 1 mkdir -p &lt;디렉터리명>/&lt;하위 디렉터리명> Cp copy의 약자로 파일 또는 디렉터리를 복사할 때 사용 1 2 3 4 5 6 7 8 # source를 target으로 복사 $ cp source target # target 파일의 이미 있는 경우 덮어쓰기 $ cp -f source target # 디렉터리를 복사할 때 사용. 하위 디렉터리도 모두 복사하기 $ cp -R sourceDir targetDir Mv move의 약자로 파일 또는 디렉터리의 위치를 옮길 때 사용. 혹은 이름을 변경할 때도 사용 1 2 3 4 5 6 7 8 # afile 이름을 bfile로 변경 $ mv afile bfile # afile을 상위 디렉터리로 옮김 $ mv afile ../ # afile을 /opt 이하 디렉터리로 옮김 $ mv afile /opt/ Rm remove의 약자로 파일 또는 디렉터리를 삭제할 때 사용 1 2 3 4 5 6 7 8 9 10 11 # afile을 삭제 $ rm afile # 디렉터리 adir을 삭제. 삭제 시 확인을 함 $ rm -r adir # 디렉터리 adir을 삭제. 삭제 시 확인 안 함 $ rm -rf adir # txt로 끝나는 모든 파일을 삭제할지 물어보면서 삭제 $ rm -i *.txt Cat catenate의 약자로 파일의 내용을 확인할 때 사용. 1 2 # test.txt 파일의 내용을 확인 $ cat test.txt Touch touch는 빈 파일을 생성. 혹은 파일의 날짜와 시간을 수정할 때 사용한다. 1 2 3 4 5 6 7 8 # afile을 생성 $ touch afile # afile의 시간을 현재 시간으로 갱신 $ touch -c afile # bfile의 날짜 정보를 afile의 정보와 동일하게 변경 $ touch -r afile bfile Echo echo는 어떤 문자열을 화면에 보여줄 때 사용. echo와 리다이렉션을 사용해 파일을 생성, 추가하는 작업을 많이 한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # helloworld 출력 $ echo 'helloworld' # 패스로 지정된 문자열을 출력 $ echo $PATH # 이스케이프 문자열을 해석 $ echo -e 문자열 # 개행을 표시할 수 있음 $ echo -e "안녕하세요\n이렇게 하면\n새 줄이생겨요" # ls와 유사하게 현재 디렉터리의 파일과 폴더를 출력 $ echo * # 리다이렉션 '>'을 사용해 hello.txt 파일 생성. 파일 내용에는 echo로 표시되는 내용이 들어감 $ echo hello redirection > hello.txt # 추가 연산자 >>를 사용해 기존 파일에 문자열 추가 $ echo hello2 >> hello.txt Ip addr/ifconfig 접속한 리눅스의 IP 정보를 알아낼 때 사용. 1 2 3 4 5 6 7 8 9 10 11 $ ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 50000 link/ether fa:16:3e:5d:0b:d7 brd ff:ff:ff:ff:ff:ff inet 10.201.1.10/16 brd 10.202.255.255 scope global eth0 valid_lft forever preferred_lft forever ip addr이 설치되어 있지 않은 경우에는 ifconfig를 사용. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ ifconfig eth0 Link encap:Ethernet HWaddr 06:4d:de:ae:a8:50 inet addr:172.31.27.212 Bcast:172.31.31.255 Mask:255.255.240.0 inet6 addr: fe80::44d:deff:feae:a850/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:9001 Metric:1 RX packets:68903966 errors:0 dropped:0 overruns:0 frame:0 TX packets:75295223 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:15691124260 (15.6 GB) TX bytes:42265387295 (42.2 GB) lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 inet6 addr: ::1/128 Scope:Host UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:6623596 errors:0 dropped:0 overruns:0 frame:0 TX packets:6623596 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:349206971 (349.2 MB) TX bytes:349206971 (349.2 MB) Ss socket statistics의 약자로 네트워크 상태를 확인하는 데 사용. nestat과 동일. 옵션으로 a, t, u, l, p, n 등이 있다. Option Description ss -a 모든 포트 확인 ss -t TCP 포트 확인 ss -u UDP 포트 확인 ss -l LISTEN 상태 포트 확인 ss -p 프로세스 표시 ss -n 호스트, 포트, 사용자명을 숫자로 표시 TCP 포트 중 LISTEN 상태인 포트의 번호를 알고 싶을 때 다음과 같이. 1 2 3 4 $ ss -tln LISTEN 0 511 *:443 *:* LISTEN 0 1 127.0.0.1:8006 *:* LISTEN 0 511 *:80 *:* Nc netcat의 약자로 예전에는 포트가 열렸는지 확인하는 데 사용. 1 2 3 4 5 6 7 8 # 포트가 오픈됐는지 확인 $ nc IP주소 포트 # 더 자세한 정보가 남음 $ nc -v IP주소 포트 # 현재 서버의 포트를 오픈(방화벽에 해당 포트 번호가 설정 함) $ nc -l 포트 Which, Whereis, Locate which는 특정 명령어의 위치를 찾아줌. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ which git /usr/local/bin/git # which -a : 검색 가능한 모든 경로에서 명령어를 찾아준다. $ which -a git /usr/local/bin/git /usr/bin/git # where : which -a와 같다. $ where git /usr/local/bin/git /usr/bin/git # whereis는 실행 파일, 소스, man 페이지의 파일을 찾아준다. $ whereis ssh ssh: /usr/bin/ssh /usr/share/man/man1/ssh.1 # locate는 파일명을 패턴으로 빠르게 찾아준다. # 아래 예제는 .java 파일을 찾아주는 명령. $ locate *.java Tail tail은 파일의 마지막 부분을 보여준다. 이와 반대로 head는 파일의 첫 부분을 보여준다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 파일의 마지막 라인부터 숫자만큼의 파일의 라인 수를 보여주기 $ tail -n {숫자} {파일경로} # 숫자로 지정한 라인부터 보여주기 $ tail -n +{숫자} {파일경로} # 파일의 마지막 라인부터 숫자로 지정한 바이트 수 만큼 보여주기 $ tail -c {숫자} {파일경로} # Ctrl + C로 중단하기 전까지 지정한 파일의 마지막에 라인이 추가되면 계속 출력하기 $ tail -f {파일경로} : # 파일의 마지막 라인부터 지정한 숫자만큼을 # {초}로 지정한 시간이 지날 때마다 리프레시해서 보여주기 $ tail -n {숫자} -s {초} -f {파일경로} Find find는 명령어의 뜻 그대로 파일이나 디렉터리를 찾는 데 사용하는 명령어. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 확장자 명으로 찾기 $ find {디렉터리} -name '*.bak' # 디렉터리를 지정해 찾기 $ find {디렉터리} -path '**/검색 시 사용하는 디렉터리명/**.*.js' # 파일명을 패턴으로 찾기 $ find {디렉터리} -name '*패턴*' # 파일명을 패턴으로 찾되 특정 경로는 제외하기 $ find {디렉터리} -name '*.py' -not -path '*/site-packates/*' # 파일을 찾은 다음 명령어 실행하기 $ find {디렉터리} -name '*.ext' -exec wc -l {} \; # 최근 7일간 수정된 파일을 찾고 삭제하기 $ find {디렉터리} -daystart -mtime -7 -delete # 0바이트인 파일을 찾고 삭제하기 $ find {디렉터리} -type f -empty -delete Ps 현재 실행 중인 프로세스 목록과 상태를 보여준다. 1 2 3 4 5 6 7 8 9 10 11 # 실행 중인 모든 프로세스를 보여주기 $ ps aux # 실행 중인 모든 프로세스를 전체 커맨드를 포함해 보여주기 $ ps auxww # 특정 문자열과 매칭되는 프로세스 찾기(grep은 바로 다음에 나옵니다) $ ps aus | grep {패턴} # 메모리 사용량에 따라 정렬하기 $ ps --sort size ps와 grep을 pipe로 사용하여 현재 실행 중인 프로세스 목록중 특정 명칭을 포함하는 프로세스를 찾는 식으로 사용하기도 한다. Grep grep은 입력에서 패턴에 매칭되는 내용을 찾는 명령어. grep이라는 이름은 ed의 명령어인 g/re/p(내용 전체를 정규식으로 찾은 다음 프린트하라: globally search for a regular expression and print matching lines)에서 왔음. 보통 find, ps 등과 조합해 사용. 1 2 3 4 5 6 7 8 9 10 11 # 파일에서 특정 패턴을 만족하는 부분 찾기 $ grep "패턴" 파일경로 # 파일명과 라인을 함께 표시하기 $ grep --with-filename --line-number "패턴" 파일경로 # 매칭하지 않는 부분 표시하기 $ grep --invert-match "패턴" # cat과 함께 사용하기 $ cat 파일경로 | grep "패턴" Kill 프로세스를 죽이는 명령어 프로세스를 죽인다고는 하지만 원리는 프로세스에 중지하라는 시그널을 보내는 것 SIGKILL, SIGSTOP은 강제 종료이며 나머지는 정상적으로 종료. 프로세스 아이디는 ps 명령어로 알아낼 수 있다. 1 2 3 4 5 6 7 8 9 10 11 # kill에서 사용할 수 있는 시그널 표시하기 $ kill -l # 프로세스 죽이기 SIGTERM(terminate) $ kill 프로세스ID # 백그라운드 잡 종료시키기 $ kill {잡ID} # 프로세스 강제 종료 $ kill -9 | KILL 프로세스ID Alias alias를 사용하면 줄여서 사용할 수 있다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 모든 alias 표시하기 $ alias # alias 만들기 # 예) alias ll="ls -al" $ alias 단어="명령" # cd ../..을 cd …으로 줄여 쓰기 # cd ../../../은 cd ….으로 가능 $ alias ...=../.. $ alias ....=../../.. $ alias .....=../../../.. $ alias ......=../../../../.. # alias 삭제하기 $ unalias 단어 Vi / Vim vi 혹은 vim은 대부분의 리눅스에 기본적으로 설치되어 있는 텍스트 에디터 1 vi test.txt 참고 및 출처 백엔드 개발자라면 알아야 할 리눅스 필수 명령어 21개
...</p></div><footer class=entry-footer><span title='2024-10-01 15:39:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;1993 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linux Basic Command" href=https://buenhyden.github.io/posts/computer-science/computer-system/computer-architecture/operating-system/types/linux/linux-basic-command/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux Permission</h2></header><div class=entry-content><p>Linux Permission Source: https://medium.com/@usamashafique00786/day-4-task-linux-permissions-and-access-control-lists-ef59cebf9324
File type: 파일 유형 type Description - normal file d directory l link p named pipe s socket c character device b block device Permissions: 각 파일에 접근해서 읽거나 쓰거나 실행할 권리를 갖는 소유자 / 그룹 / 다른 사용자로 나눠서 관리
Source: https://pamirwebhost.com/check-linux-file-permissions-with-ls/
Permission은 3개로 나눠서 관리 Description User 파일을 만든 소유주 Group 파일을 만든 소유주가 속한 그룹 Other 기타 사용자 Permission은 4가지에 대하여 구분 Permission 파일 디렉토리 r 파일에 대한 읽기 권한.열기, 읽기 허용 디렉토리 내의 파일을 나열할 수 있게 허용 w 파일에 대한 쓰기 권한.쓰기, 잘라내기 허용.이름 변경이나 파일 삭제 허용되지 않음. 파일 삭제나 파일 이름 변경 디렉토리 속성에 의해 결정 디렉토리 내의 파일들을 생성, 삭제, 이름 변경이 가능하도록 허용 x 파일에 대한 실행 권한.파일이 프로그램으로 처리되고 파일이 실행되도록 허용.스크립트 언어에서 작성된 프로그램 파일들은 읽기 가능으로 설정 되어 있어야만 실행 가능 디렉토리 내에서 탐색을 위해 이동할 수 있도록 허용(디렉토리에 들어올 수 있도록 허용) - r,w,x에 대한 권한이 없음을 표시 r,w,x에 대한 권한이 없음을 표시 Permission
Source: https://medium.com/@gumbershruti1119/day-6-file-permissions-and-access-control-lists-2126f994a5b8
...</p></div><footer class=entry-footer><span title='2024-10-01 15:39:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;220 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linux Permission" href=https://buenhyden.github.io/posts/computer-science/computer-system/computer-architecture/operating-system/types/linux/linux-permission/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>