<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>부동 소수점 (Float)</h2></header><div class=entry-content><p>부동 소수점 (Float) 부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.
‘부동’은 소수점이 움직인다는 의미로, 넓은 범위의 실수를 표현할 수 있다.
특징 IEEE 754 표준을 따름 부호, 지수, 가수 부분으로 구성 IEEE 754 표준에 따른 부동 소수점 종류 Half Precision
이 형식은 가장 작은 부동 소수점 표현 방식.
16비트를 사용한다.
1비트는 부호, 5비트는 지수부, 10비트는 가수부로 구성된다.
주로 그래픽스나 머신러닝에서 메모리를 절약하기 위해 사용된다.
약 3자리의 십진 정밀도를 제공하며, ±6.1 × 10⁻⁵에서 ±6.5 × 10⁴까지의 범위를 표현할 수 있다.
예시:
Python: 1 2 3 import numpy as np x = np.float16(3.14) print(x) # 3.14 JavaScript: JavaScript는 기본적으로 Half Precision을 지원하지 않는다. 외부 라이브러리를 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부동 소수점 (Float)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/float/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Trunk-based Development</h2></header><div class=entry-content><p>Trunk-based Development Trunk-based Development(TBD)는 모든 개발자가 단일 메인 브랜치(trunk)에 작고 빈번한 변경사항을 직접 통합하는 버전 관리 방법론이다. 이는 지속적 통합(CI)과 지속적 배포(CD)의 필수 전제조건으로, 현대 DevOps 환경에서 가장 효율적인 브랜치 전략으로 인정받고 있다. 긴 수명의 기능 브랜치 대신 짧은 수명의 브랜치나 직접 커밋을 통해 코드 통합의 마찰을 최소화하고, 항상 배포 가능한 상태의 코드베이스를 유지하는 것이 핵심이다.
핵심 개념 Trunk-based Development의 핵심 개념은 다음과 같다:
단일 메인 브랜치: 모든 개발이 하나의 trunk(main/master) 브랜치에 집중 작고 빈번한 커밋: 작업을 작은 단위로 나누어 자주 통합 짧은 수명의 브랜치: 필요한 경우 최대 1-2일 이내의 피처 브랜치 사용 지속적 통합: 하루에 여러 번 코드 통합 및 자동화된 테스트 항상 릴리스 가능한 상태: trunk는 언제나 프로덕션 배포가 가능한 상태 유지 피처 플래그: 미완성 기능을 main에 통합하되 런타임에 비활성화 graph TD main[main 브랜치] -->|분기| feature[feature/기능] feature -->|풀 리퀘스트| main main -->|자동 배포| Production 목적 코드 통합의 복잡성과 병합 충돌 최소화 개발 및 배포 속도 극대화 지속적 통합/배포(CI/CD) 실현 팀 협업 효율성 향상 코드베이스의 일관성과 품질 유지 빠른 피드백 사이클 구현 필요성 현대 DevOps 및 애자일 개발 방법론의 요구사항 충족 마이크로서비스 아키텍처에서의 빠른 배포 필요 대규모 개발팀의 효율적인 협업 지원 병합 지옥(merge hell) 방지 지속적 배포를 통한 경쟁력 확보 고품질 소프트웨어의 빠른 출시 요구 역할 개발 프로세스 단순화: 복잡한 브랜치 모델 제거 배포 주기 가속화: 빠른 릴리스 사이클 지원 품질 보증: 지속적인 테스트를 통한 품질 유지 팀 협업 강화: 코드 리뷰와 페어 프로그래밍 촉진 기술 부채 방지: 장기 브랜치로 인한 기술 부채 최소화 특징 브랜치 최소화 통합의 빈도 극대화 Feature Toggle 사용 권장 Conflict를 예방하는 설계 주요 기능 직접 trunk 커밋: 소규모 팀의 경우 trunk에 직접 커밋 Pull Request 워크플로우: 코드 리뷰를 위한 짧은 수명의 브랜치 자동화된 테스트: 모든 커밋에 대한 자동 테스트 실행 피처 플래그: 기능의 점진적 롤아웃 지원 지속적 통합: 자동화된 빌드 및 테스트 파이프라인 브랜치별 CI: PR/브랜치 단위 자동화 검증 주요 원리 Trunk-based Development의 주요 원리는 다음 다이어그램으로 표현할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trunk-based Development" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/git-workflow/branch-strategies/trunk-based-development/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Snapshot vs. Delta</h2></header><div class=entry-content><p>Snapshot vs. Delta 스냅샷(Snapshot)과 델타(Delta)는 데이터 변화를 관리하는 두 가지 근본적인 접근 방식이다.
스냅샷: 특정 시점의 전체 시스템 상태를 저장한다. Git이 대표적으로, 각 커밋 시 프로젝트 전체의 파일 상태를 기록한다. 델타: 이전 버전 대비 변경된 부분만 저장한다. SVN, CVS 등 전통적 VCS에서 사용되며, 저장 공간 효율성이 장점이다. 이 두 방식은 저장 효율성, 성능, 복구 속도에서 차이를 보이며, 현대 시스템에서는 버전 관리 시스템(Git, SVN 등), 백업 솔루션, 데이터베이스 시스템 등 여러 컴퓨팅 분야에서 중요하게 사용된다. 또한, 두 방식의 혼합하여 사용하는 하이브리드 접근법(예: Git의 git gc를 통한 델타 압축)도 활용된다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:01:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Snapshot vs. Delta" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/vcs-theory/snapshot-vs-delta/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Submodule</h2></header><div class=entry-content><p>Git Submodule Git Submodule 은 하나의 Git 저장소 안에 또 다른 Git 저장소를 포함시킬 수 있도록 하는 기능이다. 이는 외부 라이브러리, 공통 모듈, 또는 서드파티 코드 등을 독립적으로 유지하며 주 저장소와 연동하여 사용하는 데 활용된다.
서브모듈은 특정 커밋을 참조하는 방식으로 작동하며, 주 저장소 (부모 저장소) 와 서브모듈 저장소 (자식 저장소) 간의 명확한 경계를 유지한다.
복잡한 프로젝트 구조에서 모듈화를 실현하고, 공통 코드의 버전 동기화 및 유지관리를 용이하게 한다.
핵심 개념 Git Submodule은 한 Git 저장소 (부모 저장소) 내에 다른 Git 저장소 (자식 저장소) 를 현재 저장소의 하위 디렉토리로 포함시키는 방식이다. 서브모듈은 다른 외부 저장소의 특정 커밋을 가리키는 주 저장소 내의 기록이다. 서브모듈은 매우 정적이며 특정 커밋만 추적한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;22 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Submodule" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/deployment-technologies/version-control-systems/git-workflow/git-submodule/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3. 설계 (Design)</h2></header><div class=entry-content><p>설계 (Design) 요구사항을 바탕으로 시스템의 구조와 세부 사항을 설계하는 단계
아키텍처 설계 주요 목적 시스템의 전체적인 구조와 주요 컴포넌트를 정의한다. 시스템의 품질 속성(성능, 보안, 확장성 등)을 만족시키는 구조를 설계한다. 개발 팀에게 시스템 구현을 위한 청사진을 제공한다. 시스템의 복잡성을 관리하고 모듈화를 촉진한다. 향후 변경과 확장에 대비한 유연한 구조를 제공한다. 기술적 제약사항과 비즈니스 요구사항 간의 균형을 맞춘다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 분석 아키텍처에 영향을 미치는 주요 요구사항 식별 아키텍처 관련 요구사항 문서 아키텍처 패턴 선택 시스템에 적합한 아키텍처 패턴 결정 (예: 마이크로서비스, 레이어드 등) 아키텍처 패턴 결정 문서 시스템 분해 주요 컴포넌트 및 모듈 식별 시스템 컴포넌트 다이어그램 인터페이스 정의 컴포넌트 간 인터페이스 설계 인터페이스 명세서 데이터 아키텍처 설계 데이터 저장 및 흐름 구조 설계 데이터 아키텍처 다이어그램 기술 스택 선정 사용할 기술 및 프레임워크 결정 기술 스택 문서 성능 및 확장성 고려 성능 요구사항을 만족시키는 아키텍처 설계 성능 모델 및 확장성 계획 보안 아키텍처 설계 보안 요구사항을 반영한 아키텍처 설계 보안 아키텍처 문서 아키텍처 문서화 설계 결정사항 및 근거 문서화 아키텍처 설계 문서 아키텍처 검토 이해관계자와 함께 아키텍처 검토 아키텍처 검토 보고서 주의해야할 요소 주의 요소 설명 확장성 미래의 성장과 변화에 대응할 수 있는 유연한 구조 설계 성능 시스템의 응답 시간, 처리량 등 성능 요구사항 충족 보안 데이터 보호, 인증, 권한 부여 등 보안 측면 고려 유지보수성 쉬운 유지보수와 업데이트를 위한 모듈화 설계 기술 제약 조직의 기술적 역량과 제약사항 고려 비용 구현 및 운영 비용을 고려한 아키텍처 설계 통합성 외부 시스템과의 통합 용이성 고려 표준 준수 산업 표준 및 모범 사례 준수 복잡성 관리 과도한 복잡성을 피하고 이해하기 쉬운 구조 설계 테스트 용이성 효과적인 테스트가 가능한 구조 설계 사용자 인터페이스(UI) 설계 주요 목적 사용자가 시스템과 효과적으로 상호작용할 수 있는 인터페이스를 제공한다. 사용자 경험(UX)을 최적화하여 시스템의 사용성을 향상시킨다. 시스템의 기능을 직관적이고 접근하기 쉬운 방식으로 제시한다. 사용자의 요구사항과 기대를 시각적으로 구현한다. 브랜드 아이덴티티와 일관된 디자인을 제공한다. 다양한 디바이스와 화면 크기에 대응할 수 있는 반응형 디자인을 구현한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 사용자 연구 사용자의 니즈, 행동, 선호도 분석 사용자 페르소나, 사용자 여정 지도 정보 구조 설계 콘텐츠 구조화 및 내비게이션 체계 수립 사이트맵, 정보 구조도 와이어프레이밍 페이지 레이아웃 및 기능 배치 설계 와이어프레임 상호작용 설계 사용자 동작에 대한 시스템 반응 설계 상호작용 흐름도, 프로토타입 시각적 디자인 색상, 타이포그래피, 아이콘 등 시각 요소 설계 스타일 가이드, 목업 프로토타이핑 상호작용 가능한 UI 프로토타입 제작 인터랙티브 프로토타입 사용성 테스트 설계된 UI의 사용성 평가 사용성 테스트 보고서 접근성 검토 다양한 사용자를 위한 접근성 확인 접근성 체크리스트 반응형 디자인 다양한 디바이스에 대응하는 UI 설계 반응형 디자인 명세서 디자인 시스템 구축 재사용 가능한 UI 컴포넌트 및 패턴 정의 디자인 시스템 문서 주의해야할 요소 주의 요소 설명 일관성 전체 UI에 걸쳐 일관된 디자인 언어 사용 사용자 중심 설계 사용자의 니즈와 행동 패턴을 중심으로 설계 직관성 사용자가 쉽게 이해하고 사용할 수 있는 인터페이스 피드백 제공 사용자 행동에 대한 적절한 피드백 제공 효율성 최소한의 단계로 작업을 완료할 수 있는 설계 오류 방지 사용자 오류를 최소화하는 설계 접근성 다양한 능력을 가진 사용자를 고려한 설계 성능 고려 UI 요소가 시스템 성능에 미치는 영향 고려 브랜드 일치성 회사 또는 제품의 브랜드 아이덴티티 반영 문화적 고려 다양한 문화와 언어를 고려한 설계 데이터베이스 설계 주요 목적 시스템의 데이터 요구사항을 효율적으로 구조화한다. 데이터의 무결성, 일관성, 보안성을 보장한다. 데이터 중복을 최소화하고 정규화를 통해 효율성을 높인다. 데이터 접근 및 검색 성능을 최적화한다. 향후 데이터 확장성을 고려한 구조를 제공한다. 비즈니스 규칙과 제약조건을 데이터 모델에 반영한다. 다양한 애플리케이션 요구사항을 지원할 수 있는 유연한 구조를 설계한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 분석 데이터 관련 요구사항 수집 및 분석 데이터 요구사항 문서 개념적 모델링 핵심 엔티티와 관계 식별 개념적 ERD (Entity-Relationship Diagram) 논리적 모델링 상세 속성 정의 및 정규화 논리적 데이터 모델, 정규화된 스키마 물리적 모델링 DBMS 특성을 고려한 물리적 구조 설계 물리적 데이터 모델, 테이블 정의서 인덱스 설계 성능 향상을 위한 인덱스 전략 수립 인덱스 설계 문서 데이터 무결성 규칙 정의 제약조건 및 비즈니스 규칙 정의 데이터 무결성 규칙 문서 데이터 보안 설계 접근 제어 및 보안 메커니즘 설계 데이터 보안 정책 문서 데이터 마이그레이션 계획 기존 데이터 이전 전략 수립 데이터 마이그레이션 계획서 성능 최적화 쿼리 성능 및 데이터 접근 최적화 성능 최적화 전략 문서 백업 및 복구 전략 데이터 백업 및 재해 복구 계획 수립 백업 및 복 주의해야할 요소 주의 요소 설명 확장성 미래의 데이터 증가를 고려한 유연한 구조 설계 성능 대량 데이터 처리 및 복잡한 쿼리에 대한 성능 고려 데이터 무결성 데이터의 정확성과 일관성을 보장하는 제약조건 설계 정규화 수준 적절한 정규화를 통한 데이터 중복 최소화 보안 민감한 데이터에 대한 보안 메커니즘 구현 DBMS 특성 선택한 DBMS의 특성과 제약사항 고려 트랜잭션 관리 데이터 일관성을 위한 트랜잭션 처리 고려 데이터 타입 효율적인 저장과 처리를 위한 적절한 데이터 타입 선택 인덱싱 전략 과도한 인덱스 사용 지양 및 효과적인 인덱스 설계 유지보수성 향후 스키마 변경이 용이한 구조 설계 보안 설계 주요 목적 시스템의 기밀성, 무결성, 가용성을 보장한다. 잠재적인 보안 위협을 식별하고 대응 방안을 수립한다. 데이터와 시스템 자원에 대한 무단 접근을 방지한다. 규제 요구사항 및 업계 표준을 준수한다. 보안 사고 발생 시 신속한 탐지와 대응을 가능하게 한다. 사용자 인증 및 권한 부여 메커니즘을 구축한다. 전체 시스템의 보안 수준을 향상시켜 신뢰성을 높인다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 위협 모델링 잠재적 보안 위협 식별 및 분석 위협 모델 문서 보안 요구사항 정의 시스템의 보안 요구사항 명세 보안 요구사항 명세서 인증 및 권한 부여 설계 사용자 인증 및 접근 제어 메커니즘 설계 인증/권한 부여 설계 문서 암호화 전략 수립 데이터 암호화 방식 및 키 관리 전략 정의 암호화 정책 문서 네트워크 보안 설계 네트워크 계층의 보안 아키텍처 설계 네트워크 보안 아키텍처 문서 보안 로깅 및 모니터링 설계 보안 이벤트 로깅 및 모니터링 체계 수립 로깅/모니터링 설계 문서 보안 테스트 계획 보안 취약점 테스트 전략 및 계획 수립 보안 테스트 계획서 인시던트 대응 계획 보안 사고 발생 시 대응 절차 수립 인시던트 대응 계획서 보안 아키텍처 문서화 전체 보안 아키텍처 및 설계 결정사항 문서화 보안 아키텍처 문서 규정 준수 검토 관련 법규 및 표준 준수 여부 검토 규정 준수 체크리스트 주의해야할 요소 주의 요소 설명 심층 방어 다층적 보안 메커니즘 구현으로 단일 실패점 방지 최소 권한 원칙 필요한 최소한의 권한만 부여하는 접근 제어 설계 안전한 기본 설정 보안에 강한 기본 설정으로 시스템 구성 입력 유효성 검사 모든 사용자 입력에 대한 철저한 검증 보안과 사용성 균형 보안 강화와 사용자 경험 간의 적절한 균형 유지 암호화 강도 충분한 강도의 암호화 알고리즘 및 키 길이 선택 세션 관리 안전한 세션 생성, 관리, 종료 메커니즘 구현 에러 처리 보안 정보를 노출하지 않는 안전한 에러 처리 제3자 컴포넌트 보안 외부 라이브러리 및 서비스의 보안성 검토 지속적인 업데이트 새로운 보안 위협에 대응하기 위한 설계의 유연성 인터페이스 설계 주요 목적 시스템 컴포넌트 간의 효과적인 통신 방법을 정의한다. 외부 시스템과의 상호작용 방식을 명확히 한다. 모듈 간 의존성을 최소화하고 결합도를 낮춘다. 시스템의 확장성과 유지보수성을 향상시킨다. 데이터 교환의 표준화된 형식과 프로토콜을 정의한다. 시스템 통합을 용이하게 하고 재사용성을 증진시킨다. 사용자와 시스템 간의 상호작용 방식을 설계한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 인터페이스 요구사항 분석 시스템 간 통신 요구사항 파악 인터페이스 요구사항 문서 API 설계 애플리케이션 프로그래밍 인터페이스 정의 API 명세서 데이터 교환 형식 정의 데이터 전송 형식 (예: JSON, XML) 결정 데이터 형식 정의서 프로토콜 설계 통신 프로토콜 선택 및 설계 프로토콜 명세서 오류 처리 방식 정의 인터페이스 오류 상황 대응 방식 설계 오류 처리 가이드라인 버전 관리 전략 수립 인터페이스 버전 관리 방식 정의 버전 관리 정책 문서 보안 고려사항 정의 인터페이스 보안 요구사항 명세 인터페이스 보안 설계서 성능 요구사항 정의 응답 시간, 처리량 등 성능 기준 설정 성능 요구사항 문서 문서화 인터페이스 사용 방법 및 제약사항 문서화 인터페이스 문서 모의 인터페이스 개발 테스트 및 개발을 위한 모의 객체 생성 모의 인터페이스 (Mock) 주의해야할 요소 주의 요소 설명 일관성 모든 인터페이스에 걸쳐 일관된 설계 원칙 적용 단순성 복잡성을 최소화하고 이해하기 쉬운 인터페이스 설계 확장성 향후 요구사항 변화에 대응할 수 있는 유연한 설계 표준 준수 업계 표준 및 best practices 준수 버전 호환성 이전 버전과의 호환성 유지 보안 데이터 전송 및 접근에 대한 보안 고려 성능 효율적인 데이터 전송 및 처리를 위한 설계 문서화 명확하고 상세한 인터페이스 문서 제공 테스트 용이성 인터페이스 테스트가 용이한 구조 설계 오류 처리 명확한 오류 메시지 및 예외 처리 메커니즘 구현 모듈 설계 주요 목적 시스템을 관리 가능한 작은 단위로 분해한다. 각 모듈의 기능과 책임을 명확히 정의한다. 모듈 간의 결합도를 낮추고 응집도를 높인다. 코드의 재사용성과 유지보수성을 향상시킨다. 병렬 개발을 가능하게 하여 개발 효율성을 높인다. 시스템의 복잡성을 관리하고 이해도를 높인다. 테스트와 디버깅을 용이하게 한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 기능 분해 시스템 기능을 모듈 단위로 분할 기능 분해도 모듈 정의 각 모듈의 목적과 책임 정의 모듈 명세서 인터페이스 설계 모듈 간 상호작용 방식 정의 모듈 인터페이스 문서 의존성 분석 모듈 간 의존 관계 파악 의존성 다이어그램 데이터 흐름 설계 모듈 간 데이터 전달 방식 정의 데이터 흐름도 알고리즘 설계 주요 알고리즘 및 로직 설계 알고리즘 명세서 오류 처리 설계 모듈 수준의 예외 처리 방식 정의 오류 처리 가이드라인 성능 최적화 모듈 수준의 성능 고려사항 정의 성능 최적화 전략 문서 재사용성 분석 재사용 가능한 모듈 식별 재사용 모듈 목록 모듈 테스트 계획 단위 테스트 전략 수립 모듈 테스트 계획서 주의해야할 요소 주의 요소 설명 단일 책임 원칙 각 모듈이 하나의 명확한 책임만 가지도록 설계 낮은 결합도 모듈 간 의존성을 최소화하여 유연성 확보 높은 응집도 관련 기능을 하나의 모듈로 그룹화 인터페이스 명확성 모듈 간 인터페이스를 명확하고 간단하게 정의 정보 은닉 모듈 내부 구현 세부사항을 외부로부터 숨김 재사용성 범용적으로 사용 가능한 모듈 설계 확장성 향후 기능 추가나 변경이 용이한 구조 설계 테스트 용이성 단위 테스트가 쉬운 모듈 구조 설계 성능 고려 모듈 간 통신 오버헤드 최소화 명명 규칙 일관되고 의미 있는 모듈 및 함수 이름 사용 성능 및 확장성 설계 주요 목적 시스템의 응답 시간, 처리량, 자원 사용을 최적화한다. 사용자 수와 데이터 양 증가에 대비한 확장 가능한 구조를 설계한다. 성능 병목 현상을 사전에 식별하고 해결 방안을 마련한다. 시스템의 부하 분산 및 고가용성을 확보한다. 미래의 성장을 고려한 유연한 아키텍처를 구축한다. 비용 효율적인 리소스 사용을 계획한다. 성능 요구사항을 충족시키는 동시에 확장성을 보장한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 성능 요구사항 분석 시스템의 성능 목표 및 기준 정의 성능 요구사항 문서 부하 예측 예상 사용자 수, 데이터 양 등 추정 부하 예측 보고서 성능 모델링 시스템 성능을 수학적으로 모델링 성능 모델 문서 아키텍처 확장성 설계 확장 가능한 시스템 구조 설계 확장성 아키텍처 문서 데이터베이스 최적화 DB 구조 및 쿼리 최적화 전략 수립 DB 최적화 계획서 캐싱 전략 수립 데이터 캐싱 방식 및 정책 정의 캐싱 전략 문서 로드 밸런싱 설계 부하 분산 방식 및 구조 설계 로드 밸런싱 아키텍처 병렬 처리 설계 동시 처리를 위한 병렬화 전략 수립 병렬 처리 설계서 리소스 관리 계획 CPU, 메모리, 네트워크 등 자원 관리 계획 리소스 관리 계획서 성능 테스트 계획 성능 및 부하 테스트 전략 수립 성능 테스트 계획서 주의해야할 요소 주의 요소 설명 확장성 vs 복잡성 확장성 확보와 시스템 복잡도 증가 사이의 균형 비용 효율성 성능 향상과 비용 사이의 적절한 균형 유지 데이터 일관성 분산 환경에서의 데이터 일관성 보장 병목 현상 식별 잠재적 성능 병목 지점 사전 식별 및 대응 네트워크 지연 분산 시스템에서의 네트워크 지연 고려 상태 관리 확장 시 상태 정보 관리 전략 수립 모니터링 및 알림 성능 모니터링 및 문제 감지 메커니즘 설계 보안과의 균형 성능 최적화와 보안 요구사항 간의 균형 유지보수성 확장 및 성능 개선이 용이한 구조 설계 테스트 환경 실제 환경을 반영한 성능 테스트 환경 구축 설계 검토 및 평가 주요 목적 설계의 품질, 완전성, 일관성을 확인한다. 요구사항과 설계의 일치 여부를 검증한다. 잠재적인 문제점과 리스크를 조기에 식별한다. 설계 결정사항의 타당성을 평가한다. 최적의 설계 대안을 선택한다. 이해관계자들의 합의를 도출한다. 설계 문서의 명확성과 이해도를 향상시킨다. 프로젝트의 성공 가능성을 높인다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 설계 문서 검토 모든 설계 문서의 상세 검토 문서 검토 보고서 설계 워크스루 설계자가 설계 내용을 설명하고 토론 워크스루 회의록 기술적 검토 회의 기술 전문가들의 심층적인 설계 검토 기술 검토 보고서 요구사항 추적성 분석 설계와 요구사항의 연관성 확인 추적성 매트릭스 아키텍처 평가 전체 시스템 아키텍처의 적합성 평가 아키텍처 평가 보고서 성능 및 확장성 검토 성능 요구사항 충족 여부 검토 성능 검토 문서 보안 설계 검토 보안 요구사항 및 위협 모델 검토 보안 검토 보고서 사용성 평가 UI/UX 설계의 사용성 검토 사용성 평가 보고서 리스크 분석 설계 관련 리스크 식별 및 평가 리스크 평가 문서 피어 리뷰 동료 개발자들의 코드 및 설계 리뷰 피어 리뷰 결과 주의해야할 요소 주의 요소 설명 객관성 유지 개인적 편견 없이 객관적인 평가 수행 다양한 관점 고려 다양한 이해관계자와 전문가의 의견 수렴 명확한 기준 설정 평가를 위한 명확하고 측정 가능한 기준 정의 시간 관리 과도한 검토로 인한 일정 지연 방지 건설적인 피드백 문제점 지적뿐만 아니라 개선 제안 제공 문서화 검토 과정과 결과의 철저한 문서화 후속 조치 식별된 문제점에 대한 적절한 후속 조치 계획 전체적 시각 유지 세부사항과 함께 전체 시스템 관점 고려 미래 지향적 평가 현재 요구사항뿐만 아니라 미래 확장성 고려 합의 도출 주요 설계 결정에 대한 이해관계자 간 합의 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-20 00:53:00 +0000 UTC'>September 20, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 3. 설계 (Design)" href=https://buenhyden.github.io/posts/software-development/software-development-lifecycle/3-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Design and Architecture</h2></header><div class=entry-content><p>System Design and Architecture 시스템 디자인 (System Design) 은 복잡한 소프트웨어 시스템의 아키텍처, 구성 요소, 인터페이스, 데이터 흐름 등을 정의하여 안정적이고 확장 가능한 시스템을 구축하는 과정을 의미한다. 분산 아키텍처, 데이터 저장소, 캐싱, 로드 밸런싱, 마이크로서비스 등 다양한 기술과 패턴을 활용하여 확장 가능하고 복원력 있는 시스템을 구축한다. 요구사항 정의부터 실행 가능한 설계까지 체계적인 방법론을 제공한다.
이는 소프트웨어 공학, 컴퓨터 과학, 시스템 엔지니어링 등 다양한 분야와 밀접하게 연관되어 있으며, 대규모 분산 시스템, 클라우드 기반 서비스, IoT(사물인터넷) 등 현대 IT 인프라의 핵심 요소로 자리잡고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 21:24:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;48 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Design and Architecture" href=https://buenhyden.github.io/posts/system-design/system-design-fundamentals/system-design-and-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Back Tracking vs. Depth-First Search</h2></header><div class=entry-content><p>Back Tracking vs. Depth-First Search 백트래킹과 깊이 우선 탐색은 모두 그래프나 트리 구조에서 해결책을 찾기 위한 알고리즘 기법이다.
DFS는 그래프의 모든 노드를 방문하는 데 중점을 두는 반면, 백트래킹은 제약 조건을 만족하는 해결책을 효율적으로 찾는 데 초점을 맞춘다.
백트래킹은 DFS의 개념을 기반으로 하지만, 유망성 테스트와 가지치기라는 중요한 최적화 기법을 추가하여 탐색 공간을 줄이고 효율성을 높인다. 따라서 백트래킹은 DFS의 확장된 형태라고 볼 수 있다.
깊이 우선 탐색(Depth-First Search, DFS) 깊이 우선 탐색은 그래프 탐색 알고리즘으로, 가능한 한 깊이 들어가면서 모든 노드를 방문하는 방법이다.
...</p></div><footer class=entry-footer><span title='2024-12-29 13:55:00 +0000 UTC'>December 29, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Tracking vs. Depth-First Search" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/back-tracking/back-tracking-vs-depth-first-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Traversal 방법 비교</h2></header><div class=entry-content><p>Traversal 방법 비교 트리 순회는 트리 구조의 모든 노드를 체계적으로 방문하는 프로세스이다.
각 순회 방법은 노드를 방문하는 순서가 다르며, 이는 다양한 응용 프로그램에서 서로 다른 목적으로 사용된다.
트리 순회 방법은 각기 다른 특성과 장단점을 가지고 있으며, 문제의 성격에 따라 적합한 순회 방법을 선택해야 한다.
중위 순회(Inorder): 정렬된 순서가 필요할 때 특히 이진 탐색 트리에서 유용하다. 전위 순회(Preorder): 트리의 구조를 복제하거나 직렬화할 때 효과적이다. 후위 순회(Postorder): 자식 노드를 먼저 처리해야 하는 경우, 특히 트리 삭제 작업에 적합하다. 레벨 순서 순회(Level Order): 레벨별 처리가 필요하거나 최단 경로 문제를 해결할 때 유용하다. 각 순회 방법의 구현은 재귀적 접근법과 반복적 접근법 모두 가능하지만, 복잡성과 효율성 측면에서 차이가 있다. 재귀적 접근법은 구현이 간단하지만 깊은 트리에서는 스택 오버플로우가 발생할 수 있다. 반복적 접근법은 더 복잡한 구현이 필요하지만 메모리 효율성이 높다.
...</p></div><footer class=entry-footer><span title='2024-12-06 11:54:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Traversal 방법 비교" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/traversal-%EB%B0%A9%EB%B2%95-%EB%B9%84%EA%B5%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>퀵 정렬 (Quick Sort)</h2></header><div class=entry-content><p>퀵 정렬 (Quick Sort) 퀵 정렬은 1960년 Tony Hoare가 개발한 효율적인 분할 정복(Divide and Conquer) 알고리즘으로, 평균적으로 매우 빠른 성능을 보이는 정렬 방식이다. 실제 많은 프로그래밍 언어의 표준 라이브러리에 구현되어 있을 정도로 실용적인 정렬 알고리즘이다.
퀵 정렬은 간단한 아이디어를 바탕으로 하면서도 매우 효율적인 정렬 알고리즘이다.
평균적인 성능이 우수하고 실제 구현에서 다양한 최적화 기법을 적용할 수 있어 많은 환경에서 선호된다.
최악의 경우를 대비한 피벗 선택 최적화와 하이브리드 접근 방식을 통해 단점을 보완하여 현대적인 정렬 알고리즘의 기반이 되고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 퀵 정렬 (Quick Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/quick-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JIT Compiler vs AOT Compiler</h2></header><div class=entry-content><p>JIT Compiler vs. AOT Compiler JIT 컴파일러와 AOT 컴파일러는 모두 소스 코드 또는 중간 표현(바이트코드)을 기계어 코드로 변환한다는 공통점을 가지지만, 언제 그리고 어떻게 컴파일하는지에 큰 차이가 있다.
JIT와 AOT 컴파일러는 각각 고유한 장단점을 가지고 있으며, 사용 환경과 요구사항에 따라 적합한 접근 방식이 달라진다.
JIT 컴파일러는 런타임 정보를 활용한 최적화와 플랫폼 독립성을 제공하는 반면, AOT 컴파일러는 빠른 시작 시간과 예측 가능한 성능을 제공한다.
현대 소프트웨어 개발에서는 이 두 접근 방식의 장점을 결합한 하이브리드 방식이 점점 더 인기를 얻고 있다.
앞으로는 기계 학습, 특화된 하드웨어 활용, WebAssembly 확산 등의 동향이 컴파일러 기술의 발전을 이끌 것으로 예상된다.
...</p></div><footer class=entry-footer><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JIT Compiler vs AOT Compiler" href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilers-vs-interpreters/compiler/jit-compiler-vs-aot-compiler/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>