<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MSA 패턴 유형별 비교</h2></header><div class=entry-content><p>MSA 패턴 유형별 비교 https://microservices.io/patterns/
아래 표는 MSA의 주요 패턴 유형들을 체계적으로 정리한 것이다.
기본 인프라 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Cross-cutting Concern Patterns 여러 서비스에 공통적으로 적용되는 기능을 분리하여 관리 인프라 수준에서 공통 관심사 처리 • 코드 중복 감소
• 일관성 있는 처리
• 유지보수 용이 • 추가적인 인프라 필요
• 복잡도 증가 • Service Mesh
• Sidecar
• Ambassador Configuration Management Patterns 서비스 구성 정보를 외부화하여 중앙 관리 환경별 설정 분리 및 동적 구성 지원 • 유연한 설정 변경
• 환경별 구성 용이 • 구성 정보 관리 복잡
• 보안 고려 필요 • External Configuration
• Config Server
• Environment Variables Service Registry Patterns 서비스 위치 정보를 동적으로 관리 서비스 등록 및 발견 자동화 • 동적 확장 용이
• 자동 장애 감지 • 추가 인프라 필요
• 의존성 증가 • Service Discovery
• Service Registry
• Client-side Discovery 데이터 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Database Patterns 데이터 저장소 설계 및 관리 전략 서비스별 독립적 데이터 관리 • 데이터 독립성
• 확장성 향상 • 데이터 일관성 관리 어려움
• 복잡도 증가 • Database per Service
• CQRS
• Saga Data Management Patterns 데이터 처리 및 동기화 전략 분산 데이터 관리 • 데이터 일관성 보장
• 효율적 처리 • 구현 복잡도
• 성능 오버헤드 • Event Sourcing
• Materialized View
• Shared Data State Management Patterns 서비스 상태 관리 전략 상태 정보의 일관성 유지 • 상태 추적 용이
• 복구 용이 • 구현 복잡도
• 성능 영향 • Stateless Service
• Session State
• Distributed Cache 서비스 구조 및 통신 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Decomposition Patterns 서비스 분할 전략 비즈니스 기능 기반 분할 • 독립적 개발/배포
• 확장성 향상 • 서비스 경계 설정 어려움
• 통신 복잡도 증가 • Business Capability
• Domain-Driven
• Strangler Communication Patterns 서비스 간 통신 방식 정의 동기/비동기 통신 지원 • 유연한 통신
• 느슨한 결합 • 메시지 관리 복잡
• 디버깅 어려움 • Synchronous RPC
• Event-Driven
• Message Queue Integration Patterns 서비스 통합 전략 다양한 통합 방식 제공 • 유연한 통합
• 재사용성 • 구현 복잡도
• 관리 어려움 • API Gateway
• BFF
• Aggregator 운영 및 품질 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Deployment Patterns 서비스 배포 전략 무중단 배포 지원 • 안정적 배포
• 위험 감소 • 인프라 비용
• 복잡도 증가 • Blue-Green
• Canary
• Rolling Update Testing Patterns 서비스 테스트 전략 다양한 수준의 테스트 지원 • 품질 보장
• 신뢰성 향상 • 테스트 환경 구축 비용
• 실행 시간 증가 • Consumer-Driven
• Contract Test
• End-to-End Test Observability Patterns 서비스 모니터링 전략 시스템 상태 가시화 • 문제 감지 용이
• 분석 용이 • 데이터 양 증가
• 저장/분석 비용 • Distributed Tracing
• Log Aggregation
• Health Check 성능 및 보안 관련 패턴 패턴 유형 목적 특징 장점 단점 주요 패턴 예시 Scalability Patterns 서비스 확장성 확보 동적 확장/축소 지원 • 자원 효율성
• 비용 최적화 • 구현 복잡도
• 관리 어려움 • Horizontal Scaling
• Sharding
• Load Balancer Performance Patterns 성능 최적화 전략 응답 시간 및 처리량 개선 • 사용자 경험 향상
• 자원 효율성 • 구현 복잡도
• 유지보수 어려움 • Caching
• Async Processing
• Throttling Versioning Patterns API 버전 관리 전략 하위 호환성 보장 • 안정적 변경
• 클라이언트 독립성 • 관리 복잡도
• 테스트 부담 • URI Versioning
• Header Versioning
• Content Negotiation Resilience Patterns 장애 대응 전략 시스템 복원력 향상 • 안정성 향상
• 가용성 보장 • 구현 복잡도
• 성능 영향 • Circuit Breaker
• Bulkhead
• Retry Security Patterns 보안 통제 전략 다층적 보안 구현 • 보안성 향상
• 규정 준수 • 구현 복잡도
• 성능 영향 • OAuth/OIDC
• API Security
• Zero Trust 패턴 선택 시 고려사항 실제 구현 시에는 비즈니스 요구사항, 기술적 제약사항, 팀의 역량 등을 고려하여 적절한 패턴을 선택하고 조합해야 한다.
또한, 각 패턴은 독립적으로 사용될 수도 있지만, 대부분의 경우 여러 패턴을 함께 사용하여 시너지를 얻을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-19 02:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MSA 패턴 유형별 비교" href=https://buenhyden.github.io/posts/software-engineering/requirements-and-design/architecture-and-system-design/use-cases/industry-patterns/msa-pattern-comparison/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Test</h2></header><div class=entry-content><p>테스트 (Test) 소프트웨어 테스트는 “주요 이해관계자들에게 시험 대상 제품 또는 서비스의 품질에 관한 정보를 제공하는 조사 과정"으로 정의된다.
테스트의 주요 목적은 다음과 같다:
결함 발견: 프로그램 내의 오류, 버그, 잠재적 문제를 식별하고 수정 품질 보증: 안정적이고 신뢰성 있는 소프트웨어 제공 사용자 만족도 향상: 소프트웨어가 기대한 대로 작동하는지 확인 테스트의 중요성 소프트웨어 테스트는 다음과 같은 이유로 중요하다:
비용 절감: 초기에 결함을 발견하고 수정함으로써 개발 비용을 절감 신뢰성 확보: 안정적이고 예측 가능한 소프트웨어 제공 고객 만족도 향상: 품질이 보장된 소프트웨어로 사용자 경험 개선 소프트웨어 테스트의 7가지 원칙 결함 발견: 테스트의 주요 목적은 결함을 찾는 것 완벽한 테스트는 불가능: 모든 경우를 테스트하는 것은 현실적으로 불가능 초기 테스트: 개발 초기 단계에서 테스트를 시작하는 것이 중요 결함 집중: 일부 모듈에 결함이 집중되는 경향이 있음 살충제 패러독스: 동일한 테스트를 반복하면 새로운 결함을 발견하기 어려움 테스트는 상황에 의존적: 소프트웨어의 용도와 환경에 따라 테스트 방법이 달라짐 오류 부재의 오해: 결함이 없다고 해서 사용자의 요구를 완전히 만족시키는 것은 아님 테스트 프로세스 소프트웨어 테스트 프로세스는 일반적으로 다음 단계를 포함한다:
...</p></div><footer class=entry-footer><span title='2024-10-30 06:14:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Test" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance/fundamentals/qa-fundamentals/test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Quality Control</h2></header><div class=entry-content><p>Quality Control 품질관리(Quality Control, QC)는 제품이나 서비스가 일정한 품질 기준을 충족하도록 보장하는 일련의 절차를 의미한다.
주요 목표 품질관리의 주요 목표는 다음과 같다:
제품 품질 향상 고객 만족도 증대 불량률 감소 생산성 향상 비용 절감 기업 경쟁력 강화 주요 특징 QC의 주요 특징은 다음과 같다:
데이터 기반 의사결정: 통계적 기법을 활용하여 객관적인 데이터를 바탕으로 품질 관리 결정을 내린다. 예방 중심: 문제가 발생하기 전에 미리 그 원인을 차단하는 예방 활동에 초점을 맞춘다. 전사적 참여: 모든 구성원이 품질 관리에 참여하여 협력한다. 지속적 개선: PDCA(Plan-Do-Check-Action) 사이클을 통해 지속적인 품질 개선을 추구한다. 과학적 접근: 문제 해결에 있어 과학적이고 체계적인 방법을 사용한다. 중요성 품질관리의 중요성은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-29 16:27:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Quality Control" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance/fundamentals/qa-fundamentals/quality-control/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>병합 정렬 (Merge Sort)</h2></header><div class=entry-content><p>병합 정렬 (Merge Sort) 병합 정렬은 분할 정복(Divide and Conquer) 패러다임을 기반으로 하는 효율적인 정렬 알고리즘이다.
여러 정렬 알고리즘 중에서도 안정적인 성능과 일관된 시간 복잡도를 제공하는 방식으로 널리 사용된다.
병합 정렬은 안정적인 성능과 예측 가능한 시간 복잡도를 제공하는 매우 유용한 정렬 알고리즘. 추가 메모리가 필요하다는 단점이 있지만, 대규모 데이터 처리나 외부 정렬에 적합하며, 안정적인 정렬이 필요한 상황에서 특히 유용하다.
알고리즘의 단순성과 병렬화 가능성도 중요한 장점이다.
병합 정렬의 기본 원리 병합 정렬은 다음 세 단계로 동작한다:
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병합 정렬 (Merge Sort)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/merge-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Just-In-Time (JIT) Compiler</h2></header><div class=entry-content><p>Just-In-Time (JIT) Compiler Just-In-Time (JIT) 컴파일러는 프로그램 실행 도중에 필요할 때마다 바이트코드나 중간 표현(IR)을 해당 플랫폼의 네이티브 기계어로 변환하는 동적 컴파일 기술이다.
JIT 컴파일러는 전통적인 정적 컴파일러와 달리 프로그램이 실행되는 동안 “핫스팟"이라고 부르는 자주 실행되는 코드 영역을 감지하여, 이 부분을 최적화된 기계어 코드로 변환한 후 캐시에 저장함으로써 이후부터는 빠른 실행 속도를 제공할 수 있다. 주로 자바(JVM), 자바스크립트(V8), 닷넷(CLR) 등에서 사용되며, 런타임 최적화를 통해 애플리케이션 성능을 크게 향상시킨다.
JIT 컴파일은 런타임 유연성과 성능 사이의 균형을 찾은 기술이다.
모던 프로그래밍 언어와 프레임워크에서 필수적인 요소로 자리잡았으며, 클라우드 네이티브 환경과 실시간 애플리케이션에서 더욱 중요해질 전망이다.
개발자는 대상 시스템의 요구사항에 따라 JIT과 AOT를 전략적으로 조합해 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 17:55:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Just-In-Time (JIT) Compiler" href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/just-in-time-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Native Compiler vs Cross Compiler</h2></header><div class=entry-content><p>Native Compiler vs. Cross Compiler Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.
Native Compiler는 컴파일러가 실행되는 동일한 시스템의 하드웨어와 운영체제에 최적화된 코드를 생성한다. Cross Compiler는 호스트 시스템에서 실행되지만 다른 플랫폼(즉, 대상 시스템)에서 실행될 코드를 생성한다. 네이티브 컴파일러(Native Compiler)의 이해 네이티브 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 동일한 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자가 사용하는 컴퓨터와 동일한 운영체제 및 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 03:33:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler vs Cross Compiler" href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/native-compiler-vs-cross-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>브루트 포스 (Brute Force)</h2></header><div class=entry-content><p>브루트 포스 (Brute Force) 브루트 포스는 가장 직관적이고 단순한 문제 해결 기법으로, 가능한 모든 경우의 수를 철저하게 조사하여 문제의 해결책을 찾는 방법이다.
“무차별 대입법” 또는 “완전 탐색"이라고도 불리는 이 접근법은 컴퓨터 과학과 알고리즘 설계에서 기본적인 방법론으로 사용된다.
브루트 포스는 가장 직관적이고 단순한 문제 해결 접근법으로, 구현이 쉽고 모든 가능한 해결책을 검사하기 때문에 완전성을 보장한다. 그러나 시간 복잡도가 높아 큰 문제에는 적합하지 않다.
실제 응용에서는 브루트 포스를 단독으로 사용하기보다는 다른 최적화 기법과 함께 사용하거나, 더 효율적인 알고리즘이 없는 경우의 대안으로 활용한다. 또한, 브루트 포스는 문제 해결의 기본 접근법으로서 다른 고급 알고리즘의 기초가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-13 07:50:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 브루트 포스 (Brute Force)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/basic-techniques/brute-force/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>부동 소수점 (Float)</h2></header><div class=entry-content><p>부동 소수점 (Float) 부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.
‘부동’은 소수점이 움직인다는 의미로, 넓은 범위의 실수를 표현할 수 있다.
특징 IEEE 754 표준을 따름 부호, 지수, 가수 부분으로 구성 IEEE 754 표준에 따른 부동 소수점 종류 Half Precision
이 형식은 가장 작은 부동 소수점 표현 방식.
16비트를 사용한다.
1비트는 부호, 5비트는 지수부, 10비트는 가수부로 구성된다.
주로 그래픽스나 머신러닝에서 메모리를 절약하기 위해 사용된다.
약 3자리의 십진 정밀도를 제공하며, ±6.1 × 10⁻⁵에서 ±6.5 × 10⁴까지의 범위를 표현할 수 있다.
예시:
Python: 1 2 3 import numpy as np x = np.float16(3.14) print(x) # 3.14 JavaScript: JavaScript는 기본적으로 Half Precision을 지원하지 않는다. 외부 라이브러리를 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부동 소수점 (Float)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/float/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Trunk-based Development</h2></header><div class=entry-content><p>Trunk-based Development Trunk-based Development(TBD)는 모든 개발자가 단일 메인 브랜치(trunk)에 작고 빈번한 변경사항을 직접 통합하는 버전 관리 방법론이다. 이는 지속적 통합(CI)과 지속적 배포(CD)의 필수 전제조건으로, 현대 DevOps 환경에서 가장 효율적인 브랜치 전략으로 인정받고 있다. 긴 수명의 기능 브랜치 대신 짧은 수명의 브랜치나 직접 커밋을 통해 코드 통합의 마찰을 최소화하고, 항상 배포 가능한 상태의 코드베이스를 유지하는 것이 핵심이다.
핵심 개념 Trunk-based Development의 핵심 개념은 다음과 같다:
단일 메인 브랜치: 모든 개발이 하나의 trunk(main/master) 브랜치에 집중 작고 빈번한 커밋: 작업을 작은 단위로 나누어 자주 통합 짧은 수명의 브랜치: 필요한 경우 최대 1-2일 이내의 피처 브랜치 사용 지속적 통합: 하루에 여러 번 코드 통합 및 자동화된 테스트 항상 릴리스 가능한 상태: trunk는 언제나 프로덕션 배포가 가능한 상태 유지 피처 플래그: 미완성 기능을 main에 통합하되 런타임에 비활성화 graph TD main[main 브랜치] -->|분기| feature[feature/기능] feature -->|풀 리퀘스트| main main -->|자동 배포| Production 목적 코드 통합의 복잡성과 병합 충돌 최소화 개발 및 배포 속도 극대화 지속적 통합/배포(CI/CD) 실현 팀 협업 효율성 향상 코드베이스의 일관성과 품질 유지 빠른 피드백 사이클 구현 필요성 현대 DevOps 및 애자일 개발 방법론의 요구사항 충족 마이크로서비스 아키텍처에서의 빠른 배포 필요 대규모 개발팀의 효율적인 협업 지원 병합 지옥(merge hell) 방지 지속적 배포를 통한 경쟁력 확보 고품질 소프트웨어의 빠른 출시 요구 역할 개발 프로세스 단순화: 복잡한 브랜치 모델 제거 배포 주기 가속화: 빠른 릴리스 사이클 지원 품질 보증: 지속적인 테스트를 통한 품질 유지 팀 협업 강화: 코드 리뷰와 페어 프로그래밍 촉진 기술 부채 방지: 장기 브랜치로 인한 기술 부채 최소화 특징 브랜치 최소화 통합의 빈도 극대화 Feature Toggle 사용 권장 Conflict를 예방하는 설계 주요 기능 직접 trunk 커밋: 소규모 팀의 경우 trunk에 직접 커밋 Pull Request 워크플로우: 코드 리뷰를 위한 짧은 수명의 브랜치 자동화된 테스트: 모든 커밋에 대한 자동 테스트 실행 피처 플래그: 기능의 점진적 롤아웃 지원 지속적 통합: 자동화된 빌드 및 테스트 파이프라인 브랜치별 CI: PR/브랜치 단위 자동화 검증 주요 원리 Trunk-based Development의 주요 원리는 다음 다이어그램으로 표현할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trunk-based Development" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/trunk-based-development/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Snapshot vs. Delta</h2></header><div class=entry-content><p>Snapshot vs. Delta 스냅샷(Snapshot)과 델타(Delta)는 데이터 변화를 관리하는 두 가지 근본적인 접근 방식이다.
스냅샷: 특정 시점의 전체 시스템 상태를 저장한다. Git이 대표적으로, 각 커밋 시 프로젝트 전체의 파일 상태를 기록한다. 델타: 이전 버전 대비 변경된 부분만 저장한다. SVN, CVS 등 전통적 VCS에서 사용되며, 저장 공간 효율성이 장점이다. 이 두 방식은 저장 효율성, 성능, 복구 속도에서 차이를 보이며, 현대 시스템에서는 버전 관리 시스템(Git, SVN 등), 백업 솔루션, 데이터베이스 시스템 등 여러 컴퓨팅 분야에서 중요하게 사용된다. 또한, 두 방식의 혼합하여 사용하는 하이브리드 접근법(예: Git의 git gc를 통한 델타 압축)도 활용된다.
...</p></div><footer class=entry-footer><span title='2024-09-28 10:01:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Snapshot vs. Delta" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/snapshot-vs-delta/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/7/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/9/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>