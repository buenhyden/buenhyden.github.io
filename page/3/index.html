<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Javascript vs. Python</h2></header><div class=entry-content><p>Javascript vs. Python JavaScript와 Python은 현대 프로그래밍 세계에서 가장 인기 있는 두 언어이다.
두 언어 모두 높은 수준의 프로그래밍 언어이지만, 설계 철학, 사용 사례, 문법 등에서 중요한 차이점이 있다.
JavaScript와 Python은 각각 고유한 강점과 약점을 가진 강력한 프로그래밍 언어이다.
JavaScript는 웹 개발에서 독보적인 위치를 차지하고 있으며, 비동기 프로그래밍 모델과 빠른 실행 속도가 특징이다. Python은 가독성이 뛰어나고 데이터 과학, 기계 학습, 자동화 분야에서 뛰어난 라이브러리 지원을 제공한다.
역사와 배경 JavaScript JavaScript는 1995년 Netscape의 Brendan Eich에 의해 웹 브라우저용 스크립팅 언어로 개발되었다.
처음에는 ‘Mocha’라고 불렸으며, 나중에 ‘LiveScript’로 이름이 바뀌었고, 마지막으로 마케팅 목적으로 ‘JavaScript’라는 이름이 되었다 (Java와의 관련성은 거의 없다).
JavaScript는 웹 페이지에 상호작용성을 추가하기 위해 만들어졌으며, 시간이 지남에 따라 Node.js와 같은 플랫폼 덕분에 서버 측 개발로 확장되었다.
...</p></div><footer class=entry-footer><span title='2024-12-22 04:24:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Javascript vs. Python" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript-vs-python/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비꼬리 재귀(Non-tail Recursion)</h2></header><div class=entry-content><p>비꼬리 재귀(Non-tail Recursion) 비꼬리 재귀(Non-tail Recursion)는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다.
이러한 형태의 재귀는 꼬리 재귀(Tail Recursion)와 대비되는 개념으로, 프로그래밍과 알고리즘 설계에서 중요한 의미를 가진다.
비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수의 형태이다.
이런 형태의 재귀는 많은 알고리즘과 자료구조에서 자연스럽게 발생하며, 종종 문제를 직관적으로 해결할 수 있게 해준다.
그러나 비꼬리 재귀는 스택 오버플로우 위험과 같은 실용적인 제약이 있다. 이러한 제약을 극복하기 위해 꼬리 재귀로의 변환, 메모이제이션, 또는 반복적 접근법으로의 전환을 고려할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 09:36:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비꼬리 재귀(Non-tail Recursion)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/types/non-tail-recursion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Inorder Traversal</h2></header><div class=entry-content><p>중위 순회(Inorder Traversal) 중위 순회(Inorder Traversal)는 트리 자료구조, 특히 이진 트리를 탐색하는 세 가지 기본적인 방법(전위, 중위, 후위) 중 하나이다. 이 순회 방식은 특유의 방문 순서 때문에 특별한 의미와 활용 가치를 지니고 있다.
왼쪽 서브트리를 먼저 방문한 후 현재 노드를 방문하고 마지막으로 오른쪽 서브트리를 방문하는 이 방법은 정렬된 데이터가 필요한 다양한 문제에 활용된다.
이진 검색 트리에서 중위 순회를 수행하면 노드 값이 오름차순으로 방문되는 특성은 검색, 삽입, 삭제, 범위 쿼리 등 많은 작업에서 핵심적인 역할을 한다. 또한 표현식 트리에서 중위 표기법을 생성하거나 트리의 유효성을 검사하는 데에도 널리 사용된다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Inorder Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear/tree/fundamentals/traversal/inorder-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Low-Level Virtual Machine</h2></header><div class=entry-content><p>Low-Level Virtual Machine (LLVM) LLVM은 소스 코드를 최적화하고 대상 플랫폼에 맞는 기계어로 변환하는 모듈식 컴파일러 프레임워크이다.
원래 “Low-Level Virtual Machine"의 약자에서 출발했으나, 현재는 그 이름 그대로 하나의 독립적인 프로젝트가 되어 다양한 언어와 플랫폼을 지원하고 있다.
LLVM은 소스 코드 → 중간 표현(IR) 변환부터, 여러 단계의 최적화, 그리고 최종 기계어 코드 생성을 위한 백엔드로 구성되며, 컴파일 타임, 링크 타임, 런타임, 심지어 유휴 시간까지 전반에 걸친 지속적 최적화(Lifelong Optimization) 를 지원한다.
LLVM의 핵심 아이디어는 컴파일러를 모듈화하여 프론트엔드(언어 파싱), 중간표현(IR) 최적화, 백엔드(코드 생성) 단계를 독립적으로 개발하고 재사용할 수 있게 만든 것으로, 컴파일러 개발의 유연성과 효율성을 크게 향상시켰다.
...</p></div><footer class=entry-footer><span title='2024-12-05 03:41:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Low-Level Virtual Machine" href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/compilers--interpreters/language-processor/compiler/low-level-virtual-machine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Functions</h2></header><div class=entry-content><p>Functions 함수는 프로그래밍의 핵심 구성 요소로, 특정 작업을 수행하는 독립적이고 재사용 가능한 코드 블록이다.
함수는 입력값(매개변수)을 받아 처리한 후 결과값을 반환할 수 있다.
함수는 코드의 가독성을 높이고 모듈화된 구조를 만들어 유지보수와 확장성을 크게 개선할 수 있다.
함수는 프로그래밍의 근본 개념으로, 다양한 언어에서 조금씩 다른 문법과 용법을 가지고 있지만 기본적인 원리는 동일하다.
각 언어의 특성과 장점을 이해하고 적재적소에 적용함으로써 더 효율적이고 관리하기 쉬운 소프트웨어를 개발할 수 있다.
함수의 기본 개념 함수는 하나의 작업 또는 연산을 수행하기 위해 정의된 코드 집합이며, 필요에 따라 여러 번 호출하여 사용할 수 있다. 함수는 입력 값(매개변수)을 받고, 이를 처리한 후 결과(반환 값)를 돌려줄 수 있어 코드 재사용과 분업에 용이하다. 함수 선언 및 구현 함수 정의: 함수를 정의할 때는 함수 이름과 괄호 안에 입력 매개변수를 명시하며, 중괄호 또는 들여쓰기로 본문을 구분한다.
...</p></div><footer class=entry-footer><span title='2024-12-05 01:09:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Functions" href=https://buenhyden.github.io/posts/programming-languages/programming-language-theory/syntax-and-semantics/language-syntax/functions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분산 원장 기술(Distributed Ledger Technology, DLT)</h2></header><div class=entry-content><p>분산 원장 기술(Distributed Ledger Technology, DLT) 분산 원장 기술(Distributed Ledger Technology, DLT)은 중앙 관리자 없이 네트워크 참여자들이 공동으로 데이터를 기록·검증·관리하는 디지털 시스템이다.
블록체인, DAG(Directed Acyclic Graph), 해시그래프 등 다양한 형태로 구현되며, 금융·물류·의료 등 다양한 산업에서 혁신을 주도하고 있다.
분산 원장 기술은 단순한 데이터 저장 방식을 넘어 신뢰의 패러다임을 재정의하고 있다.
현재, 확장성 해결을 위한 레이어2 솔루션(라이트닝 네트워크 등)과 규제 체계 정립이 활발히 진행 중이며, Web3와 메타버스 생태계의 핵심 인프라로 자리매김할 전망이다.
...</p></div><footer class=entry-footer><span title='2024-12-04 07:14:00 +0000 UTC'>December 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 원장 기술(Distributed Ledger Technology, DLT)" href=https://buenhyden.github.io/posts/emerging-technologies/blockchain-and-distributed-ledger/blockchain/distributed-ledger-technology/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Stylesheet</h2></header><div class=entry-content><p>Stylesheet 웹 개발에서 스타일시트는 웹 페이지의 시각적 표현을 정의하는 중요한 기술.
스타일시트는 HTML 문서의 레이아웃, 디자인, 시각적 효과를 제어하는 규칙들의 집합이다.
스타일시트는 웹 페이지의 모든 시각적 요소를 정의한다.
기본적인 CSS 스타일시트의 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 기본 레이아웃 스타일 */ .container { max-width: 1200px; margin: 0 auto; padding: 20px; /* 이 스타일은 콘텐츠를 중앙에 배치하고 적절한 여백을 제공합니다 */ } /* 텍스트 스타일링 */ .article-text { font-family: 'Arial', sans-serif; line-height: 1.6; color: #333; /* 읽기 쉬운 텍스트 스타일을 정의합니다 */ } 스타일시트는 시간이 지나면서 더욱 발전했고, 현재는 여러 가지 고급 기능을 제공하는 다양한 방식이 존재한다.
프리프로세서(Preprocessor) 스타일시트의 예시를 보자:
...</p></div><footer class=entry-footer><span title='2024-12-01 06:58:00 +0000 UTC'>December 1, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stylesheet" href=https://buenhyden.github.io/posts/frontend-development/styling-and-design-systems/stylesheet/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Framework vs. Library</h2></header><div class=entry-content><p>Framework vs. Library 프레임워크와 라이브러리는 소프트웨어 개발에서 필수적인 구성 요소로, 각각의 목적과 사용 방식이 다르다. 라이브러리는 특정 기능을 제공하는 코드 집합으로 개발자가 직접 호출해 사용한다. 반면, 프레임워크는 애플리케이션의 구조와 흐름을 정의하며, 개발자가 작성한 코드를 필요에 따라 호출하는 ’ 제어의 역전 ’ 원칙을 따른다. 이 차이는 시스템 설계의 핵심 원리와 실무 적용에 큰 영향을 미치며, 각 도구의 장단점, 적용 사례, 최적화 및 실무 적용 시 고려사항 등에서 뚜렷하게 드러난다.
핵심 개념 제어의 역전 (Inversion of Control, IoC): 프로그램의 제어 흐름이 전통적인 방식과 반대로 동작하는 설계 원칙 Hollywood Principle: “Don’t call us, we’ll call you” - 프레임워크가 개발자 코드를 호출 의존성 주입 (Dependency Injection): 객체의 의존성을 외부에서 주입하는 방식 애플리케이션 프레임워크 (Application Framework): 특정 도메인의 애플리케이션 개발을 위한 포괄적인 구조 코드 라이브러리 (Code Library): 재사용 가능한 함수와 클래스의 집합 Framework vs. Library 비교 구분 프레임워크 (Framework) 라이브러리 (Library) 정의 애플리케이션 개발을 위한 구조와 제어 흐름을 제공하는 소프트웨어 플랫폼 특정 기능을 수행하는 코드 집합으로, 필요 시 개발자가 직접 호출 제어 흐름 (Control Flow) 프레임워크가 전체 흐름을 제어하며, 개발자의 코드를 호출 (제어의 역전: IoC) 개발자가 라이브러리를 직접 호출하여 제어 흐름을 관리 사용 방식 프레임워크의 구조에 맞춰 코드를 작성하고, 확장 지점을 통해 기능 구현 필요한 기능만 선택적으로 가져와 호출 구조 제공 애플리케이션의 아키텍처 및 구성 방식을 정의 구조에 영향을 주지 않음 확장성 명확한 확장 포인트 제공 (예: Hook, 인터페이스 등) 함수 단위로 조합하여 사용 가능 유연성 프레임워크의 구조를 따르므로 상대적으로 유연성은 낮음 특정 기능 단위로 자유롭게 사용 가능 재사용성 특정 프레임워크에 종속적일 수 있음 다양한 프로젝트에서 재사용 가능함 예시 Spring, Angular, Django, React (의견 분분하지만 구조 제공 시 프레임워크로 분류되기도 함) Lodash, NumPy, jQuery, Requests 사용 시나리오 비교 구분 Framework Library 적합한 프로젝트 대규모, 복잡한 애플리케이션 특정 기능이 필요한 프로젝트 팀 규모 대규모 팀 (일관성 중요) 소규모 팀 (유연성 중요) 유지보수 프레임워크 업데이트에 의존 개별적으로 관리 가능 테스트 프레임워크 테스트 환경 사용 독립적인 단위 테스트 구조 및 아키텍처 Framework 아키텍처 graph TD A[Framework Core] --> B[Application Lifecycle] A --> C[Dependency Injection Container] A --> D[Configuration Management] A --> E[Plugin System] B --> F[Initialization] B --> G[Execution] B --> H[Cleanup] C --> I[Bean Factory] C --> J[Dependency Resolution] D --> K[XML/Annotation Config] D --> L[Environment Properties] E --> M[Extension Points] E --> N[Custom Components] F --> O[Developer Code] G --> O H --> O Framework 구성요소:
...</p></div><footer class=entry-footer><span title='2024-11-20 06:47:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Framework vs. Library" href=https://buenhyden.github.io/posts/software-engineering/principles/design-principles/inversion-of-control/framework-vs.-library/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Pipeline Pattern</h2></header><div class=entry-content><p>Data Pipeline Pattern 데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.
이 패턴은 데이터의 수집, 처리, 저장, 분석에 이르는 전체 과정을 효율적으로 관리하는 데 사용된다.
데이터 파이프라인 패턴을 효과적으로 구현하면 데이터 기반 의사결정을 지원하고, 비즈니스 인텔리전스를 향상시킬 수 있다. 각 조직의 요구사항과 데이터 특성에 맞는 최적의 패턴을 선택하고 구현하는 것이 중요하다.
https://www.informatica.com/blogs/data-processing-pipeline-patterns.html
데이터 파이프라인의 주요 구성요소 데이터 수집 (Data Ingestion)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 데이터를 추출한다. 실시간 또는 배치 방식으로 데이터를 수집할 수 있다. 데이터 처리 및 변환 (Data Processing and Transformation)
...</p></div><footer class=entry-footer><span title='2024-11-19 03:56:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Pipeline Pattern" href=https://buenhyden.github.io/posts/data-science-and-engineering/data-engineering/data-pipeline/data-pipeline-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>선택 정렬 (Selection Sort)</h2></header><div class=entry-content><p>선택 정렬 (Selection Sort) 선택 정렬은 가장 직관적이고 이해하기 쉬운 정렬 알고리즘 중 하나이다.
선택 정렬은 개념적으로 가장 단순한 정렬 알고리즘 중 하나로, 알고리즘을 처음 배우는 사람들에게 좋은 시작점이 된다. 비록 대규모 데이터에서는 효율적이지 않지만, 특정 상황에서는 실용적인 선택이 될 수 있다.
선택 정렬의 핵심 특징은 다음과 같다:
구현이 매우 간단합니다. 교환 연산의 수가 적습니다(최대 n-1번). 메모리 사용이 최소화된다. 입력 데이터의 상태와 관계없이 일정한 성능을 보인다. 더 효율적인 정렬 알고리즘이 많이 존재하지만, 선택 정렬은 그 단순함과 직관적인 접근 방식으로 알고리즘 학습에 중요한 역할을 한다. 또한 작은 데이터셋이나 특정 제약 조건이 있는 환경에서는 여전히 유용한 알고리즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 선택 정렬 (Selection Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>