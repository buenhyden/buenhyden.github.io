<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linux Permission</h2></header><div class=entry-content><p>Linux Permission Source: https://medium.com/@usamashafique00786/day-4-task-linux-permissions-and-access-control-lists-ef59cebf9324
File type: 파일 유형 type Description - normal file d directory l link p named pipe s socket c character device b block device Permissions: 각 파일에 접근해서 읽거나 쓰거나 실행할 권리를 갖는 소유자 / 그룹 / 다른 사용자로 나눠서 관리
Source: https://pamirwebhost.com/check-linux-file-permissions-with-ls/
Permission은 3개로 나눠서 관리 Description User 파일을 만든 소유주 Group 파일을 만든 소유주가 속한 그룹 Other 기타 사용자 Permission은 4가지에 대하여 구분 Permission 파일 디렉토리 r 파일에 대한 읽기 권한.열기, 읽기 허용 디렉토리 내의 파일을 나열할 수 있게 허용 w 파일에 대한 쓰기 권한.쓰기, 잘라내기 허용.이름 변경이나 파일 삭제 허용되지 않음. 파일 삭제나 파일 이름 변경 디렉토리 속성에 의해 결정 디렉토리 내의 파일들을 생성, 삭제, 이름 변경이 가능하도록 허용 x 파일에 대한 실행 권한.파일이 프로그램으로 처리되고 파일이 실행되도록 허용.스크립트 언어에서 작성된 프로그램 파일들은 읽기 가능으로 설정 되어 있어야만 실행 가능 디렉토리 내에서 탐색을 위해 이동할 수 있도록 허용(디렉토리에 들어올 수 있도록 허용) - r,w,x에 대한 권한이 없음을 표시 r,w,x에 대한 권한이 없음을 표시 Permission
Source: https://medium.com/@gumbershruti1119/day-6-file-permissions-and-access-control-lists-2126f994a5b8
...</p></div><footer class=entry-footer><span title='2024-10-19 15:39:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;220 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linux Permission" href=https://buenhyden.github.io/posts/computer-system/operating-system/linux/linux-permission/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Celery</h2></header><div class=entry-content><p>Celery Celery는 파이썬으로 작성된 분산 작업 큐 시스템이다.
주로 웹 애플리케이션에서 비동기 작업 처리와 작업 스케줄링을 위해 사용된다.
Celery는 파이썬으로 작성된 비동기 작업 큐/작업 스케줄러이다. 분산 메시지 전달을 기반으로 동작하며, 실시간 처리와 작업 스케줄링을 지원한다.
주요 역할:
비동기 작업 처리 실시간 작업 처리 예약된 작업 실행 분산 시스템에서의 작업 관리 Celery는 복잡한 비동기 작업 처리와 분산 시스템 구축에 매우 유용한 도구이다.
웹 애플리케이션의 성능을 향상시키고 확장성을 높이는 데 큰 도움이 된다.
...</p></div><footer class=entry-footer><span title='2025-01-29 07:04:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;747 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Celery" href=https://buenhyden.github.io/posts/programming-languages/python/library/queue/celery/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Keywords</h2></header><div class=entry-content><p>Keywords 키워드들은 JavaScript 프로그래밍의 기본 구성 요소이며, ECMAScript 표준의 일부이다.
각 키워드는 특정한 프로그래밍 목적을 위해 설계되었으며, 이들을 올바르게 이해하고 사용하는 것이 효과적인 JavaScript 프로그래밍의 기초가 된다.
선언 관련 키워드 키워드 설명 예시 var 변수 선언 (함수 스코프) var name = "John"; let 변수 선언 (블록 스코프) let age = 25; const 상수 선언 (재할당 불가) const PI = 3.14; function 함수 선언 function add(a, b) { return a + b; } class 클래스 선언 class Person { constructor() {} } 조건문 및 반복문 키워드 키워드 설명 예시 if 조건문 if (age > 18) { console.log("Adult"); } else if문의 대안 조건 else { console.log("Minor"); } switch 다중 분기 조건문 switch (value) { case 1: break; } case switch문의 각 경우 case "A": return "Excellent"; default switch문의 기본 경우 default: return "Invalid"; for 반복문 for (let i = 0; i &lt; 5; i++) {} while 조건기반 반복문 while (count &lt; 10) {} do 최소 한번 실행되는 반복문 do { count++; } while (count &lt; 5); 제어 흐름 키워드 키워드 설명 예시 break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 함수에서 값 반환 return result; throw 예외 발생 throw new Error("Invalid input"); try 예외처리 시도 블록 try { riskyOperation(); } catch 예외처리 블록 catch (error) { handleError(error); } finally 예외 발생 여부와 관계없이 실행 finally { cleanup(); } 객체 지향 프로그래밍 키워드 키워드 설명 예시 this 현재 객체 참조 this.name = name; super 부모 클래스 참조 super(name); new 객체 생성 new Date(); extends 클래스 상속 class Student extends Person {} static 클래스 레벨 멤버 정의 static count = 0; get getter 메서드 정의 get name() { return this._name; } set setter 메서드 정의 set name(value) { this._name = value; } 모듈 및 패키지 키워드 키워드 설명 예시 import 모듈 가져오기 import { useState } from 'react'; export 모듈 내보내기 export default class MyComponent {} from 모듈 출처 지정 import React from 'react'; as 모듈 별칭 지정 import * as utils from './utils'; 기타 키워드 키워드 설명 예시 typeof 데이터 타입 확인 typeof value === "string" instanceof 객체 타입 확인 obj instanceof Array void undefined 값 반환 void function() {} delete 객체 프로퍼티 삭제 delete object.property in 프로퍼티 존재 확인 "name" in object debugger 디버깅 중단점 debugger; 예약된 리터럴 키워드 설명 예시 true 논리 참 값 let isActive = true; false 논리 거짓 값 let isDisabled = false; null 값이 없음을 나타내는 객체 let value = null; undefined 정의되지 않은 값 let value = undefined; 엄격 모드 키워드 키워드 설명 예시 “use strict” 엄격 모드 선언 "use strict"; // 코드의 시작 부분 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-29 03:18:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;424 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Keywords" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/keywords/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Java Keywords</h2></header><div class=entry-content><p>Keyword 키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.
변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.
이들을 올바르게 이해하고 사용하는 것이 효과적인 Java 프로그래밍의 기초가 된다.
각 키워드의 특징과 주의사항:
모든 키워드는 소문자로만 작성된다. 키워드는 식별자(변수명, 메서드명 등)로 사용할 수 없다. 일부 키워드는 특정 컨텍스트에서만 의미를 가진다. 예약어 중 일부는 현재 사용되지 않지만 향후 사용을 위해 예약되어 있다. 데이터 타입 키워드 키워드 설명 예시 byte 8비트 정수형 (-128 ~ 127) byte b = 100; short 16비트 정수형 (-32,768 ~ 32,767) short s = 1000; int 32비트 정수형 int i = 10000; long 64비트 정수형 long l = 100000L; float 32비트 단정도 실수형 float f = 3.14f; double 64비트 배정도 실수형 double d = 3.14159; boolean 논리형 (true/false) boolean flag = true; char 16비트 유니코드 문자 char c = 'A'; void 반환값이 없음을 나타냄 void method() {} 제어문 키워드 키워드 설명 예시 if 조건문 시작 if (x > 0) {} else if문의 대안 경로 else {} switch 다중 분기문 시작 switch(value) {} case switch문의 각 경우 case 1: default switch문의 기본 경우 default: for 반복문 for (int i = 0; i &lt; n; i++) while 조건 기반 반복문 while (condition) do do-while 반복문 시작 do {} while(); break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 메소드에서 값 반환/종료 return value; 클래스 관련 키워드 키워드 설명 예시 class 클래스 정의 public class MyClass {} interface 인터페이스 정의 interface MyInterface {} extends 클래스/인터페이스 상속 class Child extends Parent {} implements 인터페이스 구현 class MyClass implements Interface {} enum 열거형 정의 enum Direction {NORTH, SOUTH} this 현재 인스턴스 참조 this.value = value; super 상위 클래스 참조 super.method(); new 객체 생성 new Object(); instanceof 객체 타입 검사 obj instanceof String 접근 제어 키워드 키워드 설명 예시 public 전체 접근 허용 public class Public {} private 클래스 내부만 접근 가능 private int value; protected 패키지와 자식 클래스 접근 가능 protected void method() {} default 패키지 내부만 접근 가능 int value; (키워드 생략) 제어자 키워드 키워드 설명 예시 static 클래스 레벨 멤버 정의 static int count; final 변경 불가 선언 final int MAX = 100; abstract 추상 클래스/메소드 선언 abstract class Abstract {} synchronized 스레드 동기화 synchronized void method() {} volatile 메모리 직접 접근 변수 volatile boolean flag; transient 직렬화 제외 필드 transient int temp; native 네이티브 메소드 선언 native void method(); strictfp 엄격한 부동소수점 연산 strictfp class Math {} 예외 처리 키워드 키워드 설명 예시 try 예외 발생 가능 블록 try {} catch 예외 처리 블록 catch (Exception e) {} finally 항상 실행되는 블록 finally {} throw 예외 발생 throw new Exception(); throws 예외 선언 void method() throws Exception {} assert 조건 검증 assert x > 0; 패키지 관련 키워드 키워드 설명 예시 package 패키지 선언 package com.example; import 클래스 임포트 import java.util.List; 리터럴 키워드 키워드 설명 예시 true 논리 참 값 boolean t = true; false 논리 거짓 값 boolean f = false; null 참조 없음 Object obj = null; 예약된 키워드 (미사용) 키워드 설명 const 상수 (사용되지 않음) goto 이동 (사용되지 않음) 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-29 02:56:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;503 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Java Keywords" href=https://buenhyden.github.io/posts/programming-languages/java/concepts/keywords/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOC 2</h2></header><div class=entry-content><p>SOC 2 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-28 13:04:00 +0000 UTC'>January 28, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOC 2" href=https://buenhyden.github.io/posts/qa/standards-and-policies/soc-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PCI DSS</h2></header><div class=entry-content><p>PCI DSS 참고 및 출처</p></div><footer class=entry-footer><span title='2025-01-28 13:03:00 +0000 UTC'>January 28, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PCI DSS" href=https://buenhyden.github.io/posts/qa/standards-and-policies/pci-dss/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Allocation Policy</h2></header><div class=entry-content><p>Allocation Policy Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.
이 정책은 시스템의 성능과 효율성에 큰 영향을 미치므로 신중하게 선택해야 한다.
Cache Allocation Policy의 주요 유형과 특징 Write-Allocate (Fetch-on-Write)
Write-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우(write miss), 먼저 해당 블록을 캐시로 가져온 후 쓰기 작업을 수행한다. 이 방식은 후속 읽기 작업이 캐시에서 바로 데이터를 찾을 수 있어 읽기 성능을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;295 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Allocation Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/allocation-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prefetch Policy</h2></header><div class=entry-content><p>Prefetch Policy Cache Policy의 Prefetch Policy는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략이다.
이 정책은 시스템의 성능을 향상시키기 위해 사용되며, 특히 데이터 접근이 반복적이거나 예측 가능한 경우에 효과적이다.
Prefetching은 프로그램이 실제로 데이터에 접근하기 전에 미리 데이터를 메모리로 가져오는 기술이다.
이를 통해 캐시 미스를 줄이고, 데이터 접근 속도를 높이며, 전반적인 시스템 성능을 개선할 수 있다.
Prefetch Policy는 이러한 prefetching 작업을 어떻게 수행할지를 결정하는 규칙이나 방법론을 의미한다.
Prefetch Policy는 캐시 시스템에서 성능 향상을 위한 중요한 전략이다.
하드웨어, 소프트웨어 또는 컴파일러 수준에서 구현될 수 있으며, 다양한 유형의 prefetching 기법이 존재한다. 적절한 prefetch 정책을 선택하고 구현함으로써 시스템 성능을 크게 개선할 수 있으며, 데이터 접근 패턴과 요구사항에 맞춰 최적화하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;358 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prefetch Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/prefetch-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Replacement Policy</h2></header><div class=entry-content><p>Replacement Policy Cache Replacement Policy(캐시 교체 정책) 는 캐시 메모리에서 새로운 데이터를 저장하기 위해 기존의 데이터를 교체할 때 어떤 데이터를 제거할지를 결정하는 규칙이다.
캐시는 한정된 크기를 가지므로, 새로운 데이터가 들어올 때 기존의 데이터를 교체해야 한다. 이때 어떤 데이터를 선택할지는 시스템의 성능에 큰 영향을 미친다.
Cache Replacement Policy는 캐시 메모리의 효율성을 극대화하는 데 중요한 역할을 한다. LRU, FIFO, LFU 등 다양한 정책들이 있으며, 각 정책은 특정 상황과 요구 사항에 따라 장단점이 다르다.
적절한 교체 정책을 선택함으로써 시스템의 성능을 개선하고 데이터 접근 속도를 높일 수 있다. 캐시를 효과적으로 관리하기 위해서는 워크로드 특성과 시스템 요구 사항을 면밀히 분석하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Replacement Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/replacement-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Write Policy</h2></header><div class=entry-content><p>Write Policy Cache Policy의 Write Policy(쓰기 정책) 는 캐시 메모리에서 데이터를 쓰는 방식과, 캐시에 저장된 데이터가 메인 메모리와 어떻게 동기화될지를 결정하는 규칙을 의미한다.
이 정책은 데이터 일관성과 시스템 성능에 중요한 영향을 미친다.
Write Policy는 캐싱 시스템의 성능과 일관성에 중요한 영향을 미치는 요소이다. Write-Through와 Write-Back은 각각 장단점이 있으며, 워크로드 특성과 요구사항에 따라 적절한 정책을 선택해야 한다. 또한, Write Allocate와 No Write Allocate 같은 추가적인 처리 방식을 조합하여 최적의 결과를 얻을 수 있다. 올바른 정책 선택은 시스템의 효율성을 극대화하고 사용자 경험을 향상시키는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2025-01-23 10:53:00 +0000 UTC'>January 23, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;565 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Write Policy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-policy/write-policy/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/2/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>