<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>테스트 커버리지 (Test Coverage)</h2></header><div class=entry-content><p>테스트 커버리지 (Test Coverage) 테스트 커버리지는 테스트 대상 시스템이나 소프트웨어에 대해 얼마나 충분한 테스트가 수행되었는지를 나타내는 척도. 즉, 작성된 테스트 코드가 실제 프로덕션 코드를 얼마나 검증하고 있는지를 백분율로 표현한다.
테스트 커버리지를 측정하기 위해서는 실제로 코드가 실행되어야 하므로 테스트 커버리지는 기본적으로 동적 테스팅에 해당한다.
그리고, 테스트 커버리지를 측정하기 위해서는 코드의 내부 구조를 알아야 한다.
예를 들어:
구문 커버리지를 측정하려면 어떤 코드 라인이 실행되었는지 알아야 한다. 분기 커버리지를 측정하려면 조건문의 각 분기가 실행되었는지 알아야 한다. 경로 커버리지를 측정하려면 코드의 모든 가능한 실행 경로를 알아야 한다.
이러한 특성 때문에 테스트 커버리지는 화이트박스 테스팅 기법으로 분류된다. 테스트 커버리지가 실제 코드 실행을 통해(동적) 코드의 내부 구조를 분석하여(화이트박스) 테스트의 완성도를 측정하는 도구이다.
테스트 커버리지 자체는 측정 도구이며, 이를 측정하는 과정에서 정적 분석 도구를 보조적으로 사용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-09 09:47:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;544 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테스트 커버리지 (Test Coverage)" href=https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/test-coverage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Halstead Complexity</h2></header><div class=entry-content><p>Halstead Complexity Halstead 복잡도는 1977년 Maurice Howard Halstead가 제안한 소프트웨어 메트릭으로, 프로그램의 복잡성을 연산자(operators)와 피연산자(operands)의 수를 기반으로 측정한다.
이는 프로그램의 구현 난이도와 이해도를 정량적으로 평가하는 방법을 제공한다.
코드의 구현을 반영하지만 특정 플랫폼에서의 실행과는 독립적이다.
기본 측정 요소:
프로그램의 기본 요소는 다음과 같이 정의된다:
n1: 고유 연산자의 수 n2: 고유 피연산자의 수 N1: 총 연산자의 출현 횟수 N2: 총 피연산자의 출현 횟수
예를 들어, 다음 코드를 살펴보자. 1 sum = a + b * 2; 이 코드에서:
...</p></div><footer class=entry-footer><span title='2024-11-09 09:43:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;387 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Halstead Complexity" href=https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/halstead-complexity/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>순환 복잡도 (Cyclomatic Complexity)</h2></header><div class=entry-content><p>순환 복잡도 (Cyclomatic Complexity) 순환 복잡도는 1976년 Thomas McCabe가 제안한 메트릭으로, 프로그램의 논리적 복잡성을 정량적으로 측정하는 지표이다.
코드 내의 독립적인 경로의 수를 측정하여, 해당 코드를 완전히 테스트하기 위해 필요한 최소한의 테스트 케이스 수를 나타낸다.
순환 복잡도의 계산 방법은 다음과 같다:
V(G) = E - N + 2P
여기서:
E는 제어 흐름 그래프의 엣지(연결선) 수 N은 노드(구문) 수 P는 연결된 컴포넌트 수(일반적으로 1) 또는 더 간단하게:
V(G) = 분기문의 수 + 1
여기서 분기문은 if, while, for, case 등의 조건문을 의미한다.
...</p></div><footer class=entry-footer><span title='2024-11-09 07:12:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1071 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 순환 복잡도 (Cyclomatic Complexity)" href=https://buenhyden.github.io/posts/qa/quality-strategy-and-planning/quality-metric/cyclomatic-complexity/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spring</h2></header><div class=entry-content><p>Spring Spring은 Java 기반의 현대적인 엔터프라이즈 애플리케이션 개발을 위한 포괄적인 프레임워크.
Spring은 웹 프레임워크가 아닌 일반 프레임워크.
그 이유는:
범위의 차이
웹 프레임워크: 웹 애플리케이션 개발에 특화 (예: Django, Flask) Spring: 웹 외에도 다양한 종류의 애플리케이션 개발 가능 기능의 포괄성
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Spring으로 웹이 아닌 일반 애플리케이션도 개발 가능 @SpringBootApplication public class BatchProcessingApplication { @Scheduled(fixedRate = 1000) public void processData() { // 배치 처리 로직 } } // 데스크톱 애플리케이션도 가능 @SpringBootApplication public class DesktopApplication extends Application { @Override public void start(Stage stage) { // JavaFX UI 로직 } } 모듈성
Spring은 필요한 기능만 선택적으로 사용할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-07 09:52:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;947 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spring" href=https://buenhyden.github.io/posts/programming-languages/java/framework/spring/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spring Boot</h2></header><div class=entry-content><p>Spring Boot Spring Boot는 Spring 프레임워크를 기반으로 한 Java 애플리케이션 개발을 더욱 쉽고 빠르게 만들어주는 도구
주요 특징과 장점 자동 구성 (Auto Configuration) Spring Boot는 @SpringBootApplication 어노테이션을 통해 자동 구성 기능을 제공한다.
이는 클래스패스에 있는 라이브러리를 기반으로 애플리케이션을 자동으로 설정하여 개발자가 수동으로 빈(Bean)을 구성할 필요성을 줄여준다.
독립 실행형 (Standalone) Spring Boot 애플리케이션은 외부 서버에 의존하지 않고 독립적으로 실행될 수 있다.
내장된 서버(예: Tomcat, Jetty, Undertow)를 포함하고 있어 별도의 웹 애플리케이션 서버 설치 없이 애플리케이션을 실행할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-07 04:36:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;462 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spring Boot" href=https://buenhyden.github.io/posts/programming-languages/java/web-framework/spring-boot/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Junit</h2></header><div class=entry-content><p>Junit Java 프로그래밍 언어를 위한 가장 널리 사용되는 단위 테스트(Unit Testing) 프레임워크.
소프트웨어 개발 과정에서 코드의 품질을 보장하고 버그를 사전에 발견하는 데 중요한 역할을 한다.
JUnit은 Kent Beck과 Erich Gamma에 의해 1997년에 처음 개발되었.
당시 소프트웨어 개발에서 테스트의 중요성이 점점 커지면서, 개발자들이 쉽게 사용할 수 있는 테스트 프레임워크의 필요성이 대두되었.
현재는 JUnit 5 버전까지 발전했으며, 각 버전마다 더욱 강력하고 사용하기 쉬운 기능들이 추가되었다.
Spring Boot 2.2.0 버전부터는 기본적으로 JUnit 5를 지원한다.
...</p></div><footer class=entry-footer><span title='2024-11-07 00:23:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;564 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Junit" href=https://buenhyden.github.io/posts/programming-languages/java/testing/junit/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cypress</h2></header><div class=entry-content><p>Cypress Cypress는 JavaScript 기반의 강력한 프론트엔드 테스팅 프레임워크.
웹 애플리케이션의 엔드투엔드(E2E) 테스트를 위해 설계되었다.
주요 특징 브라우저 내 실행: Cypress는 애플리케이션과 동일한 실행 루프에서 작동하여 더 빠르고 안정적인 테스트를 가능하게 한다. 자동 대기: 요소가 나타나거나 애니메이션이 완료될 때까지 자동으로 기다려 별도의 대기 시간 설정이 필요 없다. 실시간 리로드: 테스트 파일을 저장하면 자동으로 테스트를 다시 실행한다. 디버깅 용이성: 시간 여행 디버깅, 스냅샷 기능 등을 통해 테스트 실패 원인을 쉽게 파악할 수 있다. 네트워크 트래픽 제어: 웹 트래픽을 읽고 수정할 수 있어 다양한 시나리오 테스트가 가능하다. 장점 속도와 안정성: 브라우저 내에서 직접 실행되어 빠르고 안정적인 테스트가 가능하다. 사용 편의성: 직관적인 API와 풍부한 문서를 제공하여 쉽게 학습하고 사용할 수 있다. 크로스 브라우저 테스팅: Chrome, Firefox, Edge 등 다양한 브라우저에서 테스트 가능하다. 실시간 디버깅: 테스트 실행 중 실시간으로 문제를 식별하고 디버깅할 수 있다. CI/CD 통합: 지속적 통합 및 배포 파이프라인과 쉽게 통합된다. 잠재적 한계 JavaScript/Node.js 생태계에 최적화 크로스 브라우저 지원이 제한적 모바일 웹 테스트에는 다소 제한적 사용 방법 설치: npm을 통해 Cypress를 설치한다.
...</p></div><footer class=entry-footer><span title='2024-11-06 23:53:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cypress" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/cypress/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Jest</h2></header><div class=entry-content><p>Jest Facebook에서 개발한 인기 있는 JavaScript 테스팅 프레임워크로, JavaScript 코드의 단위 테스트(Unit Test)를 위해 설계되었다.
주로 React 애플리케이션과 함께 사용되지만, Vue, Angular, Node.js 등 다양한 JavaScript 프로젝트에서도 널리 사용된다.
주요 특징 간단한 설정: 추가 설정 없이 바로 사용 가능한 “제로 구성” 철학을 따른다. 빠른 실행: 병렬 처리를 통해 테스트를 빠르게 실행한다. 모의(Mock) 기능: 복잡한 의존성을 가진 코드도 쉽게 테스트할 수 있다. 코드 커버리지: 내장된 코드 커버리지 도구를 제공한다. 스냅샷 테스팅: UI 컴포넌트의 변경사항을 쉽게 추적할 수 있다. 장점 통합된 솔루션: 테스트 러너, 단언 라이브러리, 모의 기능을 모두 제공한다. 쉬운 사용법: 직관적인 API로 테스트 작성이 용이하다. 풍부한 매처(Matcher) 함수: 다양한 비교 함수를 제공한다. 활발한 커뮤니티: 지속적인 업데이트와 지원을 받을 수 있다. 단점 및 한계 브라우저 환경 테스트의 제한: JSDOM을 사용하여 브라우저 환경을 시뮬레이션하지만, 실제 브라우저와는 차이가 있다. 학습 곡선: 고급 기능을 사용하기 위해서는 추가적인 학습이 필요할 수 있다. 설정의 복잡성: 대규모 프로젝트에서는 설정이 복잡해질 수 있다. 사용 방법 설치
...</p></div><footer class=entry-footer><span title='2024-11-06 23:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;446 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Jest" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/jest/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MochaJS</h2></header><div class=entry-content><p>MochaJS Mocha.js는 Node.js와 브라우저 환경 모두에서 동작하는 유연하고 강력한 JavaScript 코드의 단위 테스트, 통합 테스트 등을 위한 JavaScript 테스팅 프레임워크.
2011년 TJ Holowaychuk에 의해 개발되었으며, 개발자들에게 테스트 작성의 자유와 유연성을 제공한다.
주요 특징 유연한 테스트 스타일
Mocha는 다양한 어설션(assertion) 라이브러리와 함께 사용할 수 있어, 개발자의 선호에 따라 테스트 스타일을 커스터마이징할 수 있다.
대표적으로 Chai, Should.js, Expect.js 등의 라이브러리와 호환된다.
비동기 테스트 지원
비동기 코드 테스트에 특화되어 있으며, Promise, async/await, 콜백 등 다양한 비동기 패턴을 쉽게 테스트할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-06 23:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;566 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MochaJS" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/mochajs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Playwright</h2></header><div class=entry-content><p>Playwright Playwright는 Microsoft에서 개발한 현대적이고 강력한 웹 자동화 및 테스팅 라이브러리.
크로스 브라우저, 크로스 플랫폼 웹 테스팅을 위해 설계되었으며, Chromium, Firefox, WebKit을 포함한 주요 브라우저들을 단일 API로 제어할 수 있다.
안정적이고 신뢰할 수 있는 E2E 테스트 환경을 제공하며, 복잡한 애플리케이션에서도 안정적으로 동작한다.
주요 특징 다중 브라우저 지원
Playwright는 다음 브라우저들을 완벽하게 지원한다:
Google Chrome Microsoft Edge Mozilla Firefox Apple Safari (WebKit)
이는 개발자들이 여러 브라우저에서 일관된 테스트를 수행할 수 있게 해준다. 최신 웹 기술 대응
현대 웹 애플리케이션의 복잡한 시나리오를 처리할 수 있는 고급 기능 제공:
...</p></div><footer class=entry-footer><span title='2024-11-06 23:52:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;512 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Playwright" href=https://buenhyden.github.io/posts/programming-languages/javascript/testing/playwright/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/13/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/15/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>