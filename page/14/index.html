<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern vs Observer Pattern</h2></header><div class=entry-content><p>Mediator Pattern Vs Observer Pattern Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.
Mediator 패턴:
객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴 객체 간 결합도를 낮추고 상호작용을 중앙 집중화함 복잡한 다대다 관계를 단순화하는 데 유용 Observer 패턴:
객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴 주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함 상태 변경에 대한 효율적인 알림 메커니즘을 제공 Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 객체 간의 결합도를 줄이고 상호작용 로직을 집중시키는 데 적합하다. Observer 패턴은 상태 변화에 따른 자동 알림 및 실시간 동기화를 구현할 때 적합하며, 이벤트 기반 시스템에 자주 사용된다. 두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, Mediator는 상호작용을 캡슐화하고 Observer는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-24 00:49:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern vs Observer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/mediator-pattern-vs-observer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Test vs End-to-End Test</h2></header><div class=entry-content><p>System Test vs. End-to-End Test System Testing과 End-to-End Testing은 소프트웨어 테스팅 과정에서 사용되는 두 가지 중요한 테스트 방법이다. 이 두 방법은 소프트웨어의 품질을 보장하기 위해 사용되지만, 그 범위와 목적에 차이가 있다.
비교 항목 System Test End-to-End Test 정의 전체 시스템이 요구사항 명세서에 따라 정상적으로 동작하는지 검증하는 테스트 실제 사용자의 시나리오에 따라 처음부터 끝까지의 전체 비즈니스 프로세스를 검증하는 테스트 테스트 범위 시스템의 기능적/비기능적 요구사항 전체 사용자 관점에서의 전체 비즈니스 프로세스 흐름 수행 시점 통합 테스트 완료 후, 인수 테스트 전 모든 하위 단계 테스트 완료 후 최종 단계 테스트 환경 테스트 환경 (실제 환경과 유사하게 구성) 실제 운영 환경과 동일한 환경 테스트 주체 QA 팀, 테스트 엔지니어 QA 팀, 비즈니스 분석가, 때로는 실제 최종 사용자 검증 대상 시스템의 모든 기능, 성능, 보안 등 실제 사용자의 업무 흐름과 시나리오 테스트 데이터 테스트용 데이터 실제 운영 데이터와 유사한 데이터 테스트 관점 기술적 관점과 비즈니스 관점 모두 포함 순수하게 비즈니스 관점, 사용자 경험 중심 자동화 수준 중간~높음 낮음~중간 테스트 케이스 작성 기준 요구사항 명세서 기반 사용자 시나리오 기반 결함 발견 초점 시스템 내부의 기술적 결함 비즈니스 프로세스 상의 결함 테스트 비용 중간 높음 실행 시간 비교적 짧음 길음 (전체 프로세스 수행) 유지보수 복잡도 중간 높음 테스트 준비 사항 테스트 환경, 테스트 데이터, 테스트 케이스 전체 시스템 구성, 외부 시스템 연동, 실제 데이터 주요 목적 시스템의 완전성과 정확성 검증 비즈니스 프로세스의 정상 작동 검증 피드백 대상 개발팀, QA 팀 비즈니스 팀, 최종 사용자 커버리지 중점 기능 커버리지 비즈니스 프로세스 커버리지 이러한 차이점들은 각각의 테스트가 서로 다른 목적과 관점에서 수행되면서도 상호 보완적인 역할을 한다는 것을 보여준다.
System Test가 시스템의 기술적인 완성도를 검증하는 데 중점을 둔다면, End-to-End Test는 실제 사용자의 관점에서 전체 비즈니스 프로세스가 정상적으로 작동하는지를 검증하는 데 초점을 맞춘다.
...</p></div><footer class=entry-footer><span title='2024-11-05 02:11:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Test vs End-to-End Test" href=https://buenhyden.github.io/posts/quality-assurance/testing-techniques/system-test-vs-end-to-end-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동적테스트(Dynamic Test) vs 정적테스트(Static Test)</h2></header><div class=entry-content><p>동적테스트(Dynamic Test)와 정적테스트(Static Test) 동적테스트 (Dynamic Test)과 정적테스트(Static Test)
소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.
이는 크게 정적 테스팅과 동적 테스팅으로 나눌 수 있다.
효과적인 테스팅을 위해서는 두 방식을 적절히 조합하여 사용하는 것이 중요하다.
예를 들어:
개발 초기 단계: 정적 테스팅으로 기본적인 문제 해결 코드 리뷰로 설계 문제 조기 발견 개발 중기: 단위 테스트로 개별 기능 검증 통합 테스트로 모듈 간 상호작용 확인 개발 후기: 시스템 테스트로 전체 기능 검증 성능 테스트로 실제 환경 적합성 확인 동적 테스트 (Dynamic Test) 소프트웨어 테스트 기법 중 하나로, 프로그램을 실제로 실행하면서 소프트웨어의 동작을 분석하고 평가하는 방법.
소프트웨어의 코드를 직접 실행시키며 수행하는 테스트 유형의 총칭.
소프트웨어의 런타임 동작을 관찰하고 평가하여 기능, 성능, 안정성 등을 검증한다.
...</p></div><footer class=entry-footer><span title='2024-11-05 02:35:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동적테스트(Dynamic Test) vs 정적테스트(Static Test)" href=https://buenhyden.github.io/posts/quality-assurance/dynamic-test-vs-static-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns vs. Creational Design Patterns vs. Structural Design Patterns 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Javascript</h2></header><div class=entry-content><p>NodeJS vs. Javascript JavaScript는 웹 페이지에 동적인 기능을 추가하기 위해 만들어진 프로그래밍 언어이다.
주요 특징은 다음과 같다:
객체 기반의 스크립트 언어이다. 동적이며 타입을 명시할 필요가 없는 인터프리터 언어이다. 이벤트 중심의 프로그래밍이 가능하다. 웹 브라우저에서 실행되며, HTML 문서와 함께 사용된다. 프로토타입 기반의 객체지향 프로그래밍을 지원한다. 1 2 3 4 5 6 7 8 9 10 // JavaScript 예시 // DOM 조작 document.getElementById('myButton').addEventListener('click', function() { alert('버튼이 클릭되었습니다!'); }); // 비동기 처리 fetch('https://api.example.com/data') .then(response => response.json()) .then(data => console.log(data));**** Node.js는 JavaScript를 서버 측에서 실행할 수 있게 해주는 런타임 환경이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:33:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. Javascript" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-javascript/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>import vs require</h2></header><div class=entry-content><p>Import vs. Require 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-23 03:21:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to import vs require" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/import-vs-require/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) vs. Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) vs. Web Server Web Server와 Application Server는 모두 클라이언트 요청을 처리하고 응답을 반환하는 서버이지만, 역할과 기능에서 중요한 차이가 있다. 이 두 서버는 종종 함께 사용되며, 서로 보완적인 관계를 형성한다.
정의 및 주요 역할 Web Server 주로 정적 콘텐츠(HTML, CSS, JavaScript, 이미지 등)를 제공하는 서버이다. HTTP 프로토콜을 기반으로 클라이언트 요청에 응답한다. 정적 리소스를 빠르게 처리하며, 동적 요청은 Application Server로 전달하는 역할도 수행한다. Application Server 동적 콘텐츠를 생성하고 비즈니스 로직을 처리하는 서버이다. 데이터베이스와 상호작용하거나 애플리케이션 로직을 실행하여 클라이언트 요청에 따라 맞춤형 데이터를 반환한다. 동적 콘텐츠를 처리하기 때문에 복잡한 트랜잭션 관리 및 비즈니스 로직 수행이 가능하다. 기능 Web Server 정적 콘텐츠 제공: HTML, CSS, 이미지 파일 등. 요청 전달: 동적 콘텐츠 요청은 Application Server로 전달. 캐싱 및 로드 밸런싱: 웹사이트 성능 최적화를 위한 기능 제공. Application Server 동적 콘텐츠 생성: 클라이언트 요청에 따라 실시간으로 데이터를 생성. 비즈니스 로직 처리: 데이터베이스와 통신하거나 복잡한 연산 수행. 트랜잭션 관리: 다중 사용자 환경에서 데이터 일관성을 유지. 사용 사례 Web Server
...</p></div><footer class=entry-footer><span title='2024-10-22 07:36:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server (WAS) vs. Web Server" href=https://buenhyden.github.io/posts/backend-development/web-infrastructure/web-application-servers/web-application-server-vs-web-server/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Strategy vs Cache Policy</h2></header><div class=entry-content><p>Cache Strategy vs. Cache Policy 캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.
이 둘은 상호보완적이지만 명확한 차이가 있다.
캐시 전략(Cache Strategy) 캐시 전략은 시스템 전체의 캐시 사용 방식을 결정하는 상위 레벨의 설계 접근법을 의미한다.
주로 다음과 같은 요소를 포함한다:
계층적 구조: L1, L2, L3 캐시로 이어지는 메모리 계층 구조 설계 분산 캐시: 여러 서버에 캐시를 분산하여 처리 능력 확장 데이터 프리페칭: 프로세서가 필요로 할 데이터를 미리 예측하여 캐시에 로드 클라이언트 측 캐싱: 사용자 브라우저에 데이터 저장으로 서버 부하 감소 예시: 멀티코어 프로세서에서 L3 캐시를 공유하여 코어 간 데이터 일관성 유지
...</p></div><footer class=entry-footer><span title='2024-09-30 15:24:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Strategy vs Cache Policy" href=https://buenhyden.github.io/posts/system-design/caching/cache-strategy-vs-cache-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>QA vs QC vs Testing</h2></header><div class=entry-content><p>Quality Assurance (QA) and Quality Control (QC) and Testing Quality Assurance (QA)는 제품이나 서비스의 품질을 보장하기 위한 계획적이고 체계적인 활동들의 집합이다.
QA는 프로세스 중심적이며, 품질 문제가 발생하기 전에 예방하는 것을 목표로 한다.
전체 개발 수명주기에 걸쳐 품질 기준과 절차를 수립하고 관리한다.
Quality Control (QC)는 개발된 제품이나 서비스가 정해진 품질 기준을 충족하는지 확인하는 활동이다.
QC는 제품 중심적이며, 실제 결과물을 검사하고 결함을 찾아내는 데 중점을 둔다.
주로 테스트와 검토를 통해 이루어진다.
Testing은 소프트웨어가 예상대로 작동하는지 확인하는 구체적인 실행 활동이다.
버그를 찾아내고, 시스템의 기능성과 성능을 검증하는 것이 주요 목적이다.
QC의 중요한 하위 활동으로 볼 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-05 07:13:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to QA vs QC vs Testing" href=https://buenhyden.github.io/posts/quality-assurance/quality-assurance-vs-quality-control-vs-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend-development/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/13/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/15/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>