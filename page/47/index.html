<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>용량 테스트 (Volume Test)</h2></header><div class=entry-content><p>용량 테스트 (Volume Test) 용량 테스트는 소프트웨어 시스템이 대량의 데이터를 처리할 때 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.
이는 시스템이 대규모 데이터를 효율적으로 처리할 수 있는지 검증하는 과정이다.
데이터베이스 시스템의 용량 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import time from database import DatabaseConnection from data_generator import DataGenerator class VolumeTest: def __init__(self): self.db = DatabaseConnection() self.data_generator = DataGenerator() self.metrics = [] def test_large_data_handling(self): """대용량 데이터 처리 테스트""" print("대용량 데이터 처리 테스트 시작…") # 테스트 데이터 생성 test_data = self.data_generator.generate_large_dataset( records=1000000, # 백만 건의 레코드 size_per_record="2KB" # 레코드당 2KB ) start_time = time.time() try: # 데이터 삽입 테스트 print("데이터 삽입 테스트 중…") self.test_bulk_insert(test_data) # 데이터 조회 테스트 print("데이터 조회 테스트 중…") self.test_data_retrieval() # 데이터 집계 테스트 print("데이터 집계 테스트 중…") self.test_data_aggregation() finally: execution_time = time.time() - start_time print(f"전체 테스트 소요 시간: {execution_time:f}초") def test_bulk_insert(self, data): """대량 데이터 삽입 성능 테스트""" batch_size = 10000 # 배치 크기 for i in range(0, len(data), batch_size): batch = data[i:i + batch_size] # 삽입 시간 측정 start_time = time.time() self.db.bulk_insert(batch) insert_time = time.time() - start_time # 성능 메트릭 기록 self.metrics.append({ 'operation': 'bulk_insert', 'batch_size': len(batch), 'execution_time': insert_time, 'records_per_second': len(batch) / insert_time }) 특징과 목적 용량 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-03 02:32:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;764 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 용량 테스트 (Volume Test)" href=https://buenhyden.github.io/posts/qa/testing-techniques/non-functional-testing/performance-test/volume-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>확장성 테스트 (Scalability Test)</h2></header><div class=entry-content><p>확장성 테스트 (Scalability Test) 확장성 테스트는 소프트웨어 시스템이 증가하는 부하나 규모에 얼마나 잘 대응할 수 있는지를 평가하는 성능 테스트의 한 유형이다.
이는 시스템의 확장 능력을 측정하고 검증하는 과정이다.
웹 서비스의 확장성 테스트 예시 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import time from concurrent.futures import ThreadPoolExecutor from monitoring import SystemMonitor class ScalabilityTest: def __init__(self): self.monitor = SystemMonitor() self.results = [] def test_vertical_scaling(self): """수직적 확장성 테스트 (단일 서버의 자원 증가에 따른 성능 변화 측정)""" # 서버 자원을 단계적으로 증가시키며 테스트 resource_configs = [ {"cpu_cores": 2, "memory": "2GB"}, {"cpu_cores": 4, "memory": "4GB"}, {"cpu_cores": 8, "memory": "8GB"} ] for config in resource_configs: # 서버 리소스 조정 self.adjust_server_resources(config) # 성능 측정 metrics = self.measure_performance() # 결과 기록 self.results.append({ "config": config, "metrics": metrics }) # 선형적 확장성 검증 self.verify_linear_scaling(config, metrics) def test_horizontal_scaling(self): """수평적 확장성 테스트 (서버 수 증가에 따른 성능 변화 측정)""" # 서버 인스턴스 수를 단계적으로 증가 for server_count in range(1, 6): # 서버 추가 self.add_server_instances(server_count) # 부하 테스트 실행 with ThreadPoolExecutor(max_workers=100) as executor: # 동시 요청 시뮬레이션 futures = [ executor.submit(self.simulate_request) for _ in range(1000) ] # 결과 수집 responses = [f.result() for f in futures] # 성능 메트릭 분석 self.analyze_scaling_metrics(server_count, responses) 특징과 목적 확장성 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-03 02:32:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;856 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 확장성 테스트 (Scalability Test)" href=https://buenhyden.github.io/posts/qa/testing-techniques/non-functional-testing/performance-test/scalability-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>스모크 테스트 (Smoke Test)</h2></header><div class=entry-content><p>스모크 테스트 (Smoke Test) 스모크 테스트는 소프트웨어의 가장 중요한 기능이 제대로 작동하는지 빠르게 확인하는 예비 테스트이다.
간단한 웹 애플리케이션의 스모크 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import requests import logging class WebAppSmokeTest: def __init__(self, base_url): self.base_url = base_url self.logger = logging.getLogger(__name__) def run_smoke_test(self): """기본 기능 스모크 테스트 실행""" test_results = { "homepage_access": self.test_homepage(), "login_page": self.test_login_page(), "basic_search": self.test_search_functionality(), "server_health": self.test_server_status() } # 테스트 결과 분석 failed_tests = [test for test, result in test_results.items() if result == False] if failed_tests: self.logger.error(f"스모크 테스트 실패: {failed_tests}") return False self.logger.info("모든 스모크 테스트 통과") return True def test_homepage(self): """홈페이지 접속 테스트""" try: response = requests.get(f"{self.base_url}/") return response.status_code == 200 except Exception as e: self.logger.error(f"홈페이지 접속 실패: {str(e)}") return False def test_login_page(self): """로그인 페이지 접속 테스트""" try: response = requests.get(f"{self.base_url}/login") return "로그인" in response.text except Exception as e: self.logger.error(f"로그인 페이지 접속 실패: {str(e)}") return False 특징과 목적 스모크 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-03 02:15:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1697 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스모크 테스트 (Smoke Test)" href=https://buenhyden.github.io/posts/qa/testing-techniques/functional-testing/smoke-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>엔드투엔드 테스트(End-to-End Test, E2E Test)</h2></header><div class=entry-content><p>엔드투엔드 테스트(End-to-End Test, E2E Test) 엔드투엔드 테스트는 소프트웨어 시스템을 처음부터 끝까지 검증하는 테스트 방법이다.
이는 사용자의 관점에서 전체 애플리케이션의 흐름을 테스트하여 모든 구성 요소가 올바르게 작동하는지 확인한다.
온라인 쇼핑몰의 엔드투엔드 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # Selenium을 사용한 E2E 테스트 예시 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC class ShoppingMallE2ETest: def setUp(self): # 브라우저 실행 및 초기 설정 self.driver = webdriver.Chrome() self.driver.get("https://example-shop.com") def test_complete_purchase_flow(self): # 1. 로그인 self.login("test@example.com", "password123") # 2. 상품 검색 search_box = self.driver.find_element(By.ID, "search") search_box.send_keys("노트북") search_box.submit() # 3. 상품 선택 product = WebDriverWait(self.driver, 10).until( EC.presence_of_element_located((By.CLASS_NAME, "product-item")) ) product.click() # 4. 장바구니 담기 add_to_cart = self.driver.find_element(By.ID, "add-to-cart") add_to_cart.click() # 5. 결제 진행 checkout_button = self.driver.find_element(By.ID, "checkout") checkout_button.click() # 6. 배송 정보 입력 self.fill_shipping_info({ "name": "홍길동", "address": "서울시 강남구", "phone": "010-1234-5678" }) # 7. 결제 완료 확인 confirmation = WebDriverWait(self.driver, 20).until( EC.presence_of_element_located((By.CLASS_NAME, "order-confirmation")) ) assert confirmation.is_displayed() # 8. 주문 내역 확인 order_number = confirmation.find_element(By.CLASS_NAME, "order-number").text assert len(order_number) > 0 특징과 목적 사용자 중심: 실제 사용자의 경험을 시뮬레이션한다. 전체 시스템 검증: 모든 구성 요소와 외부 종속성을 포함하여 테스트한다. 실제 환경 유사성: 프로덕션 환경과 유사한 조건에서 테스트를 수행한다. 테스트 범위 엔드투엔드 테스트는 다음과 같은 요소를 포함한다:
...</p></div><footer class=entry-footer><span title='2024-11-03 02:14:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;573 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 엔드투엔드 테스트(End-to-End Test, E2E Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/end-to-end-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>스파이크 테스트(Spike Test)</h2></header><div class=entry-content><p>스파이크 테스트(Spike Test) 스파이크 테스트는 시스템에 갑작스럽고 극단적인 부하를 주어 시스템의 반응을 측정하는 성능 테스트의 한 유형이다.
이는 마치 갑자기 많은 사람들이 한 번에 몰려드는 상황을 시뮬레이션하는 것과 비슷하다.
웹 서비스의 스파이크 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import time from concurrent.futures import ThreadPoolExecutor from monitoring import SystemMonitor class SpikeTest: def __init__(self): self.monitor = SystemMonitor() self.base_load = 100 # 기본 사용자 수 self.spike_load = 5000 # 스파이크 시 사용자 수 def run_spike_test(self): """스파이크 테스트 실행""" print("스파이크 테스트 시작…") # 1. 기본 부하 상태 측정 print("기본 부하 상태 측정 중…") base_metrics = self.measure_system_state(self.base_load) # 2. 스파이크 부하 생성 print(f"스파이크 발생: {self.spike_load}명의 동시 사용자 생성") spike_metrics = self.generate_spike_load() # 3. 복구 과정 모니터링 print("시스템 복구 과정 모니터링 중…") recovery_metrics = self.monitor_recovery() # 4. 결과 분석 self.analyze_results(base_metrics, spike_metrics, recovery_metrics) def measure_system_state(self, user_count): """시스템 상태 측정""" with ThreadPoolExecutor(max_workers=user_count) as executor: # 동시 요청 생성 futures = [ executor.submit(self.simulate_user_request) for _ in range(user_count) ] # 응답 수집 responses = [f.result() for f in futures] return { 'response_times': [r['response_time'] for r in responses], 'error_count': sum(1 for r in responses if r['error']), 'system_metrics': self.monitor.get_current_metrics() } 특징과 목적 스파이크 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-03 01:54:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;823 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스파이크 테스트(Spike Test)" href=https://buenhyden.github.io/posts/qa/testing-techniques/non-functional-testing/performance-test/spike-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>지속성 테스트(Endurance Test)</h2></header><div class=entry-content><p>지속성 테스트(Endurance Test) 지속성 테스트는 소프트웨어 시스템이 장기간 동안 지속적인 부하 상태에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.
웹 서버의 지속성 테스트 예시 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import time import psutil from datetime import datetime class EnduranceTest: def __init__(self, duration_hours=24): self.duration = duration_hours * 3600 # 시간을 초로 변환 self.metrics_history = [] def run_endurance_test(self): """24시간 지속성 테스트 실행""" print(f"테스트 시작: {datetime.now()}") start_time = time.time() while time.time() - start_time &lt; self.duration: # 시스템 메트릭 수집 metrics = self.collect_system_metrics() self.metrics_history.append(metrics) # 성능 저하 검사 if self.detect_performance_degradation(metrics): print("성능 저하 감지!") self.analyze_degradation() # 메모리 누수 검사 if self.detect_memory_leak(metrics): print("메모리 누수 감지!") self.analyze_memory_usage() time.sleep(60) # 1분마다 측정 def collect_system_metrics(self): """시스템 성능 지표 수집""" return { 'timestamp': datetime.now(), 'cpu_usage': psutil.cpu_percent(), 'memory_usage': psutil.virtual_memory().percent, 'disk_io': psutil.disk_io_counters(), 'response_time': self.measure_response_time() } def measure_response_time(self): """시스템 응답 시간 측정""" start_time = time.time() try: # 주요 API 엔드포인트 호출 response = requests.get('http://example.com/api/health') return time.time() - start_time except Exception as e: print(f"응답 시간 측정 실패: {str(e)}") return None 특징과 목적 지속성 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-03 01:53:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;670 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지속성 테스트(Endurance Test)" href=https://buenhyden.github.io/posts/qa/testing-techniques/non-functional-testing/performance-test/endurance-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Use Case Testing</h2></header><div class=entry-content><p>유즈케이스 테스팅 (Use Case Testing)) 유즈케이스 테스팅은 유즈케이스나 비즈니스 시나리오를 기반으로 테스트를 명세화하는 블랙박스 테스트 설계 기법이다.
이 방법은 액터와 시스템 간의 상호작용을 표현하고, 그 결과를 사용자에게 전달하는 과정을 테스트한다.
실제 예시를 통해 구체적으로 살펴보자.
온라인 쇼핑몰의 상품 주문 기능에 대한 유즈케이스 테스팅을 설계한다고 가정해보면:
기본 흐름(Basic Flow):
사용자가 상품을 장바구니에 추가한다 시스템이 장바구니 내용을 표시한다 사용자가 주문하기 버튼을 클릭한다 시스템이 배송 정보 입력 폼을 표시한다 사용자가 배송 정보를 입력한다 시스템이 결제 수단 선택 화면을 표시한다 사용자가 결제 수단을 선택하고 결제한다 시스템이 주문 완료 화면을 표시한다 대체 흐름(Alternative Flows):
...</p></div><footer class=entry-footer><span title='2024-11-02 17:11:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;486 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Use Case Testing" href=https://buenhyden.github.io/posts/qa/fundamentals/testing-approaches/black-box-testing/specification-based-test/use-case-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Requirements-based Testing</h2></header><div class=entry-content><p>요구사항 기반 테스팅 (Requirements-based Testing) 요구사항 기반 테스팅은 소프트웨어 요구사항 명세서(SRS)에 명시된 기능적, 비기능적 요구사항을 검증하는 테스트 기법이다.
이 방법은 개발된 소프트웨어가 사용자와 개발 조직 간의 공식 합의에 따른 기능을 정확히 수행하는지 확인하는 것을 목표로 한다.
실제 예시를 통해 더 구체적으로 살펴보자.
온라인 쇼핑몰의 로그인 기능에 대한 요구사항이 있다고 가정해보자:
"사용자는 이메일과 비밀번호로 로그인할 수 있어야 한다. 이메일은 올바른 형식이어야 하며, 비밀번호는 최소 8자 이상이어야 한다. 로그인 실패 시 적절한 오류 메시지를 표시해야 한다."
...</p></div><footer class=entry-footer><span title='2024-11-02 10:02:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;518 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Requirements-based Testing" href=https://buenhyden.github.io/posts/qa/fundamentals/testing-approaches/black-box-testing/specification-based-test/requirements-based-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Metamorphic Testing</h2></header><div class=entry-content><p>메타모픽 테스팅 (Metamorphic Testing, MT) 소프트웨어 테스트에서 “오라클 문제”(테스트 결과의 정확성을 판단하기 어려운 상황)를 해결하기 위해 개발된 방법으로,
메타모픽 테스팅은 소프트웨어의 의도된 기능에 대한 필수적인 속성인 메타모픽 관계(Metamorphic Relations, MRs)를 활용하여 테스트를 수행한다.
이 방법은 정확한 출력값을 알지 못해도 테스트가 가능하다는 점에서 특징적이다.
메타모픽 테스팅의 핵심 원리는 입력값들 사이의 관계와 그에 따른 출력값들 사이의 관계를 활용하는 것이다.
예를 들어, 어떤 숫자에 2를 곱한 값과 원래 숫자의 제곱을 비교한다고 생각해보자.
입력값이 3일 때, 3 × 2 = 6이고 3² = 9이다.
여기서 우리는 “어떤 숫자에 2를 곱한 값은 항상 그 숫자의 제곱보다 작다"라는 메타모픽 관계를 발견할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-02 10:01:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;438 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Metamorphic Testing" href=https://buenhyden.github.io/posts/qa/fundamentals/testing-approaches/black-box-testing/specification-based-test/metamorphic-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Boundary Value Analysis</h2></header><div class=entry-content><p>경계값 분석 (Boundary Value Analysis, BVA) 경계값 분석은 입력 또는 출력 범위의 경계 근처에서 결함이 발생할 가능성이 높다는 경험적 관찰에 기반한 테스트 기법.
프로그래머들이 흔히 “off-by-one” 오류를 범하거나 경계 조건을 잘못 처리하는 경향이 있기 때문에, 이러한 경계값을 집중적으로 테스트하는 것이 효과적이다.
예를 들어, 어떤 시스템이 1에서 100 사이의 숫자만 받아들인다고 가정해보자.
이때 0, 1, 2와 99, 100, 101 같은 경계값들을 테스트하는 것이 중요하다.
왜냐하면 이러한 값들에서 시스템이 올바르게 작동하지 않을 가능성이 높기 때문이다.
...</p></div><footer class=entry-footer><span title='2024-11-02 09:58:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;734 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Boundary Value Analysis" href=https://buenhyden.github.io/posts/qa/fundamentals/testing-approaches/black-box-testing/specification-based-test/boundary-value-analysis/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/46/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/48/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>