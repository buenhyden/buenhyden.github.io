<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KISS Principle</h2></header><div class=entry-content><p>KISS (Keep It Simple, Stupid) 원칙 시스템이나 코드의 복잡성을 최소화하라.
잘못된 예 1 2 3 4 5 6 def complex_calculation(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z): # 너무 많은 파라미터와 복잡한 로직이 포함되어 있음 result = a + b - c * d / e + f - g + h + i - j + k * l / m - n + o - p + q + r - s + t + u - v + w - x + y - z return result # 주석: 함수가 너무 복잡하고 많은 파라미터를 사용하여 KISS를 위반합니다. 잘된 예 1 2 3 4 5 def simple_calculation(a,b,c): result = a + b - c return result # 주석: 필요한 최소한의 파라미터와 간단한 로직으로 KISS를 준수합니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 01:00:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;123 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to KISS Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAGNI Principle</h2></header><div class=entry-content><p>YAGNI(You Ain’t Gonna Need It) Principle 당장 필요하지 않은 기능을 미리 구현하지 마라.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.loyalty_points = 0 # 아직 사용하지 않는 기능 def upgrade_to_premium(self): self.premium_member = True def add_loyalty_points(self, points): # 아직 사용하지 않는 기능 self.loyalty_points += points # 주석: 아직 사용하지 않는 loyalty_points 기능을 미리 구현하여 YAGNI 원칙을 위반합니다. # 이는 불필요한 복잡성을 추가하고, 실제로 필요하지 않을 수 있는 기능을 유지보수해야 하는 부담을 줍니다. class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.vip_status = False # 아직 필요 없는 기능 self.loyalty_points = 0 # 아직 필요 없는 기능 self.referred_users = [] # 아직 필요 없는 기능 self.last_login_history = [] # 아직 필요 없는 기능 def calculate_benefits(self): # 복잡한 혜택 계산 로직 (아직 필요 없음) pass def generate_referral_code(self): # 추천 코드 생성 로직 (아직 필요 없음) pass def track_login_history(self): # 로그인 이력 추적 로직 (아직 필요 없음) pass 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 주석: 현재 필요한 기능만 구현하여 YAGNI 원칙을 준수합니다. # 이를 통해 코드를 간결하게 유지하고, 실제로 필요한 기능이 확인될 때 추가할 수 있습니다. # YAGNI 준수 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 나중에 필요할 때 기능을 추가 class PremiumUser(User): def __init__(self, name, email): super().__init__(name, email) self.premium_member = True def get_premium_benefits(self): return ["무료 배송", "특별 할인"] 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:59:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAGNI Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle 코드 중복을 피하고 로직을 한 곳에서 관리하도록 권장하는 원칙.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = width * height perimeter = 2 * (width + height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 면적과 둘레 계산 로직이 중복되어 DRY 원칙을 위반합니다. # 계산 로직이 변경될 경우 여러 곳을 수정해야 하며, 실수의 가능성이 높아집니다. # 코드 중복 class Order: def calculate_total_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 total = total * 1.1 # 배송비 추가 if total &lt; 50: total += 10 return total class Cart: def calculate_preview_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 (중복된 로직) total = total * 1.1 # 배송비 추가 (중복된 로직) if total &lt; 50: total += 10 return total 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = calculate_rectangle_area(width, height) perimeter = calculate_rectangle_perimeter(width, height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 계산 로직을 함수로 분리하여 재사용하므로 DRY 원칙을 준수합니다. # 로직 변경 시 한 곳만 수정하면 되어 유지보수가 용이하고 일관성을 유지할 수 있습니다. # DRY 원칙 적용 class PriceCalculator: @staticmethod def calculate_price(items): total = sum(item.price for item in items) total = PriceCalculator.apply_tax(total) total = PriceCalculator.add_shipping_fee(total) return total @staticmethod def apply_tax(amount): return amount * 1.1 @staticmethod def add_shipping_fee(amount): return amount + 10 if amount &lt; 50 else amount class Order: def calculate_total_price(self, items): return PriceCalculator.calculate_price(items) class Cart: def calculate_preview_price(self, items): return PriceCalculator.calculate_price(items) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:58:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙.
단일 책임 원칙 (Single Responsibility Principle, SRP) 클래스는 단 하나의 책임만 가져야 한다.
여기서 ‘책임’이란 ‘변경의 이유’를 의미한다. 즉, 모듈은 오직 하나의 액터에 의해서만 변경되어야 한다.
이를 통해 코드의 모듈성과 유지보수성이 향상된다.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class User: def __init__(self, name): self.name = name def get_name(self): return self.name def save(self): # 데이터베이스에 사용자 정보를 저장하는 로직 pass def send_email(self, message): # 이메일을 보내는 로직 pass # 주석: 이 클래스는 사용자 정보 관리, 데이터베이스 저장, 이메일 발송 등 # 여러 책임을 가지고 있어 SRP를 위반합니다. 변경 사유가 여러 개 발생할 수 있습니다. 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class User: def __init__(self, name): self.name = name def get_name(self): return self.name class UserRepository: def save(self, user): # 데이터베이스에 사용자 정보를 저장하는 로직 pass class EmailService: def send_email(self, user, message): # 이메일을 보내는 로직 pass # 주석: 각 클래스가 단일 책임을 가지도록 분리되어 SRP를 준수합니다. # User 클래스는 사용자 정보만 관리하고, UserRepository는 저장을, # EmailService는 이메일 발송만 담당합니다. 각 기능의 변경이 다른 클래스에 영향을 주지 않습니다. 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다는 의미이다.
주로 상속이나 구성을 통해 달성되며, 안정적이고 오류가 적은 코드베이스를 만든다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;923 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-09-22 12:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;647 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Class and Object and Instance</h2></header><div class=entry-content><p>Class and Object and Instance 객체 지향 프로그래밍(Object-Oriented Programming, OOP)에서 클래스(Class)와 객체(Object), 그리고 인스턴스(Instance)는 핵심적인 개념이다.
클래스(Class) 클래스는 객체를 생성하기 위한 템플릿 또는 청사진이다.
정의: 객체를 정의해놓은 것 또는 객체의 설계도/틀 용도: 객체를 생성하는데 사용됨 구성: 연관된 데이터(속성)와 메서드(행동)의 집합 특징: 메모리를 차지하지 않음 한 번만 선언됨 예를 들어, ‘자동차’ 클래스는 모든 자동차의 공통적인 특성(브랜드, 모델, 색상 등)과 행동(시동 걸기, 가속하기 등)을 정의한다.
1 2 3 4 5 6 7 8 9 10 11 12 class Car: # 생성자: 객체가 생성될 때 초기화하는 메서드 def __init__(self, brand, color, year): self.brand = brand # 브랜드 속성 self.color = color # 색상 속성 self.year = year # 연식 속성 self.engine_on = False # 시동 상태 # 시동 걸기 메서드 def start_engine(self): self.engine_on = True return f"{self.brand} 차량의 시동을 겁니다." 객체(Object) 객체는 클래스를 기반으로 생성된 실체.
...</p></div><footer class=entry-footer><span title='2024-09-22 12:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;337 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Object and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-object-and-instance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다형성 (Polymorphism)</h2></header><div class=entry-content><p>다형성 (Polymorphism) 다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 특징 중 하나로, “여러 가지 형태를 가질 수 있는 능력"을 의미한다. 하나의 객체가 여러 가지 타입을 가질 수 있거나, 동일한 동작이 다양한 방식으로 실행될 수 있는 것을 말한다.
다형성의 본질은 “하나의 인터페이스, 다양한 구현"이다. 마치 리모컨이라는 하나의 인터페이스로 TV, 에어컨, 음향기기 등 다양한 기기를 제어할 수 있는 것과 같다.
실생활 예시 키보드의 Enter 키를 생각해보면 다형성을 쉽게 이해할 수 있다:
텍스트 편집기에서는 새로운 줄을 만든다 대화창에서는 메시지를 전송한다 웹 브라우저의 주소창에서는 페이지를 로드한다 같은 Enter 키지만, 상황에 따라 다른 동작을 수행하는 것이 바로 다형성의 예시이다.
...</p></div><footer class=entry-footer><span title='2024-09-22 10:25:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;784 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 다형성 (Polymorphism)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/polymorphism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>상속 (Inheritance)</h2></header><div class=entry-content><p>상속 (Inheritance) 상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 기존 클래스의 특성을 다른 클래스가 물려받아 재사용하고 확장할 수 있게 해주는 메커니즘이다.
이를 통해 코드의 재사용성을 높이고 계층적인 관계를 구현할 수 있다.
상속을 사용할 때 가장 중요한 세 가지 원칙이 있다:
IS-A 관계 확인: 자식 클래스는 반드시 부모 클래스의 한 종류여야 한다. “고양이는 동물이다"는 성립하지만, “자동차는 엔진이다"는 성립하지 않는다. 기능의 확장: 자식 클래스는 부모 클래스의 기능을 물려받아 확장하는 것이 목적이다. 기존 기능을 제한하거나 완전히 다른 의미로 변경하는 것은 좋지 않다. 적절한 캡슐화: protected 접근 제어자를 통해 상속 관계에서만 접근 가능한 멤버를 적절히 설계해야 한다. 상속의 의미 상속을 통해 우리는 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-22 10:10:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;818 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상속 (Inheritance)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/inheritance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>추상화 (Abstraction)</h2></header><div class=entry-content><p>추상화 (Abstraction) 프로그래밍에서 핵심적인 개념으로, 복잡한 시스템이나 데이터를 단순화하여 필수적인 특징만을 강조하는 과정이다.
필요한 세부사항을 숨기고 중요한 정보만을 표현함으로써 코드의 복잡성을 줄이고 이해도를 높이는 데 도움을 준다.
주요 특징 복잡성 감소: 추상화는 시스템의 복잡한 내부 로직을 감추고 사용자에게 필요한 기능만을 제공한다. 코드 재사용성 향상: 공통 로직을 추상화하여 여러 곳에서 재사용할 수 있게 한다. 유연성 증가: 구체적인 구현을 숨기고 인터페이스만 제공함으로써, 나중에 구현 방법을 변경해도 외부에 영향을 주지 않는다. 모듈성 향상: 시스템을 독립적인 모듈로 나눌 수 있어 개발과 유지보수가 용이해진다. 추상화의 종류 데이터 추상화: 복잡한 데이터 구조를 단순화하여 표현한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 06:46:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;418 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 추상화 (Abstraction)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/abstraction/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Abstract Classes</h2></header><div class=entry-content><p>Abstract Classes 추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스이다.
추상 메서드는 선언만 되고 구현되지 않은 메서드를 말한다.
이는 기본적인 구조는 정의하지만 세부적인 구현은 하위 클래스에 맡긴다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def calculate_area(self): """도형의 넓이를 계산하는 추상 메서드""" pass @abstractmethod def calculate_perimeter(self): """도형의 둘레를 계산하는 추상 메서드""" pass def get_description(self): """일반 메서드 - 모든 하위 클래스가 공유""" return "이것은 2차원 도형입니다." 주요 특징 인스턴스화 불가: 추상 클래스는 직접 객체를 생성할 수 없다. 상속 목적: 다른 클래스들의 기본 클래스 역할을 한다. 추상 및 구체 메서드 포함: 추상 메서드와 구현된 메서드를 모두 가질 수 있다. 공통 인터페이스 제공: 관련된 클래스들에 대한 공통 인터페이스나 동작을 정의한다. 추상 클래스의 구현과 활용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Circle(Shape): def __init__(self, radius): self.radius = radius def calculate_area(self): """원의 넓이 계산 구현""" return 3.14 * self.radius * self.radius def calculate_perimeter(self): """원의 둘레 계산 구현""" return 2 * 3.14 * self.radius class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def calculate_area(self): """직사각형의 넓이 계산 구현""" return self.width * self.height def calculate_perimeter(self): """직사각형의 둘레 계산 구현""" return 2 * (self.width + self.height) 사용 목적 계층 구조 생성: 관련 클래스들의 공통 속성과 메서드를 정의한다. 템플릿 메서드 패턴: 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스에서 구현하도록 한다. 프레임워크 개발: API나 프레임워크에서 기본 구조를 정의하는 데 사용된다. 예시 Java에서 추상 클래스 선언 예:
이 예시에서 Shape는 추상 클래스로, draw() 메서드는 추상 메서드이며 setColor() 메서드는 구체적인 구현을 가진다.
...</p></div><footer class=entry-footer><span title='2024-09-22 04:56:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;301 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Abstract Classes" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/paradigm-features/abstract-classes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/74/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/76/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>