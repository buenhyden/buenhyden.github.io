<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>명령어 집합 구조 (Instruction Set Architecture)</h2></header><div class=entry-content><p>명령어 집합 구조 (Instruction Set Architecture) 명령어 집합 구조(Instruction Set Architecture, ISA)는 프로세서 아키텍처의 핵심 요소로, 하드웨어와 소프트웨어 간의 인터페이스 역할을 한다.
ISA는 프로세서가 실행할 수 있는 명령어들의 집합을 정의하며, 프로그래머와 컴파일러 작성자에게 중요한 추상화 계층을 제공한다.
Source: https://www.geeksforgeeks.org/microarchitecture-and-instruction-set-architecture/
ISA의 주요 구성 요소 명령어 세트
연산 유형: 산술 연산, 논리 연산, 데이터 이동, 제어 흐름 등 명령어 형식: 각 명령어의 비트 구조와 인코딩 방식 주소 지정 모드: 직접 주소 지정, 간접 주소 지정, 즉시 주소 지정 등 레지스터
...</p></div><footer class=entry-footer><span title='2024-09-23 02:18:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;294 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 명령어 집합 구조 (Instruction Set Architecture)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/instruction-set-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Bus</h2></header><div class=entry-content><p>System Bus System Bus는 컴퓨터 아키텍처에서 주요 구성 요소들을 연결하는 중요한 통신 경로로, 컴퓨터의 혈관과 같은 역할을 한다. CPU, 메모리, 입출력 장치 등 컴퓨터의 주요 구성 요소들 사이에서 데이터와 신호를 전달한다.
Source: https://witscad.com/course/computer-architecture/chapter/io-communication-io-controller
시스템 버스의 주요 구성 요소 시스템 버스는 세 가지 주요 버스로 구성된다:
데이터 버스 (Data Bus):
양방향 버스로, 시스템 구성 요소들 사이에서 실제 데이터를 전송한다. 예를 들어, CPU가 메모리에서 데이터를 읽거나 쓸 때 사용된다. 버스의 폭(width)은 한 번에 전송할 수 있는 데이터의 양을 결정한다. 1 2 // 예시: 32비트 데이터 버스의 데이터 전송 DataBus.transfer(0x1234ABCD); // 32비트 데이터를 한 번에 전송 주소 버스 (Address Bus):
...</p></div><footer class=entry-footer><span title='2024-09-23 02:17:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;408 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Bus" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/i-o-systems/system-bus/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Harvard Architecture</h2></header><div class=entry-content><p>Harvard Architecture 하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.
하버드 아키텍처는 다음과 같은 주요 특징을 가지고 있다:
메모리 분리: 프로그램(명령어) 메모리와 데이터 메모리가 물리적으로 분리되어 있다. 독립적 접근: CPU가 명령어와 데이터에 동시에 접근할 수 있어, 병렬 처리가 가능하다. 버스 구조: 명령어용 버스와 데이터용 버스가 별도로 존재한다. 성능 향상: 메모리 접근의 병렬화로 인해 처리 속도가 향상된다. 기본 구조:
1 2 3 4 5 [프로그램 메모리] [데이터 메모리] ↓ ↓ [CPU] ←→ [제어 유닛] ↓ ↓ [프로그램 버스] [데이터 버스] https://www.researchgate.net/figure/Harvard-architecture-scheme_fig6_356598013
...</p></div><footer class=entry-footer><span title='2024-09-23 01:51:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;266 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Harvard Architecture" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/harvard-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Von Neumann architecture</h2></header><div class=entry-content><p>Von Neumann Architecture Von Neumann architecture는 1945년 John von Neumann이 제안한 컴퓨터 아키텍처로, 현대 대부분의 컴퓨터 시스템의 기본이 되는 설계이다.
Source: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/
특징 순차적 실행:
명령어를 메모리에서 한 번에 하나씩 순차적으로 가져와 실행 레지스터:
프로그램 카운터 (PC): 다음 실행할 명령어의 주소 저장 명령어 레지스터 (CIR): 현재 실행 중인 명령어 저장 메모리 주소 레지스터 (MAR): 접근할 메모리 주소 저장 메모리 데이터 레지스터 (MDR): 메모리와 주고받는 데이터 저장 누산기 (Accumulator): 연산 결과 임시 저장 버스 시스템:
...</p></div><footer class=entry-footer><span title='2024-09-23 01:51:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;471 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Von Neumann architecture" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/processor-architecture/von-neumann-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>캐시 (Cache)</h2></header><div class=entry-content><p>캐시 (Cache) 캐시(Cache)는 컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 저장소를 의미한다.
데이터 접근 속도를 높이고 시스템 성능을 향상시킬 수 있다.
자주 사용되는 데이터는 빠르게 접근할 수 있는 위치에 복사해두는데 이 위치를 캐시(Cache)라고 말한다.
캐시의 특징 속도: 주 메모리나 디스크보다 훨씬 빠르다. 용량: 일반적으로 주 메모리보다 작다. 비용: 고속이기 때문에 상대적으로 비싸다. 캐시의 장점 빠른 데이터 접근: 자주 사용되는 데이터에 빠르게 접근할 수 있다. 시스템 성능 향상: 전체적인 시스템 응답 시간을 줄인다. 리소스 절약: 반복적인 데이터 요청을 줄여 서버 부하를 감소시킨다. 캐시 사용 시 주의점 일관성 유지: 원본 데이터가 변경될 때 캐시도 업데이트해야 한다. 캐시 크기 관리: 너무 크면 메모리 낭비, 너무 작으면 효율이 떨어진다. 캐시 교체 정책: 캐시가 가득 찼을 때 어떤 데이터를 제거할지 결정해야 한다. 캐시의 동작 과정 데이터 요청: 프로그램이 데이터를 요청한다. 캐시 확인: 시스템은 먼저 캐시에서 데이터를 찾는다. 캐시 히트(Cache Hit): 데이터가 캐시에 있으면 즉시 반환한다. 캐시 미스(Cache Miss): 데이터가 캐시에 없으면 주 메모리나 디스크에서 가져와 캐시에 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 캐시의 기본 작동 원리를 보여주는 예제 class SimpleCache: def __init__(self): self.cache = {} # 데이터를 저장할 공간 def get_data(self, key): # 1. 캐시에서 먼저 찾아봅니다 if key in self.cache: print("캐시에서 데이터를 찾았습니다!") return self.cache[key] # 2. 캐시에 없다면 원본 소스에서 가져옵니다 print("캐시에 없어서 원본에서 가져옵니다…") data = self.fetch_from_source(key) # 3. 다음 사용을 위해 캐시에 저장합니다 self.cache[key] = data return data 캐시의 종류 CPU 캐시: CPU와 주 메모리 사이에 위치한 고속의 소용량 메모리
역할:
...</p></div><footer class=entry-footer><span title='2024-09-22 13:25:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;835 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 캐시 (Cache)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Byte Addressable Memory vs Word Addressable Memory</h2></header><div class=entry-content><p>Byte Addressable Memory Vs Word Addressable Memory Byte Addressable Memory와 Word Addressable Memory는 컴퓨터 메모리의 주소 지정 방식을 설명하는 개념이다.
이 두 가지 방식은 메모리의 구조와 데이터 접근 방법에 중요한 차이를 나타낸다.
Sourece: https://examradar.com/memory-organisation/
Byte Addressable Memory Byte Addressable Memory는 각 바이트(8비트)마다 고유한 주소가 할당되어 개별적으로 접근할 수 있는 메모리 구조이다.
가장 작은 주소 지정 단위(smallest addressable unit)는 1바이트(8비트)이며, 이를 통해 메모리의 각 바이트에 직접 접근할 수 있다.
CPU는 개별 바이트 단위로 메모리에 접근할 수 있으며, 워드(일반적으로 4바이트 또는 8바이트) 단위의 접근도 가능하다.
32비트 시스템에서는 2^32개의 주소를 가질 수 있어 최대 4GB의 메모리를 지원하며, 64비트 시스템에서는 훨씬 더 큰 주소 공간을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 11:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;609 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Byte Addressable Memory vs Word Addressable Memory" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/byte-addressable-memory-vs-word-addressable-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Memory</h2></header><div class=entry-content><p>Cache Memory 캐시 메모리(Cache Memory)는 컴퓨터 아키텍처에서 중요한 역할을 하는 CPU와 주 메모리(RAM) 사이에 위치한 소규모의 고속 메모리이다.
주요 목적은 자주 사용되는 데이터와 명령어를 CPU 가까이에 저장하여 접근 시간을 줄이고 전체 시스템 성능을 향상시키는 것이다.
특징 속도: RAM보다 10-100배 빠르며, 응답 시간은 몇 나노초에 불과하다. 용량: RAM보다 작지만 더 빠른 SRAM을 사용한다. 비용: 단위 용량당 RAM보다 비싸지만 성능이 월등히 높다. 위치: CPU 칩 내부 또는 매우 가까운 곳에 위치한다. 작동 원리 지역성 원리: 최근 접근한 데이터나 명령어는 가까운 미래에 다시 사용될 가능성이 높다는 원리를 활용한다. 캐시 히트와 미스: CPU가 데이터를 요청할 때 캐시에서 찾으면 ‘캐시 히트’, 찾지 못하면 ‘캐시 미스’가 발생한다. 캐시 정책: 어떤 데이터를 캐시에 유지할지 결정하는 정책으로, LRU(Least Recently Used)나 MRU(Most Recently Used) 등이 있다. 캐시 레벨 L1 캐시: CPU에 가장 가까운 최소, 최고속 캐시로, 보통 명령어용(L1i)과 데이터용(L1d)으로 나뉜다. L2 캐시: L1보다 크고 느리지만 여전히 고속인 캐시이다. L3 캐시: 더 큰 용량을 제공하며, 여러 코어가 공유할 수 있다. 캐시 매핑 기법 직접 매핑: 각 메모리 블록이 특정 캐시 라인에 매핑된다. 완전 연관 매핑: 메모리 블록이 어느 캐시 라인에나 로드될 수 있다. 집합 연관 매핑: 직접과 완전 연관의 절충안으로, 메모리 블록이 특정 집합 내 어느 라인에나 로드될 수 있다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-22 11:36:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;193 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Memory" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/cache-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Branch 전략</h2></header><div class=entry-content><p>Git Branch 전략 Git Flow Source: https://nvie.com/posts/a-successful-git-branching-model/
특징 Vincent Driessen이 2010년에 제안한 브랜치 전략 엄격하고 체계적인 브랜치 관리 구조 장기적인 릴리즈 주기와 버전 관리에 적합 여러 개의 프로덕션 버전을 동시에 지원. 명확한 역할 분담과 작업 흐름 제공. 핵심 원칙 master(main) 브랜치는 항상 배포 가능한 상태로 유지 모든 개발은 develop 브랜치를 기반으로 진행 새로운 기능 개발은 항상 feature 브랜치에서 수행 release 브랜치는 릴리즈 준비가 완료된 후에만 master로 병합 구조 및 Branch 종류 주요 브랜치 master(main): 제품 출시 버전을 관리 항상 배포 가능한 상태를 유지 모든 커밋에 태그로 버전 번호 부여 직접적인 커밋 금지 release 또는 hotfix에서 병합만 가능 develop: 다음 버전 개발 코드 관리 feature 브랜치의 기준점. 기능 개발 완료된 코드 통합 다음 릴리즈를 위한 코드베이스 보조 브랜치 feature: 새로운 기능 개발 develop에서 분기 기능 단위로 생성 개발 완료 후 develop에 병합 네이밍: feature/기능명 release: 출시 준비 develop에서 분기 버그 수정, 문서 작업 등 릴리즈 준비 작업만 허용 완료시 master(main)와 develop에 병합 네이밍: release-버전 hotfix: 긴급 버그 수정 master(main)에서 분기 수정 후 master(main)와 develop에 병합 네이밍: hotfix-버전
각 브랜치의 명명 규칙을 정하여 따르도록 한다.
예) feature/*: 기능 이름 사용 release/*: 버전 번호 사용 hotfix/*: 버그 식별자 사용 작업 시나리오 신규 시나리오 develop 브랜치에서 시작 feature 브랜치 생성 기능 개발 및 테스트 develop에 병합 feature 브랜치 삭제 릴리즈 프로세스 develop에서 release 브랜치 생성 버전 번호 업데이트 최종 테스트 및 버그 수정 master와 develop에 병합 태그 생성 및 release 브랜치 삭제 긴급 버그 수정 master에서 hotfix 브랜치 생성 버그 수정 및 버전 업데이트 master와 develop에 병합 태그 생성 및 hotfix 브랜치 삭제 장단점 장점 단점 체계적이고 예측 가능한 개발 프로세스
버전 관리와 유지보수가 용이
대규모 프로젝트와 팀에 적합
릴리즈 주기가 긴 프로젝트에 효과적
엄격한 코드 품질 관리
명확한 역할 분담 복잡한 브랜치 구조로 인한 학습 곡선
소규모 프로젝트나 빠른 배포가 필요한 경우 과도할 수 있다.
브랜치 관리에 시간과 노력이 많이 소요될 수 있음. 적용 적합성 프로젝트 규모 팀 규모 배포 빈도 품질 관리 수준 중대형 프로젝트 5인 이상 주/월 단위 정기적인 릴리즈 높은 수준의 QA 프로세스 필요
체계적인 테스트 체계 필요
코드 리뷰 문화 필수 리스크 요소 통합 리스크 배포 리스크 품질 리스크 관리 리스크 장기 실행 브랜치의 병합 충돌
feature 브랜치 간의 의존성
큰 규모의 병합으로 인한 위험 복잡한 배포 프로세스
릴리즈 준비 기간 장기화
hotfix 적용의 복잡성 브랜치 간 코드 동기화 문제
테스트 커버리지 확보 어려움
코드 리뷰 병목 현상 브랜치 관리에 많은 시간이 노력이 필요 복잡도 증가 요인 다양한 종류의 브랜치 사용 엄격한 브랜치 생성 및 병합 규칙 릴리스 및 핫픽스 프로세스의 복잡성 CI/CD를 위한 요구 사항 자동화된 테스트 시스템 각 브랜치 별 자동 빌드 및 테스트 환경 릴리즈 브랜치에 대한 자동 배포 파이프라인 브랜치 상태 모니터링 시스템 통합 방법 브랜치 전략과 CI/CD 파이프라인 연동 master(main)와 develop 브랜치에 대한 자동 빌드 및 테스트 파이프라인 구성 feature, release, hotfix 브랜치에 대한 별도의 CI 파이프라인 설정. 자동화된 테스트 모든 브랜치에 대해 자동화된 단위 테스트, 통합 테스트 실행 develop 브랜치로의 병합 시 추가적인 테스트 수행 환경별 배포 develop 브랜치는 개발/테스트 환경에 자동 배포 release 브랜치는 스테이징 환경에 배포 master 브랜치는 프로덕션 환경에 배포 코드 리뷰 프로세스 Pull Request 생성 시 자동으로 CI 파이프라인 실행 코드 리뷰 승인 후 자동 병합 및 배포 버전 관리 release 브랜치 생성 시 자동으로 버전 태그 생성 배포 시 해당 버전 정보 포함 모니터링 및 롤백 배포 후 자동화된 모니터링 시스템 연동 문제 발생 시 빠른 롤백 메커니즘 구현 문서화 CI/CD 파이프라인 실행 결과 자동 문서화 릴리즈 노트 자동 생성 버전 관리 방식 버전 관리 체계 Semantic Versioning(SemVer)을 사용
...</p></div><footer class=entry-footer><span title='2024-09-22 10:28:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;2639 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Branch 전략" href=https://buenhyden.github.io/posts/software-development-and-maintenance/devops/ci-and-cd/git/git-branch-%EC%A0%84%EB%9E%B5/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 접근 방법 (Memory Access Methods)</h2></header><div class=entry-content><p>메모리 접근 방식 (Memory Access Methods) 컴퓨터 시스템에서 메모리에 접근하는 주요 방식은 다음과 같다:
순차적 접근 (Sequential Access)
메모리를 선형적인 순서로 접근하는 방식. 데이터를 처음부터 순서대로 읽거나 쓰며, 특정 위치에 접근하려면 그 앞의 모든 데이터를 거쳐야 한다. 주로 자기 테이프와 같은 저장 장치에서 사용된다. 직접 접근 (Direct Access)
각 메모리 블록이 고유한 주소를 가지고 있어 직접 접근이 가능하다. 일반적인 위치로 직접 접근한 후, 순차적 검색을 통해 최종 목적지에 도달한다. 하드 디스크와 같은 저장 장치에서 주로 사용된다. 랜덤 접근 (Random Access)
...</p></div><footer class=entry-footer><span title='2024-09-22 08:05:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;292 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 접근 방법 (Memory Access Methods)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-access-methods/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 주소 지정 방식 (Memory Address Modes)</h2></header><div class=entry-content><p>메모리 주소 지정 방식 (Memory Address Modes) 메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.
유형 즉시 주소 지정 방식 (Immediate Addressing):
데이터가 명령어 자체에 포함되어 있다. 예: “5를 더해라” 라고 직접 지시하는 것과 같다. 가장 빠르지만, 큰 데이터를 다루기 어렵다. 직접 주소 지정 방식 (Direct Addressing):
명령어에 데이터가 있는 메모리 주소를 직접 지정한다. 예: “주소 100번에 있는 값을 가져와라” 라고 지시하는 것과 같다. 간단하고 이해하기 쉽다. 간접 주소 지정 방식 (Indirect Addressing):
...</p></div><footer class=entry-footer><span title='2024-09-22 08:04:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;144 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 주소 지정 방식 (Memory Address Modes)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/memory-address-modes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/56/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/58/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>