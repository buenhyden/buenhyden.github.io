<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Skip List</h2></header><div class=entry-content><p>Skip List Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다.
Skip List는 여러 레벨의 연결 리스트로 구성된 데이터 구조로, 각 레벨은 그 아래 레벨의 일부 요소를 포함하며, 최하위 레벨은 모든 요소를 포함한다.
https://en.wikipedia.org/wiki/Skip_list#/media/File:Skip_list.svg
특징 다중 레벨 구조: 여러 층의 연결 리스트로 구성된다. 확률적 균형: 랜덤화를 통해 구조의 균형을 유지한다. 정렬 상태 유지: 요소들은 정렬된 순서로 유지된다. 장점 빠른 검색: 평균 O(log n) 시간 복잡도로 검색이 가능하다. 효율적인 삽입/삭제: 평균 O(log n) 시간에 삽입과 삭제가 가능하다. 구현의 단순성: 균형 이진 탐색 트리에 비해 구현이 간단하다. 단점 추가 메모리 사용: 여러 레벨의 포인터로 인해 추가 메모리가 필요하다. 확률적 성능: 최악의 경우 O(n) 시간 복잡도가 발생할 수 있다. 응용 데이터베이스 인덱싱: RocksDB와 같은 키-값 저장소에서 사용된다. 메모리 관리: 비휘발성 메모리 최적화에 활용된다. 캐시 구현: 효율적인 캐시 시스템 구축에 사용된다. 동작 원리 검색: 최상위 레벨에서 시작하여 목표 값보다 작은 노드를 따라 이동하고, 큰 값을 만나면 아래 레벨로 내려간다. 삽입: 랜덤하게 레벨을 결정하고, 해당 레벨까지 노드를 생성하여 연결한다. 삭제: 노드를 찾아 모든 레벨에서 제거한다. 구성 요소 노드: 키, 값, 여러 레벨의 다음 노드 포인터를 포함한다. 헤드 노드: 모든 레벨의 시작점 역할을 한다. 레벨: 여러 층의 연결 리스트 구조를 형성한다. 구현 방식 JavaScript를 사용한 Skip List 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;822 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Skip List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/complex/skip-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Deque</h2></header><div class=entry-content><p>Deque (Double-ended Queue) Deque는 양쪽 끝에서 삽입과 삭제가 가능한 선형 데이터 구조로, 큐와 스택의 특성을 모두 가지고 있다.
Deque는 Double-ended Queue의 줄임말로, 양방향에서 데이터를 처리할 수 있는 자료구조이다.
큐의 전단(front)과 후단(rear) 모두에서 삽입과 삭제가 가능한 확장된 형태의 큐입니다.
https://www.geeksforgeeks.org/difference-between-queue-and-deque-queue-vs-deque/
특징 양방향 접근: 데이터의 앞과 뒤에서 모두 삽입과 삭제가 가능하다. 가변 크기: 필요에 따라 크기가 동적으로 조절될 수 있다. 임의 접근: 인덱스를 통해 요소에 직접 접근할 수 있다. FIFO와 LIFO: 큐와 스택의 특성을 모두 가지고 있어 유연하게 사용할 수 있다. 장점 유연성: 양쪽에서 데이터를 처리할 수 있어 다양한 상황에 적용 가능한다. 효율성: 양 끝에서의 삽입과 삭제 연산이 O(1)의 시간 복잡도를 가진다. 다목적성: 스택이나 큐로도 사용할 수 있어 다양한 알고리즘에 활용된다. 단점 구현 복잡성: 양방향 연산을 지원하기 위해 구현이 복잡할 수 있다. 메모리 사용: 동적 크기 조절을 위해 추가적인 메모리를 사용할 수 있다. 중간 삽입/삭제의 비효율성: 양 끝이 아닌 중간에서의 연산은 O(n)의 시간 복잡도를 가진다. 응용 작업 스케줄링: 운영 체제에서 프로세스 관리에 사용된다. 웹 브라우저의 방문 기록: 앞으로 가기와 뒤로 가기 기능을 구현할 때 활용된다. 실시간 데이터 처리: 양방향에서 데이터를 빠르게 추가하거나 제거해야 하는 경우에 사용된다. 팰린드롬 체크: 문자열이 앞뒤로 동일한지 확인하는 알고리즘에 활용된다. 동작 원리 삽입 연산: addFirst(): 덱의 앞쪽에 요소를 추가한다. addLast(): 덱의 뒤쪽에 요소를 추가한다. 삭제 연산: removeFirst(): 덱의 앞쪽에서 요소를 제거하고 반환한다. removeLast(): 덱의 뒤쪽에서 요소를 제거하고 반환한다. 조회 연산: getFirst(): 덱의 첫 번째 요소를 반환한다. getLast(): 덱의 마지막 요소를 반환한다. 구성 요소 데이터 저장소: 배열 또는 연결 리스트를 사용하여 요소를 저장한다. 두 개의 포인터: front와 rear 포인터로 덱의 양 끝을 가리킨다. 크기 정보: 현재 저장된 요소의 수를 추적한다. 구현 방식 Deque는 주로 두 가지 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:53:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;611 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deque" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/queue/deque/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동적 배열 (Dynamic Array)</h2></header><div class=entry-content><p>동적 배열 (Dynamic Array) 동적 배열은 크기가 가변적인 배열 형태의 데이터 구조이다.
정적 배열과 달리 실행 시간에 크기를 조절할 수 있어 메모리를 효율적으로 사용할 수 있다.
https://www.geeksforgeeks.org/how-do-dynamic-arrays-work/
특징 가변적 크기: 필요에 따라 크기가 자동으로 조절된다. 연속된 메모리 할당: 요소들이 메모리상에 연속적으로 저장된다. 임의 접근(Random Access): 인덱스를 통해 O(1) 시간에 요소에 접근할 수 있다. 동적 메모리 할당: 실행 시간에 메모리를 할당하고 해제할 수 있다. 장점 유연성: 크기를 미리 정하지 않아도 되어 유연한 데이터 관리가 가능하다. 메모리 효율성: 필요한 만큼만 메모리를 사용한다. 빠른 접근 속도: 인덱스를 통한 빠른 요소 접근이 가능하다. 단점 재할당 비용: 크기 조정 시 새로운 메모리 할당과 데이터 복사에 따른 비용이 발생한다. 메모리 단편화: 빈번한 크기 조정으로 메모리 단편화가 발생할 수 있다. 삽입/삭제 연산의 비효율성: 중간에 요소를 삽입하거나 삭제할 때 다른 요소들을 이동시켜야 한다. 응용 리스트 구현: Java의 ArrayList, Python의 list 등의 기본 자료구조 구현에 사용된다. 스택과 큐 구현: 동적 배열을 이용해 스택과 큐를 효율적으로 구현할 수 있다. 데이터베이스 인덱싱: 빠른 검색을 위한 인덱스 구조에 활용된다. 동작 원리 초기화: 일정 크기의 배열로 시작한다. 삽입: 배열이 가득 차면 더 큰 크기의 새 배열을 생성하고 기존 데이터를 복사한다. 삭제: 요소를 제거하고 필요시 배열 크기를 줄인다. 접근: 인덱스를 통해 직접 접근한다. 구성 요소 내부 배열: 실제 데이터를 저장하는 고정 크기 배열 크기(size): 현재 저장된 요소의 수 용량(capacity): 내부 배열의 전체 크기 구현 방식 (Java) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 public class DynamicArray&lt;T> { private T[] array; private int size; private int capacity; @SuppressWarnings("unchecked") public DynamicArray(int initialCapacity) { array = (T[]) new Object[initialCapacity]; size = 0; capacity = initialCapacity; } public void add(T element) { if (size == capacity) { grow(); } array[size++] = element; } @SuppressWarnings("unchecked") private void grow() { capacity *= 2; T[] newArray = (T[]) new Object[capacity]; System.arraycopy(array, 0, newArray, 0, size); array = newArray; } public T get(int index) { if (index &lt; 0 || index >= size) { throw new IndexOutOfBoundsException(); } return array[index]; } public int size() { return size; } } 구현 시 고려사항 초기 크기 설정 예상 데이터 량에 따른 적절한 초기 크기 설정 너무 작으면 잦은 재할당, 너무 크면 메모리 낭비 확장 정책 단순 2배 증가 vs 다른 증가 비율 애플리케이션 특성에 맞는 정책 선택 축소 정책 언제 배열 크기를 줄일 것인지 메모리 효율성과 성능 사이의 균형 스레드 안전성 멀티스레드 환경에서의 동기화 고려 락(Lock) 메커니즘 구현 여부 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-08 07:03:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;409 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동적 배열 (Dynamic Array)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/array/dynamic-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Array vs Linked List</h2></header><div class=entry-content><p>Array Vs Linked List 데이터 구조는 프로그래밍에서 데이터를 효율적으로 저장하고 관리하기 위한 방법을 제공합니다. 이 중에서도 배열과 연결 리스트는 가장 기본적이면서도 중요한 데이터 구조이다.
두 구조는 서로 다른 특성과 장단점을 가지고 있어 적절한 상황에 맞게 선택해 사용해야 한다.
배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.
반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.
적절한 상황에 맞는 자료구조 선택은 효율적인 프로그램 개발의 핵심이다. 따라서 문제의 특성과 요구사항을 잘 분석하여 최적의 자료구조를 선택해야 한다. 때로는 두 자료구조의 장점을 결합한 하이브리드 접근 방식이나 다른 고급 자료구조를 활용하는 것이 더 나은 해결책이 될 수도 있다.
...</p></div><footer class=entry-footer><span title='2024-10-07 16:32:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1282 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Array vs Linked List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/array-vs-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>논리값 (Boolean)</h2></header><div class=entry-content><p>논리값 (Boolean) Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.
Boolean 데이터 타입은 참(true)과 거짓(false)의 두 가지 값만을 가질 수 있는 데이터 타입으로, 수학자 George Boole의 이름을 따서 명명되었으며, 논리 연산과 조건문에서 주로 사용된다.
특징 오직 두 가지 값만 가짐: true 또는 false 조건문과 논리 연산에서 주로 사용됨 메모리 사용이 효율적 (일반적으로 1비트만으로도 표현이 가능하다(true = 1, false = 0). 하지만 실제 프로그래밍 언어에서는 메모리 정렬(alignment) 때문에 보통 1바이트를 사용) 특성 비교 연산의 결과로 자주 생성됨 제어 흐름을 결정하는 데 중요한 역할을 함 다른 데이터 타입으로부터 변환 가능 (예: 숫자 0은 false, 나머지는 true) 연산 종류 및 설명 논리 연산 AND (&&): 두 피연산자가 모두 true일 때만 true 반환 OR (||): 두 피연산자 중 하나라도 true이면 true 반환 NOT (!): 피연산자의 값을 반전 비교 연산 동등 비교 (==, ===) 부등 비교 (!=,!==) 대소 비교 (&lt;, >, &lt;=, >=) 실제 활용 사례 및 설명 조건문에서의 사용 플래그 변수로 사용 (예: 상태 체크) 데이터 유효성 검사 각 언어별 예시와 특징 각 언어의 특징적인 부분을 살펴보면:
...</p></div><footer class=entry-footer><span title='2024-10-07 07:33:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1120 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 논리값 (Boolean)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/boolean/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>문자 (Character)과 문자열 (String)</h2></header><div class=entry-content><p>문자 (Character) 단일 문자를 표현하는 데이터 타입이다. 각 프로그래밍 언어별로 character의 구현과 사용 방식이 다소 다르다.
Character는 단일 문자를 나타내는 데이터 타입으로, 일반적으로 문자, 숫자, 특수 문자, 공백 등을 포함할 수 있다.
특징 고정 크기: 대부분의 언어에서 character는 고정된 메모리 크기를 가진다. 유니코드 지원: 많은 현대 프로그래밍 언어에서 유니코드 문자를 지원한다. 정수형과의 호환성: 대부분의 언어에서 character는 정수형으로 변환 가능하다. 특성 불변성: 많은 언어에서 character는 불변(immutable) 타입이다. 순서성: ASCII 또는 유니코드 값을 기반으로 순서를 가진다. 단일 값: 하나의 문자만을 저장할 수 있다. 연산 종류 및 설명 비교 연산: 문자 간 대소 비교가 가능하다. 산술 연산: 정수형으로 변환하여 산술 연산이 가능하다. 형변환: 정수형이나 문자열로의 변환이 가능하다. 실제 활용 사례 및 설명 Java Java에서는 ‘char’ 키워드를 사용하여 character를 선언한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;542 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 문자 (Character)과 문자열 (String)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/character-and-string/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>부동 소수점 (Float)</h2></header><div class=entry-content><p>부동 소수점 (Float) 부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.
‘부동’은 소수점이 움직인다는 의미로, 넓은 범위의 실수를 표현할 수 있다.
특징 IEEE 754 표준을 따름 부호, 지수, 가수 부분으로 구성 IEEE 754 표준에 따른 부동 소수점 종류 Half Precision
이 형식은 가장 작은 부동 소수점 표현 방식.
16비트를 사용한다.
1비트는 부호, 5비트는 지수부, 10비트는 가수부로 구성된다.
주로 그래픽스나 머신러닝에서 메모리를 절약하기 위해 사용된다.
약 3자리의 십진 정밀도를 제공하며, ±6.1 × 10⁻⁵에서 ±6.5 × 10⁴까지의 범위를 표현할 수 있다.
예시:
Python: 1 2 3 import numpy as np x = np.float16(3.14) print(x) # 3.14 JavaScript: JavaScript는 기본적으로 Half Precision을 지원하지 않는다. 외부 라이브러리를 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;540 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부동 소수점 (Float)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/float/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정수(Integer)</h2></header><div class=entry-content><p>정수 (Integer) 정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.
특징과 특성 고정된 크기의 메모리 사용 빠른 연산 속도 범위의 제한 (오버플로우 가능성) 직접적인 산술 연산 지원 종류 byte
범위: -128 ~ 127 8비트 비트 구성: 1비트 부호 + 7비트 값 특징: 가장 작은 정수 타입 메모리 효율적이지만 표현 범위가 제한적 주로 작은 범위의 데이터나 문자 표현에 사용 short
범위: -32,768 ~ 32,767 16비트 비트 구성: 1비트 부호 + 15비트 값 특징: 8비트보다 넓은 범위 표현 가능 메모리 사용량과 표현 범위의 균형이 좋음 작은 정수 값을 다룰 때 효율적 int
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 정수(Integer)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/integer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 (Hash)</h2></header><div class=entry-content><p>해시 (Hash) 임의의 크기를 가진 데이터를 고정된 크기의 데이터로 변환하는 과정이다.
이때 사용되는 함수를 해시 함수(Hash Function)라고 하며, 변환된 결과값을 해시값(Hash Value) 또는 해시 코드라고 한다. 그리고, 해시 테이블은 해시 함수를 사용하여 키(key)를 특정 버킷(bucket) 또는 슬롯(slot)에 매핑하는 자료구조이다.
해시 (Hash)는 임의의 크기를 가진 데이터를 고정된 크기의 값으로 변환한다. 해시 함수를 통해 생성된 해시 값에서 원래의 입력 데이터를 역으로 추적하는 것은 매우 어렵거나 불가능하다. 동일한 입력에 대해 항상 같은 해시 값을 생성한다. 이상적으로는 서로 다른 입력에 대해 다른 해시 값을 생성해야 한다. 해시의 특징 고정된 길이의 해시 값 생성 키-값 쌍으로 데이터 저장 빠른 검색 및 삽입 연산 해시 충돌 가능성 해시의 장점 빠른 검색 속도: 평균적으로 O(1)의 시간 복잡도로 데이터를 검색할 수 있다. 효율적인 메모리 사용: 키를 통해 직접 접근이 가능하므로 메모리를 효율적으로 사용한다. 데이터의 고유성 보장: 같은 키에 대해 항상 같은 해시 값을 생성한다. 해시의 단점 해시 충돌: 서로 다른 키가 같은 해시 값을 가질 수 있다. 순서 보장의 어려움: 데이터의 순서를 유지하기 어렵다. 공간 효율성 저하: 충돌 해결을 위한 추가 공간이 필요할 수 있다. 해시의 응용 데이터베이스 인덱싱 암호화 및 데이터 무결성 검증 캐싱 시스템 블록체인 기술 해시의 동작 원리 키를 입력받아 해시 함수를 통해 해시 값 생성 해시 값을 인덱스로 사용하여 데이터 저장 또는 검색 충돌 발생 시 해결 방법 적용 (체이닝 또는 개방 주소법) 해시 충돌과 해결 방법
...</p></div><footer class=entry-footer><span title='2024-10-07 01:33:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1004 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 (Hash)" href=https://buenhyden.github.io/posts/computer-science/security/hashing/hash/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Callback Function (콜백 함수)</h2></header><div class=entry-content><p>Callback Function 프로그래밍에서 다른 함수의 인수로 전달되어 특정 작업이 완료된 후 호출되는 함수.
하나의 함수가 실행되는 동안, 특정 시점이나 조건이 충족되었을 때 호출될 함수를 미리 전달하는 방식.
이 개념은 동기적(synchronous) 또는 비동기적(asynchronous) 작업에서 모두 사용되며, 특히 비동기 프로그래밍에서 매우 중요하다.
간단한 예시를 통해 콜백 함수의 개념을 이해:
1 2 3 4 5 6 7 8 9 10 function greet(name, callback) { console.log('안녕하세요, ' + name + '님!'); callback(); } function sayGoodbye() { console.log('안녕히 가세요!'); } greet('홍길동', sayGoodbye); 이 예시에서 sayGoodbye 함수가 콜백 함수로 greet 함수에 전달된다. greet 함수는 인사말을 출력한 후 콜백 함수를 실행한다. 콜백 함수의 동작 원리 함수 전달: 콜백 함수는 다른 함수의 매개변수로 전달된다. 호출 시점 결정: 전달받은 함수는 호출자 함수 내부에서 특정 조건이나 작업 완료 시 호출된다. 결과 처리: 콜백 함수는 호출자 함수의 결과나 상태를 기반으로 추가 작업을 수행한다. 콜백 함수의 장점 코드의 재사용성 동일한 함수에 다른 콜백을 전달하여 다양한 동작을 구현할 수 있다. 중복 코드를 줄일 수 있다. 유연성 실행 시점에 필요한 동작을 결정할 수 있다. 프로그램의 동작을 쉽게 변경할 수 있다. 비동기 프로그래밍 지원 긴 작업을 기다리지 않고 다른 작업을 수행할 수 있다. 프로그램의 반응성을 향상시킬 수 있다. 이벤트 처리 사용자의 행동(클릭, 키보드 입력 등)에 반응하는 데 사용된다. 웹 브라우저의 이벤트 리스너가 대표적인 예시이다. 콜백 함수의 종류 동기적(Synchronous) 콜백 호출자 함수가 실행되는 동안 즉시 호출된다. 일반적으로 작업 순서가 중요할 때 사용된다. 예시: 배열 메서드(forEach, map)에서 사용되는 콜백. 1 2 3 4 const numbers = [1, 2, 3]; numbers.forEach((num) => { console.log(num); // 배열의 각 요소를 출력 }); 비동기적(Asynchronous) 콜백 호출자 함수가 실행된 후, 특정 작업이 완료되었을 때 호출된다. 주로 시간이 걸리는 작업(예: 파일 읽기, API 요청)에서 사용된다. 예시: setTimeout 또는 이벤트 리스너. 1 2 3 setTimeout(() => { console.log("3초 후에 실행됩니다."); }, 3000); 콜백 함수를 사용하는 이유 비동기 작업 처리: 시간이 걸리는 작업(API 요청, 파일 읽기 등)을 처리하는 동안 메인 프로그램 흐름을 막지 않음. 코드 유연성 증가: 특정 작업 이후 실행할 동작을 동적으로 정의 가능. 모듈화 및 재사용성 증가: 코드의 특정 동작을 분리하여 재사용 가능. 주의할 점 콜백 지옥(Callback Hell)
복잡한 비동기 작업이 중첩되어 코드 가독성이 떨어지고 유지보수가 어려워지는 현상.
해결책 Promise 사용: 비동기 작업을 체인 형태로 작성하여 가독성을 개선. Async/Await 사용: 비동기 코드를 동기 코드처럼 작성 가능. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 잘못된 방식 getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { // 콜백 지옥… }); }); }); }); // 올바른 방식 // Promise나 async/await를 사용하여 개선 async function fetchData() { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); // 더 깔끔하고 읽기 쉬운 코드 } 오류 처리
콜백 함수에서 발생하는 오류를 적절히 처리해야 한다.
오류 처리 콜백을 별도로 제공하는 것이 좋다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 잘못된 방식 function fetchData(callback) { // 에러 처리가 없음 callback(data); } // 올바른 방식 function fetchData(callback) { try { // 데이터 처리 callback(null, data); } catch (error) { callback(error, null); } } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 실행 순서 보장
비동기 콜백의 경우 실행 순서를 신중히 고려해야 한다.
필요한 경우 콜백 체인을 사용하여 순서를 보장할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function processUserUnsafe(userId) { let userData; fetchUserData( userId, (user) => { userData = user; console.log("1. 사용자 데이터 받음:", userData); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); // userData가 설정되기 전에 실행될 수 있음 console.log("2. userData 사용:", userData); } // 4. 콜백 체인을 사용한 실행 순서 보장 function processUserSafe(userId) { fetchUserData( userId, (user) => { console.log("1. 사용자 데이터 받음:", user); validateUser(user, (validatedUser) => { console.log("2. 사용자 검증 완료:", validatedUser); updateUser(validatedUser, (updatedUser) => { console.log("3. 사용자 정보 업데이트 완료:", updatedUser); }, (error) => console.error("사용자 업데이트 실패:", error) ); }, (error) => console.error("사용자 검증 실패:", error) ); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); } 파이썬에서의 콜백 함수 예제 파이썬에서도 함수를 매개변수로 전달하여 콜백 함수를 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-06 12:45:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;803 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Function (콜백 함수)" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/callback-function/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/56/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/58/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>