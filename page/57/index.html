<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Code Review Best Practices</h2></header><div class=entry-content><p>Code Review Best Practices **Version Control Systems (VCS)**에서 Code Review Best Practices는 코드 품질 향상과 팀 협업 강화를 위한 핵심 프로세스입니다. 소프트웨어 개발 과정에서 동료 개발자가 작성한 코드를 검토하여 품질을 향상시키고, 버그를 사전에 방지하며, 지식 공유를 촉진하는 역할을 한다. 2025 년 현재 AI 통합, 자동화된 검토 도구, 지표 기반 평가가 주요 트렌드로 부상하며, Git 을 중심으로 한 워크플로우 최적화가 중요시된다.
핵심 개념 및 목적 코드 리뷰는 한 개발자가 작성한 코드를 다른 개발자가 검토하는 체계적인 프로세스이다. 주로 풀 리퀘스트 (Pull Request) 또는 머지 리퀘스트 (Merge Request) 를 통해 이루어지며, 코드의 품질, 가독성, 기능성 및 표준 준수 여부를 평가한다.
...</p></div><footer class=entry-footer><span title='2024-10-01 09:48:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Code Review Best Practices" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/code-review-best-practices/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Open Source Contribution</h2></header><div class=entry-content><p>Open Source Contribution 오픈소스 기여 (Open Source Contribution) 는 공개된 소프트웨어 프로젝트에 개인이나 조직이 코드, 문서, 테스트, 버그 리포트 등을 통해 참여하는 활동이다. 이는 버전 관리 시스템 (특히 Git) 을 중심으로 이루어지며, Fork-Clone- 수정 -Pull Request 로 이어지는 표준화된 워크플로우를 통해 진행된다. 오픈소스 기여는 소프트웨어 개발 생태계의 지속 가능성을 유지하고, 개발자 간 지식 공유와 협업을 촉진하며, 개인 개발자에게는 실무 경험과 평판을 쌓을 기회를 제공한다.
핵심 개념 오픈소스 기여는 공개된 소프트웨어 프로젝트에 개발자가 자발적으로 참여하여 코드, 문서, 디자인, 테스트 등을 통해 가치를 더하는 활동이다.
...</p></div><footer class=entry-footer><span title='2024-10-01 06:07:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Open Source Contribution" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/open-source-contribution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pull Request Flow</h2></header><div class=entry-content><p>Pull Request Flow **Version Control Systems (VCS)**에서 Pull Request Flow는 코드 변경 사항의 체계적 검토와 협업을 위한 핵심 프로세스입니다. 2025 년 현재 AI 기반 자동화, 실시간 협업 도구, 보안 강화가 주요 트렌드로 부상하며, GitHub 및 GitLab 을 중심으로 한 워크플로우 최적화가 중요시됩니다. 아래에서는 PR 흐름의 핵심 원칙부터 실무 적용 사례까지 종합적으로 정리합니다.
1. 주제 분류 적절성 검토 분류: Computer Science and Engineering > Backend Development > Version Control Systems > Collaboration 적절성: Pull Request(PR) 는 코드 리뷰, 병합 전략, 팀 협업을 관리하는 과정이므로 “Collaboration” 하위 분류는 타당합니다. Git 의 Fork-PR 모델과 GitHub/GitLab 의 협업 기능과 직접 연관됩니다 [1][3][7]. 2. 개요 구분 설명 핵심 개념 코드 변경 사항의 체계적 검토 및 병합 프로세스 목적 코드 품질 향상, 병렬 개발 효율화, 롤백 관리 주요 기능 PR 생성, 리뷰, 충돌 해결, 머지 전략 아키텍처 중앙집중형 (GitHub) vs 분산형 (GitLab) 최신 동향 AI 기반 자동 리뷰, 실시간 협업, SBOM 통합 3. 핵심 내용 정리 3.1 Pull Request 의 핵심 원칙 원칙 설명 출처 단일 책임 원칙 하나의 PR 은 하나의 기능/버그 수정만 포함 [6] 명확한 설명 제목과 본문에 변경 사항의 목적/영향 명시 [6][12] 소규모 변경 200-400 라인 이하로 분할하여 리뷰 효율성 ↑ [15] 3.2 분류에 따른 PR 유형 유형 특징 사용 사례 도구 Feature Branch 기능 단위 분기 → main 병합 신규 기능 개발 GitHub Gitflow develop/release 분기 활용 릴리스 관리 GitLab Forking 외부 기여자용 포크 기반 PR 오픈소스 기여 Bitbucket 3.3 장점과 단점 구분 항목 설명 ✅ 장점 코드 품질 다중 검토를 통한 버그 감소 [1][15] 협업 효율성 팀원 간 지식 공유 촉진 [3][19] ⚠ 단점 시간 소모 대규모 PR 검토 시 리소스 과부하 [15] 주관적 편향 리뷰어의 코딩 스타일 반영 가능 [18] 3.4 실무 적용 예시 시나리오 해결 방안 도구/기법 대규모 팀 리뷰 지연 CODEOWNERS 로 리뷰어 자동 지정 GitLab[8] 커밋 이력 단순화 Squash Merge 로 여러 커밋 압축 GitHub[9] 보안 취약성 검출 CodeQL + AI 리뷰봇 연동 Bugdar[12] 4. 추가 조사 내용 4.1 PR 템플릿 작성 목적: 표준화된 리뷰 프로세스 구축 [7]
...</p></div><footer class=entry-footer><span title='2024-10-01 02:11:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;34 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pull Request Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/pull-request-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>캐시 (Cache)</h2></header><div class=entry-content><p>캐시 (Cache) 캐시(Cache)는 컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 저장소를 의미한다.
데이터 접근 속도를 높이고 시스템 성능을 향상시킬 수 있다.
자주 사용되는 데이터는 빠르게 접근할 수 있는 위치에 복사해두는데 이 위치를 캐시(Cache)라고 말한다.
캐시의 특징 속도: 주 메모리나 디스크보다 훨씬 빠르다. 용량: 일반적으로 주 메모리보다 작다. 비용: 고속이기 때문에 상대적으로 비싸다. 캐시의 장점 빠른 데이터 접근: 자주 사용되는 데이터에 빠르게 접근할 수 있다. 시스템 성능 향상: 전체적인 시스템 응답 시간을 줄인다. 리소스 절약: 반복적인 데이터 요청을 줄여 서버 부하를 감소시킨다. 캐시 사용 시 주의점 일관성 유지: 원본 데이터가 변경될 때 캐시도 업데이트해야 한다. 캐시 크기 관리: 너무 크면 메모리 낭비, 너무 작으면 효율이 떨어진다. 캐시 교체 정책: 캐시가 가득 찼을 때 어떤 데이터를 제거할지 결정해야 한다. 캐시의 동작 과정 데이터 요청: 프로그램이 데이터를 요청한다. 캐시 확인: 시스템은 먼저 캐시에서 데이터를 찾는다. 캐시 히트(Cache Hit): 데이터가 캐시에 있으면 즉시 반환한다. 캐시 미스(Cache Miss): 데이터가 캐시에 없으면 주 메모리나 디스크에서 가져와 캐시에 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 캐시의 기본 작동 원리를 보여주는 예제 class SimpleCache: def __init__(self): self.cache = {} # 데이터를 저장할 공간 def get_data(self, key): # 1. 캐시에서 먼저 찾아봅니다 if key in self.cache: print("캐시에서 데이터를 찾았습니다!") return self.cache[key] # 2. 캐시에 없다면 원본 소스에서 가져옵니다 print("캐시에 없어서 원본에서 가져옵니다…") data = self.fetch_from_source(key) # 3. 다음 사용을 위해 캐시에 저장합니다 self.cache[key] = data return data 캐시의 종류 CPU 캐시: CPU와 주 메모리 사이에 위치한 고속의 소용량 메모리
역할:
...</p></div><footer class=entry-footer><span title='2024-09-30 13:25:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 캐시 (Cache)" href=https://buenhyden.github.io/posts/system-design/caching/cache/cache/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Byte Addressable Memory vs Word Addressable Memory</h2></header><div class=entry-content><p>Byte Addressable Memory vs. Word Addressable Memory Byte Addressable Memory와 Word Addressable Memory는 컴퓨터 메모리의 주소 지정 방식을 설명하는 개념이다.
이 두 가지 방식은 메모리의 구조와 데이터 접근 방법에 중요한 차이를 나타낸다.
Sourece: https://examradar.com/memory-organisation/
Byte Addressable Memory Byte Addressable Memory는 각 바이트(8비트)마다 고유한 주소가 할당되어 개별적으로 접근할 수 있는 메모리 구조이다.
가장 작은 주소 지정 단위(smallest addressable unit)는 1바이트(8비트)이며, 이를 통해 메모리의 각 바이트에 직접 접근할 수 있다.
CPU는 개별 바이트 단위로 메모리에 접근할 수 있으며, 워드(일반적으로 4바이트 또는 8바이트) 단위의 접근도 가능하다.
32비트 시스템에서는 2^32개의 주소를 가질 수 있어 최대 4GB의 메모리를 지원하며, 64비트 시스템에서는 훨씬 더 큰 주소 공간을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 11:38:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Byte Addressable Memory vs Word Addressable Memory" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Allocation Policy</h2></header><div class=entry-content><p>Allocation Policy Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.
이 정책은 시스템의 성능과 효율성에 큰 영향을 미치므로 신중하게 선택해야 한다.
Cache Allocation Policy의 주요 유형과 특징 Write-Allocate (Fetch-on-Write)
Write-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우(write miss), 먼저 해당 블록을 캐시로 가져온 후 쓰기 작업을 수행한다. 이 방식은 후속 읽기 작업이 캐시에서 바로 데이터를 찾을 수 있어 읽기 성능을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Allocation Policy" href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/allocation-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prefetch Policy</h2></header><div class=entry-content><p>Prefetch Policy Cache Policy의 Prefetch Policy는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략이다.
이 정책은 시스템의 성능을 향상시키기 위해 사용되며, 특히 데이터 접근이 반복적이거나 예측 가능한 경우에 효과적이다.
Prefetching은 프로그램이 실제로 데이터에 접근하기 전에 미리 데이터를 메모리로 가져오는 기술이다.
이를 통해 캐시 미스를 줄이고, 데이터 접근 속도를 높이며, 전반적인 시스템 성능을 개선할 수 있다.
Prefetch Policy는 이러한 prefetching 작업을 어떻게 수행할지를 결정하는 규칙이나 방법론을 의미한다.
Prefetch Policy는 캐시 시스템에서 성능 향상을 위한 중요한 전략이다.
하드웨어, 소프트웨어 또는 컴파일러 수준에서 구현될 수 있으며, 다양한 유형의 prefetching 기법이 존재한다. 적절한 prefetch 정책을 선택하고 구현함으로써 시스템 성능을 크게 개선할 수 있으며, 데이터 접근 패턴과 요구사항에 맞춰 최적화하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prefetch Policy" href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/prefetch-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Replacement Policy</h2></header><div class=entry-content><p>Replacement Policy Cache Replacement Policy(캐시 교체 정책) 는 캐시 메모리에서 새로운 데이터를 저장하기 위해 기존의 데이터를 교체할 때 어떤 데이터를 제거할지를 결정하는 규칙이다.
캐시는 한정된 크기를 가지므로, 새로운 데이터가 들어올 때 기존의 데이터를 교체해야 한다. 이때 어떤 데이터를 선택할지는 시스템의 성능에 큰 영향을 미친다.
Cache Replacement Policy는 캐시 메모리의 효율성을 극대화하는 데 중요한 역할을 한다. LRU, FIFO, LFU 등 다양한 정책들이 있으며, 각 정책은 특정 상황과 요구 사항에 따라 장단점이 다르다.
적절한 교체 정책을 선택함으로써 시스템의 성능을 개선하고 데이터 접근 속도를 높일 수 있다. 캐시를 효과적으로 관리하기 위해서는 워크로드 특성과 시스템 요구 사항을 면밀히 분석하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Replacement Policy" href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/replacement-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Placement Policy</h2></header><div class=entry-content><p>Placement Policy Cache Placement Policy는 캐시 메모리에서 특정 메모리 블록이 캐시에 저장될 위치를 결정하는 규칙을 의미한다.
이는 캐시의 구조와 데이터 접근 패턴에 따라 성능과 효율성에 큰 영향을 미친다. Placement Policy는 캐시 메모리의 설계와 운영에서 중요한 역할을 하며, 주로 다음 세 가지 주요 유형으로 나뉜다:
Direct-Mapped Cache Fully Associative Cache Set-Associative Cache. Cache Placement Policy란? 정의: Placement Policy는 특정 메모리 블록이 캐시에 저장될 때, 캐시 내에서 어느 위치(캐시 라인)에 저장될지를 결정하는 규칙이다. 목적: 캐시 메모리의 효율적인 사용. 데이터 접근 속도 최적화. 충돌(Collision) 관리: 동일한 캐시 라인에 여러 데이터가 매핑되는 상황을 최소화. Cache Placement Policy는 데이터가 캐시에 저장되는 위치를 결정하며, 시스템 성능과 효율성에 직접적인 영향을 미친다.
Direct-Mapped, Fully Associative, Set-Associative 각각 장단점이 있으므로, 애플리케이션 요구사항과 하드웨어 제약 조건을 고려하여 적절한 정책을 선택해야 한다.
Set-Associative는 대부분의 현대 시스템에서 자주 사용되는 절충안으로, 성능과 비용 간 균형을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:50:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Placement Policy" href=https://buenhyden.github.io/posts/system-design/caching/cache-policy/placement-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 접근 방법 (Memory Access Methods)</h2></header><div class=entry-content><p>메모리 접근 방식 (Memory Access Methods) 컴퓨터 시스템에서 메모리에 접근하는 주요 방식은 다음과 같다:
순차적 접근 (Sequential Access)
메모리를 선형적인 순서로 접근하는 방식. 데이터를 처음부터 순서대로 읽거나 쓰며, 특정 위치에 접근하려면 그 앞의 모든 데이터를 거쳐야 한다. 주로 자기 테이프와 같은 저장 장치에서 사용된다. 직접 접근 (Direct Access)
각 메모리 블록이 고유한 주소를 가지고 있어 직접 접근이 가능하다. 일반적인 위치로 직접 접근한 후, 순차적 검색을 통해 최종 목적지에 도달한다. 하드 디스크와 같은 저장 장치에서 주로 사용된다. 랜덤 접근 (Random Access)
...</p></div><footer class=entry-footer><span title='2024-09-30 08:05:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 접근 방법 (Memory Access Methods)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/access-methods/memory-access-methods/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/56/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/58/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>