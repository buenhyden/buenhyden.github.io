<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Doubly Linked List</h2></header><div class=entry-content><p>Doubly Linked List Doubly Linked List는 노드들이 양방향으로 연결된 선형 데이터 구조로, 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 포함하고 있다.
Doubly Linked List는 각 노드가 데이터와 두 개의 링크 필드를 가지고 있는 있으며, 이 두 개의 링크는 이전 노드(previous node)와 다음 노드(next node)를 가리킨다.
이러한 구조로 인해 리스트의 양방향 순회가 가능해진다.
![Doubly Linked List](Insertion-at-the-End-in-Doubly-Linked-List-copy.webp “https://www.geeksforgeeks.org/doubly-linked-list/ _
특징 양방향 연결: 각 노드는 이전 노드와 다음 노드를 모두 가리킨다. 헤드와 테일: 리스트의 시작(헤드)과 끝(테일)을 모두 가리키는 포인터를 유지한다. 순환 구조: 마지막 노드의 다음 노드는 첫 번째 노드를, 첫 번째 노드의 이전 노드는 마지막 노드를 가리킬 수 있다. 장점 양방향 탐색: 리스트를 앞뒤로 탐색할 수 있어 효율적인 검색이 가능하다. 삽입과 삭제의 효율성: 노드의 삽입과 삭제가 O(1) 시간 복잡도로 수행된다. 리스트 끝에서의 연산: 테일 포인터를 통해 리스트의 마지막 요소에 즉시 접근할 수 있다. 단점 메모리 사용량 증가: 각 노드가 두 개의 포인터를 저장해야 하므로 메모리 사용량이 증가한다. 구현의 복잡성: 단일 연결 리스트에 비해 구현이 더 복잡하다. 삽입과 삭제 시 포인터 조작: 노드 삽입과 삭제 시 여러 포인터를 조작해야 한다. 응용 웹 브라우저의 앞으로/뒤로 탐색 기능 음악 플레이어의 재생 목록 운영 체제의 작업 스케줄링 캐시 구현 복잡한 데이터 구조(예: 그래프)의 기본 구성 요소 동작 원리 삽입: 새 노드를 생성하고 이전 노드와 다음 노드의 포인터를 적절히 조정한다. 삭제: 삭제할 노드의 이전 노드와 다음 노드를 서로 연결하고 해당 노드를 메모리에서 해제한다. 탐색: 헤드나 테일에서 시작하여 원하는 노드를 찾을 때까지 포인터를 따라 이동한다. 구성 요소 노드: 데이터와 이전/다음 노드를 가리키는 두 개의 포인터로 구성된다. 헤드 포인터: 리스트의 첫 번째 노드를 가리킨다. 테일 포인터: 리스트의 마지막 노드를 가리킨다. 구현 방식 JavaScript를 사용한 Doubly Linked List 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Doubly Linked List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear/linked-list/types/doubly-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Skip List</h2></header><div class=entry-content><p>Skip List Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다.
Skip List는 여러 레벨의 연결 리스트로 구성된 데이터 구조로, 각 레벨은 그 아래 레벨의 일부 요소를 포함하며, 최하위 레벨은 모든 요소를 포함한다.
https://en.wikipedia.org/wiki/Skip_list#/media/File:Skip_list.svg
특징 다중 레벨 구조: 여러 층의 연결 리스트로 구성된다. 확률적 균형: 랜덤화를 통해 구조의 균형을 유지한다. 정렬 상태 유지: 요소들은 정렬된 순서로 유지된다. 장점 빠른 검색: 평균 O(log n) 시간 복잡도로 검색이 가능하다. 효율적인 삽입/삭제: 평균 O(log n) 시간에 삽입과 삭제가 가능하다. 구현의 단순성: 균형 이진 탐색 트리에 비해 구현이 간단하다. 단점 추가 메모리 사용: 여러 레벨의 포인터로 인해 추가 메모리가 필요하다. 확률적 성능: 최악의 경우 O(n) 시간 복잡도가 발생할 수 있다. 응용 데이터베이스 인덱싱: RocksDB와 같은 키-값 저장소에서 사용된다. 메모리 관리: 비휘발성 메모리 최적화에 활용된다. 캐시 구현: 효율적인 캐시 시스템 구축에 사용된다. 동작 원리 검색: 최상위 레벨에서 시작하여 목표 값보다 작은 노드를 따라 이동하고, 큰 값을 만나면 아래 레벨로 내려간다. 삽입: 랜덤하게 레벨을 결정하고, 해당 레벨까지 노드를 생성하여 연결한다. 삭제: 노드를 찾아 모든 레벨에서 제거한다. 구성 요소 노드: 키, 값, 여러 레벨의 다음 노드 포인터를 포함한다. 헤드 노드: 모든 레벨의 시작점 역할을 한다. 레벨: 여러 층의 연결 리스트 구조를 형성한다. 구현 방식 JavaScript를 사용한 Skip List 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Skip List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear/linked-list/variants/skip-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linked List vs. Array</h2></header><div class=entry-content><p>Array vs. Linked List 데이터 구조는 프로그래밍에서 데이터를 효율적으로 저장하고 관리하기 위한 방법을 제공합니다. 이 중에서도 배열과 연결 리스트는 가장 기본적이면서도 중요한 데이터 구조이다.
두 구조는 서로 다른 특성과 장단점을 가지고 있어 적절한 상황에 맞게 선택해 사용해야 한다.
배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.
반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.
적절한 상황에 맞는 자료구조 선택은 효율적인 프로그램 개발의 핵심이다. 따라서 문제의 특성과 요구사항을 잘 분석하여 최적의 자료구조를 선택해야 한다. 때로는 두 자료구조의 장점을 결합한 하이브리드 접근 방식이나 다른 고급 자료구조를 활용하는 것이 더 나은 해결책이 될 수도 있다.
...</p></div><footer class=entry-footer><span title='2024-10-07 16:32:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linked List vs. Array" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linear/linked-list/linked-list-vs-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 보호와 안전 (Memory Protection and Safety)</h2></header><div class=entry-content><p>메모리 보호와 안전 (Memory Protection and Safety) 메모리 보호와 안전은 현대 컴퓨터 시스템에서 매우 중요한 요소이다.
메모리 보호는 컴퓨터 시스템에서 프로세스가 허가되지 않은 메모리 영역에 접근하는 것을 방지하는 메커니즘이다.
주요 목적은 다음과 같다:
프로세스 간 격리 유지 운영 체제 커널 보호 버그나 악성 소프트웨어로부터 시스템 보호 메모리 보호 기술 하드웨어 기반 보호 메모리 관리 장치 (MMU): 가상 주소를 물리적 주소로 변환하고 접근 권한을 확인한다. 보호 키: 메모리 영역에 키를 할당하여 접근을 제어한다. 보호 링: 권한 수준에 따라 메모리 접근을 제어한다. 세그먼테이션: 메모리를 논리적 세그먼트로 나누어 보호한다. 소프트웨어 기반 보호 가상 메모리: 각 프로세스에 독립적인 주소 공간을 제공한다. 주소 공간 레이아웃 랜덤화 (ASLR): 메모리 주소를 무작위화하여 공격을 어렵게 한다. 데이터 실행 방지 (DEP): 데이터 영역에서 코드 실행을 방지한다. 메모리 안전성 (Memory Safety) 메모리 안전성은 프로그램이 할당된 메모리 범위 내에서만 작동하도록 보장하는 개념이다.
...</p></div><footer class=entry-footer><span title='2024-10-05 08:06:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 보호와 안전 (Memory Protection and Safety)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/memory-protection-and-safety/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>코루틴(Coroutine)</h2></header><div class=entry-content><p>코루틴 (Coroutine) 코루틴 (Coroutine) 은 복잡한 비동기 작업을 간단하고 효율적으로 처리할 수 있게 해주는 프로그래밍 개념이다.
프로그램의 실행 흐름을 제어할 수 있는 프로그래밍 구성 요소이다.
일반적인 함수와 달리, 코루틴은 실행을 일시 중단하고 재개할 수 있으며, 여러 진입점과 종료점을 가질 수 있다.
이는 마치 대화하는 것처럼, 실행을 주고받을 수 있다는 특징이 있다.
1 2 3 4 5 6 7 8 9 10 11 12 13 # Python에서의 간단한 코루틴 예제 async def simple_coroutine(): print("코루틴 시작") await asyncio.sleep(1) # 중단점 print("1초 후 재개") await asyncio.sleep(1) # 다른 중단점 print("또 1초 후 재개") # 코루틴 실행 async def main(): await simple_coroutine() asyncio.run(main()) https://medium.com/@turxan.dunya97/simple-explanation-what-is-coroutines-in-programming-d01e0ddf6f06
...</p></div><footer class=entry-footer><span title='2024-10-05 06:52:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 코루틴(Coroutine)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/threads/coroutine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Thread</h2></header><div class=entry-content><p>스레드의 기본 개념과 프로세스와의 차이점 설명. 멀티스레딩의 장점과 주요 구현 방식(POSIX Threads, Windows Threads). 유사 기술: 멀티프로세싱, 비동기 처리. Thread Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.
하나의 프로세스는 여러 개의 Thread를 가질 수 있으며, 이들은 프로세스의 자원을 공유한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
Thread의 구성 요소 Thread는 다음과 같은 구성 요소를 가진다:
프로그램 카운터 레지스터 집합 스택 공간 Thread ID
이러한 요소들은 각 Thread의 독립적인 실행을 가능하게 한다. Thread의 특징 경량성: Thread는 프로세스에 비해 생성과 관리가 더 빠르고 효율적이다. 자원 공유: 같은 프로세스 내의 Thread들은 코드, 데이터, 파일 등의 자원을 공유한다. 병렬 실행: 멀티코어 시스템에서는 여러 Thread가 실제로 동시에 실행될 수 있다. 기능과 역할 기능 역할 장점 병렬 처리 - 동시에 여러 작업 수행
CPU 활용도 증가 - 성능 향상
- 응답성 개선 자원 공유 - 프로세스 자원 공유
- 효율적인 메모리 사용 - 메모리 절약
- 통신 비용 감소 비동기 처리 - 독립적인 작업 수행
- 이벤트 처리 - 응답성 향상
UI 처리 효율화 Thread의 종류 Thread는 크게 두 가지로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-04 23:32:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Thread" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/threads/threads/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multithreading</h2></header><div class=entry-content><p>멀티 쓰레딩 (Multithreading) Multithreading은 운영 체제에서 프로그램이 여러 작업을 동시에 수행할 수 있게 해주는 기능이다. 즉, 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 의미하며, 각 스레드는 프로세스의 자원을 공유하면서도 독립적인 실행 경로를 가진다.
이는 단일 프로세스 내에서 여러 실행 흐름(스레드)을 생성하고 관리하며, 현대 컴퓨터 시스템의 성능과 효율성을 크게 향상시킨다.
Source: https://www.geeksforgeeks.org/multithreading-in-operating-system/
각 스레드는 자신만의 프로그램 카운터, 레지스터 집합, 스택을 가지고 있다. 하지만 같은 프로세스 내의 스레드들은 코드, 데이터 섹션, 파일과 같은 자원을 공유한다. 이는 프로세스보다 스레드의 생성과 컨텍스트 스위칭이 더 가벼운 이유가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-04 14:33:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multithreading" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/multithreading/__index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mutex</h2></header><div class=entry-content><p>Mutex Mutex(Mutual Exclusion) 는 공유 자원에 대한 접근을 동기화하는 객체.
한 번에 하나의 스레드만이 Mutex 를 소유할 수 있으며, 소유권 개념이 있어 Mutex 를 획득한 스레드만이 이를 해제할 수 있다.
Source: https://www.geeksforgeeks.org/std-mutex-in-cpp/
주요 특징 두 가지 상태 (잠김/열림) 를 가집니다. 한 번에 하나의 스레드만 소유할 수 있습니다. 소유한 스레드만이 잠금을 해제할 수 있습니다. Mutex 의 종류 일반 Mutex (Normal Mutex) 가장 기본적인 형태의 Mutex.
단순한 상호 배제 기능을 제공하며, 재진입이 불가능하다.
가장 빠른 성능을 제공하지만 우선순위 상속과 같은 고급 기능은 지원하지 않는다.
...</p></div><footer class=entry-footer><span title='2024-10-04 11:00:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;51 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutex" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization-primitives/software-level/mutex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>조건 변수 (Condition Variable)</h2></header><div class=entry-content><p>조건 변수 (Condition Variable) 조건 변수 (Condition Variables) 는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.
스레드가 특정 조건이 만족될 때까지 대기하고, 조건이 충족되면 다른 스레드가 대기 중인 스레드를 깨우는 데 사용된다.
뮤텍스와의 연관 조건 변수는 일반적으로 뮤텍스와 함께 사용된다.
뮤텍스는 조건을 원자적으로 검사하고 변경할 수 있도록 보장한다.
주요 연산 wait(): 스레드가 조건이 충족될 때까지 대기하도록 한다. signal()/notify_one(): 대기 중인 단일 스레드를 깨운다. broadcast()/notify_all(): 해당 조건 변수에서 대기 중인 모든 스레드를 깨운다. 사용 패턴 조건을 보호하는 뮤텍스를 획득한다. 조건을 테스트한다. 조건이 거짓이면 wait() 를 호출하여 대기한다. 조건이 참이면 작업을 수행하고 뮤텍스를 해제한다. 가짜 깨우기 (Spurious Wakeup) 가짜 깨우기는 조건 변수 (Condition Variable) 를 사용할 때 발생할 수 있는 현상이다.
스레드가 실제로 signal 이나 broadcast 를 받지 않았는데도 wait 상태에서 깨어나는 현상을 말한다.
...</p></div><footer class=entry-footer><span title='2024-10-04 10:54:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조건 변수 (Condition Variable)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/condition-synchronization/implementation-mechanisms/condition-variable/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>원자적 연산 (Atomic Operation)</h2></header><div class=entry-content><p>원자적 연산 (Atomic Operation) 원자적 연산(Atomic Operation)은 멀티스레딩 환경에서 데이터의 일관성과 안전성을 보장하기 위한 중요한 개념으로, 상호 배제(Mutual Exclusion)를 구현하는 데 중요한 역할을 한다.
원자적 연산이란, 더 이상 쪼개질 수 없는 최소 단위의 연산을 의미하는데 중단되거나 간섭받지 않고 완전히 실행되는 연산을 말한다.
이는 마치 물리학에서 원자가 더 이상 쪼개질 수 없는 가장 작은 단위인 것처럼, 컴퓨터 과학에서도 더 이상 분할할 수 없는 가장 작은 실행 단위를 의미한다.
주요 특징 불가분성: 원자적 연산은 중간에 중단되거나 다른 프로세스에 의해 간섭받지 않는다. 일관성: 연산이 성공적으로 완료되거나 아예 실행되지 않는다. 가시성: 다른 스레드에서 원자적 연산의 결과를 즉시 확인할 수 있다. 원자적 연산의 중요성 데이터 무결성 보장: 여러 스레드가 동시에 같은 데이터에 접근할 때 발생할 수 있는 경쟁 조건(Race Condition)을 방지한다. 동기화 구현: 원자적 연산은 복잡한 동기화 메커니즘의 기본 구성 요소이다. 성능 향상: 락(Lock)과 같은 고수준의 동기화 메커니즘보다 더 가볍고 빠르다. 원자적 연산의 예시 읽기-수정-쓰기(Read-Modify-Write) 연산:
...</p></div><footer class=entry-footer><span title='2024-10-04 10:48:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 원자적 연산 (Atomic Operation)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization-primitives/hardware-level/atomic-operation/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/49/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/51/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>