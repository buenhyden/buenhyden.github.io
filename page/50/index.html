<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분산 트랜잭션 (Distributed transaction)</h2></header><div class=entry-content><p>분산 트랜잭션 (Distributed transaction) 분산 트랜잭션은 두 개 이상의 데이터 저장소(특히 데이터베이스)에 걸쳐 수행되는 일련의 데이터 작업이다.
이는 일반적으로 네트워크로 연결된 별도의 노드에서 조정되며, 단일 서버의 여러 데이터베이스에 걸쳐 있을 수도 있다.
특징:
ACID 속성 준수: 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 보장한다. 일관성 유지: 모든 분산 데이터베이스가 최신 정보로 동일하게 업데이트되어야 한다. 종료 보장: 분산 트랜잭션은 완전히 실행되거나 전혀 실행되지 않아야 한다. 장점:
데이터 일관성 보장 복잡한 비즈니스 프로세스 지원 시스템 신뢰성 향상 단점:
...</p></div><footer class=entry-footer><span title='2024-10-22 09:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 트랜잭션 (Distributed transaction)" href=https://buenhyden.github.io/posts/backend-development/databases/rdbms/fundamentals/transactions/distributed-transaction/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분산 트랜잭션 (Distributed transaction)</h2></header><div class=entry-content><p>분산 트랜잭션 (Distributed transaction) 분산 트랜잭션은 두 개 이상의 데이터 저장소(특히 데이터베이스)에 걸쳐 수행되는 일련의 데이터 작업이다.
이는 일반적으로 네트워크로 연결된 별도의 노드에서 조정되며, 단일 서버의 여러 데이터베이스에 걸쳐 있을 수도 있다.
특징:
ACID 속성 준수: 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 보장한다. 일관성 유지: 모든 분산 데이터베이스가 최신 정보로 동일하게 업데이트되어야 한다. 종료 보장: 분산 트랜잭션은 완전히 실행되거나 전혀 실행되지 않아야 한다. 장점:
데이터 일관성 보장 복잡한 비즈니스 프로세스 지원 시스템 신뢰성 향상 단점:
...</p></div><footer class=entry-footer><span title='2024-10-22 09:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분산 트랜잭션 (Distributed transaction)" href=https://buenhyden.github.io/posts/backend-development/databases/rdbms/tracsactions/distributed-transaction/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 캐싱 (Database Caching)</h2></header><div class=entry-content><p>데이터베이스 캐싱 (Database Caching) 데이터베이스 캐싱은 자주 사용되는 데이터를 빠르게 접근할 수 있는 메모리에 임시로 저장하는 기술.
정의와 목적 자주 액세스하는 데이터를 고속 메모리에 저장하여 빠른 검색 가능 데이터베이스 서버의 부하 감소 및 응답 시간 단축 주요 장점 성능 향상: 데이터 검색 속도 개선 서버 부하 감소: 반복적인 쿼리 처리 최소화 비용 절감: 데이터베이스 리소스 사용 효율화 사용자 경험 개선: 빠른 응답 시간 제공 작동 원리 캐시 히트: 요청 데이터가 캐시에 있어 즉시 반환 캐시 미스: 데이터가 캐시에 없어 원본 데이터베이스에서 조회 캐싱 전략 인-메모리 캐싱: RAM에 데이터 저장 (예: Redis, Memcached) 쿼리 결과 캐싱: 자주 실행되는 쿼리 결과 저장 객체 캐싱: 애플리케이션 레벨에서 객체 단위로 캐싱 주의사항 데이터 일관성 유지: 캐시와 원본 데이터 간 불일치 방지 적절한 캐시 갱신 정책 수립 필요 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 06:25:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 캐싱 (Database Caching)" href=https://buenhyden.github.io/posts/backend-development/backend-performance/caching/server-side/database-caching/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>쿼리 최적화 (Query Optimization)</h2></header><div class=entry-content><p>쿼리 최적화 (Query Optimization) 데이터베이스 쿼리 최적화는 데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 중요한 프로세스이다.
쿼리 최적화의 목적 쿼리 응답 시간 단축 시스템 자원 사용 효율성 증대 전반적인 데이터베이스 성능 향상 사용자 경험 개선 주요 최적화 기법 인덱스 최적화 적절한 인덱스 생성 및 관리 복합 인덱스 활용 선택도가 높은 컬럼에 인덱스 생성 불필요한 인덱스 제거 1 2 3 4 5 6 7 8 9 -- 자주 사용되는 조건절에 대한 인덱스 생성 CREATE INDEX idx_orders_amount_date ON orders(total_amount, order_date); -- 위 인덱스를 활용하는 최적화된 쿼리 SELECT customers.name, orders.order_date, orders.total_amount FROM orders -- 인덱스를 가진 테이블을 먼저 참조 JOIN customers ON customers.id = orders.customer_id WHERE orders.total_amount > 1000 ORDER BY orders.order_date DESC; 쿼리 재작성 복잡한 쿼리 단순화 서브쿼리 최소화 및 조인으로 대체 WHERE 절 최적화 필요한 컬럼만 선택 (SELECT *) 테이블 조인 순서와 조인 유형을 적절히 선택 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 비효율적인 서브쿼리 SELECT * FROM customers WHERE id IN ( SELECT customer_id FROM orders WHERE total_amount > 1000 ); -- 더 효율적인 조인으로 변환 SELECT DISTINCT c.* FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.total_amount > 1000; 실행 계획 분석 쿼리 실행 계획 확인 및 분석 비효율적인 실행 계획 개선 쿼리 실행 계획은 데이터베이스가 쿼리를 어떻게 처리할지를 보여주는 로드맵과 같다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:23:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 쿼리 최적화 (Query Optimization)" href=https://buenhyden.github.io/posts/backend-development/databases/rdbms/sql/query-optimization/query-optimization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud Networking</h2></header><div class=entry-content><p>Cloud Networking 클라우드 네트워킹은 클라우드 컴퓨팅 환경에서 리소스들을 연결하고 통신할 수 있게 해주는 인프라를 의미한다.
기존의 물리적 네트워크와 달리, 가상화 기술을 기반으로 하여 더욱 유연하고 확장성 있는 네트워크 구성이 가능하다.
클라우드 서비스의 안정적인 제공과 효율적인 리소스 관리를 위해서는 견고한 네트워크 인프라가 필수적이다.
기본 개념 클라우드 네트워킹은 클라우드 기반 서비스를 사용하여 조직의 직원, 리소스 및 애플리케이션을 연결하는 기업 네트워크를 배포하는 것.
이는 가상 라우터, 방화벽, 네트워크 관리 소프트웨어 등으로 구성된 WAN(Wide Area Network)이다.
...</p></div><footer class=entry-footer><span title='2024-10-20 17:39:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud Networking" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/cloud-networking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>네트워크 기능 가상화(Network Functions Virtualization, NFV)</h2></header><div class=entry-content><p>네트워크 기능 가상화(Network Functions Virtualization, NFV) NFV는 전통적으로 전용 하드웨어 장비에서 실행되던 네트워크 기능들을 가상화하여 소프트웨어로 구현하는 네트워크 아키텍처 개념이다.
이를 통해 범용 서버에서 가상 네트워크 기능(VNF)을 실행할 수 있게 된다.
주요 구성요소 가상화된 네트워크 기능(VNF): 소프트웨어로 구현된 네트워크 기능 NFV 인프라(NFVI): VNF를 실행하기 위한 하드웨어 및 소프트웨어 환경 NFV 관리 및 오케스트레이션(MANO): VNF와 NFVI를 관리하고 조율하는 프레임워크 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class NFVArchitecture: def __init__(self): # NFVI (NFV Infrastructure) self.compute_resources = VirtualCompute() self.network_resources = VirtualNetwork() self.storage_resources = VirtualStorage() # VNF (Virtual Network Functions) self.network_functions = { "firewall": VirtualFirewall(), "load_balancer": VirtualLoadBalancer(), "router": VirtualRouter() } # MANO (Management and Orchestration) self.orchestrator = NFVOrchestrator() self.vnf_manager = VNFManager() self.infrastructure_manager = InfrastructureManager() class VirtualNetworkFunction: def __init__(self, function_type): self.type = function_type self.status = "initialized" self.resources = {} def deploy(self, resources): """가상 네트워크 기능 배포""" self.resources = resources self.status = "deployed" def scale(self, factor): """자원 스케일링""" self.resources = { k: v * factor for k, v in self.resources.items() } 장점 하드웨어 비용 절감 유연성과 확장성 향상 신규 서비스 출시 시간 단축 운영 효율성 증대 자동화를 통한 관리 간소화 구현 과제와 해결 방안 성능 최적화
가상화로 인한 성능 저하를 최소화하기 위한 전략들:
...</p></div><footer class=entry-footer><span title='2024-10-20 02:06:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 네트워크 기능 가상화(Network Functions Virtualization, NFV)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/network-functions-virtualization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)</h2></header><div class=entry-content><p>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN) 네트워크의 제어 기능을 네트워크 장비에서 분리하여 소프트웨어 기반 컨트롤러로 중앙집중화하는 네트워크 아키텍처.
목적 네트워크 리소스 최적화 변화하는 비즈니스 요구사항에 신속한 대응 네트워크 관리 및 구성의 간소화 특징 제어 평면 (Control Plane) 과 데이터 평면 (Data Plane) 의 분리: 네트워크 장비의 제어 기능 (라우팅 결정 등) 을 별도의 소프트웨어 컨트롤러로 분리. 중앙집중식 관리: 전체 네트워크를 단일 지점에서 관리할 수 있어 효율성이 향상. 프로그래밍 가능성: API 를 통해 네트워크 동작을 프로그래밍할 수 있어 유연성이 증가 개방형 표준: 표준화된 프로토콜과 인터페이스를 사용하여 다양한 벤더의 장비를 통합 관리할 수 있음. 계층 구조 애플리케이션 계층 (Application Layer) 네트워크 서비스, 비즈니스 애플리케이션 API 를 통한 네트워크 제어 ↕ Northbound API 제어 계층 (Control Layer) SDN 컨트롤러 네트워크 정책 및 제어 로직 ↕ Southbound API (OpenFlow 등) 인프라 계층 (Infrastructure Layer) 스위치, 라우터 등 네트워크 장비 패킷 전송 및 처리 장점 유연성과 민첩성: 네트워크 구성을 신속하게 변경할 수 있다. 비용 절감: 하드웨어 의존도를 줄여 CAPEX 와 OPEX 를 절감할 수 있다. 중앙집중식 관리: 네트워크 전체를 단일 지점에서 관리할 수 있다. 보안 강화: 중앙에서 일관된 보안 정책을 적용할 수 있음. 단점 단일 장애 지점: 중앙 컨트롤러에 문제가 생기면 전체 네트워크에 영향을 줌. 성능 저하 가능성: 네트워크 규모가 커지면 컨트롤러의 부하가 증가할 수 있음. 보안 취약점: 중앙 컨트롤러가 공격 대상이 될 수 있음. 기업의 지출을 구분하는 두 가지 주요 카테고리
...</p></div><footer class=entry-footer><span title='2024-10-20 02:00:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/layered-network-models/evolved-architectures/sdn-nfv-architecture/software-defined-networking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RDMA</h2></header><div class=entry-content><p>RDMA (Remote Direct Memory Access) 네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술
주요 특징:
낮은 지연 시간(Low Latency): CPU 개입 없이 메모리 간 직접 데이터 전송이 가능하므로, 전송 지연 시간이 매우 짧다. 높은 대역폭(High Bandwidth): 데이터 복사 과정이 없기 때문에 빠르고 효율적으로 대량의 데이터를 처리할 수 있다. 낮은 CPU 사용률(Low CPU Utilization): 데이터 전송 작업이 네트워크 어댑터(NIC)에서 이루어지기 때문에 CPU는 다른 작업에 집중할 수 있다. 제로-카피(Zero-Copy): 데이터가 중간 버퍼링 없이 메모리에서 바로 전송되므로, 데이터 복사로 인한 오버헤드가 없다. 효율성(Efficiency): 운영 체제와 CPU의 개입을 최소화하여 시스템 전체의 효율성을 높인다. 장점:
...</p></div><footer class=entry-footer><span title='2024-10-20 01:36:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RDMA" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/rdma/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프록시(Proxy)</h2></header><div class=entry-content><p>프록시(Proxy) 프록시(Proxy)는 “대리” 또는 “대신"이라는 의미를 가진 개념으로, 네트워크 환경에서 중요한 역할을 수행한다.
프록시 서버는 클라이언트의 요청을 받아 대신 서버에 접속하여 데이터를 주고받는 중개자 역할을 한다.
이 과정에서 프록시 서버는 클라이언트의 IP 주소를 숨기고, 자신의 IP 주소를 사용하여 서버와 통신한다.
프록시의 주요 기능 익명성 제공: 클라이언트의 실제 IP 주소를 숨겨 개인정보를 보호한다. 캐싱: 자주 요청되는 데이터를 저장하여 네트워크 성능을 향상시킨다. 접근 제어: 특정 웹사이트나 콘텐츠에 대한 접근을 제한할 수 있다. 로깅 및 모니터링: 네트워크 트래픽을 기록하고 분석할 수 있다. 프록시 사용의 장점 보안 강화: 클라이언트와 서버 사이의 직접적인 연결을 차단하여 보안을 향상시킨다. 성능 최적화: 캐싱을 통해 반복적인 요청에 대한 응답 속도를 높인다. 접근 제어: 조직 내 네트워크 사용을 관리하고 제한할 수 있다. 익명성: 사용자의 실제 IP 주소와 위치를 숨길 수 있다. 프록시 사용의 주의점 속도 저하: 추가적인 네트워크 홉으로 인해 약간의 지연이 발생할 수 있다. 보안 위험: 잘못 구성된 프록시는 오히려 보안 취약점이 될 수 있다. 호환성 문제: 일부 애플리케이션이나 서비스와 호환되지 않을 수 있다. 프록시의 작동 방식 사용자(클라이언트)가 웹사이트에 접속하려고 할 때, 직접 웹사이트 서버에 연결하지 않고 프록시 서버에 연결한다. 프록시 서버는 사용자의 요청을 받아 웹사이트 서버에 전달한다. 웹사이트 서버는 프록시 서버에 응답을 보낸다. 프록시 서버는 받은 응답을 다시 사용자에게 전달한다. Reverse Proxy vs. Forward-Proxy 프록시 서버는 클라이언트와 서버 간의 중개자 역할을 하는 서버로, 네트워크 아키텍처에서 중요한 구성 요소이다.
프록시 서버는 크게 포워드 프록시(Forward Proxy)와 리버스 프록시(Reverse Proxy)로 구분된다.
...</p></div><footer class=entry-footer><span title='2024-10-19 08:47:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프록시(Proxy)" href=https://buenhyden.github.io/posts/system-design/system-architecture/web-infrastructure/reverse-proxy/proxy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HATEOAS (Hypermedia As The Engine Of Application State)</h2></header><div class=entry-content><p>HATEOAS (Hypermedia As The Engine Of Application State) 서버가 클라이언트에게 하이퍼 미디어를 통해 정보를 동적으로 제공해주는 것을 말한다.
RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.
하이퍼미디어를 애플리케이션의 상태를 관리하기 위한 메커니즘으로 사용한다. 이는 클라이언트가 서버와 동적으로 상호작용할 수 있도록 하며, API 응답에 관련 리소스에 대한 링크를 포함시키는 방식으로 구현된다.
전통적인 API와 HATEOAS API의 차이점 기존 API:
1 2 3 4 5 { "orderId": "123", "total": 100, "status": "pending" } HATEOAS API:
...</p></div><footer class=entry-footer><span title='2024-10-19 07:35:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HATEOAS (Hypermedia As The Engine Of Application State)" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/hypermedia-style/hateoas/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/49/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/51/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>