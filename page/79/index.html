<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.141.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CQRS 패턴 (Command Query Responsibility Segregation)</h2></header><div class=entry-content><p>CQRS 패턴 (Command Query Responsibility Segregation) 애플리케이션의 명령(Command)과 쿼리(Query)의 책임을 분리하는 소프트웨어 아키텍처 패턴
이 패턴은 데이터를 변경하는 작업과 데이터를 읽는 작업을 별도의 모델로 분리하여 처리한다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from dataclasses import dataclass from datetime import datetime from typing import List, Optional # 도메인 모델 @dataclass class Product: id: str name: str price: float stock: int created_at: datetime updated_at: datetime # Command 모델 (쓰기 작업) @dataclass class CreateProductCommand: name: str price: float stock: int @dataclass class UpdateProductStockCommand: product_id: str stock: int # Query 모델 (읽기 작업) @dataclass class ProductDetailsQuery: product_id: str @dataclass class ProductListQuery: page: int page_size: int # Command 핸들러 (쓰기 작업 처리) class ProductCommandHandler: def __init__(self, command_db): self.command_db = command_db def handle_create_product(self, command: CreateProductCommand) -> str: product = Product( id=generate_id(), name=command.name, price=command.price, stock=command.stock, created_at=datetime.now(), updated_at=datetime.now() ) self.command_db.save(product) # 이벤트 발행 (읽기 데이터베이스 동기화를 위함) publish_event("ProductCreated", product) return product.id def handle_update_stock(self, command: UpdateProductStockCommand): product = self.command_db.get_by_id(command.product_id) if not product: raise ValueError("Product not found") product.stock = command.stock product.updated_at = datetime.now() self.command_db.update(product) publish_event("ProductStockUpdated", product) # Query 핸들러 (읽기 작업 처리) class ProductQueryHandler: def __init__(self, query_db): self.query_db = query_db def handle_product_details(self, query: ProductDetailsQuery) -> Optional[Product]: return self.query_db.get_by_id(query.product_id) def handle_product_list(self, query: ProductListQuery) -> List[Product]: return self.query_db.get_page(query.page, query.page_size) # API 레이어 class ProductAPI: def __init__(self, command_handler: ProductCommandHandler, query_handler: ProductQueryHandler): self.command_handler = command_handler self.query_handler = query_handler def create_product(self, name: str, price: float, stock: int) -> str: command = CreateProductCommand(name=name, price=price, stock=stock) return self.command_handler.handle_create_product(command) def update_stock(self, product_id: str, stock: int): command = UpdateProductStockCommand(product_id=product_id, stock=stock) self.command_handler.handle_update_stock(command) def get_product(self, product_id: str) -> Optional[Product]: query = ProductDetailsQuery(product_id=product_id) return self.query_handler.handle_product_details(query) def list_products(self, page: int, page_size: int) -> List[Product]: query = ProductListQuery(page=page, page_size=page_size) return self.query_handler.handle_product_list(query) 주요 구성 요소 https://junuuu.tistory.com/891
...</p></div><footer class=entry-footer><span title='2024-11-20 08:30:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CQRS 패턴 (Command Query Responsibility Segregation)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Repository Pattern</h2></header><div class=entry-content><p>Repository Pattern 리포지토리 패턴(Repository Pattern)은 데이터 접근 로직을 추상화하고 캡슐화하여 비즈니스 로직과 데이터 저장소 간의 의존성을 줄이는 소프트웨어 아키텍처 패턴.
이 패턴은 데이터의 저장, 검색 및 관리를 위한 일관된 인터페이스를 제공한다.
주요 개념 추상화: 데이터 접근 로직을 추상화하여 비즈니스 로직이 데이터 저장소의 구체적인 구현에 의존하지 않도록 합니다. 캡슐화: CRUD(Create, Read, Update, Delete) 작업을 캡슐화하여 데이터 접근의 복잡성을 숨깁니다. 중앙 집중화: 데이터 접근 로직을 중앙에서 관리하여 코드 중복을 줄이고 일관성을 유지합니다. 구조 ![](repository-aggregate-database-table-relationships.png “https://tech.buzzvil.com/handbook/repository/ _
...</p></div><footer class=entry-footer><span title='2024-11-20 08:30:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1057 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Repository Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/repository-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Blackboard Pattern</h2></header><div class=entry-content><p>Blackboard Pattern Blackboard 패턴은 복잡하고 비결정적인 문제를 해결하기 위한 소프트웨어 아키텍처 패턴.
이 패턴은 여러 전문화된 구성 요소(지식 소스 또는 에이전트)가 협력하여 문제를 해결하는 방식을 제공한다.
기본 개념은 실제 교실의 칠판과 매우 유사하다.
여러 전문가들이 함께 모여 칠판에 정보를 공유하고, 문제를 해결해나가는 과정을 소프트웨어 아키텍처로 구현한 것.
Blackboard 패턴은 다음과 같은 상황에서 특히 유용하다:
명확한 해결 알고리즘이 없는 복잡한 문제 여러 전문 분야의 지식이 필요한 문제 다양한 해결 접근 방식을 시도해볼 필요가 있는 경우 Blackboard 패턴은 다음과 같은 분야에서 주로 사용된다:
...</p></div><footer class=entry-footer><span title='2024-11-20 08:28:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;653 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Blackboard Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/blackboard-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Master-Slave Pattern</h2></header><div class=entry-content><p>Master-Slave Pattern 마스터-슬레이브 패턴(Master-Slave Pattern)은 분산 시스템에서 널리 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 하나의 마스터 컴포넌트와 여러 슬레이브 컴포넌트로 구성되어 있으며, 작업을 효율적으로 분배하고 관리하는 데 사용된다.
주요 구성요소 마스터(Master):
작업 분배와 조정을 담당합니다 슬레이브들의 상태를 관리합니다 작업의 완료 여부를 추적합니다 결과를 취합하고 클라이언트에게 전달합니다 슬레이브(Slave):
마스터로부터 할당받은 작업을 처리합니다 독립적으로 동작합니다 처리 결과를 마스터에게 반환합니다 자신의 상태(사용 가능/처리 중)를 관리합니다 작업(Task):
처리해야 할 작업의 단위입니다 작업에 필요한 데이터와 결과를 포함합니다 고유한 식별자를 가집니다 작동 방식 마스터는 전체 작업을 여러 개의 하위 작업으로 분할합니다. 분할된 작업을 슬레이브들에게 분배합니다. 슬레이브들은 할당받은 작업을 독립적으로 수행합니다. 작업 완료 후, 슬레이브들은 결과를 마스터에게 보고합니다. 마스터는 모든 결과를 취합하여 최종 결과를 생성합니다. 장점 병렬 처리: 여러 슬레이브가 동시에 작업을 수행하여 전체 처리 속도를 향상시킵니다. 확장성: 슬레이브의 수를 늘리거나 줄여 시스템의 처리 능력을 조절할 수 있습니다. 부하 분산: 마스터가 작업을 효율적으로 분배하여 시스템 자원을 최적화할 수 있습니다. fault tolerance: 일부 슬레이브가 실패해도 마스터가 작업을 재분배하여 시스템이 계속 작동할 수 있습니다. 단점 단일 장애점: 마스터 노드가 실패하면 전체 시스템이 중단될 수 있습니다. 복잡성: 여러 노드 간의 통신과 동기화를 관리해야 하므로 시스템이 복잡해질 수 있습니다. 불균형한 작업 크기: 작업의 크기가 불균형할 경우 일부 슬레이브가 과부하될 수 있습니다. 적용 분야 데이터베이스 복제: 마스터 데이터베이스가 쓰기 작업을 처리하고, 슬레이브 데이터베이스들이 읽기 작업을 분산 처리합니다. 분산 컴퓨팅: 대규모 계산 작업을 여러 노드에 분산하여 처리합니다. 데이터 처리: 빅데이터 처리 시스템에서 마스터 노드가 작업을 관리하고 슬레이브 노드들이 실제 데이터 처리를 수행합니다. 임베디드 시스템: 여러 센서나 액추에이터를 제어하는 데 사용됩니다. 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 import threading from abc import ABC, abstractmethod from queue import Queue from typing import List import time import random # 작업을 정의하는 기본 클래스 class Task: def __init__(self, task_id: int, data: List[int]): self.task_id = task_id self.data = data self.result = None # 슬레이브의 추상 클래스 class Slave(ABC): def __init__(self, slave_id: int): self.slave_id = slave_id self.is_busy = False @abstractmethod def process_task(self, task: Task) -> None: pass # 구체적인 슬레이브 구현 - 숫자 배열의 합을 계산 class SumCalculatorSlave(Slave): def process_task(self, task: Task) -> None: print(f"Slave {self.slave_id} starting task {task.task_id}") # 실제 작업 처리를 시뮬레이션하기 위한 지연 time.sleep(random.uniform(0.5, 2.0)) task.result = sum(task.data) print(f"Slave {self.slave_id} completed task {task.task_id}, result: {task.result}") # 마스터 클래스 class Master: def __init__(self, num_slaves: int): # 슬레이브 풀 초기화 self.slaves = [SumCalculatorSlave(i) for i in range(num_slaves)] # 작업 큐 self.task_queue = Queue() # 완료된 작업 저장 self.completed_tasks = {} # 작업 분배를 위한 쓰레드 self.distribution_thread = threading.Thread(target=self._distribute_tasks) self.is_running = True def start(self): """마스터 시작""" print("Master starting…") self.distribution_thread.start() def stop(self): """마스터 종료""" print("Master stopping…") self.is_running = False self.distribution_thread.join() def submit_task(self, task: Task): """새로운 작업 제출""" print(f"Submitting task {task.task_id}") self.task_queue.put(task) def get_result(self, task_id: int) -> int: """작업 결과 조회""" while task_id not in self.completed_tasks: time.sleep(0.1) # 결과가 준비될 때까지 대기 return self.completed_tasks[task_id] def _distribute_tasks(self): """작업 분배 로직""" while self.is_running: try: # 대기 중인 작업이 있는지 확인 task = self.task_queue.get(timeout=1.0) # 사용 가능한 슬레이브 찾기 slave = self._get_available_slave() if slave: # 작업 처리를 위한 새 쓰레드 시작 threading.Thread( target=self._process_task_with_slave, args=(slave, task) ).start() except Queue.Empty: continue def _get_available_slave(self) -> Slave: """사용 가능한 슬레이브 찾기""" for slave in self.slaves: if not slave.is_busy: return slave return None def _process_task_with_slave(self, slave: Slave, task: Task): """슬레이브를 사용하여 작업 처리""" try: slave.is_busy = True slave.process_task(task) self.completed_tasks[task.task_id] = task.result finally: slave.is_busy = False # 사용 예시 def main(): # 3개의 슬레이브로 마스터 생성 master = Master(num_slaves=3) master.start() try: # 여러 작업 제출 tasks = [ Task(1, [1, 2, 3, 4, 5]), Task(2, [10, 20, 30, 40, 50]), Task(3, [100, 200, 300, 400, 500]), Task(4, [1000, 2000, 3000, 4000, 5000]) ] # 작업 제출 for task in tasks: master.submit_task(task) # 결과 수집 for task in tasks: result = master.get_result(task.task_id) print(f"Final result for task {task.task_id}: {result}") # 잠시 대기 후 종료 time.sleep(5) finally: master.stop() if __name__ == "__main__": main() 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-20 08:28:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;742 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Master-Slave Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/master-slave-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Peer-to-Peer Pattern</h2></header><div class=entry-content><p>Peer-to-Peer Pattern (P2P 패턴) 피어-투-피어(Peer-to-Peer, P2P) 패턴은 분산 네트워크 아키텍처의 한 형태로, 각 노드(피어)가 클라이언트와 서버의 역할을 동시에 수행하는 구조.
이 패턴은 중앙 서버에 의존하지 않고 피어들이 직접 리소스를 공유하고 통신하는 것이 특징이다.
https://www.geeksforgeeks.org/what-is-p2p-peer-to-peer-process/
P2P 패턴의 주요 특징 분산화: 중앙 서버 없이 모든 피어가 동등한 권한과 책임을 가집니다. 자율성: 각 피어는 독립적으로 작동하며, 네트워크의 전체 기능에 영향을 주지 않고 참여하거나 떠날 수 있습니다. 확장성: 새로운 피어가 추가될수록 네트워크의 전체 용량과 리소스 풀이 증가합니다. 리소스 공유: 피어들은 파일, 대역폭, 처리 능력 등의 리소스를 직접 공유합니다. 익명성: 중앙 서버를 통하지 않고 직접 통신하므로 사용자의 익명성을 유지할 수 있습니다. 장점 효율적인 리소스 활용: 유휴 컴퓨팅 자원을 효과적으로 활용할 수 있습니다. 높은 확장성: 피어가 증가할수록 네트워크의 성능이 향상됩니다. 내결함성: 일부 피어의 장애가 전체 네트워크에 큰 영향을 미치지 않습니다. 비용 효율성: 중앙 서버 구축 및 유지 비용이 감소합니다. 단점 보안 위험: 중앙 통제가 없어 악성 코드나 불법 콘텐츠의 유통 위험이 있습니다. 성능 불균형: 피어들의 리소스 제공 정도에 따라 네트워크 성능이 불균형할 수 있습니다. 데이터 무결성: 피어들이 자유롭게 데이터를 추가하고 조작할 수 있어 데이터 무결성 유지가 어려울 수 있습니다. 구현 시 고려사항 피어 발견:
...</p></div><footer class=entry-footer><span title='2024-11-20 08:28:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;891 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Peer-to-Peer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/peer-to-peer-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/78/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/80/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>