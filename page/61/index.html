<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Memento Pattern</h2></header><div class=entry-content><p>Memento Pattern Memento Pattern은 행위 디자인 패턴 중 하나로, 객체의 상태를 저장하고 이전 상태로 복원할 수 있게 해주는 패턴이다.
메멘토 패턴(Memento Pattern)은 소프트웨어 디자인 패턴 중 하나로, 객체의 상태를 저장하고 나중에 복원할 수 있는 메커니즘을 제공한다.
이 패턴의 주요 목적은 객체의 내부 상태를 캡슐화하면서도 외부에서 해당 상태를 저장하고 복원할 수 있게 하는 것이다.
메멘토 패턴은 객체의 상태 관리와 복원이 중요한 애플리케이션에서 매우 유용한 디자인 패턴이다.
이 패턴을 적절히 활용하면 코드의 유연성과 유지보수성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-24 08:26:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memento Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/memento-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Command Pattern</h2></header><div class=entry-content><p>Command Pattern 요청을 객체의 형태로 캡슐화하여 나중에 사용할 수 있도록 하는 행동 디자인 패턴
요청을 하는 객체와 그 요청을 수행하는 객체를 분리한다.
이를 통해 요청을 큐에 저장하거나, 로그를 남기거나, 작업을 취소하는 등의 부가적인 기능을 쉽게 추가할 수 있다.
특징 요청을 객체로 캡슐화하여 매개변수화한다. 요청 발신자와 수신자를 분리합니다. 주요 구성요소 Command: 실행될 작업을 캡슐화하는 인터페이스 ConcreteCommand: Command 인터페이스를 구현하여 특정 작업을 수행하는 클래스 Invoker: Command 객체를 실행하는 클래스 Receiver: 실제 작업을 수행하는 클래스 Client: Command 객체를 생성하고 Invoker에게 전달하는 클래스 사용사례 GUI 버튼 및 메뉴 항목의 액션 구현 트랜잭션 시스템에서의 작업 큐 관리 매크로 기록 및 실행 기능 구현 장점 느슨한 결합: 명령을 실행하는 객체와 실제 작업을 수행하는 객체가 분리되어 있어, 시스템의 유연성이 향상된다. 확장성: 새로운 Command 클래스를 추가하는 것만으로 새로운 기능을 쉽게 추가할 수 있다. 작업 취소/재실행: Command 객체가 이전 상태를 저장할 수 있어, Undo/Redo 기능을 쉽게 구현할 수 있다. 작업 큐잉과 로깅: Command 객체를 저장하고 나중에 실행하거나, 실행 이력을 보관할 수 있다. 단점 클래스 증가: 각 명령마다 별도의 클래스가 필요하므로, 클래스의 수가 증가할 수 있다. 복잡성: 간단한 작업의 경우에도 Command 객체를 생성해야 하므로, 불필요한 복잡성이 추가될 수 있다. 메모리 사용: 작업 이력을 저장할 경우 메모리 사용량이 증가할 수 있다. 주의사항 및 고려사항 Command 인터페이스 설계: Command 인터페이스는 가능한 한 단순하게 유지하되, 필요한 모든 작업을 수행할 수 있어야 합니다. 일반적으로 execute()와 undo() 메서드를 포함한다. 상태 관리: Undo/Redo 기능을 구현할 경우, Command 객체는 이전 상태를 적절히 저장하고 복원할 수 있어야 한다. 복합 Command: 여러 Command를 그룹화하여 하나의 Command처럼 실행할 수 있는 MacroCommand를 구현할 수 있다. 예외 처리: Command 실행 중 발생할 수 있는 예외 상황을 적절히 처리해야 한다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 from abc import ABC, abstractmethod from typing import List import time # Receiver 클래스들 class Light: def __init__(self, location: str): self.location = location self.is_on = False self.brightness = 0 def turn_on(self) -> None: self.is_on = True print(f"{self.location} light is now on") def turn_off(self) -> None: self.is_on = False print(f"{self.location} light is now off") def dim(self, level: int) -> None: self.brightness = level print(f"{self.location} light dimmed to {level}%") class Thermostat: def __init__(self, location: str): self.location = location self.temperature = 20 def set_temperature(self, temperature: float) -> None: self.temperature = temperature print(f"{self.location} thermostat set to {temperature}°C") # Command 인터페이스 class Command(ABC): @abstractmethod def execute(self) -> None: pass @abstractmethod def undo(self) -> None: pass # Concrete Command 클래스들 class LightOnCommand(Command): def __init__(self, light: Light): self.light = light self._prev_state = None def execute(self) -> None: self._prev_state = self.light.is_on self.light.turn_on() def undo(self) -> None: if self._prev_state is False: self.light.turn_off() class LightDimCommand(Command): def __init__(self, light: Light, level: int): self.light = light self.level = level self._prev_level = None def execute(self) -> None: self._prev_level = self.light.brightness self.light.dim(self.level) def undo(self) -> None: if self._prev_level is not None: self.light.dim(self._prev_level) class SetThermostatCommand(Command): def __init__(self, thermostat: Thermostat, temperature: float): self.thermostat = thermostat self.temperature = temperature self._prev_temperature = None def execute(self) -> None: self._prev_temperature = self.thermostat.temperature self.thermostat.set_temperature(self.temperature) def undo(self) -> None: if self._prev_temperature is not None: self.thermostat.set_temperature(self._prev_temperature) # Invoker 클래스 class SmartHomeController: def __init__(self): self._command_history: List[Command] = [] self._current_command = None def execute_command(self, command: Command) -> None: self._current_command = command command.execute() self._command_history.append(command) def undo_last_command(self) -> None: if self._command_history: command = self._command_history.pop() command.undo() # 클라이언트 코드 def main(): # Receiver 객체들 생성 living_room_light = Light("Living Room") bedroom_light = Light("Bedroom") living_room_thermostat = Thermostat("Living Room") # Command 객체들 생성 light_on = LightOnCommand(living_room_light) bedroom_light_dim = LightDimCommand(bedroom_light, 50) set_temp = SetThermostatCommand(living_room_thermostat, 22.5) # Invoker 생성 및 커맨드 실행 controller = SmartHomeController() print("=== Executing commands ===") controller.execute_command(light_on) time.sleep(1) # 실행 간격을 위한 지연 controller.execute_command(bedroom_light_dim) time.sleep(1) controller.execute_command(set_temp) print("\n=== Undoing commands ===") time.sleep(1) controller.undo_last_command() # 온도 설정 취소 time.sleep(1) controller.undo_last_command() # 조명 밝기 조절 취소 time.sleep(1) controller.undo_last_command() # 조명 켜기 취소 if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 // Receiver 클래스들 class Light { constructor(location) { this.location = location; this.isOn = false; this.brightness = 0; } turnOn() { this.isOn = true; console.log(`${this.location} light is now on`); } turnOff() { this.isOn = false; console.log(`${this.location} light is now off`); } dim(level) { this.brightness = level; console.log(`${this.location} light dimmed to ${level}%`); } } class Thermostat { constructor(location) { this.location = location; this.temperature = 20; } setTemperature(temperature) { this.temperature = temperature; console.log(`${this.location} thermostat set to ${temperature}°C`); } } // Command 인터페이스 class Command { execute() { throw new Error('execute method must be implemented'); } undo() { throw new Error('undo method must be implemented'); } } // Concrete Command 클래스들 class LightOnCommand extends Command { constructor(light) { super(); this.light = light; this._prevState = null; } execute() { this._prevState = this.light.isOn; this.light.turnOn(); } undo() { if (this._prevState === false) { this.light.turnOff(); } } } class LightDimCommand extends Command { constructor(light, level) { super(); this.light = light; this.level = level; this._prevLevel = null; } execute() { this._prevLevel = this.light.brightness; this.light.dim(this.level); } undo() { if (this._prevLevel !== null) { this.light.dim(this._prevLevel); } } } class SetThermostatCommand extends Command { constructor(thermostat, temperature) { super(); this.thermostat = thermostat; this.temperature = temperature; this._prevTemperature = null; } execute() { this._prevTemperature = this.thermostat.temperature; this.thermostat.setTemperature(this.temperature); } undo() { if (this._prevTemperature !== null) { this.thermostat.setTemperature(this._prevTemperature); } } } // Invoker 클래스 class SmartHomeController { constructor() { this._commandHistory = []; this._currentCommand = null; } executeCommand(command) { this._currentCommand = command; command.execute(); this._commandHistory.push(command); } undoLastCommand() { if (this._commandHistory.length > 0) { const command = this._commandHistory.pop(); command.undo(); } } } // 클라이언트 코드 async function main() { // Receiver 객체들 생성 const livingRoomLight = new Light("Living Room"); const bedroomLight = new Light("Bedroom"); const livingRoomThermostat = new Thermostat("Living Room"); // Command 객체들 생성 const lightOn = new LightOnCommand(livingRoomLight); const bedroomLightDim = new LightDimCommand(bedroomLight, 50); const setTemp = new SetThermostatCommand(livingRoomThermostat, 22.5); // Invoker 생성 및 커맨드 실행 const controller = new SmartHomeController(); console.log("=== Executing commands ==="); controller.executeCommand(lightOn); await new Promise(resolve => setTimeout(resolve, 1000)); // 실행 간격을 위한 지연 controller.executeCommand(bedroomLightDim); await new Promise(resolve => setTimeout(resolve, 1000)); controller.executeCommand(setTemp); console.log("\n=== Undoing commands ==="); await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 온도 설정 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 밝기 조절 취소 await new Promise(resolve => setTimeout(resolve, 1000)); controller.undoLastCommand(); // 조명 켜기 취소 } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Command Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/command-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>State Pattern</h2></header><div class=entry-content><p>State Pattern 객체의 내부 상태가 변경될 때 객체의 행동이 변경되도록 하는 행동 디자인 패턴
상태별 동작을 별도의 클래스로 분리하고, 현재 상태를 나타내는 객체에게 행동을 위임하는 것
특징 객체의 내부 상태에 따라 행동을 변경할 수 있게 합니다. 상태 전이를 명시적으로 표현합니다. 각 상태를 별도의 클래스로 캡슐화합니다. 유한 상태 기계(Finite-State Machine)의 개념과 유사합니다. 사용사례 문서 처리 시스템: 문서가 초안, 검토 중, 승인됨, 게시됨 등의 상태를 가지며 각 상태에서 허용되는 작업이 다릅니다. 주문 처리 시스템: 주문이 생성됨, 결제 완료, 배송 중, 배송 완료 등의 상태를 거치며, 각 상태에서 가능한 작업이 달라집니다. 게임 캐릭터: 캐릭터가 서있음, 걷기, 달리기, 점프 등 다양한 상태를 가지며, 각 상태에서의 동작이 다릅니다. 네트워크 연결: 연결 중, 연결됨, 연결 끊김 등의 상태에 따라 다른 동작을 수행합니다. 장점 상태별 동작의 명확한 분리: 각 상태의 동작이 별도의 클래스로 캡슐화되어 코드의 구조가 명확해집니다. 상태 전환 로직의 체계화: 상태 전환이 명시적으로 이루어지며, 각 상태 클래스에서 가능한 전환을 정의할 수 있습니다. 새로운 상태 추가의 용이성: 기존 코드를 수정하지 않고도 새로운 상태를 추가할 수 있어 개방-폐쇄 원칙을 만족합니다. 단점 클래스 수의 증가: 각 상태마다 새로운 클래스가 필요하므로 클래스 수가 많아질 수 있습니다. 상태 전환 로직의 복잡성: 상태 간의 전환이 복잡할 경우 관리가 어려워질 수 있습니다. Context와 State 간의 결합: State 클래스들이 Context를 참조해야 하는 경우가 있어 결합도가 높아질 수 있습니다. 주의사항 및 고려사항 상태 전환의 일관성: 상태 전환이 일관되게 이루어지도록 주의해야 하며, 잘못된 전환을 방지해야 합니다. 메모리 관리: 상태 객체들을 적절히 재사용하거나 관리하지 않으면 메모리 사용량이 증가할 수 있습니다. 순환 참조 방지: Context와 State 간의 순환 참조가 발생하지 않도록 주의해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 from abc import ABC, abstractmethod # State 인터페이스 class MediaPlayerState(ABC): @abstractmethod def play(self, player) -> None: pass @abstractmethod def pause(self, player) -> None: pass @abstractmethod def stop(self, player) -> None: pass @abstractmethod def get_state_name(self) -> str: pass # 구체적인 State 클래스들 class PlayingState(MediaPlayerState): def play(self, player) -> None: print("이미 재생 중입니다.") def pause(self, player) -> None: print("재생을 일시정지합니다.") player.change_state(PausedState()) def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "재생 중" class PausedState(MediaPlayerState): def play(self, player) -> None: print("재생을 재개합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("이미 일시정지 상태입니다.") def stop(self, player) -> None: print("재생을 중지합니다.") player.change_state(StoppedState()) def get_state_name(self) -> str: return "일시정지" class StoppedState(MediaPlayerState): def play(self, player) -> None: print("재생을 시작합니다.") player.change_state(PlayingState()) def pause(self, player) -> None: print("중지 상태에서는 일시정지할 수 없습니다.") def stop(self, player) -> None: print("이미 중지 상태입니다.") def get_state_name(self) -> str: return "중지됨" # Context 클래스 class MediaPlayer: def __init__(self): # 초기 상태는 중지 상태 self._state = StoppedState() print(f"미디어 플레이어가 {self._state.get_state_name()} 상태로 시작됩니다.") def change_state(self, state: MediaPlayerState) -> None: self._state = state print(f"상태가 {self._state.get_state_name()}(으)로 변경되었습니다.") def play(self) -> None: self._state.play(self) def pause(self) -> None: self._state.pause(self) def stop(self) -> None: self._state.stop(self) # 사용 예시 def main(): player = MediaPlayer() # 재생 시작 player.play() # 중지 -> 재생 # 일시정지 player.pause() # 재생 -> 일시정지 # 재생 재개 player.play() # 일시정지 -> 재생 # 중지 player.stop() # 재생 -> 중지 # 일시정지 시도 (중지 상태에서는 불가능) player.pause() if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // State 인터페이스 interface OrderState { processPayment(order: Order): void; shipOrder(order: Order): void; cancelOrder(order: Order): void; getStateName(): string; } // 구체적인 State 클래스들 class PendingState implements OrderState { processPayment(order: Order): void { console.log("결제를 진행합니다."); order.changeState(new PaidState()); } shipOrder(order: Order): void { console.log("결제가 필요합니다. 배송을 시작할 수 없습니다."); } cancelOrder(order: Order): void { console.log("주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 대기"; } } class PaidState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("배송을 시작합니다."); order.changeState(new ShippedState()); } cancelOrder(order: Order): void { console.log("결제가 환불되었습니다. 주문이 취소되었습니다."); order.changeState(new CancelledState()); } getStateName(): string { return "결제 완료"; } } class ShippedState implements OrderState { processPayment(order: Order): void { console.log("이미 결제가 완료되었습니다."); } shipOrder(order: Order): void { console.log("이미 배송 중입니다."); } cancelOrder(order: Order): void { console.log("배송이 시작된 주문은 취소할 수 없습니다."); } getStateName(): string { return "배송 중"; } } class CancelledState implements OrderState { processPayment(order: Order): void { console.log("취소된 주문은 결제할 수 없습니다."); } shipOrder(order: Order): void { console.log("취소된 주문은 배송할 수 없습니다."); } cancelOrder(order: Order): void { console.log("이미 취소된 주문입니다."); } getStateName(): string { return "주문 취소"; } } // Context 클래스 class Order { private state: OrderState; private readonly orderId: string; constructor(orderId: string) { this.orderId = orderId; this.state = new PendingState(); console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 생성되었습니다.`); } public changeState(state: OrderState): void { this.state = state; console.log(`주문 ${this.orderId}가 ${this.state.getStateName()} 상태로 변경되었습니다.`); } public processPayment(): void { this.state.processPayment(this); } public shipOrder(): void { this.state.shipOrder(this); } public cancelOrder(): void { this.state.cancelOrder(this); } } // 사용 예시 function main() { const order = new Order("ORD-2024-001"); // 정상적인 주문 프로세스 console.log("\n=== 정상적인 주문 프로세스 ==="); order.processPayment(); // 결제 대기 -> 결제 완료 order.shipOrder(); // 결제 완료 -> 배송 중 // 취소된 주문 시나리오 console.log("\n=== 취소된 주문 시나리오 ==="); const cancelledOrder = new Order("ORD-2024-002"); cancelledOrder.cancelOrder(); // 결제 대기 -> 취소됨 cancelledOrder.processPayment(); // 결제 시도 (실패) cancelledOrder.shipOrder(); // 배송 시도 (실패) } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/state-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Template Method Pattern</h2></header><div class=entry-content><p>Template Method Pattern 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴
특징 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현할 수 있게 합니다. 공통 로직은 상위 클래스에서 정의하고, 변화가 필요한 부분만 하위 클래스에서 구현합니다. 알고리즘의 구조를 변경하지 않고 특정 단계를 재정의할 수 있습니다. 두 가지 주요 부분으로 구성된다.
추상 클래스(Abstract Class): 알고리즘의 골격을 정의하는 템플릿 메서드를 포함 서브클래스에서 구현해야 하는 추상 메서드 정의 선택적으로 오버라이드할 수 있는 훅(hook) 메서드 제공 구체 클래스(Concrete Class): 추상 클래스를 상속받아 추상 메서드를 실제로 구현 필요한 경우 훅 메서드를 오버라이드하여 알고리즘을 커스터마이즈 사용사례 프레임워크에서 기본 동작을 정의하고 사용자가 일부를 커스터마이즈해야 할 때 데이터 마이닝 작업에서 데이터 처리 파이프라인을 구현할 때 리포트 생성 시스템에서 다양한 형식의 리포트를 생성할 때 장점 코드 재사용성이 높아집니다 알고리즘의 공통 부분을 한 곳에서 관리할 수 있습니다 확장성이 좋아 새로운 변형을 쉽게 추가할 수 있습니다 단점 템플릿 메소드가 복잡해질수록 유지보수가 어려워질 수 있습니다 하위 클래스에서 상위 클래스의 메소드를 실수로 오버라이드할 수 있습니다 알고리즘 단계가 많아지면 클래스 계층 구조가 복잡해질 수 있습니다 주의사항 및 고려사항 템플릿 메소드는 final로 선언하여 하위 클래스가 override하지 못하도록 해야 합니다. Python에서는 관례적으로 메소드 이름 앞에 언더스코어를 붙여 protected임을 나타냅니다. 추상 메소드(반드시 구현해야 하는 메소드)와 훅 메소드(선택적으로 구현할 수 있는 메소드)를 명확히 구분해야 합니다. 상속 계층이 깊어지지 않도록 주의해야 합니다. 일반적으로 추상 클래스와 구체 클래스의 2단계 정도가 적절합니다. 템플릿 메소드가 너무 많은 단계를 가지지 않도록 해야 합니다. 복잡한 알고리즘은 더 작은 단위로 분리하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from abc import ABC, abstractmethod class DataMiner(ABC): """데이터 마이닝을 위한 템플릿 메소드 패턴 구현""" def mine_data(self, path: str) -> None: """템플릿 메소드: 데이터 마이닝의 전체 프로세스를 정의""" raw_data = self._read_file(path) cleaned_data = self._clean_data(raw_data) analyzed_data = self._analyze_data(cleaned_data) self._send_report(analyzed_data) @abstractmethod def _read_file(self, path: str) -> list: """파일을 읽어오는 추상 메소드""" pass def _clean_data(self, data: list) -> list: """데이터 정제를 위한 훅 메소드""" return data @abstractmethod def _analyze_data(self, data: list) -> dict: """데이터 분석을 위한 추상 메소드""" pass def _send_report(self, data: dict) -> None: """분석 결과 보고를 위한 훅 메소드""" print("기본 보고서 생성:", data) class PDFDataMiner(DataMiner): """PDF 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"PDF 파일 읽기: {path}") return ["PDF 데이터 1", "PDF 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "PDF", "results": data} def _clean_data(self, data: list) -> list: # PDF 특화 데이터 정제 로직 return [item.strip() for item in data] class CSVDataMiner(DataMiner): """CSV 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"CSV 파일 읽기: {path}") return ["CSV 데이터 1", "CSV 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "CSV", "results": data} # 사용 예시 if __name__ == "__main__": pdf_miner = PDFDataMiner() csv_miner = CSVDataMiner() pdf_miner.mine_data("sample.pdf") csv_miner.mine_data("sample.csv") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class BeverageMaker { /** * 음료 제조를 위한 템플릿 메소드 * @returns {void} */ prepare() { this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) { this.addCondiments(); } this.serve(); } /** * 물을 끓이는 공통 메소드 * @private */ boilWater() { console.log('물을 끓입니다'); } /** * 음료를 우리는 추상 메소드 * @abstract * @private */ brew() { throw new Error('brew 메소드를 구현해야 합니다'); } /** * 컵에 따르는 공통 메소드 * @private */ pourInCup() { console.log('컵에 따릅니다'); } /** * 고객이 첨가물을 원하는지 확인하는 훅 메소드 * @returns {boolean} */ customerWantsCondiments() { return true; } /** * 첨가물을 추가하는 추상 메소드 * @abstract * @private */ addCondiments() { throw new Error('addCondiments 메소드를 구현해야 합니다'); } /** * 음료를 서빙하는 공통 메소드 * @private */ serve() { console.log('음료가 준비되었습니다'); } } class CoffeeMaker extends BeverageMaker { brew() { console.log('커피를 우립니다'); } addCondiments() { console.log('설탕과 우유를 추가합니다'); } customerWantsCondiments() { // 고객 선호도에 따라 첨가물 추가 여부 결정 return Math.random() > 0.5; } } class TeaMaker extends BeverageMaker { brew() { console.log('차를 우립니다'); } addCondiments() { console.log('레몬을 추가합니다'); } } // 사용 예시 const coffee = new CoffeeMaker(); const tea = new TeaMaker(); console.log('=== 커피 준비 ==='); coffee.prepare(); console.log('\n=== 차 준비 ==='); tea.prepare(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Template Method Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/template-method-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Access Modifiers</h2></header><div class=entry-content><p>Access Modifiers 객체지향 프로그래밍(OOP)에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 중요한 개념이다. 이를 통해 캡슐화를 구현하고 코드의 안정성과 유지보수성을 향상시킬 수 있다.
접근 제어자를 적절히 사용하면 객체지향 프로그래밍의 핵심 원칙인 캡슐화를 효과적으로 구현할 수 있으며, 이는 코드의 품질과 유지보수성을 크게 향상시킨다.
접근 제어자의 종류 public
가장 넓은 접근 범위를 가진다. 어떤 클래스에서든 접근이 가능하다. 모든 패키지의 모든 클래스에서 이 요소에 접근할 수 있다. 1 2 3 4 5 6 class BankAccount: def __init__(self): self.account_number = "123-456-789" # public 변수 def get_balance(self): # public 메서드 return self.balance protected
...</p></div><footer class=entry-footer><span title='2024-09-23 04:49:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Access Modifiers" href=https://buenhyden.github.io/posts/computer-science/programming-paradigms/imperative-programming/oop/access-modifiers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KISS Principle</h2></header><div class=entry-content><p>KISS (Keep It Simple, Stupid) 원칙 KISS 원칙은 “Keep It Simple, Stupid"의 약자로, 때로는 “Keep It Short and Simple” 또는 “Keep It Simple and Straightforward"로도 해석된다. 이 원칙은 시스템 설계에서 단순함을 추구해야 한다는 기본 철학을 담고 있다.
KISS 원칙은 1960년대 미 해군의 항공기 엔지니어인 켈리 존슨(Kelly Johnson)이 처음 제안했다고 알려져 있다. 그는 항공기 설계와 관련하여 “어떤 항공기든 평균적인 기술자가 기본적인 도구만으로 현장에서 수리할 수 있을 만큼 단순해야 한다"고 주장했다. 이 철학은 소프트웨어 개발을 포함한 다양한 엔지니어링 분야로 확장되었다.
...</p></div><footer class=entry-footer><span title='2024-09-23 01:00:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to KISS Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/kiss-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAGNI Principle</h2></header><div class=entry-content><p>YAGNI(You Ain’t Gonna Need It) Principle YAGNI(You Ain’t Gonna Need It)는 소프트웨어 개발에서 중요한 원칙으로, “당신은 그것이 필요하지 않을 것이다"라는 의미를 담고 있다. 이 원칙은 개발자가 현재 필요하지 않은 기능이나 코드를 미리 구현하지 말아야 한다고 제안한다.
YAGNI 원칙은 익스트림 프로그래밍(XP, Extreme Programming)의 창시자인 론 제프리스(Ron Jeffries)와 다른 XP 선구자들에 의해 1990년대에 공식화되었다. 이들은 미래에 필요할지도 모른다는 예측에 기반하여 기능을 구현하는 것이 종종 낭비가 된다는 점을 깨달았다.
현재 요구사항에 집중하고 미래에 대한 과도한 예측을 피함으로써, 개발자는 더 단순하고, 유지보수하기 쉬우며, 실제 가치를 제공하는 코드를 작성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:59:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAGNI Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/yagni-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle DRY(Don’t Repeat Yourself) 원칙은 소프트웨어 개발의 기본 지침으로, 중복을 제거하고 코드의 유지보수성, 가독성, 신뢰성을 향상시키는 데 중요한 역할을 한다.
이 원칙은 “모든 지식은 시스템 내에서 단 한 번만, 단 한 곳에서만 표현되어야 한다” 는 개념을 중심으로 한다.
그러나 DRY 원칙은 맹목적으로 적용해서는 안 된다. 과도한 추상화, 조기 추상화, 불필요한 의존성 등의 위험을 고려해야 한다. DRY를 효과적으로 적용하려면 맥락을 고려하고, 점진적으로 리팩토링하며, 테스트로 변경 사항을 뒷받침하고, 공통점과 차이점을 명확히 식별해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:58:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/dry-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles SOLID 원칙은 객체 지향 프로그래밍(OOP)에서 가장 중요한 설계 원칙 모음으로, 유지보수가 용이하고 확장 가능한 소프트웨어를 만들기 위한 지침이다.
이 원칙들은 로버트 C. 마틴(Robert C. Martin, ‘Uncle Bob’으로도 알려진)이 2000년대 초반에 제안했으며, 마이클 페더스(Michael Feathers)가 SOLID라는 약어로 정리했다.
SOLID는 다음 다섯 가지 원칙의 첫 글자를 따서 만들어졌다:
Single Responsibility Principle (단일 책임 원칙) Open/Closed Principle (개방/폐쇄 원칙) Liskov Substitution Principle (리스코프 치환 원칙) Interface Segregation Principle (인터페이스 분리 원칙) Dependency Inversion Principle (의존성 역전 원칙) 단일 책임 원칙 (Single Responsibility Principle, SRP) 핵심 개념 “하나의 클래스는 오직 하나의 책임만 가져야 한다.”
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/solid-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-09-22 12:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/computer-science/programming-paradigms/imperative-programming/oop/components/class/class-and-instance/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/60/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/62/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>