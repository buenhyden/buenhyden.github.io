<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.141.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로미스(Promise)</h2></header><div class=entry-content><p>프로미스(Promise) 프로미스(Promise)는 자바스크립트에서 비동기 처리를 위해 사용되는 객체이다.
프로미스(Promise)는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체이다.
이는 비동기 처리를 동기적으로 처리할 수 있게 해주며, 콜백 함수의 단점을 보완한다.
프로미스(Promise)의 상태 프로미스(Promise)는 세 가지 상태를 가진다.
대기(Pending): 초기 상태, 비동기 처리 로직이 아직 완료되지 않은 상태 이행(Fulfilled): 비동기 처리가 성공적으로 완료되어 프로미스(Promise)가 결과 값을 반환한 상태 거부(Rejected): 비동기 처리가 실패하거나 오류가 발생한 상태 Promise 생성자와 Executor 함수의 기본 구조 프로미스(Promise)는 new Promise() 생성자를 통해 생성된다.
Promise를 생성할 때는 다음과 같은 구조를 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-12 14:54:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;979 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로미스(Promise)" href=https://buenhyden.github.io/posts/programming-languages/javascript/promise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Callback Function (콜백 함수)</h2></header><div class=entry-content><p>Callback Function 프로그래밍에서 다른 함수의 인수로 전달되어 특정 작업이 완료된 후 호출되는 함수.
하나의 함수가 실행되는 동안, 특정 시점이나 조건이 충족되었을 때 호출될 함수를 미리 전달하는 방식.
이 개념은 동기적(synchronous) 또는 비동기적(asynchronous) 작업에서 모두 사용되며, 특히 비동기 프로그래밍에서 매우 중요하다.
간단한 예시를 통해 콜백 함수의 개념을 이해:
1 2 3 4 5 6 7 8 9 10 function greet(name, callback) { console.log('안녕하세요, ' + name + '님!'); callback(); } function sayGoodbye() { console.log('안녕히 가세요!'); } greet('홍길동', sayGoodbye); 이 예시에서 sayGoodbye 함수가 콜백 함수로 greet 함수에 전달된다. greet 함수는 인사말을 출력한 후 콜백 함수를 실행한다. 콜백 함수의 동작 원리 함수 전달: 콜백 함수는 다른 함수의 매개변수로 전달된다. 호출 시점 결정: 전달받은 함수는 호출자 함수 내부에서 특정 조건이나 작업 완료 시 호출된다. 결과 처리: 콜백 함수는 호출자 함수의 결과나 상태를 기반으로 추가 작업을 수행한다. 콜백 함수의 장점 코드의 재사용성 동일한 함수에 다른 콜백을 전달하여 다양한 동작을 구현할 수 있다. 중복 코드를 줄일 수 있다. 유연성 실행 시점에 필요한 동작을 결정할 수 있다. 프로그램의 동작을 쉽게 변경할 수 있다. 비동기 프로그래밍 지원 긴 작업을 기다리지 않고 다른 작업을 수행할 수 있다. 프로그램의 반응성을 향상시킬 수 있다. 이벤트 처리 사용자의 행동(클릭, 키보드 입력 등)에 반응하는 데 사용된다. 웹 브라우저의 이벤트 리스너가 대표적인 예시이다. 콜백 함수의 종류 동기적(Synchronous) 콜백 호출자 함수가 실행되는 동안 즉시 호출된다. 일반적으로 작업 순서가 중요할 때 사용된다. 예시: 배열 메서드(forEach, map)에서 사용되는 콜백. 1 2 3 4 const numbers = [1, 2, 3]; numbers.forEach((num) => { console.log(num); // 배열의 각 요소를 출력 }); 비동기적(Asynchronous) 콜백 호출자 함수가 실행된 후, 특정 작업이 완료되었을 때 호출된다. 주로 시간이 걸리는 작업(예: 파일 읽기, API 요청)에서 사용된다. 예시: setTimeout 또는 이벤트 리스너. 1 2 3 setTimeout(() => { console.log("3초 후에 실행됩니다."); }, 3000); 콜백 함수를 사용하는 이유 비동기 작업 처리: 시간이 걸리는 작업(API 요청, 파일 읽기 등)을 처리하는 동안 메인 프로그램 흐름을 막지 않음. 코드 유연성 증가: 특정 작업 이후 실행할 동작을 동적으로 정의 가능. 모듈화 및 재사용성 증가: 코드의 특정 동작을 분리하여 재사용 가능. 주의할 점 콜백 지옥(Callback Hell)
복잡한 비동기 작업이 중첩되어 코드 가독성이 떨어지고 유지보수가 어려워지는 현상.
해결책 Promise 사용: 비동기 작업을 체인 형태로 작성하여 가독성을 개선. Async/Await 사용: 비동기 코드를 동기 코드처럼 작성 가능. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 잘못된 방식 getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { // 콜백 지옥… }); }); }); }); // 올바른 방식 // Promise나 async/await를 사용하여 개선 async function fetchData() { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); // 더 깔끔하고 읽기 쉬운 코드 } 오류 처리
콜백 함수에서 발생하는 오류를 적절히 처리해야 한다.
오류 처리 콜백을 별도로 제공하는 것이 좋다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 잘못된 방식 function fetchData(callback) { // 에러 처리가 없음 callback(data); } // 올바른 방식 function fetchData(callback) { try { // 데이터 처리 callback(null, data); } catch (error) { callback(error, null); } } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 실행 순서 보장
비동기 콜백의 경우 실행 순서를 신중히 고려해야 한다.
필요한 경우 콜백 체인을 사용하여 순서를 보장할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function processUserUnsafe(userId) { let userData; fetchUserData( userId, (user) => { userData = user; console.log("1. 사용자 데이터 받음:", userData); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); // userData가 설정되기 전에 실행될 수 있음 console.log("2. userData 사용:", userData); } // 4. 콜백 체인을 사용한 실행 순서 보장 function processUserSafe(userId) { fetchUserData( userId, (user) => { console.log("1. 사용자 데이터 받음:", user); validateUser(user, (validatedUser) => { console.log("2. 사용자 검증 완료:", validatedUser); updateUser(validatedUser, (updatedUser) => { console.log("3. 사용자 정보 업데이트 완료:", updatedUser); }, (error) => console.error("사용자 업데이트 실패:", error) ); }, (error) => console.error("사용자 검증 실패:", error) ); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); } 파이썬에서의 콜백 함수 예제 파이썬에서도 함수를 매개변수로 전달하여 콜백 함수를 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-12 12:45:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;803 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Function (콜백 함수)" href=https://buenhyden.github.io/posts/programming-languages/concepts/callback-function/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오버라이딩(Overriding)과 오버로딩(Overloading)</h2></header><div class=entry-content><p>오버라이딩(Overriding)과 오버로딩(Overloading) 기본 개념 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 정의 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것 같은 클래스 내에서 동일한 이름의 메서드를 매개변수를 다르게 하여 여러 개 정의하는 것 목적 상속 관계에서 메서드의 구현을 변경하기 위해 사용 비슷한 기능을 하는 메서드를 하나의 이름으로 여러 가지 방식으로 사용하기 위해 사용 다형성 유형 런타임 다형성 (동적 바인딩) 컴파일 타임 다형성 (정적 바인딩) 핵심 특징 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 이름 반드시 동일해야 함 반드시 동일해야 함 매개변수 부모 메서드와 동일해야 함 타입이나 개수가 달라야 함 반환 타입 부모 메서드와 동일하거나 공변 반환 타입이어야 함 다를 수 있음 접근 제어자 부모 메서드보다 더 제한적일 수 없음 자유롭게 지정 가능 예외 처리 부모 메서드보다 더 큰 범위의 예외를 던질 수 없음 자유롭게 지정 가능 코드 예시 비교 오버라이딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 부모 클래스 class Animal { public void makeSound() { System.out.println("동물이 소리를 냅니다"); } } // 자식 클래스 class Dog extends Animal { @Override // 오버라이딩 명시 public void makeSound() { System.out.println("멍멍!"); } } class Cat extends Animal { @Override public void makeSound() { System.out.println("야옹!"); } } 오버로딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Calculator { // 정수 덧셈 public int add(int a, int b) { return a + b; } // 실수 덧셈 public double add(double a, double b) { return a + b; } // 세 정수의 덧셈 public int add(int a, int b, int c) { return a + b + c; } // 배열의 덧셈 public int add(int[] numbers) { int sum = 0; for (int num : numbers) { sum += num; } return sum; } } 실행 시점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 결정 시점 런타임에 결정 컴파일 타임에 결정 바인딩 동적 바인딩 정적 바인딩 성능 영향 약간의 오버헤드 발생 가능 오버헤드 없음 사용 목적 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 주요 용도 • 부모 클래스 메서드의 동작 변경
• 다형성 구현
• 특화된 기능 구현 • 메서드 이름의 재사용
• 다양한 매개변수 처리
• 코드의 간결성 향상 활용 상황 • 추상 메서드 구현
• 인터페이스 구현
• 상속받은 메서드 수정 • 생성자 다중 정의
• 유틸리티 메서드 구현
• API 설계 제약사항 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 제약 • final 메서드는 오버라이드 불가
• private 메서드는 오버라이드 불가
• static 메서드는 오버라이드 불가 • 매개변수만 다르면 됨
• 반환 타입만 다른 것은 불가
• 접근 제어자 제약 없음 상속 관계 반드시 상속 관계가 있어야 함 상속 관계 불필요 기타 제약 • 부모의 메서드보다 접근성을 좁힐 수 없음
• 부모보다 더 큰 예외 선언 불가 • 매개변수 순서만 다른 경우 주의 필요
• 모호한 호출 가능성 주의 장단점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 장점 • 다형성 구현 가능
• 코드 재사용성 향상
• 유연한 설계 가능 • 직관적인 메서드명 사용
• 코드 가독성 향상
• API 사용 편의성 증가 단점 • 런타임 오버헤드
• 복잡한 상속 관계시 추적 어려움
• 잘못 사용시 부모 클래스 동작 훼손 • 과도한 사용시 복잡도 증가
• 타입 변환 오류 가능성
• 모호한 메서드 호출 가능성 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 04:56:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;535 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오버라이딩(Overriding)과 오버로딩(Overloading)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)</h2></header><div class=entry-content><p>동기(Synchronous) 동기(Synchronous)는 작업들이 순차적으로 실행되며, 하나의 작업이 완료된 후에 다음 작업이 시작되는 방식이다.
“동시에 일어난다"는 의미로, 요청과 그 결과가 동시에 일어난다는 약속이다.
파일에서 데이터를 읽고 처리하는 동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 동기식 처리 예제 function processUserData() { // 1. 파일을 읽을 때까지 다음 줄로 진행하지 않음 const userData = readFileSync('user.txt'); // 2. 데이터 처리가 완료될 때까지 대기 const processedData = processData(userData); // 3. 저장이 완료될 때까지 대기 saveToDatabase(processedData); // 4. 모든 작업이 완료된 후에만 실행 console.log('작업 완료!'); } 주요 특징 순차적 실행: 코드가 작성된 순서대로 실행된다. 블로킹(Blocking): 한 작업이 완료될 때까지 다음 작업은 대기한다. 예측 가능성: 코드의 실행 흐름이 명확하고 예측 가능하다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-11-12 00:57:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;212 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)" href=https://buenhyden.github.io/posts/programming-languages/concepts/synchronous/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비동기(Asynchronous)</h2></header><div class=entry-content><p>비동기(Asynchronous) 비동기(Asynchronous)는 작업들이 독립적으로 실행되며, 작업의 완료 여부와 관계없이 다음 작업이 시작될 수 있는 방식이다.
“동시에 일어나지 않는다"는 의미로, 요청과 결과가 동시에 일어나지 않을 것이라는 약속이다.
파일에서 데이터를 읽고 처리하는 비동기식 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 비동기식 처리 예제 async function processUserData() { try { // 1. 파일을 읽는 동안 다른 작업 수행 가능 const userData = await readFile('user.txt'); // 2. 데이터 처리 중에도 다른 작업 가능 const processedData = await processData(userData); // 3. 데이터베이스 저장 중에도 다른 작업 가능 await saveToDatabase(processedData); console.log('작업 완료!'); } catch (error) { console.error('오류 발생:', error); } } // 메인 프로그램은 계속 실행됨 console.log('프로그램 시작'); processUserData(); console.log('다른 작업 진행 중…'); 주요 특징 비순차적 실행: 작업들이 독립적으로 실행될 수 있다. 논블로킹(Non-blocking): 한 작업이 다른 작업의 실행을 막지 않는다. 이벤트 기반: 작업 완료 시 이벤트나 콜백을 통해 결과를 처리한다. 동시성: 여러 작업을 동시에 처리할 수 있다. 장단점 장점:
...</p></div><footer class=entry-footer><span title='2024-11-12 00:57:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;267 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비동기(Asynchronous)" href=https://buenhyden.github.io/posts/programming-languages/concepts/asynchronous/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/84/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/86/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>