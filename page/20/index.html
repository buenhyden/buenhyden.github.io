<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.143.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비대칭키 암호화 (Asymmetric Encryption)</h2></header><div class=entry-content><p>비대칭키 암호화 (Asymmetric Encryption) 비대칭키 암호화는 공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 방식.
장점:
키 분배가 용이하다 (공개키는 공개적으로 공유 가능) 높은 보안성을 제공한다. 디지털 서명 등 다양한 보안 기능 구현이 가능하다. 단점:
대칭키 암호화에 비해 처리 속도가 느리다. 더 많은 컴퓨팅 자원이 필요하다. 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes class AsymmetricEncryption: def __init__(self): # 키 쌍 생성 self.private_key = rsa.generate_private_key( public_exponent=65537, # 일반적으로 사용되는 공개 지수 key_size=2048 # 보안을 위한 충분한 키 크기 ) # 개인키로부터 공개키 추출 self.public_key = self.private_key.public_key() def encrypt_message(self, message): """공개키로 메시지 암호화""" encrypted = self.public_key.encrypt( message.encode(), padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return encrypted def decrypt_message(self, encrypted_message): """개인키로 메시지 복호화""" decrypted = self.private_key.decrypt( encrypted_message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return decrypted.decode() 주요 특징 키 분배 문제 해결: 안전하지 않은 채널에서도 키를 교환할 수 있다. 높은 보안성: 공개키가 노출되어도 개인키가 안전하면 전체 시스템이 안전하다. 디지털 서명 가능: 메시지의 무결성과 발신자 인증에 사용된다. 느린 처리 속도: 대칭키 암호화에 비해 연산 속도가 느리다. 작동 원리 공개키와 개인키라는 두 개의 키를 사용한다.
공개키로 암호화한 데이터는 개인키로만 복호화할 수 있다.
개인키로 암호화한 데이터는 공개키로만 복호화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:22:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;612 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비대칭키 암호화 (Asymmetric Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/asymmetric-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 함수 (Hash Functions)</h2></header><div class=entry-content><p>해시 함수 (Hash Functions) 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
특징:
일방향성: 해시 값으로부터 원본 데이터를 복구하는 것이 계산상 불가능하다.
1 2 3 4 5 6 7 8 9 10 11 12 13 def demonstrate_one_way(): """해시 함수의 일방향성을 보여주는 함수""" class PasswordManager: def __init__(self): self.password_hash = None def set_password(self, password): # 비밀번호는 해시값으로만 저장 self.password_hash = create_hash(password) def verify_password(self, password): # 입력된 비밀번호의 해시값과 저장된 해시값 비교 return create_hash(password) == self.password_hash 결정성: 같은 입력에 대해 항상 같은 해시 값을 생성한다.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:22:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1804 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 함수 (Hash Functions)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/hash-functions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>대칭키 암호화 (Symmetric Encryption)</h2></header><div class=entry-content><p>대칭키 암호화 (Symmetric Encryption) 대칭키 암호화는 동일한 키를 사용하여 데이터를 암호화하고 복호화하는 방식.
구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from cryptography.fernet import Fernet class SymmetricEncryption: def __init__(self): # 대칭키 생성 self.key = Fernet.generate_key() self.cipher_suite = Fernet(self.key) def encrypt(self, data): """데이터 암호화""" if isinstance(data, str): data = data.encode() return self.cipher_suite.encrypt(data) def decrypt(self, encrypted_data): """데이터 복호화""" decrypted_data = self.cipher_suite.decrypt(encrypted_data) return decrypted_data.decode() # 사용 예시 encryptor = SymmetricEncryption() message = "Hello, World!" encrypted = encryptor.encrypt(message) decrypted = encryptor.decrypt(encrypted) 주요 특징 암호화와 복호화에 같은 키를 사용한다. 혼돈(confusion)과 확산(diffusion)의 원리를 이용하여 평문을 암호화한다. 주로 치환(substitution)과 순열(permutation) 연산을 포함한 라운드를 반복하는 구조로 설계된다. 데이터 변환 방식에 따라 블록 암호와 스트림 암호로 구분된다. 혼돈(confusion)과 확산(diffusion)의 원리 혼돈(confusion)
암호문과 키 사이의 관계를 숨기는 것.
키의 단일 비트 변화가 암호문의 많은 비트를 변화시킴.
주로 치환(substitution) 연산을 통해 달성. 확산(diffusion)
암호문과 평문 사이의 관계를 숨기는 것.
평문의 통계적 특성을 암호문 전체에 분산시킴.
주로 순열(permutation) 연산을 통해 달성. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def confusion_example(input_data, key): # 혼돈(Confusion) 예시: XOR 연산을 사용하여 입력 데이터와 키를 결합 # 각 문자를 키와 XOR 연산하여 암호화 return [chr(ord(char) ^ key) for char in input_data] def diffusion_example(input_data): # 확산(Diffusion) 예시: 간단한 순열 연산을 사용 # 입력 데이터를 뒤집어 확산 효과를 시뮬레이션 return input_data[::-1] # 예시 데이터와 키 input_data = "HELLO" key = 3 # 혼돈 적용 confused_data = confusion_example(input_data, key) # 확산 적용 diffused_data = diffusion_example(confused_data) # 결과 출력 print("원본 데이터:", input_data) print("혼돈 적용 후:", ''.join(confused_data)) print("확산 적용 후:", ''.join(diffused_data)) 라운드 반복 구조 치환과 순열 연산을 포함한 기본 구조(라운드)를 여러 번 반복하는 방식.
...</p></div><footer class=entry-footer><span title='2024-11-09 21:21:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;806 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 대칭키 암호화 (Symmetric Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/symmetric-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동형 암호화(Homomorphic Encryption)</h2></header><div class=entry-content><p>동형 암호화(Homomorphic Encryption) 동형 암호화는 암호화된 데이터를 복호화하지 않은 상태에서 연산을 수행할 수 있게 해주는 암호화 기술.
일반적인 암호화 방식에서는 데이터를 처리하기 위해서는 먼저 복호화를 해야 하지만, 동형 암호화에서는 암호화된 상태 그대로 데이터를 처리할 수 있다.
예를 들어, 두 개의 숫자 3과 4를 동형 암호화했다고 가정해보자.
이 암호화된 값들을 더하면, 그 결과를 복호화했을 때 7(즉, 3+4)이 나오게 된다.
동형 암호화의 종류 부분 동형 암호화(Partial Homomorphic Encryption, PHE):
하나의 연산만 지원(덧셈 또는 곱셈).
- 대표적인 예로 Paillier 암호화(덧셈 지원)와 RSA(곱셈 지원)가 있다.
- 구현이 비교적 간단하고 성능이 우수합니다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:11:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;340 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동형 암호화(Homomorphic Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/homomorphic-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>양자 암호화(quantum cryptography)</h2></header><div class=entry-content><p>양자 암호화(quantum cryptography) 양자 암호화는 양자역학의 원리를 활용하여 완벽한 보안을 실현하는 암호화 기술.
전통적인 암호화가 수학적 복잡성에 기반한다면, 양자 암호화는 양자역학의 기본 법칙을 활용하여 이론적으로 해독이 불가능한 보안을 제공한다.
양자 암호화의 핵심 원리 양자 암호화의 가장 중요한 원리는 양자역학의 기본 특성들을 활용한다:
관측 효과: 양자 상태를 측정하면 그 상태가 변화한다. 이는 도청자가 통신을 엿들으려 할 때 필연적으로 흔적을 남기게 됨을 의미한다. 복제 불가능성: 양자 상태는 완벽하게 복제할 수 없다는 ‘양자 복제 불가 정리’를 기반으로 한다. 이는 도청자가 양자 정보를 완벽하게 복사할 수 없음을 보장한다. 중첩 상태: 양자는 동시에 여러 상태를 가질 수 있으며, 측정 전까지는 확률적인 상태로 존재한다. 이러한 특성은 암호키 생성에 활용된다. 양자 암호화의 구현 방식 양자키분배(Quantum Key Distribution, QKD)는 가장 대표적인 양자 암호화 구현 방식이다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:11:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;406 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 양자 암호화(quantum cryptography)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/quantum-cryptography/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>영지식 증명(Zero-Knowledge Proof, ZKP)</h2></header><div class=entry-content><p>영지식 증명(Zero-Knowledge Proof, ZKP) 영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.
즉, 증명자(Prover)는 검증자(Verifier)에게 자신이 특정 정보를 알고 있다는 것을 증명하되, 그 정보의 내용은 전혀 노출하지 않는다.
쉬운 예시를 들어보자.
색맹이 아닌 사람(증명자)이 색맹인 사람(검증자)에게 두 개의 공이 서로 다른 색이라는 것을 증명하고 싶다고 가정해보자. 검증자는 두 공의 위치를 무작위로 바꾸고, 증명자는 어떤 공이 바뀌었는지 맞춘다.
이 과정을 여러 번 반복하면, 증명자가 실제로 색의 차이를 볼 수 있다는 것이 증명되지만, 각 공이 어떤 색인지는 검증자에게 전혀 알려지지 않는다.
...</p></div><footer class=entry-footer><span title='2024-11-09 13:10:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 영지식 증명(Zero-Knowledge Proof, ZKP)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/zero-knowledge-proof/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>디지털 서명 (digital signature)</h2></header><div class=entry-content><p>디지털 서명 (digital signature) 디지털 서명은 전자 문서나 메시지의 진위성, 무결성, 그리고 부인 방지를 보장하기 위해 사용되는 암호화 기술
이는 실제 서명의 디지털 버전으로 볼 수 있다.
장점:
높은 보안성: 암호화 기술을 사용하여 위조가 매우 어렵다. 효율성: 종이 기반 서명에 비해 빠르고 비용 효율적이다. 글로벌 접근성: 지리적 제약 없이 사용 가능하다. 기본 원리 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding, rsa class DigitalSignature: def __init__(self): # 키 쌍 생성 (실제 사용시에는 더 큰 키 크기 사용) self.private_key = rsa.generate_private_key( public_exponent=65537, key_size=2048 ) self.public_key = self.private_key.public_key() def sign_document(self, document): """문서에 대한 디지털 서명 생성""" # 문서의 해시값 계산 후 서명 signature = self.private_key.sign( document.encode(), padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) return signature def verify_signature(self, document, signature): """서명 검증""" try: self.public_key.verify( signature, document.encode(), padding.PSS( mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH ), hashes.SHA256() ) return True except: return False 주요 특징 인증: 문서나 메시지가 실제로 서명자에 의해 생성되었음을 확인한다. 무결성: 전송 과정에서 데이터가 변경되지 않았음을 보장한다. 부인 방지: 서명자가 나중에 서명 사실을 부인할 수 없게 한다. 작동 과정 해시 생성 단계: 해시 함수를 사용하여 문서의 고유한 해시값을 생성한다.
...</p></div><footer class=entry-footer><span title='2024-11-09 06:16:00 +0000 UTC'>November 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;643 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 디지털 서명 (digital signature)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/digital-signature/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nonce</h2></header><div class=entry-content><p>Nonce 암호학에서 사용되는 중요한 개념으로, “Number used Once"의 약자로 단 한 번만 사용되는 임의의 숫자를 의미한다.
일상적인 예시로 이해해보면, 은행에서 일회용 인증번호(OTP)를 보내는 것과 비슷하다. 매번 새로운 번호가 생성되고, 한 번 사용하고 나면 그 번호는 더 이상 유효하지 않다.
목적 재전송 공격 방지 같은 메시지가 반복해서 전송되는 것을 막기 위해 사용됩니다. 예를 들어, 누군가가 암호화된 통신을 가로채서 그대로 재전송하는 공격을 시도할 때, Nonce가 다르기 때문에 이전 메시지는 무효화됩니다. 초기화 벡터(IV)로서의 역할 암호화 과정에서 같은 평문이라도 매번 다른 암호문이 생성되도록 합니다. 이는 패턴 분석을 통한 공격을 어렵게 만듭니다. 해시 함수에서의 활용 예를 들어, 비트코인 채굴에서는 특정 조건을 만족하는 해시값을 찾기 위해 Nonce를 계속 변경해가며 시도합니다. 이것이 작업 증명(Proof of Work)의 핵심 메커니즘입니다. 고려해야 할 사항 예측 불가능성: Nonce는 무작위성이 보장되어야 합니다. 순차적인 번호는 예측이 가능하므로 보안에 취약할 수 있습니다. 충분한 길이: Nonce의 길이가 너무 짧으면 중복될 가능성이 높아집니다. 보통 64비트 이상을 권장합니다. 저장과 검증: 사용된 Nonce를 일정 기간 저장하고 중복 사용을 검사해야 합니다. 사용 사례 인증 프로토콜 OAuth나 JWT와 같은 인증 시스템에서 요청의 유효성을 검증하는데 사용됩니다. 암호화 통신 TLS/SSL 프로토콜에서 ‘Client Nonce’와 ‘Server Nonce’를 교환하여 세션 키를 생성합니다. 블록체인 채굴 과정에서 블록의 해시값을 조정하는데 사용됩니다. 데이터베이스 보안 같은 데이터의 중복 저장을 방지하거나, 데이터의 무결성을 검증하는데 활용됩니다. 주의사항 Nonce는 재사용되어서는 안 됩니다. 한 번 사용된 Nonce는 반드시 폐기해야 합니다. 암호학적으로 안전한 난수 생성기(CSPRNG)를 사용해야 합니다. Nonce의 유효 기간을 적절히 설정하고 관리해야 합니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-08 15:31:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;223 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Nonce" href=https://buenhyden.github.io/posts/security/cryptography/nonce/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Authentication Code</h2></header><div class=entry-content><p>Message Authentication Code Message Authentication Code는 메시지의 무결성(integrity)과 출처 인증(authentication)을 동시에 보장하기 위한 암호학적 도구로, 메시지와 비밀키를 입력으로 받아 고정된 길이의 값을 생성하며, 이 값은 메시지에 대한 일종의 디지털 지문 역할을 한다.
예를 들어, Alice가 Bob에게 메시지를 보낼 때를 생각해보자.
Alice는 메시지와 함께 MAC 값을 전송하고, Bob은 수신한 메시지로부터 동일한 비밀키를 사용하여 MAC 값을 계산한다. 두 MAC 값이 일치한다면, Bob은 메시지가 변조되지 않았으며 실제로 Alice가 보낸 것임을 확신할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-08 13:10:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Authentication Code" href=https://buenhyden.github.io/posts/security/cryptography/message-authentication-code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>방화벽 (Firewall)</h2></header><div class=entry-content><p>방화벽 (Firewall) 네트워크 보안의 핵심 요소로, 내부 네트워크를 외부의 위협으로부터 보호하는 시스템.
방화벽은 미리 정의된 보안 규칙에 기반하여 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템으로 신뢰할 수 있는 내부 네트워크와 신뢰할 수 없는 외부 네트워크(예: 인터넷) 사이의 장벽 역할을 한다.
방화벽의 기본 동작 원리
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Firewall: def __init__(self): # 기본 규칙 설정 self.rules = [] self.default_policy = "DENY" # 기본적으로 모든 트래픽 차단 def add_rule(self, rule): """새로운 방화벽 규칙 추가""" self.rules.append(rule) def check_packet(self, packet): """패킷 검사 수행""" for rule in self.rules: if rule.matches(packet): return rule.action return self.default_policy class FirewallRule: def __init__(self, protocol, src_ip, dst_ip, src_port, dst_port, action): self.protocol = protocol self.src_ip = src_ip self.dst_ip = dst_ip self.src_port = src_port self.dst_port = dst_port self.action = action # "ALLOW" or "DENY" def matches(self, packet): """패킷이 규칙과 일치하는지 확인""" return ( self.protocol == packet.protocol and self.src_ip.matches(packet.src_ip) and self.dst_ip.matches(packet.dst_ip) and self.src_port.matches(packet.src_port) and self.dst_port.matches(packet.dst_port) ) 주요 기능 접근 통제(Access Control):
...</p></div><footer class=entry-footer><span title='2024-11-08 06:18:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;727 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 방화벽 (Firewall)" href=https://buenhyden.github.io/posts/security/security-tools/firewall/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/19/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/21/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>