<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.141.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns Vs Creational Design Patterns Vs Structural Design Patterns Behavioral Design Patterns, Creational Design Patterns, 그리고 Structural Design Patterns은 소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반화된 솔루션을 제공하는 디자인 패턴의 세 가지 주요 카테고리이다.
각 카테고리는 서로 다른 측면의 객체 지향 설계 문제를 다룬다.
구분 Creational Patterns Structural Patterns Behavioral Patterns 정의 객체 생성 메커니즘을 다루는 패턴 클래스와 객체의 구조를 다루는 패턴 객체 간의 상호작용과 책임 분배를 다루는 패턴 주요 목적 시스템이 사용할 구체 클래스를 지정하지 않으면서 객체 인스턴스 생성 클래스와 객체를 더 큰 구조로 조합하면서 유연성 유지 객체 간의 통신 방법과 책임 할당 방식을 정의 중점 사항 객체 생성 과정의 유연성 클래스와 객체를 더 큰 구조로 조합 알고리즘과 객체 간 책임 분배 유연성 제공 객체 생성 방식 객체 구조와 구성 객체 간 통신 방식 문제 해결 영역 객체 인스턴스화 클래스와 객체의 구조화 객체 상호작용 및 책임 핵심 원칙 “생성과 구현의 분리” “구조와 기능의 분리” “행위와 책임의 분리” 대표적인 패턴들 - Singleton
Factory Method
Abstract Factory
Builder
Prototype - Adapter
Bridge
Composite
Decorator
Facade - Observer
Strategy
Command
Iterator
Mediator 구현 예시 javascript const instance = Singleton.getInstance(); javascript const wrapper = new Adapter(oldInterface); javascript subject.addObserver(observer); 사용 시점 - 객체 생성 로직이 복잡할 때
- 객체 생성을 유연하게 처리해야 할 때
- 객체 재사용이 필요할 때 - 서로 다른 인터페이스를 통합할 때
- 시스템을 계층화할 때
- 기능을 동적으로 추가할 때 - 객체 간 결합도를 낮추고 싶을 때
- 알고리즘을 캡슐화할 때
- 객체 간 통신을 체계화할 때 주요 장점 - 객체 생성의 유연성 확보
- 코드 재사용성 향상
- 생성 로직 캡슐화 - 시스템 확장성 향상
- 클래스 간 결합도 감소
- 유연한 구조 설계 - 객체 간 느슨한 결합
- 책임의 명확한 분리
- 코드 재사용성 증가 주요 단점 - 클래스 수 증가
- 복잡성 증가
- 생성 패턴 과다 사용 시 오버헤드 - 추상화로 인한 복잡도 증가
- 클래스 계층 구조의 복잡화 - 관찰자 패턴의 성능 저하 가능성
- 패턴 적용의 오버헤드 적용 사례 - DB 연결 관리
- 객체 풀 관리
- 설정 관리 - GUI 컴포넌트
- 레거시 시스템 통합
- 프레임워크 개발 - 이벤트 처리
UI 업데이트
- 게임 로직 적용 시기 객체 생성이 복잡하거나 유연성이 필요할 때 클래스나 객체를 더 큰 구조로 조직해야 할 때 객체 간 통신이 복잡할 때 런타임 영향 객체 생성 시점에만 영향 전반적인 구조에 영향 실행 시간 전반에 영향 코드 유지보수성 중간 높음 높음 코드 재사용성 객체 생성 로직의 재사용 기존 코드의 재사용 및 확장 알고리즘의 재사용 촉진 시스템 영향 시스템과 객체 생성의 분리 클래스 간 관계 단순화 객체 간 결합도 감소 유지보수성 객체 생성 로직 변경 용이 구조 변경 및 확장 용이 동작 로직 변경 용이 디버깅 난이도 낮음-중간 중간 중간-높음 각 패턴 카테고리의 실제 활용 예시:
...</p></div><footer class=entry-footer><span title='2024-12-28 08:30:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;584 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>발행/구독 패턴 (Publisher-Subscriber Pattern)</h2></header><div class=entry-content><p>발행/구독 패턴 (Publisher-Subscriber Pattern) 발행/구독 패턴(Publisher-Subscriber Pattern)은 마이크로서비스 아키텍처(MSA)에서 통신 패턴 중 하나이다.
이 패턴은 컴포넌트 간의 느슨한 결합을 가능하게 하며, 확장성과 유연성을 제공한다.
발행/구독 패턴은 메시지를 생성하는 발행자(Publisher)와 메시지를 수신하는 구독자(Subscriber) 사이의 비동기 통신 모델이다.
이 패턴에서 발행자는 특정 수신자를 지정하지 않고 메시지를 발행하며, 구독자는 관심 있는 메시지 유형을 구독한다.
MSA에서의 활용 마이크로서비스 아키텍처에서 발행/구독 패턴은 다음과 같은 상황에서 유용하다:
이벤트 기반 아키텍처: 서비스 간 이벤트 전파에 사용된다. 비동기 통신: 서비스 간 느슨한 결합을 유지하면서 비동기 통신을 구현한다. 확장성: 새로운 마이크로서비스를 쉽게 추가하고 기존 서비스에 영향을 주지 않고 기능을 확장할 수 있다. 장점 낮은 결합도: 발행자와 구독자는 서로의 존재를 알 필요가 없다. 확장성: 새로운 구독자나 발행자를 쉽게 추가할 수 있다. 유연성: 다양한 컴포넌트가 메시지를 다른 방식으로 처리할 수 있다. 비동기 통신: 시스템 컴포넌트 간의 비동기 통신을 가능하게 한다. 단점 복잡성: 브로커의 로직이 복잡해질 수 있으며, 디버깅이 어려울 수 있다. 메시지 전달 보장: 일부 시스템에서는 메시지 전달을 완전히 보장하기 어려울 수 있다. 일관성: 발행자와 구독자 간의 관계 파악이 어려울 수 있다. 주요 구성 요소 발행자(Publisher): 메시지나 이벤트를 생성하고 브로커에게 전송한다. 구독자(Subscriber): 특정 유형의 메시지나 이벤트를 수신하고 처리한다. 메시지 브로커(Message Broker): 발행자와 구독자 사이에서 메시지를 중개하는 역할을 한다. 작동 방식 구독자는 메시지 브로커를 통해 관심 있는 토픽이나 메시지 유형을 구독한다. 발행자는 메시지를 생성하고 브로커에게 전송한다. 브로커는 수신한 메시지를 해당 토픽이나 유형을 구독한 모든 구독자에게 전달한다. 구독자는 수신한 메시지를 처리한다. flowchart TD Publisher-->|이벤트 발행|Topic[토픽/채널] Topic-->|구독|Subscriber1 Topic-->|구독|Subscriber2 Topic-->|구독|Subscriber3 style Topic fill:#f9f,stroke:#333,stroke-width:4px style Publisher fill:#bbf style Subscriber1 fill:#bfb style Subscriber2 fill:#bfb style Subscriber3 fill:#bfb 메시지 필터링 발행/구독 패턴에서는 두 가지 주요 필터링 방식이 있다:
...</p></div><footer class=entry-footer><span title='2024-12-28 07:05:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;723 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 발행/구독 패턴 (Publisher-Subscriber Pattern)" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/publisher-subscriber-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Request-Response Pattern</h2></header><div class=entry-content><p>Request-Response Pattern Request-Response Pattern은 마이크로서비스 아키텍처(MSA)에서 가장 기본적이고 널리 사용되는 통신 패턴 중 하나이다.
Request-Response Pattern은 한 서비스(클라이언트)가 다른 서비스(서버)에 요청을 보내고, 서버가 이 요청을 처리한 후 응답을 반환하는 방식의 통신이다.
이는 동기식 통신의 대표적인 예로, 클라이언트는 서버로부터 응답을 받을 때까지 대기한다.
작동 방식 클라이언트가 서버에 요청을 보낸다. 서버는 요청을 받아 처리한다. 서버는 처리 결과를 응답으로 클라이언트에게 반환한다. 클라이언트는 응답을 받아 처리한다. sequenceDiagram participant Client participant Server Note over Client,Server: HTTP/REST 기반 통신 Client->>+Server: GET /users/123 Note right of Server: 리소스 처리 Server-->>-Client: 200 OK (사용자 데이터) Client->>+Server: POST /orders Note right of Server: 주문 생성 Server-->>-Client: 201 Created 구현 방식과 프로토콜 REST API 구현
REST API는 HTTP 프로토콜을 기반으로 하는 가장 보편적인 구현 방식이다.
REST는 다음과 같은 특징을 가진다:
...</p></div><footer class=entry-footer><span title='2024-12-28 06:18:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;467 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Request-Response Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/request-response-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message-based Communication Pattern</h2></header><div class=entry-content><p>Message-based Communication Pattern Message-based Communication Pattern은 마이크로서비스 간 통신을 위해 메시지를 사용하는 방식이다.
각 서비스는 메시지를 생성하고 수신하며, 이 메시지들은 메시지 브로커를 통해 전달된다.
이 패턴은 서비스 간 느슨한 결합을 가능하게 하며, 비동기 통신을 지원한다.
주요 특징:
비동기 통신 지원 서비스 간 느슨한 결합 확장성과 유연성 향상 메시지 브로커 사용 flowchart LR Sender-->|메시지 전송|Queue[메시지 큐] Queue-->|메시지 소비|Receiver style Queue fill:#f9f,stroke:#333,stroke-width:4px style Sender fill:#bbf style Receiver fill:#bbf 구체적인 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 메시지 생산자 (Producer) @Service public class OrderService { private final MessageBroker messageBroker; public void createOrder(Order order) { // 주문 처리 로직 OrderCreatedMessage message = new OrderCreatedMessage( order.getId(), order.getCustomerId(), order.getItems(), LocalDateTime.now() ); // 메시지 발행 messageBroker.publish("orders.created", message); } } // 메시지 소비자 (Consumer) @Service public class InventoryService { @MessageListener(topic = "orders.created") public void handleOrderCreated(OrderCreatedMessage message) { // 재고 업데이트 로직 updateInventory(message.getItems()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 메시지 생산자 (Producer) from dataclasses import dataclass from datetime import datetime from typing import List, Dict @dataclass class Order: id: str customer_id: str items: List[Dict] created_at: datetime class OrderService: def __init__(self, message_broker): self.message_broker = message_broker def create_order(self, order: Order): # 주문 처리 로직 message = { "order_id": order.id, "customer_id": order.customer_id, "items": order.items, "timestamp": datetime.now().isoformat() } # 메시지 발행 self.message_broker.publish("orders.created", message) # 메시지 소비자 (Consumer) class InventoryService: def __init__(self, message_broker): self.message_broker = message_broker self.setup_listeners() def setup_listeners(self): self.message_broker.subscribe("orders.created", self.handle_order_created) def handle_order_created(self, message): # 재고 업데이트 로직 self.update_inventory(message["items"]) Message-based Communication의 유형 Request/Reply 패턴:
...</p></div><footer class=entry-footer><span title='2024-12-28 03:56:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1451 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message-based Communication Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/message-based-communication-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Synchronous Communication Pattern</h2></header><div class=entry-content><p>Synchronous Communication Pattern Synchronous Communication Pattern은 한 서비스가 다른 서비스에 요청을 보내고 응답을 받을 때까지 기다리는 방식이다.
이는 실시간 상호작용이 필요한 경우에 주로 사용된다.
주요 특징:
실시간 상호작용 즉각적인 응답 블로킹 방식의 통신 sequenceDiagram participant Client participant Server Note over Client,Server: 동기식 통신 - 응답을 기다림 Client->>+Server: 요청 Note right of Server: 요청 처리 중 Server-->>-Client: 응답 Note over Client: 응답 받은 후&lt;br/>다음 작업 진행 실제 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // REST API를 사용한 동기식 통신 예시 @Service public class OrderService { private final RestTemplate restTemplate; private final String paymentServiceUrl = "http://payment-service/api/payments"; public OrderResponse createOrder(Order order) { // 주문 생성 로직 Order savedOrder = orderRepository.save(order); // 결제 서비스 호출 (동기식) PaymentRequest paymentRequest = new PaymentRequest( order.getId(), order.getAmount(), order.getPaymentDetails() ); try { PaymentResponse paymentResponse = restTemplate.postForObject( paymentServiceUrl, paymentRequest, PaymentResponse.class ); // 결제 결과에 따른 주문 상태 업데이트 if (paymentResponse.isSuccessful()) { savedOrder.setStatus(OrderStatus.PAID); } else { savedOrder.setStatus(OrderStatus.PAYMENT_FAILED); } orderRepository.save(savedOrder); return new OrderResponse(savedOrder, paymentResponse); } catch (RestClientException e) { // 오류 처리 savedOrder.setStatus(OrderStatus.ERROR); orderRepository.save(savedOrder); throw new OrderProcessingException("결제 처리 중 오류 발생", e); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # FastAPI를 사용한 동기식 통신 예시 from fastapi import FastAPI, HTTPException from pydantic import BaseModel import httpx from typing import Optional class Order(BaseModel): id: str amount: float payment_details: dict class PaymentRequest(BaseModel): order_id: str amount: float details: dict class OrderService: def __init__(self): self.payment_service_url = "http://payment-service/api/payments" async def create_order(self, order: Order): # 주문 생성 로직 saved_order = await self.order_repository.save(order) # 결제 서비스 호출 (동기식) payment_request = PaymentRequest( order_id=order.id, amount=order.amount, details=order.payment_details ) try: async with httpx.AsyncClient() as client: response = await client.post( self.payment_service_url, json=payment_request.dict() ) payment_response = response.json() # 결제 결과에 따른 주문 상태 업데이트 if payment_response["successful"]: saved_order.status = "PAID" else: saved_order.status = "PAYMENT_FAILED" await self.order_repository.save(saved_order) return {"order": saved_order, "payment": payment_response} except httpx.RequestError as e: # 오류 처리 saved_order.status = "ERROR" await self.order_repository.save(saved_order) raise HTTPException( status_code=500, detail=f"결제 처리 중 오류 발생: {str(e)}" ) Synchronous Communication의 유형 HTTP 요청/응답: 가장 일반적인 동기식 통신 방법으로, REST API를 통해 구현된다.
...</p></div><footer class=entry-footer><span title='2024-12-28 03:56:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1463 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Synchronous Communication Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/communication/synchronous-communication-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/31/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/33/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>