<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>pm2</h2></header><div class=entry-content><p>Pm2 PM2는 Node.js 애플리케이션을 위한 고급 프로덕션 프로세스 관리자.
이는 내장된 로드 밸런서를 포함하고 있으며, 애플리케이션을 항상 실행 상태로 유지하고, 시스템 재부팅 시에도 자동으로 재시작할 수 있게 해주는 도구.
프로세스 관리의 중요성:
서버 애플리케이션을 운영할 때는 단순히 애플리케이션을 실행하는 것 이상의 관리가 필요하다.
예기치 않은 충돌이 발생할 수 있고, 서버가 재시작될 수 있으며, 성능 모니터링이 필요할 수 있다.
PM2는 이러한 운영 관련 문제들을 효과적으로 해결해주는 도구. 주요 기능 프로세스 관리:
...</p></div><footer class=entry-footer><span title='2024-11-21 12:31:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to pm2" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/library/keep-app-running/pm2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jsdoc</h2></header><div class=entry-content><p>Jsdoc JSDoc은 JavaScript 소스 코드에 대한 API 문서를 생성하기 위한 마크업 언어.
정의와 개념 JavaScript 코드에 대한 설명을 위해 사용되는 주석 시스템. /** */ 형식의 주석 안에 @로 시작하는 특별한 태그를 사용하여 정보를 제공한다. 주요 특징 API 문서 자동 생성: 주석을 기반으로 HTML 형식의 문서를 생성한다. 타입 정보 제공: 함수의 매개변수, 반환값 등의 타입을 명시할 수 있다. 코드 에디터 지원: 많은 IDE에서 JSDoc을 인식하여 자동완성, 타입 체크 등을 제공한다. 주요 태그 @param: 함수 매개변수 설명 @returns: 함수 반환값 설명 @type: 변수의 타입 지정 @typedef: 사용자 정의 타입 생성 @example: 사용 예제 제공 사용 예시 1 2 3 4 5 6 7 8 9 /** * 두 수를 더하는 함수 * @param {number} a - 첫 번째 숫자 * @param {number} b - 두 번째 숫자 * @returns {number} 두 숫자의 합 */ function add(a, b) { return a + b; } 참고 및 출처 Use JSDoc: Index
...</p></div><footer class=entry-footer><span title='2024-11-21 11:41:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jsdoc" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/fundamentals/documentation/jsdoc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Java Keywords</h2></header><div class=entry-content><p>Keyword 키워드들은 Java 언어의 기본 구성 요소이며, 각각이 특정한 프로그래밍 목적을 위해 설계되었다.
변수, 메서드, 클래스, 제어문 등 다양한 요소를 정의하고 제어하는 데 필수적인 역할을 한다.
이들을 올바르게 이해하고 사용하는 것이 효과적인 Java 프로그래밍의 기초가 된다.
각 키워드의 특징과 주의사항:
모든 키워드는 소문자로만 작성된다. 키워드는 식별자(변수명, 메서드명 등)로 사용할 수 없다. 일부 키워드는 특정 컨텍스트에서만 의미를 가진다. 예약어 중 일부는 현재 사용되지 않지만 향후 사용을 위해 예약되어 있다. 데이터 타입 키워드 키워드 설명 예시 byte 8비트 정수형 (-128 ~ 127) byte b = 100; short 16비트 정수형 (-32,768 ~ 32,767) short s = 1000; int 32비트 정수형 int i = 10000; long 64비트 정수형 long l = 100000L; float 32비트 단정도 실수형 float f = 3.14f; double 64비트 배정도 실수형 double d = 3.14159; boolean 논리형 (true/false) boolean flag = true; char 16비트 유니코드 문자 char c = 'A'; void 반환값이 없음을 나타냄 void method() {} 제어문 키워드 키워드 설명 예시 if 조건문 시작 if (x > 0) {} else if문의 대안 경로 else {} switch 다중 분기문 시작 switch(value) {} case switch문의 각 경우 case 1: default switch문의 기본 경우 default: for 반복문 for (int i = 0; i &lt; n; i++) while 조건 기반 반복문 while (condition) do do-while 반복문 시작 do {} while(); break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 메소드에서 값 반환/종료 return value; 클래스 관련 키워드 키워드 설명 예시 class 클래스 정의 public class MyClass {} interface 인터페이스 정의 interface MyInterface {} extends 클래스/인터페이스 상속 class Child extends Parent {} implements 인터페이스 구현 class MyClass implements Interface {} enum 열거형 정의 enum Direction {NORTH, SOUTH} this 현재 인스턴스 참조 this.value = value; super 상위 클래스 참조 super.method(); new 객체 생성 new Object(); instanceof 객체 타입 검사 obj instanceof String 접근 제어 키워드 키워드 설명 예시 public 전체 접근 허용 public class Public {} private 클래스 내부만 접근 가능 private int value; protected 패키지와 자식 클래스 접근 가능 protected void method() {} default 패키지 내부만 접근 가능 int value; (키워드 생략) 제어자 키워드 키워드 설명 예시 static 클래스 레벨 멤버 정의 static int count; final 변경 불가 선언 final int MAX = 100; abstract 추상 클래스/메소드 선언 abstract class Abstract {} synchronized 스레드 동기화 synchronized void method() {} volatile 메모리 직접 접근 변수 volatile boolean flag; transient 직렬화 제외 필드 transient int temp; native 네이티브 메소드 선언 native void method(); strictfp 엄격한 부동소수점 연산 strictfp class Math {} 예외 처리 키워드 키워드 설명 예시 try 예외 발생 가능 블록 try {} catch 예외 처리 블록 catch (Exception e) {} finally 항상 실행되는 블록 finally {} throw 예외 발생 throw new Exception(); throws 예외 선언 void method() throws Exception {} assert 조건 검증 assert x > 0; 패키지 관련 키워드 키워드 설명 예시 package 패키지 선언 package com.example; import 클래스 임포트 import java.util.List; 리터럴 키워드 키워드 설명 예시 true 논리 참 값 boolean t = true; false 논리 거짓 값 boolean f = false; null 참조 없음 Object obj = null; 예약된 키워드 (미사용) 키워드 설명 const 상수 (사용되지 않음) goto 이동 (사용되지 않음) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-20 02:56:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Java Keywords" href=https://buenhyden.github.io/posts/programming-languages/java/fundamentals/keywords/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Junit</h2></header><div class=entry-content><p>Junit Java 프로그래밍 언어를 위한 가장 널리 사용되는 단위 테스트(Unit Testing) 프레임워크.
소프트웨어 개발 과정에서 코드의 품질을 보장하고 버그를 사전에 발견하는 데 중요한 역할을 한다.
JUnit은 Kent Beck과 Erich Gamma에 의해 1997년에 처음 개발되었.
당시 소프트웨어 개발에서 테스트의 중요성이 점점 커지면서, 개발자들이 쉽게 사용할 수 있는 테스트 프레임워크의 필요성이 대두되었.
현재는 JUnit 5 버전까지 발전했으며, 각 버전마다 더욱 강력하고 사용하기 쉬운 기능들이 추가되었다.
Spring Boot 2.2.0 버전부터는 기본적으로 JUnit 5를 지원한다.
...</p></div><footer class=entry-footer><span title='2024-11-20 00:23:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Junit" href=https://buenhyden.github.io/posts/programming-languages/java/advanced/testing/junit/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Client-side UI composition</h2></header><div class=entry-content><p>Client-side UI Composition Client-side UI Composition은 마이크로서비스 아키텍처(MSA)에서 클라이언트(주로 브라우저)가 여러 마이크로서비스로부터 데이터를 직접 가져와 사용자 인터페이스(UI)를 구성하는 패턴이다.
이 패턴은 각 서비스가 독립적으로 UI 컴포넌트를 제공하고, 클라이언트가 이를 조합하여 최종 화면을 렌더링하는 방식으로 동작한다.
이 패턴에서는 클라이언트(브라우저)가 여러 마이크로서비스로부터 데이터를 요청하고, 해당 데이터를 기반으로 UI를 렌더링한다. 각 마이크로서비스는 자신만의 UI 컴포넌트(HTML, CSS, JavaScript 등)를 제공하며, 클라이언트는 이러한 컴포넌트를 조합해 전체 화면을 구성한다.
예를 들어, 전자상거래 웹사이트의 상품 상세 페이지를 생각해보면:
...</p></div><footer class=entry-footer><span title='2024-11-19 11:07:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-side UI composition" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/use-cases/integration-patterns/ui-integration/client-side-ui-composition/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server-side page fragment composition</h2></header><div class=entry-content><p>Server-side Page Fragment Composition Server-side page fragment composition은 마이크로서비스 아키텍처(MSA)에서 여러 서비스로부터 HTML 조각(프래그먼트)을 수집하여 서버에서 최종 웹 페이지를 구성하는 패턴이다. 이 패턴은 각 서비스가 독립적으로 개발되고 배포될 수 있도록 하면서도, 최종 사용자에게는 통합된 사용자 경험을 제공한다.
Server-side page fragment composition은 여러 마이크로서비스가 생성한 HTML 조각을 서버에서 조합하여 최종 웹 페이지를 만드는 방식이다. 각 마이크로서비스는 특정 비즈니스 기능이나 도메인에 해당하는 UI 컴포넌트를 제공하며, 이러한 컴포넌트는 서버에서 통합되어 클라이언트에 전달된다.
예를 들어, 전자상거래 사이트의 상품 상세 페이지를 구성할 때, 상품 정보, 사용자 리뷰, 추천 상품 등의 데이터는 각각 다른 서비스에서 제공되며, 서버는 이들을 조합하여 하나의 페이지로 렌더링한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:07:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-side page fragment composition" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/use-cases/integration-patterns/ui-integration/server-side-page-fragment-composition/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Key Authentication</h2></header><div class=entry-content><p>API Key Authentication API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.
API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.
API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Key Authentication" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/tttt/api-key-authentication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CORS</h2></header><div class=entry-content><p>CORS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 CORS(Cross-Origin Resource Sharing)는 매우 중요한 역할을 한다.
CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.
CORS는 MSA 환경에서 안전하고 유연한 리소스 공유를 가능하게 하는 핵심 메커니즘으로 올바르게 구현된 CORS는 마이크로서비스 간의 안전한 통신을 보장하며, 전체 시스템의 보안을 강화한다.
CORS의 작동 원리 브라우저가 다른 출처로 HTTP 요청을 보낼 때 Origin 헤더를 추가한다. 서버는 Access-Control-Allow-Origin 헤더로 응답하여 해당 출처의 접근을 허용할지 결정한다. 브라우저는 이 헤더를 확인하여 요청을 허용하거나 차단한다. Origin의 정의
Origin은 다음 세 가지 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CORS" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/tttt/cors/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mutual TLS</h2></header><div class=entry-content><p>Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.
https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutual TLS" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/tttt/mutual-tls/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OAuth2/OIDC (OpenID Connect)</h2></header><div class=entry-content><p>OAuth2/OIDC (OpenID Connect) MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.
OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.
OAuth 2.0 OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth2/OIDC (OpenID Connect)" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/tttt/oauth2-oidc/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/31/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/33/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>