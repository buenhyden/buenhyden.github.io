<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Client-side discovery</h2></header><div class=entry-content><p>Client-side Discovery Client-side Discovery는 서비스 클라이언트가 직접 서비스 레지스트리에 질의하여 필요한 서비스의 위치 정보를 얻고, 그 정보를 바탕으로 서비스를 호출하는 방식이다.
Client-side Discovery는 마이크로서비스 환경에서 유연하고 확장 가능한 서비스 디스커버리 방식을 제공한다. 그러나 클라이언트의 복잡도가 증가하는 단점이 있으므로, 프로젝트의 요구사항과 팀의 기술 스택을 고려하여 적절히 선택해야 한다.
주요 구성 요소 서비스 레지스트리(Service Registry): 각 서비스 인스턴스의 네트워크 위치(예: IP 주소, 포트)를 저장하고 관리하는 데이터베이스이다. 서비스 인스턴스는 시작 시 자신의 정보를 레지스트리에 등록하고, 종료 시 등록을 해제한다.
...</p></div><footer class=entry-footer><span title='2024-11-14 11:46:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Client-side discovery" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/service-discovery/client-side-discovery/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service deployment platform</h2></header><div class=entry-content><p>Service Deployment Platform “Service deployment platform"은 마이크로서비스 아키텍처(MSA)에서 서비스를 효율적으로 배포하고 관리하기 위한 플랫폼이다. 이 플랫폼은 개발자들이 마이크로서비스를 쉽게 개발, 배포, 운영할 수 있도록 지원하는 종합적인 환경을 제공한다.
주요 특징 자동화된 배포: Service deployment platform은 CI/CD (지속적 통합/지속적 배포) 파이프라인을 통해 자동화된 배포 프로세스를 제공한다. 이를 통해 개발자는 코드 변경사항을 빠르고 안정적으로 프로덕션 환경에 반영할 수 있다. 컨테이너 오케스트레이션: 대부분의 Service deployment platform은 쿠버네티스와 같은 컨테이너 오케스트레이션 도구를 기반으로 한다. 이를 통해 마이크로서비스의 확장성, 가용성, 복원력을 관리할 수 있다. 서비스 디스커버리: 플랫폼은 서비스 디스커버리 메커니즘을 제공하여 마이크로서비스 간의 통신을 용이하게 한다. 이를 통해 동적으로 변화하는 환경에서도 서비스 간 연결을 유지할 수 있다. 모니터링 및 로깅: Service deployment platform은 통합된 모니터링 및 로깅 기능을 제공한다. 이를 통해 개발자와 운영팀은 서비스의 성능을 실시간으로 모니터링하고 문제를 신속하게 진단할 수 있다. 주요 구성 요소 컨테이너 레지스트리: 서비스의 컨테이너 이미지를 저장하고 관리하는 중앙 저장소이다. 오케스트레이션 엔진: 쿠버네티스와 같은 도구로, 컨테이너의 배포, 스케일링, 관리를 자동화한다. API 게이트웨이: 클라이언트 요청을 적절한 마이크로서비스로 라우팅하고 인증, 로드 밸런싱 등의 기능을 제공한다. 서비스 메시: 마이크로서비스 간의 통신을 관리하고 모니터링하는 인프라 레이어이다. 설정 관리: 다양한 환경(개발, 테스트, 프로덕션)에 대한 설정을 중앙에서 관리한다. 로깅 및 모니터링 도구: 서비스의 성능과 상태를 추적하고 분석하는 도구들이다. 장점 개발 생산성 향상: 개발자가 인프라 관리보다는 비즈니스 로직 개발에 집중할 수 있게 해준다. 빠른 배포 및 롤백: 자동화된 프로세스를 통해 신속한 배포와 문제 발생 시 빠른 롤백이 가능하다. 확장성: 트래픽 증가에 따라 서비스를 쉽게 확장할 수 있다. 운영 효율성: 자동화된 모니터링과 관리 도구를 통해 운영 효율성을 높일 수 있다. 대표적인 서비스 배포 플랫폼 쿠버네티스(Kubernetes): 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈소스 플랫폼으로, MSA 환경에서 널리 사용된다. 오픈시프트(OpenShift): 레드햇에서 개발한 쿠버네티스 기반의 엔터프라이즈급 애플리케이션 플랫폼으로, 추가적인 개발자 및 운영자 도구를 제공한다. 이스티오(Istio): 서비스 메시(Service Mesh) 구현체로, 서비스 간의 통신, 보안, 모니터링, 트래픽 관리를 지원하여 MSA의 운영 복잡성을 줄여준다. 도입 시 고려사항 러닝 커브: 새로운 플랫폼 도입에 따른 학습 곡선이 있을 수 있으므로, 충분한 교육과 학습 기간이 필요하다. 인프라 요구사항: 플랫폼이 요구하는 인프라 자원을 사전에 평가하고, 이에 맞게 인프라를 구성해야 한다. 보안: 플랫폼 자체의 보안 기능과 더불어, 조직의 보안 정책에 부합하는지 검토해야 한다. 커뮤니티 및 지원: 플랫폼의 커뮤니티 활성도와 지원 체계를 확인하여, 문제 발생 시 신속한 대응이 가능한지 판단해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-13 11:36:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service deployment platform" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-components/deployment-and-operations/service-deployment-platform/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service per VM</h2></header><div class=entry-content><p>Service per VM “Service per-VM” (VM당 서비스) 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 가상 머신(VM)에 배포하는 방식이다. 이 패턴의 주요 특징과 장단점을 자세히 살펴보겠습니다.
“Service per-VM” 패턴은 강력한 격리와 리소스 관리를 제공하지만, 리소스 오버헤드와 관리 복잡성 증가라는 대가가 따른다. 이 패턴은 높은 수준의 격리가 필요하거나 서비스 간 리소스 경쟁을 최소화해야 하는 경우에 적합하다.
그러나 리소스 효율성과 빠른 배포가 중요한 경우에는 다른 배포 패턴을 고려해볼 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:36:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service per VM" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-components/deployment-and-operations/service-per-vm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multiple Services per Host</h2></header><div class=entry-content><p>Multiple Services per Host “Multiple Services per Host” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 하나의 물리적 또는 가상 호스트에 여러 개의 마이크로서비스 인스턴스를 배포하는 방식이다.
이 패턴에서는 하나 이상의 물리적 또는 가상 호스트를 준비하고, 각 호스트에 여러 개의 서비스 인스턴스를 실행한다. 이는 전통적인 애플리케이션 배포 방식을 반영한 것이다.
이 패턴은 리소스 효율성과 배포 용이성이라는 장점이 있지만, 복잡성 증가와 서비스 간 격리 부족이라는 단점도 있다. 따라서 프로젝트의 요구사항과 규모에 따라 신중하게 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multiple Services per Host" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-components/deployment-and-operations/multiple-services-per-host/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service per Container</h2></header><div class=entry-content><p>Service per-Container “Service per-Container” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 마이크로서비스를 독립적인 컨테이너에 배포하는 방식이다.
주요 특징 독립성: 각 서비스는 독립적인 컨테이너에 배포되어 자체적으로 실행된다. 이는 서비스 간의 격리를 보장하고, 각 서비스의 독립적인 확장과 관리를 가능하게 한다. 경량화: 컨테이너는 가상 머신에 비해 훨씬 가볍고 빠르게 시작할 수 있다. 이는 리소스 사용을 최적화하고 배포 속도를 향상시킨다. 이식성: 컨테이너화된 서비스는 개발, 테스트, 프로덕션 환경 간에 쉽게 이동할 수 있다. 이는 “한 번 빌드하고 어디서나 실행"이라는 원칙을 실현한다. 버전 관리: 각 서비스의 컨테이너 이미지는 독립적으로 버전 관리될 수 있어, 서비스별로 다른 버전을 쉽게 배포하고 롤백할 수 있다. 장점 확장성: 각 서비스를 독립적으로 확장할 수 있어, 특정 서비스의 부하 증가에 효과적으로 대응할 수 있다. 예를 들어, 사용자 서비스에 부하가 집중될 경우 해당 서비스의 컨테이너만 추가로 배포할 수 있다. 장애 격리: 한 서비스의 문제가 다른 서비스로 전파되는 것을 방지한다. 특정 서비스에 문제가 발생해도 다른 서비스는 정상적으로 작동할 수 있다. 기술 스택 다양성: 각 서비스는 독립적인 컨테이너에서 실행되므로, 서비스별로 다른 기술 스택을 사용할 수 있다. 예를 들어, 한 서비스는 Node.js를, 다른 서비스는 Java를 사용할 수 있다. 배포 유연성: 각 서비스를 독립적으로 배포할 수 있어, 전체 시스템을 중단하지 않고도 특정 서비스만 업데이트하거나 롤백할 수 있다. 단점 복잡성 증가: 여러 컨테이너를 관리하고 조율해야 하므로 시스템의 전반적인 복잡성이 증가할 수 있다. 이는 모니터링, 로깅, 네트워킹 등의 영역에서 추가적인 관리 부담을 초래할 수 있다. 리소스 오버헤드: 각 서비스가 독립적인 컨테이너에서 실행되므로, 전체적인 리소스 사용량이 증가할 수 있다. 통신 오버헤드: 서비스 간 통신이 네트워크를 통해 이루어지므로, 단일 프로세스 내 통신에 비해 오버헤드가 발생할 수 있다. 구현 시 고려사항 컨테이너 오케스트레이션: Kubernetes와 같은 컨테이너 오케스트레이션 도구를 사용하여 여러 컨테이너의 배포, 확장, 관리를 자동화할 수 있다. 서비스 디스커버리: 동적으로 변화하는 컨테이너 환경에서 서비스 간 통신을 위해 서비스 디스커버리 메커니즘이 필요하다. Kubernetes의 Service 리소스나 별도의 서비스 메시 솔루션을 활용할 수 있다. 로깅 및 모니터링: 분산된 환경에서의 효과적인 로깅과 모니터링을 위해 중앙화된 로깅 시스템과 모니터링 도구의 사용이 필요하다. 보안: 각 컨테이너의 보안을 개별적으로 관리해야 하며, 네트워크 보안, 이미지 보안, 런타임 보안 등 다양한 측면을 고려해야 한다. 컨테이너 이미지 최적화 기반 이미지 최소화 멀티 스테이지 빌드 적용 캐시 레이어 최적화 불필요한 파일 제거 네트워킹 서비스간 통신 설정 네트워크 보안 정책 로드 밸런싱 구현 방법 컨테이너 이미지 생성: 각 마이크로서비스를 독립적인 컨테이너 이미지로 빌드한다. Docker와 같은 도구를 사용하여 필요한 라이브러리와 종속성을 포함한 이미지를 생성한다. 컨테이너 오케스트레이션: Kubernetes, Docker Swarm 등의 오케스트레이션 도구를 사용하여 컨테이너의 배포, 확장, 관리를 자동화한다. 서비스 디스커버리, 로드 밸런싱, 자동 복구 등의 기능을 활용한다. 모니터링 및 로깅 설정: Prometheus, ELK 스택 등 모니터링 및 로깅 도구를 사용하여 각 서비스의 상태와 로그를 중앙에서 수집하고 분석한다. 예시 예를 들어, 온라인 쇼핑몰 애플리케이션에서 주문 처리 서비스와 결제 서비스를 각각 독립적인 컨테이너로 패키징하여 배포할 수 있다. 이렇게 하면 주문 처리 서비스에 대한 업데이트나 확장을 결제 서비스에 영향을 주지 않고 수행할 수 있으며, 각 서비스의 부하에 따라 독립적으로 확장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service per Container" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-components/deployment-and-operations/service-per-container/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Single Service per Host</h2></header><div class=entry-content><p>Single Service per Host “Single Service per Host” 패턴은 마이크로서비스 아키텍처(MSA)의 배포 전략 중 하나로, 각 서비스 인스턴스를 독립적인 호스트에 배포하는 방식이다.
Single Service per Host 패턴은 각 서비스 인스턴스를 자체 호스트에 배포하는 방식이다. 여기서 호스트는 물리적 머신, 가상 머신, 또는 컨테이너가 될 수 있다. 이 패턴은 서비스 간의 격리를 극대화하고 리소스 관리를 단순화하는 것을 목표로 한다.
Single Service per Host 패턴은 서비스 간 높은 수준의 격리와 리소스 관리의 단순화를 제공하지만, 리소스 활용 효율성과 운영 복잡성 측면에서 trade-off가 있다. 따라서 프로젝트의 요구사항과 운영 환경을 고려하여 적절히 선택해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:35:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Single Service per Host" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-components/deployment-and-operations/single-service-per-host/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Serverless deployment</h2></header><div class=entry-content><p>Serverless Deployment Serverless deployment는 마이크로서비스 아키텍처(MSA)의 배포 패턴 중 하나로, 서버 관리의 부담을 줄이고 개발자가 애플리케이션 로직에 집중할 수 있게 해주는 접근 방식이다.
Serverless deployment는 개발자가 서버를 관리할 필요가 없는 클라우드 컴퓨팅 모델 중 하나이다. 즉, 서버 관리를 개발자가 아닌 클라우드 제공자가 알아서 해주는 것이다. 이 방식에서는 개발자가 코드만 작성하고 배포하면, 클라우드 제공업체가 필요에 따라 자동으로 인프라를 확장하고 관리한다.
결론적으로, Serverless deployment는 개발자가 인프라 관리에서 벗어나 비즈니스 로직에 집중할 수 있게 해주는 혁신적인 배포 방식이다. 하지만 모든 상황에 적합한 것은 아니므로, 프로젝트의 특성과 요구사항을 고려하여 적절히 활용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 11:34:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Serverless deployment" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-components/deployment-and-operations/serverless-deployment/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Self-contained Service</h2></header><div class=entry-content><p>Self-contained Service 마이크로서비스 아키텍처(MSA)에서 “self-contained service” 패턴은 서비스의 자율성과 독립성을 극대화하는 중요한 개념이다.
Self-contained Service는 단일 비즈니스 기능을 완전히 독립적으로 구현한 서비스를 의미한다.
이 서비스는 자체적으로 데이터를 저장하고, 비즈니스 로직을 처리하며, 사용자 인터페이스를 제공할 수 있다.
Self-contained Service 패턴은 MSA의 핵심 원칙을 구현하는 방법 중 하나로, 서비스의 자율성과 독립성을 극대화하여 시스템의 유연성과 확장성을 높이는 데 기여한다. 하지만 이 패턴을 적용할 때는 시스템의 복잡성 증가와 데이터 일관성 관리 등의 도전 과제를 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-13 10:50:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Self-contained Service" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented/microservices-architecture/decomposition/self-contained-service/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service per team</h2></header><div class=entry-content><p>Service per Team Service per team 패턴은 각 마이크로서비스를 개별 팀이 소유하고 관리하는 방식이다.
이 패턴에서는 각 팀이 특정 비즈니스 기능을 담당하며, 해당 기능의 코드베이스를 소유한다.
Service per team 패턴은 팀의 자율성과 책임감을 높이는 동시에 마이크로서비스 아키텍처의 이점을 최대화할 수 있는 효과적인 접근 방식이다. 그러나 이 패턴을 성공적으로 구현하기 위해서는 조직 문화, 팀 구조, 그리고 기술적 인프라 등 여러 측면에서의 신중한 고려가 필요하다.
주요 특징 팀 자율성: 각 팀은 자신의 서비스를 독립적으로 개발, 테스트, 배포, 확장할 수 있다. API 중심 협업: 팀들은 주로 API를 통해 상호작용하며, 다른 팀과의 협업을 최소화한다. 소규모 팀: 일반적으로 “two-pizza team” 크기의 소규모 팀이 각 서비스를 담당한다. 인지 부하 감소: 팀원들이 전체 시스템이 아닌 특정 서비스에만 집중할 수 있어 인지 부하가 감소한다. 장점 팀 자율성 강화: 각 팀이 독립적으로 의사 결정을 내릴 수 있다. 느슨한 결합: 팀 간의 의존성이 줄어들어 더 유연한 개발이 가능하다. 코드 품질 향상: 장기적인 코드 소유권으로 인해 코드 품질이 개선된다. 빠른 개발 및 배포: 작은 팀이 독립적으로 개발하고 배포할 수 있어 시장 변화에 빠르게 대응할 수 있다. 단점 복잡한 프로젝트 조정: 여러 서비스에 걸친 복잡한 프로젝트의 경우 팀 간 조정이 어려워질 수 있다. 높은 WIP (Work in Progress): 각 팀이 항상 바쁘게 유지되어야 하므로 진행 중인 작업이 많아질 수 있다. 좁은 가치 흐름: 이상적인 구현에서는 팀들이 완전히 분리되어 있어, 조직 전체의 가치 흐름이 좁아질 수 있다. 최적화되지 않은 우선순위 지정: 팀의 가용성이 프로젝트 우선순위 결정의 주요 요인이 될 수 있다. 구현 시 고려사항 팀 구성: 각 서비스를 담당할 수 있는 cross-functional 팀을 구성해야 한다. 서비스 경계 정의: 비즈니스 기능과 하위 도메인을 기반으로 서비스 경계를 명확히 정의해야 한다. 팀 간 커뮤니케이션: API 설계와 변경에 대한 팀 간 효과적인 커뮤니케이션 채널을 구축해야 한다. 확장성 고려: 새로운 팀을 추가하거나 기존 서비스를 분할할 때의 전략을 미리 수립해야 한다. 예시: 대규모 전자상거래 플랫폼을 운영하는 기업을 예로 들어보자.
이 기업은 다음과 같은 주요 비즈니스 기능을 가지고 있다:
...</p></div><footer class=entry-footer><span title='2024-11-13 10:50:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service per team" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented/microservices-architecture/decomposition/service-per-team/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decompose by Business Capability</h2></header><div class=entry-content><p>Decompose by Business Capability “Decompose by Business Capability” 패턴은 마이크로서비스 아키텍처(MSA)에서 중요한 분해 패턴이다.
이 패턴은 비즈니스 능력을 기반으로 애플리케이션을 마이크로서비스로 분해하는 방법을 제시한다.
이 패턴은 조직의 비즈니스 능력을 기반으로 마이크로서비스를 정의한다.
비즈니스 능력은 조직이 가치를 창출하기 위해 수행하는 특정 기능이나 프로세스를 의미한다.
주요 목적은 다음과 같다:
비즈니스 목표와 소프트웨어 개발의 정렬 독립적으로 개발 및 유지보수 가능한 서비스 생성 조직 구조와 시스템 아키텍처의 일치 이 패턴을 효과적으로 적용하려면 조직의 비즈니스 도메인에 대한 깊은 이해가 필요하며, 지속적인 비즈니스 분석과 서비스 경계의 조정이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-11-13 01:20:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decompose by Business Capability" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-styles/service-oriented/microservices-architecture/decomposition/decompose-by-business-capability/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/37/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/39/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>