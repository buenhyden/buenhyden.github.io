<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>테이블레이션(Tabulation)</h2></header><div class=entry-content><p>테이블레이션(Tabulation) Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.
Tabulation은 ‘표를 만든다’는 의미로, 문제의 해결 과정을 표 형태로 정리하는 기법이다. 이 방법은 작은 부분 문제(subproblem)부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 상향식(bottom-up) 접근 방식을 사용합니다.
Tabulation의 작동 원리 문제 정의: 해결하고자 하는 문제와 그 부분 문제들을 명확히 정의한다. 표 초기화: 부분 문제의 결과를 저장할 표(보통 배열이나 리스트)를 만든다. 기본 케이스 설정: 가장 작은 부분 문제에 대한 해답을 표에 채운다. 반복적 계산: 작은 부분 문제부터 시작하여 큰 문제로 나아가며 표를 채운다. 최종 결과 도출: 표의 마지막 항목이 전체 문제의 해답이 된다. Tabulation의 예시: 피보나치 수열 피보나치 수열을 계산하는 예시
...</p></div><footer class=entry-footer><span title='2024-10-13 11:21:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;221 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테이블레이션(Tabulation)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/dynamic-programming/tabulation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>튜링 기계 (Turing Machine)</h2></header><div class=entry-content><p>튜링 기계 (Turing Machine) 튜링 기계는 1936년 앨런 튜링이 제안한 추상적인 계산 모델로, 알고리즘의 개념을 수학적으로 정형화한 것으로, 현대 컴퓨터의 이론적 기초가 되었다.
튜링 기계는 무한한 길이의 테이프, 읽기/쓰기 헤드, 그리고 상태 제어 장치로 구성된다.
튜링 기계는 다음과 같은 요소로 구성된다:
무한한 길이의 테이프: 계산에 필요한 데이터를 저장한다. 읽기/쓰기 헤드: 테이프의 심볼을 읽고 쓸 수 있다. 상태 레지스터: 현재 기계의 상태를 저장한다. 유한한 규칙 집합: 기계의 동작을 정의한다. 튜링 기계의 작동 원리:
...</p></div><footer class=entry-footer><span title='2024-10-13 10:07:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1047 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 튜링 기계 (Turing Machine)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/turing-machine/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>복잡도 클래스(Complexity Classes)</h2></header><div class=entry-content><p>복잡도 클래스(Complexity Classes) 복잡도 클래스(Complexity Classes)는 계산 복잡도 이론에서 비슷한 복잡도를 가진 문제들의 집합을 나타낸다.
이는 문제를 해결하는 데 필요한 자원(시간 또는 공간)의 양에 따라 문제들을 분류한다.
Source: https://www.geeksforgeeks.org/types-of-complexity-classes-p-np-conp-np-hard-and-np-complete/
P (Polynomial Time) 결정론적 튜링 기계(Deterministic Turing Machine, DTM)로 다항 시간 내에 해결 가능한 문제들의 집합이다.
이 문제는 단순히 배열을 한 번 순회하면 되므로, 입력 크기에 비례하는 시간이 소요된다.
효율적으로 해결 가능한 문제들이 포함되며 대부분의 실용적인 문제들이 여기에 속한다.
예시:
...</p></div><footer class=entry-footer><span title='2024-10-13 09:54:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;863 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 복잡도 클래스(Complexity Classes)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/complexity-classes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비결정성 (Non-determinism)</h2></header><div class=entry-content><p>비결정성 (Non-determinism) 알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성
특징 다중 선택: 각 단계에서 여러 가능한 다음 단계 중 하나를 임의로 선택할 수 있다. 병렬 처리: 여러 가능한 경로를 동시에 탐색할 수 있는 개념적 모델을 제공한다. 결정성과의 차이: 결정성 알고리즘은 각 단계에서 다음 단계가 유일하게 결정되는 반면, 비결정성 알고리즘은 그렇지 않다. 비결정성 알고리즘 비결정성 알고리즘은 다음과 같은 특징을 가진다.
실행 경로의 다양성: 동일한 입력에 대해 여러 가능한 실행 경로가 존재한다. 비결정도: 각 단계에서 선택 가능한 다음 단계의 최대 개수를 비결정도라고 한다. 계산 능력: 비결정성 알고리즘과 결정성 알고리즘의 계산 능력은 동일하다. 응용 NP 문제: 비결정성 알고리즘으로 다항식 시간 내에 해결 가능한 결정형 문제를 NP 문제라고 한다. 유한 오토마타: 비결정적 유한 오토마타(NFA)는 탐색과 백트래킹 기법을 통해 모든 가능한 선택을 시도한다. 탐색 및 백트래킹 알고리즘: 비결정성은 여러 가지 경우를 순차적으로 계산하며 최적값을 갱신하는 백트래킹 기법의 모델로 사용된다. 장점 간결한 표현: 복잡한 언어나 시스템을 비결정성을 통해 더 간결하게 정의할 수 있다. 논증 간소화: 비결정성을 통해 공식적인 논증을 간단히 할 수 있다. 모델링 유연성: 실제 세계의 불확실성이나 복잡성을 모델링하는 데 유용하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import random import threading # 결정적인 함수의 예 def deterministic_sum(a, b): return a + b # 항상 같은 입력에 대해 같은 결과 # 비결정적인 함수의 예 def non_deterministic_choice(options): return random.choice(options) # 매번 다른 결과가 나올 수 있음 # 비결정적인 멀티스레딩 예제 shared_counter = 0 lock = threading.Lock() def increment_counter(): global shared_counter current = shared_counter # 의도적으로 경쟁 조건을 만듦 threading.Thread(target=lambda: None).start() shared_counter = current + 1 def run_concurrent_increments(n): threads = [] for _ in range(n): t = threading.Thread(target=increment_counter) threads.append(t) t.start() for t in threads: t.join() return shared_counter 다양한 상황에서 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-13 09:18:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;701 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비결정성 (Non-determinism)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/computational-complexity/non-determinism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>브루트 포스 (Brute Force)</h2></header><div class=entry-content><p>브루트 포스 (Brute Force) 브루트 포스는 “무식한 힘"이라는 뜻으로, 가능한 모든 경우의 수를 전부 탐색하여 문제를 해결하는 방법이다.
특성 모든 가능성을 고려한다. 단순하고 직관적이다. 항상 정확한 해답을 찾는다. 목적과 필요성 복잡한 최적화 없이 문제를 해결하고자 할 때 사용한다. 다른 효율적인 알고리즘이 없거나 구현이 어려울 때 필요하다. 문제의 크기가 작을 때 빠르게 해결책을 찾을 수 있다. 장점 구현이 간단하다. 항상 최적의 해를 찾는다. 문제의 제약 조건이 까다로울 때 유용하다. 단점 시간 복잡도가 높다 (대부분의 경우 O(2^n) 또는 O(n!)). 큰 입력에 대해 비효율적이다. 메모리 사용량이 많을 수 있다. 작동 원리 가능한 모든 경우의 수를 생성한다. 각 경우에 대해 문제의 조건을 만족하는지 확인한다. 조건을 만족하는 경우를 해답으로 채택한다. 좋은 알고리즘의 조건 문제의 크기가 작을 때 효과적이다. 다른 알고리즘의 정확성을 검증하는 데 사용될 수 있다. 구현이 간단하고 버그가 적다. 효율적인 구현을 위한 팁 가능한 경우의 수를 줄이는 방법을 고려한다 (가지치기). 병렬 처리를 활용하여 성능을 개선할 수 있다. 메모이제이션을 사용하여 중복 계산을 줄인다. 핵심 구성 요소 후보 생성 함수 (generate_candidates) 유효성 검사 함수 (is_valid_solution) 반복문 또는 재귀를 통한 모든 경우의 수 탐색 실제 예시 코드 모든 가능한 비밀번호 조합을 생성하여 올바른 비밀번호를 찾는 함수
...</p></div><footer class=entry-footer><span title='2024-10-13 07:50:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 브루트 포스 (Brute Force)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/brute-force/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Approaches to algorithm design</h2></header><div class=entry-content><p>Approaches to Algorithm Design 알고리즘 설계를 위한 접근 방법 (Approaches to Algorithm Design)은 문제 해결을 위한 전략적인 사고 과정을 의미한다. 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞추며 다양한 기법들을 조합하여 사용이 가능하다.
알고리즘 설계 기법(Algorithm Design Techniques)은 이러한 접근 방법을 구체화하여 실제 알고리즘을 구현하는 데 사용되는 기술적인 방법론으로 특정 문제 유형에 최적화된 해결 방식을 제공하며 명확한 알고리즘 구조를 제공한다.
Approaches to Algorithm Design 알고리즘 설계를 위한 접근 방법은 문제 해결을 위한 전략적인 사고 과정을 의미한다.
이는 알고리즘 설계 기법과는 구별되는 개념으로, 문제를 이해하고 해결책을 도출하는 과정에 초점을 맞춘다.
...</p></div><footer class=entry-footer><span title='2024-10-13 07:30:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;951 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Approaches to algorithm design" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/approaches-to-algorithm-design/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>랜덤화 알고리즘 (Randomized Algorithm)</h2></header><div class=entry-content><p>랜덤화 알고리즘 (Randomized Algorithm) 랜덤화 알고리즘(Randomized Algorithm)은 문제 해결 과정에서 무작위성을 활용하는 알고리즘 설계 기법이다. 난수 생성기를 사용하여 실행 과정에서 무작위적인 선택을 하는 알고리즘이다. 이 무작위성은 알고리즘의 동작이나 결정에 영향을 미치며, 같은 입력에 대해서도 매번 다른 결과를 낼 수 있다.
특성 무작위성: 알고리즘의 핵심 특성으로, 난수를 사용하여 결정을 내린다. 확률적 성능: 알고리즘의 성능이 확률적으로 분석된다. 다양성: 같은 입력에 대해 다양한 출력이 가능하다. 목적과 필요성 복잡한 문제의 간단한 해결책 제공 최악의 경우 성능 개선 결정론적 알고리즘의 한계 극복 평균 실행 시간 단축 장점 단순성: 복잡한 문제에 대해 간단한 해결책 제공 효율성: 많은 경우에 결정론적 알고리즘보다 빠름 유연성: 다양한 문제에 적용 가능 단점 결과의 일관성 부족: 같은 입력에 대해 다른 결과 가능 디버깅의 어려움: 무작위성으로 인해 재현이 어려울 수 있음 최악의 경우 보장 부족: 확률적 성능으로 인해 최악의 경우를 완전히 배제할 수 없음 작동 원리 문제 정의 무작위 선택 요소 식별 난수 생성기 사용 무작위 선택에 기반한 결정 결과 도출 및 분석 좋은 알고리즘의 조건 효율성: 평균적으로 좋은 성능을 보여야 함 정확성: 높은 확률로 정확한 결과를 제공해야 함 단순성: 구현과 이해가 쉬워야 함 확장성: 다양한 입력 크기에 대응할 수 있어야 함 효율적인 구현을 위한 팁 고품질의 난수 생성기 사용 무작위성의 적절한 활용 확률 분석을 통한 성능 최적화 병렬화 가능성 고려 핵심 구성 요소 난수 생성기 무작위 선택 메커니즘 결정 함수 종료 조건 실제 예시 랜덤화된 퀵 정렬 알고리즘
...</p></div><footer class=entry-footer><span title='2024-10-13 05:55:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;516 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 랜덤화 알고리즘 (Randomized Algorithm)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/randomized-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>근사 알고리즘 (Approximation algorithm)</h2></header><div class=entry-content><p>근사 알고리즘 (Approximation algorithm) 컴퓨터 과학에서 우리가 마주치는 많은 문제들 중에는 정확한 해답을 찾는 것이 현실적으로 매우 어려운 문제들이 있다.
예를 들어, 외판원 문제(Traveling Salesman Problem)는 도시들을 모두 한 번씩만 방문하면서 가장 짧은 경로를 찾는 문제인데, 도시의 수가 증가하면 가능한 모든 경로를 확인하는 데 너무 많은 시간이 걸린다.
이런 상황에서 우리는 다음과 같은 선택을 할 수 있다:
정확한 해답을 찾되 매우 오랜 시간이 걸리는 것을 감수한다 정확하지는 않지만 ‘충분히 좋은’ 해답을 빠르게 찾는다
근사 알고리즘은 두 번째 접근 방식을 택한다. 근사 알고리즘(Approximation algorithm)은 최적해(가장 좋은 해답)를 찾는 대신, 최적해에 ‘충분히 가까운’ 해답을 찾는 알고리즘이다.
여기서 중요한 점은 근사 알고리즘이 얼마나 좋은 해답을 찾을 수 있는지 수학적으로 보장한다는 것이다.
예를 들어, “이 알고리즘은 항상 최적해의 1.5배 이내의 해답을 찾는다"와 같이 성능을 보장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1653 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 근사 알고리즘 (Approximation algorithm)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/approximation-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백트래킹 (Backtracking)</h2></header><div class=entry-content><p>백트래킹 (Backtracking) 백트래킹은 ‘되돌아가기’라는 의미를 가지고 있다.
백트래킹은 가능한 모든 방법을 탐색하면서 문제를 해결하는 알고리즘으로, 현재의 선택이 잘못되었다고 판단되면 이전 단계로 돌아가서 다른 선택을 시도한다.
이 알고리즘은 문제의 해결책을 찾기 위해 가능한 모든 경우의 수를 체계적으로 탐색하는 방법이다.
백트래킹의 핵심 아이디어는 다음과 같다:
해결책을 찾아가는 과정에서 여러 선택지를 순차적으로 시도한다. 현재의 선택이 해결책으로 이어질 가능성이 없다고 판단되면, 이전 단계로 돌아가 다른 선택지를 시도한다. 이 과정을 반복하여 최종적으로 해결책을 찾거나, 모든 가능성을 탐색한다. 백트래킹은 단순한 완전 탐색(Exhaustive Search)과는 다르다.
백트래킹은 현재의 선택이 유망한지(promising) 판단하여, 유망하지 않다면 더 이상 그 방향으로 탐색하지 않고 이전 단계로 돌아간다. 이를 ‘가지치기(pruning)‘라고 한다.
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;682 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 백트래킹 (Backtracking)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/backtracking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분기 한정법 (Branch and Bound)</h2></header><div class=entry-content><p>분기 한정법 (Branch and Bound) 분기 한정법은 복잡한 최적화 문제를 해결하기 위해 문제를 더 작은 하위 문제로 나누고(분기), 각 하위 문제의 해의 범위를 추정(한정)하여 최적해를 찾는 방법이다.
이 방법은 가능한 모든 해를 체계적으로 탐색하면서도 불필요한 탐색을 줄이는 것이 특징이다.
분기 한정법은 두 가지 주요 개념을 기반으로 한다:
분기(Branch): 문제를 더 작은 하위 문제로 나누는 과정. 한정(Bound): 각 하위 문제의 잠재적인 해결책의 품질을 평가하는 과정.
이 방법은 상태 공간 트리를 사용하여 모든 가능한 해결책을 체계적으로 탐색한다. 특성 분기(Branching): 문제를 더 작은 하위 문제로 나눈다. 각 분기는 겹치지 않는 부분 문제들을 만든다. 한정(Bounding): 각 하위 문제의 해의 범위를 추정한다. 상한(upper bound)과 하한(lower bound)을 계산한다. 유망하지 않은 분기는 더 이상 탐색하지 않는다. 가지치기(Pruning): 최적해가 될 수 없는 하위 문제를 제거한다. 상태 공간 트리(State Space Tree) 사용: 가능한 해들을 트리 구조로 표현한다. 목적과 필요성 분기 한정법의 주요 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-13 05:23:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;910 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분기 한정법 (Branch and Bound)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm-design/algorithm-design-techniques/branch-and-bound/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/37/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/39/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>