<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Release Management</h2></header><div class=entry-content><p>Release Management 릴리스 관리 (Release Management) 는 소프트웨어 개발 프로세스에서 코드 변경사항을 개발 환경에서 프로덕션 환경으로 안전하고 체계적으로 배포하는 전체 과정을 관리하는 방법론이다. 이는 버전 관리 시스템과 긴밀하게 연계되어 코드 변경사항의 추적, 버전 관리, 배포 프로세스 자동화 등을 포함한다. 효과적인 릴리스 관리는 소프트웨어의 품질 보장, 배포 위험 최소화, 사용자 경험 향상, 개발 팀의 생산성 증대에 기여한다.
2025 년 현재 DevOps 및 CI/CD 도구와의 통합을 통해 지속적 배포 자동화가 강화되고 있으며, AI 기반 위험 관리 및 클라우드 네이티브 아키텍처 지원이 주목받고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-01 09:48:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Release Management" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/release-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Open Source Contribution</h2></header><div class=entry-content><p>Open Source Contribution 오픈소스 기여 (Open Source Contribution) 는 공개된 소프트웨어 프로젝트에 개인이나 조직이 코드, 문서, 테스트, 버그 리포트 등을 통해 참여하는 활동이다. 이는 버전 관리 시스템 (특히 Git) 을 중심으로 이루어지며, Fork-Clone- 수정 -Pull Request 로 이어지는 표준화된 워크플로우를 통해 진행된다. 오픈소스 기여는 소프트웨어 개발 생태계의 지속 가능성을 유지하고, 개발자 간 지식 공유와 협업을 촉진하며, 개인 개발자에게는 실무 경험과 평판을 쌓을 기회를 제공한다.
핵심 개념 오픈소스 기여는 공개된 소프트웨어 프로젝트에 개발자가 자발적으로 참여하여 코드, 문서, 디자인, 테스트 등을 통해 가치를 더하는 활동이다.
...</p></div><footer class=entry-footer><span title='2024-10-01 06:07:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Open Source Contribution" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/open-source-contribution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pull Request Flow</h2></header><div class=entry-content><p>Pull Request Flow Pull Request(PR) 는 현대 소프트웨어 개발에서 코드 협업과 품질 관리의 중심이 되는 기능이다.
GitHub, GitLab, Bitbucket 과 같은 Git 호스팅 서비스들이 제공하는 이 기능은 코드 변경 사항을 메인 코드베이스에 통합하기 전에 검토하고 논의할 수 있는 구조화된 방법을 제공한다.
Pull Request 는 현대 소프트웨어 개발의 핵심 협업 메커니즘으로, 코드 품질 향상과 팀 지식 공유에 중요한 역할을 한다. GitHub, GitLab, Bitbucket 과 같은 플랫폼들은 각자의 방식으로 이 기능을 구현하고 있으며, 지속적으로 개선하고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-01 02:11:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pull Request Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/collaboration/pull-request-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Byte Addressable Memory vs Word Addressable Memory</h2></header><div class=entry-content><p>Byte Addressable Memory vs. Word Addressable Memory Byte Addressable Memory와 Word Addressable Memory는 컴퓨터 메모리의 주소 지정 방식을 설명하는 개념이다.
이 두 가지 방식은 메모리의 구조와 데이터 접근 방법에 중요한 차이를 나타낸다.
Sourece: https://examradar.com/memory-organisation/
Byte Addressable Memory Byte Addressable Memory는 각 바이트(8비트)마다 고유한 주소가 할당되어 개별적으로 접근할 수 있는 메모리 구조이다.
가장 작은 주소 지정 단위(smallest addressable unit)는 1바이트(8비트)이며, 이를 통해 메모리의 각 바이트에 직접 접근할 수 있다.
CPU는 개별 바이트 단위로 메모리에 접근할 수 있으며, 워드(일반적으로 4바이트 또는 8바이트) 단위의 접근도 가능하다.
32비트 시스템에서는 2^32개의 주소를 가질 수 있어 최대 4GB의 메모리를 지원하며, 64비트 시스템에서는 훨씬 더 큰 주소 공간을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 11:38:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Byte Addressable Memory vs Word Addressable Memory" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/byte-addressable-memory-vs-word-addressable-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Allocation Policy</h2></header><div class=entry-content><p>Allocation Policy Cache Allocation Policy(캐시 할당 정책)는 캐시 메모리 관리에서 중요한 역할을 하는 정책으로, 데이터를 캐시에 어떻게 할당할지 결정하는 방식을 의미한다.
이 정책은 시스템의 성능과 효율성에 큰 영향을 미치므로 신중하게 선택해야 한다.
Cache Allocation Policy의 주요 유형과 특징 Write-Allocate (Fetch-on-Write)
Write-Allocate 정책에서는 쓰기 작업 시 해당 데이터가 캐시에 없는 경우(write miss), 먼저 해당 블록을 캐시로 가져온 후 쓰기 작업을 수행한다. 이 방식은 후속 읽기 작업이 캐시에서 바로 데이터를 찾을 수 있어 읽기 성능을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Allocation Policy" href=https://buenhyden.github.io/posts/architecture-and-system-design/implementation/caching/cache-policy/allocation-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prefetch Policy</h2></header><div class=entry-content><p>Prefetch Policy Cache Policy의 Prefetch Policy는 데이터 요청을 미리 예측하여 필요한 데이터를 캐시에 미리 로드하는 전략이다.
이 정책은 시스템의 성능을 향상시키기 위해 사용되며, 특히 데이터 접근이 반복적이거나 예측 가능한 경우에 효과적이다.
Prefetching은 프로그램이 실제로 데이터에 접근하기 전에 미리 데이터를 메모리로 가져오는 기술이다.
이를 통해 캐시 미스를 줄이고, 데이터 접근 속도를 높이며, 전반적인 시스템 성능을 개선할 수 있다.
Prefetch Policy는 이러한 prefetching 작업을 어떻게 수행할지를 결정하는 규칙이나 방법론을 의미한다.
Prefetch Policy는 캐시 시스템에서 성능 향상을 위한 중요한 전략이다.
하드웨어, 소프트웨어 또는 컴파일러 수준에서 구현될 수 있으며, 다양한 유형의 prefetching 기법이 존재한다. 적절한 prefetch 정책을 선택하고 구현함으로써 시스템 성능을 크게 개선할 수 있으며, 데이터 접근 패턴과 요구사항에 맞춰 최적화하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prefetch Policy" href=https://buenhyden.github.io/posts/architecture-and-system-design/implementation/caching/cache-policy/prefetch-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Replacement Policy</h2></header><div class=entry-content><p>Replacement Policy Cache Replacement Policy(캐시 교체 정책) 는 캐시 메모리에서 새로운 데이터를 저장하기 위해 기존의 데이터를 교체할 때 어떤 데이터를 제거할지를 결정하는 규칙이다.
캐시는 한정된 크기를 가지므로, 새로운 데이터가 들어올 때 기존의 데이터를 교체해야 한다. 이때 어떤 데이터를 선택할지는 시스템의 성능에 큰 영향을 미친다.
Cache Replacement Policy는 캐시 메모리의 효율성을 극대화하는 데 중요한 역할을 한다. LRU, FIFO, LFU 등 다양한 정책들이 있으며, 각 정책은 특정 상황과 요구 사항에 따라 장단점이 다르다.
적절한 교체 정책을 선택함으로써 시스템의 성능을 개선하고 데이터 접근 속도를 높일 수 있다. 캐시를 효과적으로 관리하기 위해서는 워크로드 특성과 시스템 요구 사항을 면밀히 분석하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:53:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Replacement Policy" href=https://buenhyden.github.io/posts/architecture-and-system-design/implementation/caching/cache-policy/replacement-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Placement Policy</h2></header><div class=entry-content><p>Placement Policy Cache Placement Policy는 캐시 메모리에서 특정 메모리 블록이 캐시에 저장될 위치를 결정하는 규칙을 의미한다.
이는 캐시의 구조와 데이터 접근 패턴에 따라 성능과 효율성에 큰 영향을 미친다. Placement Policy는 캐시 메모리의 설계와 운영에서 중요한 역할을 하며, 주로 다음 세 가지 주요 유형으로 나뉜다:
Direct-Mapped Cache Fully Associative Cache Set-Associative Cache. Cache Placement Policy란? 정의: Placement Policy는 특정 메모리 블록이 캐시에 저장될 때, 캐시 내에서 어느 위치(캐시 라인)에 저장될지를 결정하는 규칙이다. 목적: 캐시 메모리의 효율적인 사용. 데이터 접근 속도 최적화. 충돌(Collision) 관리: 동일한 캐시 라인에 여러 데이터가 매핑되는 상황을 최소화. Cache Placement Policy는 데이터가 캐시에 저장되는 위치를 결정하며, 시스템 성능과 효율성에 직접적인 영향을 미친다.
Direct-Mapped, Fully Associative, Set-Associative 각각 장단점이 있으므로, 애플리케이션 요구사항과 하드웨어 제약 조건을 고려하여 적절한 정책을 선택해야 한다.
Set-Associative는 대부분의 현대 시스템에서 자주 사용되는 절충안으로, 성능과 비용 간 균형을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 10:50:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Placement Policy" href=https://buenhyden.github.io/posts/architecture-and-system-design/implementation/caching/cache-policy/placement-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 접근 방법 (Memory Access Methods)</h2></header><div class=entry-content><p>메모리 접근 방식 (Memory Access Methods) 컴퓨터 시스템에서 메모리에 접근하는 주요 방식은 다음과 같다:
순차적 접근 (Sequential Access)
메모리를 선형적인 순서로 접근하는 방식. 데이터를 처음부터 순서대로 읽거나 쓰며, 특정 위치에 접근하려면 그 앞의 모든 데이터를 거쳐야 한다. 주로 자기 테이프와 같은 저장 장치에서 사용된다. 직접 접근 (Direct Access)
각 메모리 블록이 고유한 주소를 가지고 있어 직접 접근이 가능하다. 일반적인 위치로 직접 접근한 후, 순차적 검색을 통해 최종 목적지에 도달한다. 하드 디스크와 같은 저장 장치에서 주로 사용된다. 랜덤 접근 (Random Access)
...</p></div><footer class=entry-footer><span title='2024-09-30 08:05:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 접근 방법 (Memory Access Methods)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/access-methods/memory-access-methods/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모리 주소 지정 방식 (Memory Address Modes)</h2></header><div class=entry-content><p>메모리 주소 지정 방식 (Memory Address Modes) 메모리 주소 지정 방식(Memory Address Modes)은 CPU가 메모리의 특정 위치에 어떻게 접근하는지를 나타내는 방법이다.
유형 즉시 주소 지정 방식 (Immediate Addressing):
데이터가 명령어 자체에 포함되어 있다. 예: “5를 더해라” 라고 직접 지시하는 것과 같다. 가장 빠르지만, 큰 데이터를 다루기 어렵다. 직접 주소 지정 방식 (Direct Addressing):
명령어에 데이터가 있는 메모리 주소를 직접 지정한다. 예: “주소 100번에 있는 값을 가져와라” 라고 지시하는 것과 같다. 간단하고 이해하기 쉽다. 간접 주소 지정 방식 (Indirect Addressing):
...</p></div><footer class=entry-footer><span title='2024-09-30 08:04:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모리 주소 지정 방식 (Memory Address Modes)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/memory-systems/address-modes/memory-address-modes/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/57/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/59/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>