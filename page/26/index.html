<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교</h2></header><div class=entry-content><p>멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교 멱등성과 안전한 메서드는 HTTP 메서드의 중요한 특성으로, 서버의 상태 변화와 관련이 있다.
멱등성(Idempotency)은 동일한 요청을 여러 번 수행해도 서버의 상태가 동일하게 유지되는 특성을 말한다.
즉, 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 유지된다.
안전한 메서드(Safe Methods)는 서버의 상태를 변경하지 않는 HTTP 메서드를 의미한다.
이는 주로 리소스를 조회하는 용도로 사용되며, 서버의 데이터나 상태를 수정하지 않는다.
...</p></div><footer class=entry-footer><span title='2024-10-24 00:49:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멱등성 (Idempotency)과 안전한 메서드 (Safe Methods)의 비교" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/http/idempotency-and-safe-methods/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSH (Secure Shell)</h2></header><div class=entry-content><p>SSH (Secure Shell) SSH는 네트워크 상의 다른 컴퓨터에 안전하게 접속하기 위한 암호화 네트워크 프로토콜.
1995년 핀란드 헬싱키 공과대학의 타투 일로넨(Tatu Ylönen)이 개발했으며, 당시 빈번하게 발생하던 비밀번호 스니핑 공격에 대응하기 위해 만들어졌다.
기존의 텔넷(Telnet)이나 rsh(Remote Shell)와 같은 비보안 프로토콜을 대체하기 위해 설계되었다.
SSH의 주요 특징과 장점 SSH는 다음과 같은 중요한 특징을 가지고 있다:
강력한 암호화: 통신 내용을 암호화하여 데이터의 기밀성을 보장한다. 현재 SSH-2 버전에서는 AES, 3DES 등의 강력한 암호화 알고리즘을 사용한다. 인증 메커니즘: 서버와 클라이언트 간의 상호 인증을 제공한다. 비밀번호 기반 인증뿐만 아니라, 공개키 기반의 인증도 지원하여 보다 안전한 인증이 가능하다. 데이터 무결성: 통신 과정에서 데이터가 변조되지 않았음을 보장한다. MAC(Message Authentication Code)을 사용하여 데이터의 무결성을 검증한다. 포트 포워딩: 로컬 포트 포워딩과 리모트 포트 포워딩을 통해 다른 프로토콜의 트래픽도 SSH 터널을 통해 안전하게 전송할 수 있다. SSH의 동작 방식 SSH의 동작 과정은 다음과 같은 단계로 이루어진다:
...</p></div><footer class=entry-footer><span title='2024-10-23 12:35:00 +0000 UTC'>October 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;386 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SSH (Secure Shell)" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/ssh/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SSL and TLS</h2></header><div class=entry-content><p>SSL(Secure Sockets Layer)과 TLS(Transport Layer Security) 인터넷 상에서 데이터를 안전하게 전송하기 위한 암호화 프로토콜.
TLS는 SSL의 후속 버전으로, 보안성과 성능이 향상되었다.
SSL의 역사와 개념 SSL은 1995년 Netscape에 의해 개발되었다.
주요 목적은 웹 브라우징 시 데이터의 기밀성과 무결성을 보장하는 것.
SSL은 다음과 같은 버전으로 발전했다:
SSL 1.0 (내부적으로만 사용) SSL 2.0 (1995년 공개) SSL 3.0 (1996년 공개) TLS의 등장과 발전 TLS는 SSL 3.0을 기반으로 1999년 IETF(Internet Engineering Task Force)에 의해 개발되었다.
TLS는 SSL의 보안 취약점을 개선하고 더 강력한 암호화 알고리즘을 도입했다.
TLS의 주요 버전은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-23 08:48:00 +0000 UTC'>October 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SSL and TLS" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/ssl-and-tls/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WebSocket</h2></header><div class=entry-content><p>WebSocket OSI 7계층에서 응용 계층(7계층)에 위치하며, TCP/IP 4계층에서는 응용 계층에 해당한다.
WebSocket은 HTTP를 기반으로 한 통신 프로토콜이지만, 연결이 수립된 후에는 HTTP와는 독립적으로 동작한다.
HTTP가 단방향 통신만을 지원하는 것과 달리, WebSocket은 전이중(Full-duplex) 통신을 지원한다.
이는 전화 통화처럼 양쪽에서 동시에 데이터를 주고받을 수 있다는 의미이다.
즉, 클라이언트와 서버 간의 지속적인 연결을 통해 양방향, 실시간 통신을 가능하게 하는 컴퓨터 통신 프로토콜이다.
Source: https://blog.stackademic.com/api-101-introduction-imp-of-api-paradigms-8d8e0e463f96
주요 특징 전이중 통신: 클라이언트와 서버가 동시에 데이터를 주고받을 수 있습니다. 지속적 연결: 한 번 연결이 수립되면 계속 유지됩니다. 실시간 데이터 전송: 서버에서 클라이언트로 요청 없이도 데이터를 전송할 수 있습니다. 낮은 지연 시간: 연결이 유지되므로 데이터 전송 시 지연이 적습니다. 장점 실시간 통신: 채팅, 게임, 실시간 협업 도구 등에 적합하다. 효율성: HTTP에 비해 오버헤드가 적어 네트워크 리소스를 효율적으로 사용한다. 양방향 통신: 서버에서 클라이언트로의 푸시 알림이 가능하다. 단점 복잡성: 연결 관리, 오류 처리 등 구현이 복잡할 수 있다. 브라우저 지원: 일부 구형 브라우저에서는 지원되지 않을 수 있다. 서버 부하: 많은 동시 연결을 유지해야 하므로 서버 리소스 사용이 증가할 수 있다. 동작 방식 핸드셰이크:
웹소켓 연결은 HTTP를 통해 시작된다.
클라이언트가 “Upgrade: websocket” 헤더를 포함한 요청을 보내면, 서버는 이를 수락하여 웹소켓 연결로 전환한다. 데이터 전송:
연결이 수립된 후, 클라이언트와 서버는 웹소켓 프로토콜을 사용하여 데이터를 주고받는다.
데이터는 프레임 단위로 전송된다. 연결 종료:
클라이언트나 서버 중 어느 한 쪽이 연결을 종료할 수 있다. 연결 수립 과정 (Handshake) 연결 수립 과정(Handshake)에 대해서 조금더 자세히 알아보도록 하자.
...</p></div><footer class=entry-footer><span title='2024-10-23 04:24:00 +0000 UTC'>October 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;700 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebSocket" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/websocket/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TCP</h2></header><div class=entry-content><p>TCP (Transmission Control Protocol) 인터넷 프로토콜 스위트의 핵심 프로토콜 중 하나로, IP(Internet Protocol)와 함께 TCP/IP로 널리 알려져 있다.
TCP는 연결 지향적이며, 신뢰성 있는 데이터 전송을 보장하는 전송 계층 프로토콜이다.
OSI 7계층에서 TCP는 전송 계층(Transport Layer)인 4계층에 위치하며,
TCP/IP 4계층 모델에서도 마찬가지로 전송 계층에 해당한다.
이 위치에서 TCP는 데이터의 신뢰성 있는 전송을 담당하는 핵심적인 역할을 수행한다.
TCP의 가장 중요한 특징은 연결 지향성과 신뢰성이다.
연결 지향성이란 데이터를 주고받기 전에 먼저 연결을 설정하는 것을 의미하는데, 이는 3-way handshaking이라는 과정을 통해 이루어진다.
신뢰성은 데이터가 손실없이 순서대로 전달되는 것을 보장한다는 의미이다.
...</p></div><footer class=entry-footer><span title='2024-10-23 04:21:00 +0000 UTC'>October 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;787 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCP" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/tcp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>UDP</h2></header><div class=entry-content><p>UDP (User Datagram Protocol) 인터넷 프로토콜 스위트의 핵심 전송 계층 프로토콜 중 하나로, 비연결형 통신 방식을 통해 데이터를 빠르고 효율적으로 전송한다.
TCP와 달리 연결 설정 과정 없이 데이터그램 단위로 전송하며, 신뢰성보다는 속도와 실시간 처리가 중요한 애플리케이션에서 주로 사용한다.
OSI 7계층의 전송 계층(4계층)에 속하며, TCP/IP 4계층에서도 전송 계층에 속한다.
추가적으로 알아야 할 내용:
포트 번호: UDP도 TCP와 마찬가지로 16비트 포트 번호를 사용하여 애플리케이션을 구분합니다. 체크섬: UDP는 선택적으로 체크섬을 사용하여 데이터 무결성을 확인할 수 있습니다. MTU(Maximum Transmission Unit): UDP 데이터그램의 크기가 네트워크의 MTU를 초과하면 IP 계층에서 단편화가 발생할 수 있습니다. 애플리케이션 레벨 신뢰성: UDP를 사용하는 애플리케이션은 필요한 경우 자체적으로 신뢰성 메커니즘을 구현해야 합니다. NAT 통과: UDP는 TCP에 비해 NAT(Network Address Translation) 통과가 더 쉬울 수 있습니다. 실시간 애플리케이션: 음성 통화, 비디오 스트리밍, 온라인 게임 등 실시간 애플리케이션에서 자주 사용됩니다. DNS: 도메인 네임 시스템(DNS)은 주로 UDP를 사용하여 쿼리를 처리합니다. QUIC(Quick UDP Internet Connections): Google이 개발한 프로토콜로, UDP 위에서 동작하며 TCP의 일부 특성을 구현합니다. 주요 특징 비연결성: UDP는 연결을 설정하지 않고 바로 데이터를 전송한다.
TCP의 3-way handshake와 같은 연결 설정 과정이 없다. 신속성: 연결 설정 과정이 없어 TCP보다 빠른 전송이 가능하다. 비신뢰성: 데이터 전달의 보증이나 순서를 보장하지 않는다. 패킷 손실이 발생할 수 있다. 효율성: 헤더가 단순하여 오버헤드가 적고, 네트워크 부하가 적다. 장점 빠른 데이터 전송 적은 지연 시간 간단한 구현 작은 헤더 크기로 인한 효율적인 대역폭 사용 브로드캐스트 및 멀티캐스트에 적합 동작 방식 애플리케이션이 데이터를 UDP에 전달 UDP가 데이터를 데이터그램으로 패키징 IP 계층을 통해 데이터그램 전송 수신측 UDP가 데이터그램을 받아 애플리케이션에 전달 데이터그램 UDP는 데이터를 데이터그램이라는 단위로 전송한다.
데이터그램은 독립적인 관계를 지니는 패킷을 의미한다.
...</p></div><footer class=entry-footer><span title='2024-10-23 04:21:00 +0000 UTC'>October 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;500 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UDP" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/udp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Packet</h2></header><div class=entry-content><p>Packet (패킷, 네트워크 패킷) 패킷은 네트워크에서 데이터를 주고받을 때 사용되는 형식화된 데이터 블록이다.
주요 목적은 다음과 같다:
효율적인 데이터 전송 네트워크 대역폭의 효율적 사용 오류 검출 및 복구 용이성 네트워크 혼잡 방지 패킷을 사용하는 이유는? 패킷이 모두 대상에 도착하는 한 동일한 대상에 대해 서로 다른 네트워크 경로를 사용할 수 있음을 의미한다. 특정 프로토콜에서 패킷은 각 패킷이 다른 경로를 사용하여 도착하더라도 올바른 순서로 최종 목적지에 도착해야 한다. 여러 컴퓨터의 패킷이 기본적으로 임의의 순서로 동일한 선로를 통해 이동할 수 있다. 동일한 네트워킹 장비를 통해 동시에 여러 연결을 수행할 수 있다. 그 결과로 수십억 개의 장치가 인터넷에서 동시에 데이터를 교환할 수 있다. 패킷의 구조 패킷은 일반적으로 세 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-22 10:18:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;303 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Packet" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/packet/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Routing</h2></header><div class=entry-content><p>Routing 데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.
네트워크 계층(3계층)에서 이루어지는 핵심 기능으로, 라우터가 패킷의 목적지 IP 주소를 확인하고 최적의 경로를 결정한다.
주요 특징 경로 결정: 라우팅 테이블을 참조하여 최적의 경로를 선택한다. 네트워크 연결: 서로 다른 네트워크를 연결하여 통신을 가능하게 한다. 패킷 전달: 선택된 경로를 통해 패킷을 다음 홉으로 전달한다. 중요성 효율적인 데이터 전송을 가능하게 한다. 네트워크의 안정성과 확장성을 향상시킨다. 트래픽 관리와 로드 밸런싱에 기여한다. 라우팅 방식 정적 라우팅: 관리자가 수동으로 라우팅 테이블을 구성한다.
...</p></div><footer class=entry-footer><span title='2024-10-22 10:18:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;620 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Routing" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/routing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network Hop</h2></header><div class=entry-content><p>Network Hop 네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.
홉은 데이터 패킷이 한 네트워크 지점에서 다음 지점으로 이동할 때마다 발생합니다.
각 홉은 패킷이 목적지에 도달하기 위해 거치는 중간 단계를 나타낸다. 주요 역할은 다음과 같다:
경로 결정: 각 홉에서 라우터는 패킷의 다음 목적지를 결정한다. 네트워크 성능 측정: 홉 수는 네트워크의 복잡성과 데이터 전송 경로의 길이를 나타낸다. 패킷 전달: 각 홉은 패킷을 다음 네트워크 장비로 전달하는 역할을 한다. 홉 카운트(Hop Count) 홉 카운트는 패킷이 출발지에서 목적지까지 거치는 홉의 총 개수를 의미한다. 이는 네트워크 경로의 길이를 측정하는 중요한 지표이다.
...</p></div><footer class=entry-footer><span title='2024-10-22 09:19:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;225 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Hop" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/network-hop/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프록시(Proxy)</h2></header><div class=entry-content><p>프록시(Proxy) 프록시(Proxy)는 “대리” 또는 “대신"이라는 의미를 가진 개념으로, 네트워크 환경에서 중요한 역할을 수행한다.
프록시 서버는 클라이언트의 요청을 받아 대신 서버에 접속하여 데이터를 주고받는 중개자 역할을 한다.
이 과정에서 프록시 서버는 클라이언트의 IP 주소를 숨기고, 자신의 IP 주소를 사용하여 서버와 통신한다.
프록시의 주요 기능 익명성 제공: 클라이언트의 실제 IP 주소를 숨겨 개인정보를 보호한다. 캐싱: 자주 요청되는 데이터를 저장하여 네트워크 성능을 향상시킨다. 접근 제어: 특정 웹사이트나 콘텐츠에 대한 접근을 제한할 수 있다. 로깅 및 모니터링: 네트워크 트래픽을 기록하고 분석할 수 있다. 프록시 사용의 장점 보안 강화: 클라이언트와 서버 사이의 직접적인 연결을 차단하여 보안을 향상시킨다. 성능 최적화: 캐싱을 통해 반복적인 요청에 대한 응답 속도를 높인다. 접근 제어: 조직 내 네트워크 사용을 관리하고 제한할 수 있다. 익명성: 사용자의 실제 IP 주소와 위치를 숨길 수 있다. 프록시 사용의 주의점 속도 저하: 추가적인 네트워크 홉으로 인해 약간의 지연이 발생할 수 있다. 보안 위험: 잘못 구성된 프록시는 오히려 보안 취약점이 될 수 있다. 호환성 문제: 일부 애플리케이션이나 서비스와 호환되지 않을 수 있다. 프록시의 작동 방식 사용자(클라이언트)가 웹사이트에 접속하려고 할 때, 직접 웹사이트 서버에 연결하지 않고 프록시 서버에 연결한다. 프록시 서버는 사용자의 요청을 받아 웹사이트 서버에 전달한다. 웹사이트 서버는 프록시 서버에 응답을 보낸다. 프록시 서버는 받은 응답을 다시 사용자에게 전달한다. 프록시의 종류 특성 포워드 프록시 리버스 프록시 위치 클라이언트 앞에 위치 서버 앞에 위치 주요 목적 클라이언트 보호 및 요청 중계 서버 보호 및 부하 분산 클라이언트 인식 클라이언트가 프록시 존재를 인식 클라이언트가 프록시 존재를 모름 IP 주소 은닉 클라이언트의 IP 주소를 숨김 서버의 IP 주소를 숨김 주요 기능 캐싱, 콘텐츠 필터링, 익명성 제공 로드 밸런싱, SSL 종료, 캐싱 트래픽 방향 내부에서 외부로 외부에서 내부로 보안 초점 클라이언트 보안 강화 서버 보안 강화 확장성 클라이언트 측 확장에 유리 서버 측 확장에 유리 주요 사용 사례 기업 내부 네트워크, 학교 등 웹 서버, CDN, 마이크로서비스 ...</p></div><footer class=entry-footer><span title='2024-10-22 08:47:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;289 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프록시(Proxy)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/proxy/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/25/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/27/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>