<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비꼬리 재귀(Non-tail Recursion)</h2></header><div class=entry-content><p>비꼬리 재귀(Non-tail Recursion) 비꼬리 재귀(Non-tail Recursion)는 재귀 호출이 함수의 마지막 연산이 아닌 형태의 재귀를 의미한다.
이러한 형태의 재귀는 꼬리 재귀(Tail Recursion)와 대비되는 개념으로, 프로그래밍과 알고리즘 설계에서 중요한 의미를 가진다.
비꼬리 재귀는 재귀 호출 이후에 추가 연산이 필요한 재귀 함수의 형태이다.
이런 형태의 재귀는 많은 알고리즘과 자료구조에서 자연스럽게 발생하며, 종종 문제를 직관적으로 해결할 수 있게 해준다.
그러나 비꼬리 재귀는 스택 오버플로우 위험과 같은 실용적인 제약이 있다. 이러한 제약을 극복하기 위해 꼬리 재귀로의 변환, 메모이제이션, 또는 반복적 접근법으로의 전환을 고려할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 09:36:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;991 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비꼬리 재귀(Non-tail Recursion)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/non-tail-recursion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dynamic Programming vs. Divide and Conquer</h2></header><div class=entry-content><p>Dynamic Programming vs. Divide and Conquer 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-09 05:08:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;9 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dynamic Programming vs. Divide and Conquer" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/dynamic-programming-vs-divide-and-conquer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>tail Recursion vs. Non-tail Recursion</h2></header><div class=entry-content><p>Tail Recursion vs. Non-tail Recursion 재귀(Recursion)는 문제를 작은 부분 문제로 나누어 해결하는 기법이다.
특히, 재귀 호출이 함수의 마지막 연산으로 수행되는지 여부에 따라 Tail Recursion(꼬리 재귀) 과 Non-Tail Recursion(비꼬리 재귀) 으로 구분된다.
꼬리 재귀와 비꼬리 재귀는 각각 장단점이 있다. 꼬리 재귀는 컴파일러 최적화를 통해 스택 오버플로우를 방지하고 성능을 개선할 수 있지만, 코드가 덜 직관적일 수 있다. 비꼬리 재귀는 더 자연스러운 문제 해결 방식을 제공하지만, 메모리 사용량이 더 많고 스택 오버플로우 위험이 있다.
...</p></div><footer class=entry-footer><span title='2024-12-09 00:51:00 +0000 UTC'>December 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;683 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to tail Recursion vs. Non-tail Recursion" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/recursion/tail-recursion-vs-non-tail-recursion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Binary Search Tree vs. Array</h2></header><div class=entry-content><p>Binary Search Tree vs. Array 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-08 13:49:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;8 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Binary Search Tree vs. Array" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/binary-search-tree/binary-search-tree-vs-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Binary Search Tree vs. Hash Table</h2></header><div class=entry-content><p>Binary Search Tree vs. Hash Table 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-08 13:49:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;9 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Binary Search Tree vs. Hash Table" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/binary-search-tree/binary-search-tree-vs-hash-table/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Binary Search Tree vs. Linked List</h2></header><div class=entry-content><p>Binary Search Tree vs. Linked List 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-08 13:49:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;9 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Binary Search Tree vs. Linked List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/binary-search-tree/binary-search-tree-vs-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Balance Factor</h2></header><div class=entry-content><p>Balance Factor 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-08 13:48:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Balance Factor" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/binary-search-tree/balance-factor/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Stack vs. Array</h2></header><div class=entry-content><p>Stack vs. Array 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-08 13:43:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stack vs. Array" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack/stack-vs-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Stack vs. Linked List</h2></header><div class=entry-content><p>Stack vs. Linked List 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-08 13:43:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;7 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Stack vs. Linked List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/stack/stack-vs-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Collision resolutions</h2></header><div class=entry-content><p>Collision Resolutions 해시 테이블(Hash Table)은 키(Key)를 해시 함수(Hash Function)에 적용하여 특정 인덱스(Index)에 데이터를 저장하는 자료구조이다.
그러나 서로 다른 키가 같은 해시 인덱스로 매핑되는 경우가 발생할 수 있으며, 이를 충돌(Collision) 이라고 한다.
해시 함수는 임의 크기의 데이터를 고정된 크기의 값으로 매핑한다. 해시 테이블의 크기가 제한되어 있기 때문에, 서로 다른 키들이 같은 해시 값(버킷 인덱스)을 가지는 ‘충돌’이 불가피하게 발생한다. 이는 ‘비둘기집 원리(Pigeonhole Principle)‘에 의해 증명된다 - 가능한 키의 수가 해시 테이블의 크기보다 크면 충돌은 반드시 발생한다.
...</p></div><footer class=entry-footer><span title='2024-12-08 13:40:00 +0000 UTC'>December 8, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1767 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Collision resolutions" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/hash-tables/collision-resolutions/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/25/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/27/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>