<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prototype Pattern</h2></header><div class=entry-content><p>Prototype Pattern 기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴
특징 객체 생성 비용이 높거나 복잡한 경우에 유용합니다. 원본 객체의 정확한 복사본을 제공합니다. 클라이언트가 객체의 타입을 미리 알 수 없는 경우에 사용됩니다. 사용사례 데이터베이스에서 가져온 큰 객체를 여러 번 사용해야 할 때 GUI 애플리케이션에서 복사-붙여넣기 기능을 구현할 때 게임에서 비슷한 특성을 가진 캐릭터나 아이템을 생성할 때 설정이나 구성 객체를 약간씩 다르게 여러 개 만들어야 할 때 장점 복잡한 객체를 처음부터 생성하는 비용을 절약할 수 있습니다 런타임에 동적으로 객체를 추가하거나 삭제할 수 있습니다 새로운 객체를 만들 때 상속 대신 복제를 사용하여 유연성을 높일 수 있습니다 단점 순환 참조가 있는 복잡한 객체의 경우 복제가 어려울 수 있습니다 깊은 복사(Deep Copy)를 구현할 때 모든 중첩된 객체들도 복제 가능해야 합니다 주의사항 및 고려사항 깊은 복사와 얕은 복사를 구분하여 사용해야 합니다. 객체가 다른 객체를 참조하는 경우, 깊은 복사를 사용하지 않으면 예상치 못한 부작용이 발생할 수 있습니다. 복제 과정에서 생성자가 호출되지 않음을 주의해야 합니다. 필요한 경우 초기화 로직을 별도의 메서드로 분리하여 복제 후 호출해야 합니다. 프로토타입 등록과 관리를 위한 레지스트리나 팩토리 클래스를 만들어 중앙에서 관리하는 것이 좋습니다. 복제된 객체의 식별자나 유니크한 속성들은 복제 후에 새로운 값으로 설정해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from copy import deepcopy from typing import Dict, Any class Character: def __init__(self, name: str, level: int, stats: Dict[str, int]): self.name = name self.level = level self.stats = stats def clone(self) -> 'Character': """Create a deep copy of the character""" return deepcopy(self) def __str__(self) -> str: return f"Character(name={self.name}, level={self.level}, stats={self.stats})" class CharacterPrototype: """Prototype manager class that stores and creates character templates""" def __init__(self): self._characters: Dict[str, Character] = {} def register_character(self, name: str, character: Character): """Register a character template""" self._characters[name] = character def unregister_character(self, name: str): """Remove a character template""" del self._characters[name] def clone(self, name: str, **kwargs: Any) -> Character: """Clone a character and optionally modify its attributes""" prototype = self._characters.get(name) if not prototype: raise ValueError(f"Character prototype '{name}' not found") character = prototype.clone() # Update any attributes specified in kwargs for key, value in kwargs.items(): if hasattr(character, key): setattr(character, key, value) return character # Usage example if __name__ == "__main__": # Create prototype manager prototype_manager = CharacterPrototype() # Register base warrior template warrior = Character( name="Warrior", level=1, stats={"strength": 15, "agility": 10, "intelligence": 5} ) prototype_manager.register_character("warrior", warrior) # Clone warriors with different names and levels warrior1 = prototype_manager.clone("warrior", name="Bob", level=5) warrior2 = prototype_manager.clone("warrior", name="Alice", level=7) print(warrior1) # Character(name=Bob, level=5, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) print(warrior2) # Character(name=Alice, level=7, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class DocumentTemplate { constructor(type, content, metadata) { this.type = type; this.content = content; this.metadata = metadata; } clone() { // Deep clone the object const clonedMetadata = JSON.parse(JSON.stringify(this.metadata)); return new DocumentTemplate(this.type, this.content, clonedMetadata); } customize(updates) { Object.assign(this, updates); return this; } } class DocumentPrototypeRegistry { constructor() { this.prototypes = new Map(); } registerTemplate(name, template) { this.prototypes.set(name, template); } unregisterTemplate(name) { this.prototypes.delete(name); } createDocument(templateName, customization = {}) { const template = this.prototypes.get(templateName); if (!template) { throw new Error(`Template '${templateName}' not found`); } return template.clone().customize(customization); } } // Usage example const registry = new DocumentPrototypeRegistry(); // Register some document templates const letterTemplate = new DocumentTemplate( 'letter', 'Dear {recipient},\n\n{body}\n\nBest regards,\n{sender}', { created: new Date(), version: '1.0', style: 'formal' } ); registry.registerTemplate('business_letter', letterTemplate); // Create customized documents from template const myLetter1 = registry.createDocument('business_letter', { content: 'Dear John,\n\nThank you for your inquiry.\n\nBest regards,\nJane' }); const myLetter2 = registry.createDocument('business_letter', { content: 'Dear Mary,\n\nPlease find attached our proposal.\n\nBest regards,\nBob', metadata: { version: '1.1', style: 'semiformal' } }); console.log(myLetter1); console.log(myLetter2); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:09:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;699 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prototype Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/prototype-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Thread</h2></header><div class=entry-content><p>Thread Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.
하나의 프로세스는 여러 개의 Thread를 가질 수 있으며, 이들은 프로세스의 자원을 공유한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
Thread의 구성 요소 Thread는 다음과 같은 구성 요소를 가진다:
프로그램 카운터 레지스터 집합 스택 공간 Thread ID
이러한 요소들은 각 Thread의 독립적인 실행을 가능하게 한다. Thread의 특징 경량성: Thread는 프로세스에 비해 생성과 관리가 더 빠르고 효율적이다. 자원 공유: 같은 프로세스 내의 Thread들은 코드, 데이터, 파일 등의 자원을 공유한다. 병렬 실행: 멀티코어 시스템에서는 여러 Thread가 실제로 동시에 실행될 수 있다. 기능과 역할 기능 역할 장점 병렬 처리 - 동시에 여러 작업 수행
CPU 활용도 증가 - 성능 향상
- 응답성 개선 자원 공유 - 프로세스 자원 공유
- 효율적인 메모리 사용 - 메모리 절약
- 통신 비용 감소 비동기 처리 - 독립적인 작업 수행
- 이벤트 처리 - 응답성 향상
UI 처리 효율화 Thread의 종류 Thread는 크게 두 가지로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-23 23:32:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;654 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Thread" href=https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/thread/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>컴퓨터 구성 요소 (Components of Computer Architecture)</h2></header><div class=entry-content><p>컴퓨터 구성 요소 (Components of Computer Architecture) 이 구성 요소들의 상호작용을 통해 컴퓨터가 작동하게 된다.
하드웨어 CPU (중앙처리장치) CPU는 컴퓨터의 ‘두뇌’ 역할을 하는 핵심 부품.
CPU의 성능은 처리 속도(클럭 속도)와 코어의 개수로 측정되며, 이는 컴퓨터의 전반적인 성능에 직접적인 영향을 미친다.
주요 기능:
메모리에서 명령어를 읽어들이고 해석하여 실행 데이터 처리 및 연산 수행 다른 하드웨어 구성 요소 제어 구성 요소:
ALU (산술논리연산장치): 산술 연산과 논리 연산을 수행 제어장치: 명령어를 해석하고 실행을 제어 레지스터: 데이터와 명령어를 임시로 저장하는 고속 메모리 메인보드(마더보드) 모든 부품들을 연결하고 통신을 가능하게 하는 ‘중앙 통로’ 역할을 한다.
CPU, RAM, 그래픽카드 등 주요 부품들이 메인보드에 장착되며, 각 부품 간의 데이터 전송을 관리한다.
마더보드에는 다양한 확장 슬롯과 포트가 있어 추가 부품을 장착할 수 있다.
컴퓨터 시스템의 성능, 안정성, 확장성을 결정짓는 중요한 요소가 된다.
...</p></div><footer class=entry-footer><span title='2024-09-23 16:50:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;791 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 컴퓨터 구성 요소 (Components of Computer Architecture)" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/components-of-computer-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CPU</h2></header><div class=entry-content><p>CPU CPU(중앙처리장치)는 컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.
CPU의 주요 구성요소 CPU는 크게 세 가지 주요 구성요소로 이루어져 있다
제어장치 (Control Unit, CU) 산술논리장치 (Arithmetic Logic Unit, ALU) 레지스터 (Registers) 제어장치 (Control Unit) 제어장치는 CPU의 ‘교통 경찰’ 역할을 한다.
주요 기능:
명령어를 순서대로 실행할 수 있도록 제어 주기억장치로부터 프로그램 명령을 순차적으로 가져와 해독 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치 등으로 전송 산술논리장치 (ALU) ALU는 CPU 내에서 실제 연산을 수행하는 부분
...</p></div><footer class=entry-footer><span title='2024-09-23 16:44:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CPU" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/cpu/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multithreading</h2></header><div class=entry-content><p>멀티 쓰레딩 (Multithreading) Multithreading은 운영 체제에서 프로그램이 여러 작업을 동시에 수행할 수 있게 해주는 기능이다. 즉, 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 의미하며, 각 스레드는 프로세스의 자원을 공유하면서도 독립적인 실행 경로를 가진다.
이는 단일 프로세스 내에서 여러 실행 흐름(스레드)을 생성하고 관리하며, 현대 컴퓨터 시스템의 성능과 효율성을 크게 향상시킨다.
Source: https://www.geeksforgeeks.org/multithreading-in-operating-system/
각 스레드는 자신만의 프로그램 카운터, 레지스터 집합, 스택을 가지고 있다. 하지만 같은 프로세스 내의 스레드들은 코드, 데이터 섹션, 파일과 같은 자원을 공유한다. 이는 프로세스보다 스레드의 생성과 컨텍스트 스위칭이 더 가벼운 이유가 된다.
...</p></div><footer class=entry-footer><span title='2024-09-23 14:33:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;219 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multithreading" href=https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/multithreading/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Interpreter Pattern</h2></header><div class=entry-content><p>Interpreter Pattern Interpreter 패턴은 행동 디자인 패턴의 하나로, 특정 언어의 문법을 해석하고 실행하는 방법을 정의한다.
이 패턴은 주로 간단한 언어나 표현식을 해석해야 할 때 사용된다.
Interpreter 패턴은 SQL 파서, 정규 표현식 엔진, 프로그래밍 언어 인터프리터 등 다양한 분야에서 활용된다. 하지만 복잡한 문법을 다룰 때는 파서 생성기 등 다른 도구를 고려하는 것이 좋다.
Interpreter 패턴의 주요 특징 문법 표현: 언어의 문법을 클래스 구조로 표현한다. 해석 메커니즘: 각 문법 규칙에 대한 해석 방법을 제공한다. 추상 구문 트리: 표현식을 계층적 구조로 표현한다. Interpreter 패턴의 구성 요소 AbstractExpression: 모든 표현식 클래스가 구현해야 하는 인터페이스를 정의한다. TerminalExpression: 더 이상 분해할 수 없는 기본 표현식을 나타낸다. NonterminalExpression: 다른 표현식을 포함하는 복합 표현식을 나타낸다. Context: 해석기가 해석해야 할 정보를 포함한다. Client: 추상 구문 트리를 구성하고 해석을 요청한다. Interpreter 패턴의 장점 문법 확장성: 새로운 표현식을 쉽게 추가할 수 있다. 문법 구현 용이성: 각 문법 규칙을 클래스로 표현하여 구현이 간단하다. 복잡한 문제 분해: 복잡한 문제를 작은 단위로 분해하여 해결할 수 있다. Interpreter 패턴의 단점 복잡한 문법에 부적합: 문법이 복잡해질수록 클래스 계층 구조가 복잡해진다. 성능 문제: 대규모 문법 해석 시 성능이 저하될 수 있다. Interpreter 패턴 사용 예시 아래는 인터프리터 패턴을 활용하여 후위 표기법(Postfix Notation)을 해석하고 계산하는 예제이다.
...</p></div><footer class=entry-footer><span title='2024-09-23 08:27:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;632 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Interpreter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/interpreter-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Visitor Pattern</h2></header><div class=entry-content><p>Visitor Pattern Visitor Pattern은 객체 구조와 알고리즘을 분리하는 행위 디자인 패턴이다.
이 패턴의 주요 목적은 기존 객체 구조를 변경하지 않고 새로운 동작을 추가할 수 있게 하는 것이다.
Visitor Pattern의 주요 구성 요소 Visitor (방문자) 인터페이스:
객체 구조의 각 ConcreteElement에 대한 visit() 메서드를 선언한다. ConcreteVisitor (구체적인 방문자):
Visitor 인터페이스를 구현하여 각 ConcreteElement에 대한 구체적인 동작을 정의한다. Element (요소) 인터페이스:
accept(Visitor) 메서드를 선언하여 Visitor 객체를 받아들인다. ConcreteElement (구체적인 요소):
Element 인터페이스를 구현하고, accept() 메서드에서 visitor.visit(this)를 호출한다. ObjectStructure (객체 구조):
...</p></div><footer class=entry-footer><span title='2024-09-23 08:27:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;582 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Visitor Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/visitor-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Chain of Responsibility</h2></header><div class=entry-content><p>Chain of Responsibility Chain of Responsibility 패턴은 요청을 보내는 객체와 이를 처리하는 객체들 간의 결합도를 낮추기 위한 행위 디자인 패턴이다.
Chain of Responsibility 패턴은 여러 객체를 체인으로 연결하여 요청을 순차적으로 처리하는 방식이다.
각 객체는 요청을 처리할 수 있으면 처리하고, 그렇지 않으면 다음 객체로 요청을 전달한다.
주요 특징:
요청의 발신자와 수신자를 분리한다. 여러 객체가 요청을 처리할 기회를 가진다. 요청 처리 객체를 동적으로 변경할 수 있다. 구성 요소 Handler (추상 처리자):
요청을 처리하는 인터페이스를 정의한다. 다음 처리자에 대한 참조를 가진다. ConcreteHandler (구체적 처리자):
...</p></div><footer class=entry-footer><span title='2024-09-23 08:26:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;536 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Chain of Responsibility" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/chain-of-responsibility/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern</h2></header><div class=entry-content><p>Mediator Pattern 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 08:26:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/mediator-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Memento Pattern</h2></header><div class=entry-content><p>Memento Pattern Mediator 패턴은 객체 지향 소프트웨어 디자인 패턴 중 하나로, 객체들 간의 복잡한 상호작용을 캡슐화하여 객체 간 결합도를 낮추는 행위 패턴이다.
Mediator 패턴은 객체들 간의 직접적인 통신을 제한하고, 중재자 객체를 통해 간접적으로 상호작용하도록 하는 패턴이다. 주요 목적은 다음과 같다:
객체 간 결합도 감소 객체 간 상호작용의 중앙 집중화 코드의 재사용성과 유지보수성 향상 Mediator 패턴은 객체 간 상호작용이 복잡해질 때 특히 유용하다. 이 패턴을 통해 시스템의 유지보수성을 향상시키고, 객체 간 결합도를 낮출 수 있다. 하지만 Mediator 객체가 너무 복잡해지지 않도록 주의해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-23 08:26:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;426 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Memento Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/memento-pattern/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/54/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/56/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>