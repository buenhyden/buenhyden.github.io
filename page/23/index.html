<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Lifecycle Management</h2></header><div class=entry-content><p>API Lifecycle Management API 라이프사이클 관리는 API의 계획 단계부터 폐기 단계까지 전체 수명주기를 체계적으로 관리하는 프로세스이다. 이는 조직이 API를 효과적으로 설계, 개발, 배포, 유지보수하고 궁극적으로 폐기하는 방법을 정의한다.
API 라이프사이클의 주요 단계 계획 및 전략 수립 (Planning & Strategy)
API 라이프사이클은 명확한 비즈니스 목표와 전략적 계획에서 시작한다.
비즈니스 요구사항 정의: API가 해결해야 할 비즈니스 문제와 목표를 식별한다. 대상 사용자 분석: 내부 개발자, 파트너, 또는 외부 개발자 등 API의 주요 사용자를 파악한다. API 설계 방향 결정: REST, GraphQL, gRPC 등 적절한 API 아키텍처 스타일을 선택한다. 핵심 성능 지표(KPI) 설정: API 성공을 측정할 지표를 정의한다. 설계 및 개발 (Design & Development)
이 단계에서는 API의 실제 인터페이스와 기능을 설계하고 구현한다.
...</p></div><footer class=entry-footer><span title='2025-02-02 03:24:00 +0000 UTC'>February 2, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Lifecycle Management" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-fundamentals/api-lifecycle-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Short Polling</h2></header><div class=entry-content><p>Short Polling Short polling은 클라이언트와 서버 간의 실시간에 가까운 통신을 구현하기 위한 기본적인 기술이다.
Short polling은 실시간 업데이트가 필요하지만 진정한 실시간성이 중요하지 않은 애플리케이션에서 구현이 간단하고 호환성이 좋은 솔루션이다. 그러나 사용자가 많아지거나 지연 시간이 중요한 애플리케이션에서는 Long Polling, SSE, WebSockets 같은 더 효율적인 기술의 사용을 고려해야 한다.
Short Polling의 개념 Short polling은 클라이언트가 주기적으로 서버에 HTTP 요청을 보내 새로운 데이터가 있는지 확인하는 방식이다. 클라이언트는 정해진 시간 간격으로 서버에 요청을 보내고, 서버는 그 순간 가지고 있는, 클라이언트가 아직 받지 않은 데이터를 응답한다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:45:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Short Polling" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/short-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Long Polling</h2></header><div class=entry-content><p>Long Polling Long polling은 전통적인 short polling의 한계를 극복하기 위해 발전된 웹 통신 기법으로, 실시간에 가까운 데이터 전송을 가능하게 한다. 이 기술은 특히 웹소켓(WebSocket)이 등장하기 전에 실시간 웹 애플리케이션 구현에 널리 사용되었다.
Long polling은 WebSockets의 대중화 이전에 실시간 웹 애플리케이션의 핵심 기술이었으며, 오늘날에도 특정 상황에서 유용한 접근 방식이다. 특히 WebSockets 지원이 제한된 환경이나, 단순한 실시간 요구사항을 가진 애플리케이션에서 여전히 가치 있는 솔루션이다.
최신 웹 애플리케이션에서는 WebSockets가 선호되는 경향이 있지만, Long polling은 폴백(fallback) 메커니즘으로 구현되어 WebSockets를 지원하지 않는 환경에서도 실시간에 가까운 경험을 제공할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:44:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Long Polling" href=https://buenhyden.github.io/posts/software-engineering/application-development/api-design-and-implementation/api-integration-patterns/webhooks-vs-polling/polling/types/long-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AI Engineering</h2></header><div class=entry-content><p>AI Engineering AI 엔지니어링(Artificial Intelligence Engineering)은 인공지능 시스템을 설계, 개발, 배포 및 유지보수하는 체계적인 접근 방식이다. 이는 단순히 AI 모델을 훈련하는 것을 넘어서, 실제 비즈니스 환경에서 안정적으로 작동하는 AI 솔루션을 구축하는 전체 과정을 포함한다.
기존의 소프트웨어 엔지니어링이 소프트웨어 시스템을 개발하는 원칙과 방법론을 다룬다면, AI 엔지니어링은 여기에 데이터 관리, 모델 훈련, 불확실성 처리, 지속적인 학습 등 AI 시스템 특유의 측면을 추가한다.
AI 엔지니어링은 실험실에서 개발된 모델이 실제 환경에서 가치를 창출할 수 있도록 다리를 놓는 역할을 한다.
...</p></div><footer class=entry-footer><span title='2025-01-31 12:08:00 +0000 UTC'>January 31, 2025</span>&nbsp;·&nbsp;34 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AI Engineering" href=https://buenhyden.github.io/posts/ai-and-machine-learning/ai-engineering/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Brute Force</h2></header><div class=entry-content><p>Divide and Conquer vs. Brute Force 알고리즘은 프로그래밍의 핵심이며, 문제 해결 방식에 따라 효율성과 성능이 크게 달라진다.
두 알고리즘 모두 장단점이 있으며, 상황에 따라 적절한 선택이 필요하다.
먼저 브루트 포스로 문제를 해결한 다음, 필요에 따라 분할 정복과 같은 더 효율적인 알고리즘으로 발전시키는 것이 좋다. 알고리즘의 선택은 문제의 성격, 데이터의 크기, 요구되는 효율성, 그리고 개발자의 친숙도에 따라 달라질 수 있다.
Divide and Conquer(분할 정복) 알고리즘 기본 개념 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.
이 알고리즘은 세 가지 주요 단계로 구성된다:
...</p></div><footer class=entry-footer><span title='2025-01-24 07:17:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Brute Force" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-brute-force/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Branch and Bound</h2></header><div class=entry-content><p>Divide and Conquer vs. Branch and Bound “Divide and Conquer(분할 정복)“과 “Branch and Bound(분기 한정)“은 복잡한 문제를 해결하는 다른 접근법을 제공하며, 각각의 장단점과 적합한 활용 사례가 있다.
“Divide and Conquer"와 “Branch and Bound"는 복잡한 문제를 해결하기 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.
분할 정복은 정렬, 검색 등의 기본 알고리즘에 널리 사용되며, 분기 한정은 TSP, 배낭 문제 등의 복잡한 최적화 문제에 효과적이다.
두 알고리즘 모두 컴퓨터 과학에서 중요한 도구이므로, 문제의 특성에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-24 02:16:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Branch and Bound" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>최적 부분 구조(Optimal Substructure)</h2></header><div class=entry-content><p>최적 부분 구조(Optimal Substructure) 동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.
동적 계획법이 적용되기 위해서는 두 가지 핵심 특성이 필요하다:
중복되는 하위 문제(Overlapping Subproblems) 최적 부분 구조(Optimal Substructure)
이다. 최적 부분 구조는 효율적인 알고리즘 설계의 핵심 개념이다.
문제의 특성을 이해하고 최적 부분 구조를 식별할 수 있다면, 복잡한 문제도 동적 계획법이나 그리디 알고리즘을 통해 효율적으로 해결할 수 있다.
최적 부분 구조가 없는 문제는 다른 접근 방식(예: 분할 정복, 백트래킹)을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2025-01-22 14:02:00 +0000 UTC'>January 22, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 최적 부분 구조(Optimal Substructure)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/optimal-substructure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>중복되는 하위 문제(Overlapping Subproblems)</h2></header><div class=entry-content><p>중복되는 하위 문제(Overlapping Subproblems) 동적 계획법(Dynamic Programming)은 복잡한 문제를 더 작고 간단한 하위 문제로 나누어 해결하는 알고리즘 패러다임이다.
동적 계획법이 효과적으로 적용되기 위해서는 두 가지 핵심 특성이 필요하다:
최적 부분 구조(Optimal Substructure) 중복되는 하위 문제(Overlapping Subproblems)
이다. 중복되는 하위 문제(Overlapping Subproblems)의 기본 개념 중복되는 하위 문제는 동일한 하위 문제가 알고리즘 실행 과정에서 여러 번 반복해서 나타나는 특성을 말한다.
즉, 문제를 해결하는 과정에서 같은 계산이 여러 번 수행되는 경우이다.
중복되는 하위 문제가 있을 때 동적 계획법은 각 하위 문제의 결과를 저장(메모이제이션)하여 중복 계산을 피함으로써 효율성을 크게 향상시킨다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:02:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 중복되는 하위 문제(Overlapping Subproblems)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/dynamic-programming/principles/overlapping-subproblems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>asyncio</h2></header><div class=entry-content><p>Asyncio Python의 asyncio는 비동기 I/O 프로그래밍을 지원하는 표준 라이브러리로, async/await 구문을 활용해 동시성 코드를 작성할 수 있게 해 준다. 특히 I/O 바운드 작업(네트워크 통신, 파일 입출력 등)에서 성능을 극대화할 수 있으며, Python의 GIL(Global Interpreter Lock) 제약을 우회하는 싱글 스레드 기반 동시성 구현이 가능하다.
Python 3.4부터 도입된 asyncio는 웹 서버, 데이터 수집기, 실시간 애플리케이션 등 I/O 집약적인 작업에서 혁신적인 성능 향상을 제공한다. 그러나 동기식 코드 베이스와의 통합 시 주의가 필요하며, 비동기 지원 라이브러리(aiohttp, asyncpg 등)와의 조합이 효과적이다.
...</p></div><footer class=entry-footer><span title='2025-01-19 06:25:00 +0000 UTC'>January 19, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to asyncio" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/concurrency/asynchrony/asyncio/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Greenlet and Gevent</h2></header><div class=entry-content><p>Greenlet and Gevent Greenlet과 Gevent는 Python에서 동시성 프로그래밍을 위한 라이브러리이다.
Greenlet Greenlet은 Python에서 경량 코루틴을 구현한 라이브러리이다.
추가적으로 이야기 하면, Greenlet은 Python의 경량 협력적 멀티태스킹(cooperative multitasking)을 위한 기본 단위이다. 이는 마치 매우 가벼운 스레드처럼 작동하지만, 운영체제 수준의 스레드가 아닌 사용자 공간에서 실행되는 마이크로스레드이다.
주요 특징:
경량성: 일반 스레드보다 생성 비용이 매우 적다. 협력적 멀티태스킹: 명시적으로 제어권을 양보할 때만 컨텍스트 스위칭이 일어난다. 단일 OS 스레드 내 실행: 모든 greenlet은 동일한 물리적 스레드에서 실행된다. 사용 예:
...</p></div><footer class=entry-footer><span title='2025-01-19 05:33:00 +0000 UTC'>January 19, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Greenlet and Gevent" href=https://buenhyden.github.io/posts/programming-languages/python/library/concurrency-and-parallel-processing/greenlet-and-gevent/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/22/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/24/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>