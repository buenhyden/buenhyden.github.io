<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.141.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>순차 검색 (Sequential Search)</h2></header><div class=entry-content><p>순차 검색(Sequential Search / Linear Search) 순차 검색은 데이터 집합을 처음부터 끝까지 차례대로 하나씩 검색하는 방법.
이는 선형 검색(Linear Search)으로도 불리며, 리스트에서 순차적으로 탐색하면서 원하는 값을 찾아내는 알고리즘.
Source: https://www.tutorialspoint.com/data_structures_algorithms/linear_search_algorithm.htm
장점 구현이 매우 간단하고 직관적입니다. 데이터의 정렬 여부와 상관없이 사용할 수 있습니다. 단점 데이터의 양이 많아질수록 검색 시간이 선형적으로 증가합니다. 대규모 데이터셋에서는 비효율적입니다. 주의해야 할 점 데이터의 양이 많을 경우 검색 시간이 매우 길어질 수 있으므로 주의해야 합니다. 검색 종료 조건을 명확히 설정해야 합니다.
일반적으로 두 가지 조건이 있습니다: 검색 실패: 검색할 값을 발견하지 못하고 리스트의 끝을 지나간 경우 검색 성공: 리스트에서 검색할 값과 같은 요소를 발견한 경우 주로 사용하는 데이터 구조 순차 검색은 주로 배열이나 연결 리스트와 같은 선형 자료구조에서 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-30 05:31:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;774 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 순차 검색 (Sequential Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/sequential-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>검색 알고리즘 (Searching Algorithms)</h2></header><div class=entry-content><p>검색 알고리즘 (Searching Algorithms) 데이터 집합에서 특정 값이나 조건을 만족하는 항목을 찾는 방법을 정의하는 알고리즘.
데이터의 정렬 상태, 크기, 구조 등에 따라 적합한 알고리즘이 달라진다.
장점:
데이터 검색 속도 향상 대규모 데이터셋 처리 가능 단점:
일부 알고리즘은 정렬된 데이터 필요 구현 복잡도 증가 가능 일반적인 특징 효율성: 대부분의 검색 알고리즘은 효율적인 데이터 검색을 목표로 합니다. 정확성: 검색 결과는 항상 정확해야 합니다. 적응성: 다양한 데이터 구조와 크기에 적용할 수 있어야 합니다. 확장성: 데이터셋의 크기가 증가해도 성능이 크게 저하되지 않아야 합니다. 주요 종류 기본 검색 알고리즘 알고리즘 이름 시간 복잡도 공간 복잡도 정렬 필요 여부 특징 적합한 사용 케이스 순차 검색 (Sequential Search) O(n) O(1) 불필요 • 가장 단순한 검색 방법
• 처음부터 끝까지 순차적으로 검색
• 구현이 매우 간단 • 소규모 데이터셋
• 정렬되지 않은 데이터
• 일회성 검색 이진 검색 (Binary Search) O(log n) O(1) 필수 • 정렬된 데이터에서만 사용 가능
• 중간값을 기준으로 범위를 좁혀가며 검색
• 분할 정복 방식 • 대규모 정렬된 데이터
• 반복적인 검색 작업
• 정적인 데이터셋 해시 검색 (Hash Search) O(1) 평균
O(n) 최악 O(n) 불필요 • 해시 함수를 사용하여 직접 접근
• 충돌 해결 방법 필요
• 키-값 쌍으로 데이터 저장 • 빈번한 검색 작업
• 키-값 데이터
• 캐싱 시스템 보간 검색 (Interpolation Search) O(log log n) 평균
O(n) 최악 O(1) 필수 • 이진 검색의 개선 버전
• 데이터 분포를 고려한 검색
• 균등 분포에서 효율적 • 균등 분포된 데이터
• 정렬된 숫자 데이터
• 큰 데이터셋 그래프 검색 알고리즘 알고리즘 이름 시간 복잡도 공간 복잡도 특징 적합한 사용 케이스 깊이 우선 검색 (DFS) O(V + E) O(V) • 한 경로를 끝까지 탐색
• 스택/재귀 사용
• 메모리 효율적 • 경로 존재 확인
• 위상 정렬
• 연결 요소 찾기 너비 우선 검색 (BFS) O(V + E) O(V) • 레벨 단위 탐색
• 큐 사용
• 최단 경로 보장 • 최단 경로
• 네트워크 분석
• 레벨 단위 처리 [V: 정점 수, E: 간선 수]
...</p></div><footer class=entry-footer><span title='2024-10-30 01:27:00 +0000 UTC'>October 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;372 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 검색 알고리즘 (Searching Algorithms)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/searching-algorithms/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>The Open Web Application Security Project</h2></header><div class=entry-content><p>The Open Web Application Security Project Top 10 (OWASP Top 10) 웹 애플리케이션의 가장 심각한 보안 위험 10가지를 정리한 보고서.
이 프로젝트는 전 세계 보안 전문가들의 연구와 실제 데이터를 기반으로 주기적으로 업데이트된다.
주요 특징:
정기적인 업데이트: OWASP Top 10은 3~4년 주기로 업데이트되며, 가장 최근 버전은 2021년에 발표되었다. 데이터 기반 선정: 취약점 순위는 공격 가능성과 기술적 영향을 기준으로 매겨진다 커뮤니티 참여: 업계 전문가들의 설문조사와 사용자 제공 데이터 분석을 통해 선정된다. 목적:
...</p></div><footer class=entry-footer><span title='2024-10-29 11:54:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1082 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to The Open Web Application Security Project" href=https://buenhyden.github.io/posts/security/the-open-web-application-security-project/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Transmission</h2></header><div class=entry-content><p>Data Transmission 데이터 전송 및 처리 방식은 다양한 기준에 따라 분류되며, 각 방식은 특정한 통신 환경과 요구 사항에 맞게 선택된다.
전송 방향에 따른 분류 단방향 전송 (Simplex)
데이터가 한 방향으로만 전송된다. 예: 라디오 방송, TV 방송 장점: 단순하고 효율적인 채널 사용 단점: 상호작용이 불가능 반이중 전송 (Half-Duplex)
양방향으로 데이터 전송이 가능하지만, 동시에는 불가능하다. 예: 무전기 장점: 양방향 통신 가능, 에러 감지에 유용 단점: 동시 통신 불가 전이중 전송 (Full-Duplex)
양방향으로 동시에 데이터 전송이 가능하다. 예: 전화 통화, 현대적인 컴퓨터 네트워크 장점: 실시간 양방향 통신 가능, 높은 효율성 단점: 복잡한 하드웨어 필요 비트 전송 방식에 따른 분류 직렬 전송 (Serial Transmission)
...</p></div><footer class=entry-footer><span title='2024-10-29 09:32:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;271 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Transmission" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/data-transmission/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CSR</h2></header><div class=entry-content><p>CSR (Client-side Rendering) 웹 애플리케이션에서 클라이언트 측, 즉 사용자의 웹 브라우저에서 JavaScript를 사용하여 웹 페이지를 렌더링하는 방식.
이 방식은 최근 JavaScript 라이브러리와 프레임워크의 발전으로 인해 널리 사용되고 있다.
작동 방식 사용자가 웹사이트에 접속하면 브라우저가 서버에 콘텐츠를 요청한다. 서버는 최소한의 HTML 구조와 JavaScript 파일 링크만 포함된 기본적인 HTML 문서를 응답으로 전송한다. 브라우저는 이 HTML을 받아 빈 페이지를 먼저 표시한다. 브라우저가 연결된 JavaScript 파일을 다운로드하고 실행한다. JavaScript 코드가 실행되면서 동적으로 페이지 콘텐츠를 생성하고 DOM을 조작하여 사용자에게 최종 화면을 보여준다. 장점 부드러운 사용자 경험: 페이지 전환 시 전체 페이지를 새로 로드하지 않고 필요한 부분만 업데이트하므로 화면 깜빡임이 없고 더 부드러운 사용자 경험을 제공한다. 서버 부하 감소: 초기 로딩 이후에는 필요한 데이터만 요청하므로 서버의 부하가 줄어든다. 빠른 인터랙션: 클라이언트 측에서 대부분의 로직을 처리하므로 사용자 입력에 대한 반응이 빠르다. 프론트엔드와 백엔드의 분리: 개발 과정에서 프론트엔드와 백엔드를 완전히 분리할 수 있어 개발 효율성이 높아진다. 단점 초기 로딩 속도: JavaScript 파일을 다운로드하고 실행하는 데 시간이 걸리므로 초기 페이지 로딩 속도가 느릴 수 있다. SEO 문제: 검색 엔진 크롤러가 JavaScript로 생성된 콘텐츠를 제대로 인식하지 못할 수 있어 검색 엔진 최적화(SEO)에 불리할 수 있다. 브라우저 호환성: 오래된 브라우저나 JavaScript가 비활성화된 환경에서는 제대로 작동하지 않을 수 있다. 적용 사례 CSR은 주로 단일 페이지 애플리케이션(SPA)에서 사용된다.
React, Vue.js, Angular 등의 프레임워크를 사용하여 구현되며, 동적이고 인터랙티브한 웹 애플리케이션에 적합하다.
예를 들어, 소셜 미디어 플랫폼, 온라인 메신저, 대시보드 등 사용자와의 상호작용이 많고 실시간 업데이트가 필요한 애플리케이션에서 CSR이 효과적으로 사용된다.
CSR은 현대적인 웹 개발에서 중요한 렌더링 방식 중 하나로, 프로젝트의 요구사항과 특성에 따라 서버 사이드 렌더링(SSR)과 적절히 선택하여 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-29 03:44:00 +0000 UTC'>October 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;342 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CSR" href=https://buenhyden.github.io/posts/frontend/csr/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/100/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/102/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>