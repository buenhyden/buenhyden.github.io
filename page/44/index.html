<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Anti-Corruption Layer</h2></header><div class=entry-content><p>Anti-Corruption Layer Anti-Corruption Layer (ACL) 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.
ACL은 서로 다른 시스템 간의 통신을 위한 번역 계층 역할을 한다.
주요 목적은 다음과 같다:
시스템 격리: 외부 시스템의 복잡성으로부터 내부 시스템을 보호한다. 도메인 모델 보존: 각 시스템의 고유한 도메인 모델을 유지한다. 데이터 변환: 서로 다른 데이터 모델 간의 변환을 담당한다. ACL 패턴을 효과적으로 사용하려면 시스템 간의 경계를 명확히 정의하고, 변환 로직을 신중하게 설계해야 한다.
또한, 시스템 변경에 따른 ACL의 업데이트와 유지보수 계획을 수립하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-10-04 10:07:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Anti-Corruption Layer" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/anti-corruption-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circuit Breaker</h2></header><div class=entry-content><p>Circuit Breaker 서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.
이 패턴의 주요 목적은 서비스 간 장애 전파를 방지하고, 시스템의 전반적인 안정성을 유지하는 것이다.
서킷 브레이커 패턴은 전기 회로의 차단기에서 착안한 개념이다.
전기 회로에서 과부하가 발생하면 차단기가 작동하여 전류를 차단하듯이, 소프트웨어 시스템에서도 특정 서비스에 문제가 발생했을 때 해당 서비스로의 호출을 차단한다.
서킷 브레이커 패턴을 효과적으로 사용하면 마이크로서비스 아키텍처에서 장애의 전파를 방지하고, 시스템의 전반적인 안정성과 복원력을 크게 향상시킬 수 있다. 이 패턴은 특히 외부 서비스에 의존성이 높은 시스템에서 매우 유용하며, 적절히 구현하면 사용자 경험을 크게 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-04 10:05:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;618 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circuit Breaker" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/circuit-breaker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Timeout Pattern</h2></header><div class=entry-content><p>Timeout Pattern Timeout Pattern은 마이크로서비스 간 통신에서 응답 지연이나 실패를 관리하기 위한 전략이다.
이 패턴은 서비스가 다른 서비스로부터의 응답을 무한정 기다리지 않도록 하여 시스템의 안정성과 응답성을 향상시킨다.
Timeout Pattern은 MSA 환경에서 서비스 간 통신의 신뢰성을 높이고 시스템의 전반적인 안정성을 향상시키는 중요한 전략이다. 적절히 구현된 Timeout Pattern은 마이크로서비스 아키텍처의 장점을 극대화하고 잠재적인 문제를 최소화하는 데 큰 도움이 된다.
타임아웃 패턴의 필요성 MSA 환경에서는 여러 서비스가 네트워크를 통해 상호 작용하므로, 다음과 같은 이유로 타임아웃 패턴이 필요하다:
...</p></div><footer class=entry-footer><span title='2024-10-04 02:21:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1173 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Timeout Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/timeout/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Retry Pattern</h2></header><div class=entry-content><p>Retry Pattern Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.
Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.
Retry Pattern의 주요 특징 재시도 횟수: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다. 재시도 간격: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다. 백오프 전략: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다. 조건부 재시도: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다. Retry Pattern 구현 방법 Spring Retry 사용: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다. Resilience4j 사용: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다. 커스텀 구현: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다. 재시도 패턴 구현 시 고려사항 재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:
...</p></div><footer class=entry-footer><span title='2024-10-04 02:18:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;610 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Retry Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/reliability/retry/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Strangler Application</h2></header><div class=entry-content><p>Strangler Application Strangler Application 패턴은 마이크로서비스 아키텍처로의 전환을 위한 중요한 리팩토링 전략이다.
Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.
이 패턴의 이름은 호주의 열대우림에서 볼 수 있는 스트랭글러 무화과나무에서 유래했다. 이 나무는 숙주 나무를 감싸고 자라다가 결국 숙주를 대체하는데, 이와 유사하게 새로운 서비스가 기존 시스템을 점진적으로 대체한다.
Strangler Application 패턴은 레거시 시스템을 현대화하는 효과적인 방법으로, 리스크를 관리하면서 점진적으로 마이크로서비스 아키텍처로 전환할 수 있게 해준다. 이 패턴을 통해 기업은 기존 시스템의 가치를 유지하면서 새로운 기술과 아키텍처의 이점을 활용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-04 01:20:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;313 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Strangler Application" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/refactoring-to-services/strangler-application/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Application metrics</h2></header><div class=entry-content><p>Application Metrics 마이크로서비스 아키텍처(MSA) 패턴에서 Observability는 매우 중요한 개념이며, 그 중 Application Metrics는 핵심적인 요소이다.
Application Metrics는 애플리케이션의 성능과 동작을 이해하고 문제를 해결하는 데 필수적인 도구이다.
Application Metrics는 애플리케이션의 성능, 동작, 그리고 건강 상태를 나타내는 수치화된 데이터이다.
이는 개별 작업에 대한 통계를 수집하고, 이를 중앙 집중식 메트릭 서비스에 집계하여 보고 및 경고를 제공하는 패턴을 말한다.
Application Metrics는 MSA 환경에서 Observability를 달성하는 데 핵심적인 역할을 한다.
이를 통해 개발자와 운영팀은 복잡한 시스템을 더 잘 이해하고, 문제를 신속하게 해결하며, 시스템의 성능을 지속적으로 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-03 11:23:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;359 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Application metrics" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/application-metrics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Log deployments and changes</h2></header><div class=entry-content><p>Log Deployments and Changes “Log deployments and changes” 패턴은 마이크로서비스 아키텍처(MSA)의 Observability를 향상시키기 위한 전략으로 이 패턴은 시스템의 변경사항을 추적하고 문제 해결을 용이하게 하는 데 중점을 둔다.
패턴의 정의와 목적 “Log deployments and changes” 패턴은 프로덕션 환경에서 발생하는 모든 배포와 변경사항을 로깅하는 것을 의미한다.
이 패턴의 주요 목적은 다음과 같다:
시스템 변경사항과 문제 발생 간의 상관관계 파악 문제 해결 시간 단축 시스템 동작에 대한 이해도 향상 “Log deployments and changes” 패턴을 효과적으로 구현함으로써, 개발팀과 운영팀은 시스템의 변화를 더 잘 이해하고, 문제를 신속하게 해결할 수 있으며, 전반적인 시스템 안정성을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-03 11:23:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;331 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log deployments and changes" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/observability/log-deployments-and-changes/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Consumer-side contract test</h2></header><div class=entry-content><p>Consumer-side Contract Test Consumer-side contract test는 마이크로서비스 아키텍처(MSA)의 테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.
Consumer-side contract test는 서비스 소비자(consumer)가 제공자(provider)와의 상호작용에 대한 기대치를 정의하고 검증하는 테스트이다. 이 테스트는 실제 제공자 서비스 대신 모의(mock) 제공자를 사용하여 수행된다.
Consumer-side contract test는 MSA 환경에서 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진한다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.
주요 특징 소비자 중심: 소비자의 요구사항과 기대치에 초점을 맞춘다. 격리된 테스트: 실제 제공자 없이 테스트를 수행할 수 있다. 빠른 피드백: 통합 문제를 조기에 발견할 수 있다. 계약 생성: 테스트 결과로 소비자와 제공자 간의 계약(contract)이 생성된다. 구현 단계 모의 제공자 설정: 소비자는 예상되는 요청과 응답을 정의한 모의 제공자를 생성한다. 테스트 작성: 소비자는 모의 제공자와의 상호작용을 테스트하는 코드를 작성한다. 테스트 실행: 작성된 테스트를 실행하여 소비자 코드가 예상대로 동작하는지 확인한다. 계약 생성: 테스트 실행 결과를 바탕으로 계약 파일(예: Pact 파일)이 생성된다. 계약 공유: 생성된 계약을 제공자와 공유한다(예: Pact Broker를 통해). 장점 빠른 개발 주기: 실제 제공자 없이 테스트할 수 있어 개발 속도가 향상된다. 명확한 기대치 설정: 소비자의 요구사항이 명확히 문서화된다. 독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다. 조기 오류 감지: 통합 문제를 초기 단계에서 발견할 수 있다. 주의사항 과도한 모의: 실제 제공자의 동작과 차이가 있을 수 있으므로 주의가 필요하다. 유지보수: 계약이 변경될 때마다 테스트를 업데이트해야 한다. 완전성 부족: 전체 시스템 동작을 검증하지는 않으므로 다른 테스트 방법과 병행해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-03 10:59:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;226 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Consumer-side contract test" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/testing/consumer-side-contract-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Composition</h2></header><div class=entry-content><p>API Composition API Composition 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.
API Composition은 여러 마이크로서비스의 API 응답을 집계하여 단일 API 엔드포인트로 제공하는 패턴이다.
이를 통해 클라이언트는 복잡한 데이터 요구사항을 단일 요청으로 처리할 수 있다.
API Composition 패턴은 마이크로서비스 아키텍처에서 데이터 접근을 간소화하고 클라이언트 경험을 개선하는 강력한 도구이나 구현 시 성능과 복잡성을 고려해야 하며, 시스템의 요구사항에 따라 적절히 적용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:52:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;411 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Composition" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/api-composition/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CQRS</h2></header><div class=entry-content><p>CQRS CQRS(Command Query Responsibility Segregation)는 마이크로서비스 아키텍처(MSA)에서 중요한 패턴 중 하나이다.
CQRS는 시스템의 명령(Command)과 조회(Query) 작업을 분리하여 각각의 책임을 명확히 하는 패턴이다.
CQRS는 다음과 같은 핵심 개념을 가지고 있다:
명령(Command): 시스템의 상태를 변경하는 작업 (예: 주문하기, 회원가입) 조회(Query): 시스템의 상태를 조회하는 작업 (예: 주문 목록 조회, 회원 정보 조회) 책임 분리(Responsibility Segregation): 명령과 조회 작업을 별도의 모델로 분리 CQRS 패턴은 시스템의 성능, 확장성, 유지보수성을 향상시킬 수 있는 강력한 도구이다. 하지만 모든 시스템에 적합한 것은 아니므로, 프로젝트의 요구사항과 특성을 고려하여 적용 여부를 신중히 결정해야 한다.
CQRS를 효과적으로 구현하기 위해서는 명령과 조회 모델의 분리, 데이터 동기화 전략, 그리고 전체 시스템 아키텍처에 대한 깊은 이해가 필요하다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:06:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;917 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CQRS" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/querying/cqrs/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/43/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/45/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>