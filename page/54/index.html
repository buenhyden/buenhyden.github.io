<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)</h2></header><div class=entry-content><p>램포트의 빵집 알고리즘 (Lamport’s Bakery Algorithm) 램포트의 빵집 알고리즘(Lamport’s Bakery Algorithm)은 N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.
램포트의 빵집 알고리즘은 병행 프로그래밍의 이론적 토대를 제공했지만, 현대 시스템에서는 주로 하드웨어 지원 동기화 기법이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.
핵심 원리 번호표 시스템 각 프로세스는 임계 영역 진입 전 고유한 번호표를 받는다. 번호표는 단조 증가(monotonically increasing) 방식으로 발급되며, 동시 접근 시 프로세스 ID로 우선순위 결정한다. 단조 증가(monotonically increasing)란 함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질을 의미한다. 즉, 감소하는 구간 없이 유지되거나 증가하는 경우를 말한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>피터슨 알고리즘 (Peterson's Algorithm)</h2></header><div class=entry-content><p>피터슨 알고리즘 (Peterson’s Algorithm) 피터슨 알고리즘(Peterson’s Algorithm)은 두 프로세스의 **상호 배제(Mutual Exclusion)**를 보장하기 위한 소프트웨어 기반 동기화 알고리즘이다.
1981년 개리 피터슨(Gary L. Peterson)이 제안한 이 알고리즘은 간결성과 이론적 엄밀성으로 운영체제 및 병행 프로그래밍 분야에서 널리 연구된다.
피터슨 알고리즘은 이론적 완결성을 인정받지만, 현대 시스템에서는 주로 하드웨어 기반 동기화 기법(예: TAS, CAS)이 사용됩니다. 그러나 병행 프로그래밍의 근본 원리를 이해하는 데 여전히 핵심적인 역할을 한다.
핵심 구성 요소 플래그 배열(flag) 각 프로세스의 임계 영역 진입 의사 표시 (flag, flag 초기값 False) 턴 변수(turn) 임계 영역 진입 순서 결정 (0 또는 1 값을 가짐) 동작 원리 진입 의사 표시:
프로세스 i가 임계 영역 진입 전 flag[i] = True 설정.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 피터슨 알고리즘 (Peterson's Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/petersons-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process Synchronization</h2></header><div class=entry-content><p>프로세스 동기화 (Process Synchronization) 여러 프로세스가 공유하는 자원의 일관성을 유지하기 위한 메커니즘.
컴퓨터 시스템에서 여러 프로세스가 공유 자원에 접근할 때 충돌을 방지하고 데이터의 일관성을 유지하기 위해 동기화가 필요하다.
다음 두 가지 목적을 가진다:
실행 순서 제어: 프로세스를 올바른 순서대로 실행하기 상호 배제: 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기 필요성 데이터 일관성 유지: 여러 프로세스가 공유 데이터에 동시 접근할 때 발생할 수 있는 예상치 못한 결과를 방지한다. 실행 순서 보장: 특정 프로세스의 실행이 다른 프로세스의 결과에 의존하는 경우, 올바른 순서로 실행되도록 한다. 임계 영역 문제 임계 영역(Critical Section)은 여러 프로세스가 공유하는 데이터를 접근하는 코드 영역을 말한다.
예를 들어, 은행 계좌의 잔액을 수정하는 코드가 임계 영역이 될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-03 06:22:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process Synchronization" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/process-synchronization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>소켓(Socket)</h2></header><div class=entry-content><p>소켓(Socket) 소켓은 네트워크 상에서 수행되는 두 프로그램 간의 양방향 통신 링크의 한쪽 끝 단을 의미한다.
소켓은 프로세스가 네트워크를 통해 데이터를 송수신하기 위한 실제적인 창구 역할을 한다.
운영체제는 소켓을 통해 네트워크 통신을 위한 인터페이스를 제공한다.
소켓의 구성 요소 소켓은 다음 세 가지 요소로 구성된다:
프로토콜: 데이터 전송을 위한 표준 집합 규칙 (예: TCP/IP, UDP/IP) IP 주소: 서버 또는 클라이언트의 주소 포트 번호: 통신을 사용하는 애플리케이션을 식별하는 번호 소켓의 특징 프로토콜, IP 주소, 포트 번호로 정의된다. 서버 소켓과 클라이언트 소켓으로 구분된다. 실시간 데이터 전송에 적합하다. 소켓 통신의 장점 실시간 양방향 통신이 가능하다. 서버와 클라이언트 간 지속적인 연결을 유지할 수 있다. 소켓 통신의 단점 HTTP 통신에 비해 구현이 복잡할 수 있다. 지속적인 연결 유지로 인한 리소스 소비가 있을 수 있다. 소켓의 종류 소켓은 크게 두 가지 유형으로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-02 16:30:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소켓(Socket)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_socket/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queue</h2></header><div class=entry-content><p>메시지 큐(Message Queue) 프로세스 간 통신(IPC)의 메시지 큐(Message Queue)는 프로세스 간에 데이터를 교환하는 메커니즘이다.
메시지 큐는 커널 내에 저장된 메시지의 연결 리스트로, 고유한 식별자로 구분된다.
이는 프로세스들이 비동기적으로 통신할 수 있게 해주는 IPC 메커니즘이다.
메시지 크기 제한과 시스템 리소스 사용 등의 단점도 고려해야 한다.
적절한 사용 시나리오를 파악하고 효과적으로 활용하는 것이 중요하다.
Source: https://www.javatpoint.com/ipc-using-message-queues
메시지 큐의 특징 커널 관리: 메시지 큐는 커널에 의해 관리되어 안정성이 높고 동기화가 용이하다. FIFO 순서: 메시지는 일반적으로 선입선출(FIFO) 순서로 처리된다. 비동기 통신: 송신 프로세스와 수신 프로세스가 동시에 활성화될 필요가 없다. 메시지 구조: 각 메시지는 타입 필드, 길이, 실제 데이터로 구성된다. 프로세스 분리: 메시지 큐를 사용하면 프로세스들이 서로 직접 연결되지 않아도 된다. 메시지 큐의 주요 시스템 호출 ftok(): 고유한 키를 생성한다. msgget(): 메시지 큐를 생성하거나 기존 큐의 식별자를 반환한다. msgsnd(): 메시지를 큐에 추가한다. msgrcv(): 큐에서 메시지를 검색한다. msgctl(): 큐에 대한 다양한 작업을 수행한다. 메시지 큐 사용 방법 메시지 큐 생성:
...</p></div><footer class=entry-footer><span title='2024-10-02 12:03:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_message-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shared Memory</h2></header><div class=entry-content><p>공유 메모리(Shared Memory) 공유 메모리(Shared Memory)는 운영체제의 프로세스 간 통신(IPC) 기법 중 하나로, 여러 프로세스가 동시에 접근할 수 있는 메모리 영역이며, 커널에 의해 생성되고 관리되는 공통 메모리 공간이다.
이는 여러 프로세스가 동일한 물리적 메모리 영역에 접근할 수 있게 해주며, IPC 메커니즘 중에서 가장 빠른 통신 방법을 제공한다.
Source: https://www.geeksforgeeks.org/ipc-shared-memory/
작동 원리 프로세스가 커널에 공유 메모리 할당을 요청 커널이 해당 프로세스에 메모리 공간을 할당 이후 다른 프로세스들도 해당 메모리 영역에 접근 가능 공유 메모리의 생성과 관리 공유 메모리를 사용하는 일반적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-02 12:03:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Memory" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_shared-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pipe</h2></header><div class=entry-content><p>파이프(Pipe) 파이프(Pipe)는 프로세스 간 통신(IPC)의 한 방법으로, 단방향 데이터 흐름을 제공하는 가장 오래된 IPC(프로세스 간 통신) 메커니즘 중 하나이다. 파이프는 한쪽 끝에서 데이터를 쓰고 다른 쪽 끝에서 데이터를 읽을 수 있게 해준다.
종류 익명 파이프 (Anonymous Pipe): 부모-자식 프로세스 간 통신에 사용
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os def create_anonymous_pipe(): """익명 파이프 생성 예제""" read_fd, write_fd = os.pipe() pid = os.fork() # 프로세스 생성 if pid > 0: # 부모 프로세스 os.close(read_fd) # 읽기 끝 닫기 os.write(write_fd, "Hello from parent".encode()) os.close(write_fd) else: # 자식 프로세스 os.close(write_fd) # 쓰기 끝 닫기 message = os.read(read_fd, 1024).decode() print(f"Child received: {message}") os.close(read_fd) 이름 있는 파이프 (Named Pipe 또는 FIFO): 관련 없는 프로세스 간 통신에 사용
...</p></div><footer class=entry-footer><span title='2024-10-02 12:02:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/_pipe/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로세스 제어 블록(Process Control Block, PCB)</h2></header><div class=entry-content><p>프로세스 제어 블록 (Process Control Block, PCB) 프로세스 제어 블록 (Process Control Block, PCB) 은 운영 체제에서 프로세스를 관리하기 위해 사용하는 핵심적인 데이터 구조이다.
PCB 는 각 프로세스에 대한 중요한 정보를 저장하고 관리하며, 운영 체제가 프로세스를 효율적으로 제어하고 실행할 수 있게 한다.
Sourece: https://www.geeksforgeeks.org/process-table-and-process-control-block-pcb/
PCB 의 주요 구성 요소 프로세스 식별자 (Process ID, PID): 각 프로세스에 할당되는 고유한 식별 번호이다. 프로세스 상태 (Process State): 프로세스의 현재 상태를 나타낸다. 주요 상태로는 생성 (new), 준비 (ready), 실행 (running), 대기 (waiting), 종료 (terminated) 등이 있다. 프로그램 카운터 (Program Counter): 다음에 실행할 명령어의 주소를 가리킨다. CPU 레지스터: 프로세스가 CPU 를 사용할 때의 레지스터 정보를 저장한다. CPU 스케줄링 정보: 프로세스의 우선순위, CPU 사용 시간 등 스케줄링에 필요한 정보를 포함한다. 메모리 관리 정보: 프로세스의 메모리 할당 정보, 페이지 테이블 등을 저장한다. 입출력 상태 정보: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등을 관리한다. 계정 정보: CPU 사용 시간, 메모리 사용량 등 프로세스의 리소스 사용 정보를 추적한다. PCB 의 역할과 중요성 프로세스 관리: PCB 는 운영 체제가 프로세스의 생명주기를 관리하는 데 필수적이다. 컨텍스트 스위칭: PCB 는 프로세스 간 전환 시 현재 상태를 저장하고 복원하는 데 사용된다. 스케줄링: 운영 체제는 PCB 의 정보를 바탕으로 프로세스 스케줄링 결정을 내린다. 리소스 관리: PCB 는 프로세스에 할당된 리소스를 추적하고 관리한다. 동기화 및 통신: 프로세스 간 동기화와 통신에 필요한 정보를 저장한다. PCB 의 생명주기 프로세스 생성 시 PCB 가 생성되고 초기화된다. 프로세스 실행 중 PCB 정보가 지속적으로 업데이트된다. 프로세스 종료 시 PCB 가 제거된다. PCB 의 구현 및 저장 PCB 는 운영 체제 커널의 보호된 메모리 영역에 저장된다.
일부 운영 체제에서는 PCB 를 커널 스택의 시작 부분에 위치시킨다.
...</p></div><footer class=entry-footer><span title='2024-10-02 06:59:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;25 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로세스 제어 블록(Process Control Block, PCB)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/processes/process-control-block/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로세스 간 통신 (Inter-Process Communication, IPC)</h2></header><div class=entry-content><p>프로세스 간 통신 (Inter-Process Communication, IPC) 프로세스 간 통신은 서로 다른 프로세스들이 데이터를 주고받거나 서로의 동작을 조율하기 위해 사용하는 메커니즘.
한 프로세스의 출력이 다른 프로세스의 입력으로 사용될 수 있다.
이를 통해 프로세스들은 데이터를 교환하고, 작업을 동기화하며, 리소스를 효율적으로 활용할 수 있다.
프로세스 간 통신(IPC)에 대해 체계적으로 설명해드리겠습니다. 이 개념을 더 쉽게 이해하기 위해, 실제 생활의 예시와 함께 설명을 시작하겠습니다.
Source: https://www.geeksforgeeks.org/inter-process-communication-ipc/
장점 프로세스 간 데이터 공유 및 협력 가능 모듈화 및 유연한 시스템 설계 가능 단점 구현 복잡성 증가 동기화 및 데드락 문제 발생 가능성 IPC의 주요 방식 파이프(Pipe) 파이프는 가장 오래되고 간단한 IPC 방식으로, 한 프로세스의 출력이 다른 프로세스의 입력으로 직접 전달된다.
...</p></div><footer class=entry-footer><span title='2024-10-02 06:20:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로세스 간 통신 (Inter-Process Communication, IPC)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/ipc/__index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CI/CD Principles</h2></header><div class=entry-content><p>CI/CD Principles CI/CD 원칙은 지속적 통합 (CI) 과 지속적 배포 (CD) 를 기반으로 코드 변경 사항을 빠르게 통합, 테스트, 배포하는 자동화된 프로세스를 강조한다.
CI/CD 는 DevOps 문화의 중심에 있으며, 개발팀이 더 자주, 더 안정적으로 코드를 통합하고 배포할 수 있게 해준다.
핵심 개념 CI/CD 는 두 가지 연관된 개념의 조합이다:
지속적 통합 (Continuous Integration, CI): 개발자들이 코드 변경사항을 중앙 리포지토리에 자주 통합하는 개발 방식으로, 보통 하루에 여러 번 이루어진다. 각 통합은 자동화된 빌드와 테스트로 검증되어 통합 문제를 빠르게 식별한다.
...</p></div><footer class=entry-footer><span title='2024-10-02 04:24:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI/CD Principles" href=https://buenhyden.github.io/posts/devops-and-platform-engineering/ci-cd/ci-cd-fundamentals/ci-cd-principles/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/53/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/55/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>