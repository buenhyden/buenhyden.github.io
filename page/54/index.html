<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Airflow</h2></header><div class=entry-content><p>Airflow Apache Airflow는 데이터 파이프라인을 구축, 관리, 모니터링하기 위한 오픈소스 플랫폼이다.
Airflow는 복잡한 데이터 파이프라인을 효율적으로 관리할 수 있게 해주는 강력한 도구이다.
데이터 엔지니어링 분야에서 널리 사용되며, 지속적으로 발전하고 있는 플랫폼이다.
기본적인 DAG(Directed Acyclic Graph) 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 from airflow import DAG from airflow.operators.python import PythonOperator from datetime import datetime, timedelta # DAG 기본 설정 default_args = { 'owner': 'data_engineer', 'depends_on_past': False, 'start_date': datetime(2024, 1, 1), 'email': ['alert@example.com'], 'email_on_failure': True, 'retries': 1, 'retry_delay': timedelta(minutes=5) } # DAG 정의 dag = DAG( 'data_processing_pipeline', default_args=default_args, description='데이터 처리 파이프라인', schedule_interval='0 0 * * *' # 매일 자정에 실행 ) # 태스크 함수 정의 def extract_data(**context): # 데이터 추출 로직 raw_data = {'data': 'extracted_value'} context['task_instance'].xcom_push(key='raw_data', value=raw_data) def transform_data(**context): # 데이터 변환 로직 raw_data = context['task_instance'].xcom_pull(key='raw_data') transformed_data = {'data': f"transformed_{raw_data['data']}"} context['task_instance'].xcom_push(key='transformed_data', value=transformed_data) def load_data(**context): # 데이터 적재 로직 transformed_data = context['task_instance'].xcom_pull(key='transformed_data') print(f"Loading data: {transformed_data}") # 태스크 생성 extract_task = PythonOperator( task_id='extract_data', python_callable=extract_data, provide_context=True, dag=dag ) transform_task = PythonOperator( task_id='transform_data', python_callable=transform_data, provide_context=True, dag=dag ) load_task = PythonOperator( task_id='load_data', python_callable=load_data, provide_context=True, dag=dag ) # 태스크 의존성 설정 extract_task >> transform_task >> load_task Airflow의 주요 특징 Python 기반: DAG(Directed Acyclic Graph)를 Python 코드로 정의할 수 있어 유연성과 확장성이 뛰어나다. 스케줄링: 복잡한 워크플로우를 쉽게 스케줄링할 수 있다. 모니터링: 웹 인터페이스를 통해 작업 실행 상태를 실시간으로 모니터링할 수 있다. 확장성: 다양한 외부 시스템과 쉽게 통합할 수 있다. Airflow의 주요 구성 요소 DAG (Directed Acyclic Graph):
...</p></div><footer class=entry-footer><span title='2024-10-26 05:18:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;822 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Airflow" href=https://buenhyden.github.io/posts/data/data-engineering/data-pipeline/airflow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>백프레셔(Backpressure)</h2></header><div class=entry-content><p>백프레셔(Backpressure) 백프레셔는 시스템에서 데이터나 작업의 처리 속도가 유입 속도를 따라가지 못할 때 발생하는 압력을 의미한다.
이는 마치 좁은 파이프에 과도한 물이 흐를 때 발생하는 역압과 유사하다.
다시 말하면, 백프레셔(Backpressure)는 데이터 처리 시스템에서 생산자와 소비자 간의 처리 속도 차이로 인해 발생하는 과부하 상태를 관리하는 메커니즘으로, 이는 여러 영역에서 발생한다.
주요 영역과 의미 스트림 처리 시스템
의미: 데이터 스트림의 생산 속도가 소비 속도를 초과할 때 발생하는 현상 예: 실시간 로그 처리, 센서 데이터 분석 네트워크 통신
...</p></div><footer class=entry-footer><span title='2024-10-26 04:56:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;492 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 백프레셔(Backpressure)" href=https://buenhyden.github.io/posts/system-design/asynchronism/back-pressure/backpressure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)</h2></header><div class=entry-content><p>데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication) 두 기술은 모두 데이터베이스의 가용성과 성능을 향상시키는 중요한 아키텍처 전략이지만, 각각의 목적과 구현 방식에서 차이가 있다.
기본 개념 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 정의 여러 서버를 하나의 시스템처럼 운영하여 작업을 분산처리하는 방식 데이터베이스를 복제하여 여러 위치에서 동일한 데이터를 유지하는 방식 주요 목적 성능 향상 및 고가용성 확보 데이터 안정성 및 가용성 확보 작동 방식 여러 노드가 동시에 작업을 처리 마스터 DB의 데이터를 슬레이브 DB에 복제 데이터 동기화 실시간 동기화 필수 비동기 또는 동기식 복제 가능 기술적 특징 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 노드 역할 모든 노드가 동등한 역할 수행 마스터-슬레이브 구조의 역할 구분 로드밸런싱 자동 로드밸런싱 지원 읽기 작업에 대한 로드밸런싱 가능 확장성 수평적 확장 용이 읽기 성능 위주의 확장 장애 대응 자동 페일오버 지원 수동 또는 반자동 페일오버 장단점 비교 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 장점 • 높은 가용성
• 우수한 확장성
• 효율적인 로드밸런싱
• 실시간 데이터 동기화 • 구현이 상대적으로 간단
• 비용 효율적
• 지리적 분산 용이
• 읽기 성능 향상 단점 • 구현 비용이 높음
• 복잡한 구성
• 네트워크 대역폭 필요
• 관리 어려움 • 데이터 일관성 보장 어려움
• 쓰기 성능 향상 제한적
• 마스터 노드 병목 현상
• 복제 지연 가능성 적용 시나리오 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 최적 사용 사례 • 고성능이 필요한 트랜잭션 처리
• 실시간 데이터 처리
• 무중단 서비스 필요
• 대규모 동시 접속 처리 • 데이터 백업
• 읽기 작업이 많은 서비스
• 지역별 서비스 제공
• 재해 복구 대비 산업 분야 • 금융 거래 시스템
• 통신 서비스
• 대형 전자상거래
• 실시간 예약 시스템 • 콘텐츠 제공 서비스
• 분석 리포팅 시스템
• 글로벌 서비스
• 미디어 스트리밍 구현 고려사항 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 네트워크 요구사항 • 고속 전용 네트워크 필요
• 낮은 지연시간 필수
• 안정적인 네트워크 연결 • 일반 네트워크 사용 가능
• 비동기 복제 시 네트워크 요구사항 낮음 하드웨어 요구사항 • 고성능 서버 필요
• 동일한 사양의 노드 권장
• 충분한 메모리 • 마스터 노드 성능 중요
• 슬레이브는 상대적으로 낮은 사양 가능 운영 관리 • 전문 관리자 필요
• 모니터링 시스템 필수
• 정기적인 유지보수 • 상대적으로 간단한 관리
• 백업 정책 중요
• 복제 상태 모니터링 비용 분석 구분 클러스터링 (Clustering) 레플리케이션 (Replication) 초기 구축 비용 매우 높음 중간 운영 비용 높음 중간 유지보수 비용 높음 중간~낮음 ROI 장기적으로 높음 중단기적으로 높음 특히 주목할 만한 차이점은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-25 15:42:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;476 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 클러스터링 (Clustering)과 레플리케이션(Replication)" href=https://buenhyden.github.io/posts/databases/rdbms/database-clustering-and-replication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터 불일치 (Data Inconsistency)</h2></header><div class=entry-content><p>데이터 불일치 (Data Inconsistency) 동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황
Source: https://www.geeksforgeeks.org/what-is-data-inconsistency-in-dbms/
발생 조건 데이터 불일치가 발생하는 주요 조건:
동시성 작업 여러 프로세스나 스레드가 동시에 데이터를 수정할 때 트랜잭션이 적절히 관리되지 않을 때 분산 환경 네트워크 지연이나 실패가 발생할 때 데이터 복제 과정에서 시간 차이가 발생할 때 캐싱 문제 캐시 무효화가 제대로 이루어지지 않을 때 캐시와 원본 데이터 간의 동기화 실패 시스템 오류 하드웨어 오류, 네트워크 문제, 소프트웨어 버그 등으로 인해 발생할 수 있다. 데이터 통합 문제: 서로 다른 소스의 데이터를 통합할 때 발생할 수 있다 해결책 및 방지책 데이터 표준화: 데이터 형식, 값, 표현을 일관되게 만든다. 데이터 검증: 데이터 입력 시 유효성 검사를 수행한다. 데이터 정제: 오류를 식별하고 수정하는 과정을 거친다. 데이터 거버넌스: 데이터 관리에 대한 명확한 정책과 절차를 수립한다. 동기화 메커니즘: 분산 시스템에서 데이터 동기화를 위한 알고리즘을 사용한다. 실제 시스템에서의 예방책 데이터 감사: 정기적인 데이터 감사를 통해 불일치를 식별한다. 자동화 도구 사용: 데이터 품질 관리 도구를 활용하여 불일치를 자동으로 탐지한다. 데이터 프로파일링: 데이터의 특성을 이해하고 잠재적 문제를 파악한다. 버전 관리: 데이터 변경 이력을 추적하여 불일치 발생 시 원인을 파악한다. 고려사항 및 주의사항 성능 영향: 데이터 일관성 유지 메커니즘이 시스템 성능에 미치는 영향을 고려해야 한다. 확장성: 대규모 분산 시스템에서의 데이터 일관성 유지 방법을 고려해야 한다. 사용자 교육: 데이터 입력 및 수정 시 주의사항에 대해 사용자를 교육해야 한다. 비즈니스 규칙 반영: 데이터 일관성 규칙에 비즈니스 로직을 반영해야 한다. 주의 사항 및 모범 사례 버전 관리 모든 데이터 변경에 버전 번호 부여 낙관적 락킹 구현 충돌 감지 및 해결 메커니즘 구축 캐시 전략 Cache-Aside 패턴 사용 적절한 TTL(Time-To-Live) 설정 캐시 무효화 전략 수립 동기화 메커니즘 분산 락 사용 이벤트 기반 동기화 멱등성 보장 모니터링 및 감사 버전 이력 관리 변경 로그 기록 불일치 감지 알림 실제 구현시 고려사항 확장성 수평적 확장을 고려한 설계 샤딩 전략 수립 복제 지연 관리 성능 캐시 적중률 최적화 인덱스 전략 수립 배치 처리 활용 복구 전략 백업 및 복구 계획 롤백 메커니즘 데이터 정합성 검증 모범 사례 단일 진실 소스(Single Source of Truth) 유지 데이터 품질 메트릭 정의 및 모니터링 데이터 소유권 및 책임 명확화 지속적인 데이터 품질 개선 프로세스 구축 데이터 불일치 해결을 위한 명확한 워크플로우 수립 파이썬 예제로 보는 데이터 불일치 다음은 데이터 불일치가 발생할 수 있는 상황과 이를 해결하는 방법을 보여주는 예제
...</p></div><footer class=entry-footer><span title='2024-10-25 07:22:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;975 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터 불일치 (Data Inconsistency)" href=https://buenhyden.github.io/posts/databases/data-inconsistency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 잠금 (database lock)</h2></header><div class=entry-content><p>데이터베이스 잠금 (database lock) 여러 사용자가 동시에 데이터베이스에 접근할 때 데이터의 일관성과 무결성을 보장하기 위한 핵심 메커니즘
잠금의 기본 개념과 종류 공유 잠금(Shared Lock, S-Lock) 읽기 작업을 위한 잠금. 여러 트랜잭션이 동시에 같은 데이터에 대한 공유 잠금을 가질 수 있다. 주로 SELECT 문에서 사용 1 2 3 4 5 6 -- 공유 잠금 예시 BEGIN TRANSACTION; SELECT * FROM products WITH (HOLDLOCK) -- 공유 잠금 설정 WHERE product_id = 1; -- 다른 트랜잭션도 이 데이터를 읽을 수 있지만, 수정은 불가능 COMMIT; 배타적 잠금(Exclusive Lock, X-Lock) 쓰기 작업을 위한 잠금. 한 번에 하나의 트랜잭션만 배타적 잠금을 가질 수 있다. 주로 INSERT, UPDATE, DELETE 문에서 사용 1 2 3 4 5 6 7 -- 배타적 잠금 예시 BEGIN TRANSACTION; UPDATE products -- 자동으로 배타적 잠금 설정 SET stock = stock - 1 WHERE product_id = 1; -- 다른 트랜잭션은 이 데이터를 읽거나 수정할 수 없음 COMMIT; 잠금의 단위와 범위 데이터베이스 잠금은 여러 레벨에서 적용될 수 있다
잠금 단위가 작을수록 동시성은 높아지지만, 관리가 복잡해진다.
...</p></div><footer class=entry-footer><span title='2024-10-24 15:22:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;864 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 잠금 (database lock)" href=https://buenhyden.github.io/posts/databases/more-about-databases/tracsactions/database-lock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ACID</h2></header><div class=entry-content><p>ACID 데이터베이스 관리 시스템(DBMS)에서 ACID는 트랜잭션의 신뢰성과 일관성을 정의하는 네 가지 주요 특성.
ACID는 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성)의 약자
ACID의 중요성:
데이터 무결성 유지 트랜잭션의 신뢰성 보장 동시성 제어 시스템 장애 복구 비즈니스 규칙 및 관계형 무결성 강화 장점:
데이터 일관성 유지 트랜잭션 무결성 보장 내결함성 및 복구 기능 제공 동시성 제어 가능 단점:
처리 오버헤드로 인한 성능 저하 대용량 OLTP 시스템에서의 성능 문제 제한적인 잠금으로 인한 확장성 제한 Atomicity (원자성) 원자성은 트랜잭션이 단일의 불가분한 작업 단위로 취급되어야 함을 의미합니다.
...</p></div><footer class=entry-footer><span title='2024-10-24 13:10:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;741 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ACID" href=https://buenhyden.github.io/posts/databases/more-about-databases/tracsactions/acid/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>N plus one problem</h2></header><div class=entry-content><p>N plus one problem N+1 문제는 하나의 쿼리로 N개의 엔티티를 조회한 후, 각 엔티티와 연관된 데이터를 조회하기 위해 N번의 추가 쿼리가 발생하는 현상을 말한다.
주로 ORM(Object-Relational Mapping) 기술을 사용할 때 발생하는 성능 관련 이슈로 데이터베이스에 불필요하게 많은 쿼리를 실행하게 되는 상황을 말한다.
발생 원인 연관 관계 매핑: 주로 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생한다. 지연 로딩(Lazy Loading): 연관된 엔티티를 실제로 사용할 때 추가적인 쿼리가 발생한다. 즉시 로딩(Eager Loading): 연관된 엔티티를 함께 조회하려 할 때 추가 쿼리가 발생할 수 있다. 문제점 성능 저하: 불필요한 데이터베이스 쿼리로 인해 애플리케이션의 성능이 크게 저하된다. 네트워크 부하: 데이터베이스와의 통신이 증가하여 네트워크 부하가 증가한다. 데이터베이스 부하: 과도한 쿼리 실행으로 데이터베이스 서버에 부담을 준다. 이러한 N+1 문제는 데이터베이스 성능에 큰 영향을 미칠 수 있으므로, 개발 초기 단계부터 인지하고 적절한 해결 방법을 적용하는 것이 중요하다.
특히 대규모 애플리케이션에서는 이 문제를 해결하지 않으면 심각한 성능 저하를 경험할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 11:21:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;475 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to N plus one problem" href=https://buenhyden.github.io/posts/databases/more-about-databases/n-plus-one-problem/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로시저 (Procedure)</h2></header><div class=entry-content><p>프로시저 (Procedure) 데이터베이스 프로시저(Database Procedure)는 데이터베이스 내에 저장되고 실행되는 일련의 SQL 문들의 집합으로,
자주 사용하는 SQL 명령어들을 하나의 작은 프로그램으로 미리 작성해두고 필요할 때 호출하여 사용하는 것이다.
SQL Server에서의 프로시저 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 -- 주문 처리를 위한 저장 프로시저 생성 CREATE PROCEDURE ProcessOrder @OrderID int, @CustomerID int, @TotalAmount decimal(10,2) AS BEGIN -- 트랜잭션 시작 BEGIN TRANSACTION TRY -- 주문 정보 입력 INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount) VALUES (@OrderID, @CustomerID, GETDATE(), @TotalAmount) -- 재고 수량 업데이트 UPDATE Inventory SET Quantity = Quantity - 1 WHERE ProductID IN ( SELECT ProductID FROM OrderDetails WHERE OrderID = @OrderID ) -- 고객 포인트 업데이트 UPDATE Customers SET Points = Points + (@TotalAmount * 0.01) WHERE CustomerID = @CustomerID -- 트랜잭션 완료 COMMIT TRANSACTION CATCH -- 오류 발생 시 롤백 ROLLBACK TRANSACTION -- 오류 정보 반환 SELECT ERROR_MESSAGE() AS ErrorMessage END END -- 프로시저 사용 예시 EXEC ProcessOrder @OrderID = 1001, @CustomerID = 500, @TotalAmount = 150000 프로시저의 주요 특징과 장점 성능 최적화
프로시저는 최초 실행 시 컴파일되어 캐시에 저장되므로, 반복 실행 시 더 빠른 성능을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-10-24 09:05:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;715 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로시저 (Procedure)" href=https://buenhyden.github.io/posts/databases/rdbms/procedure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>keyword</h2></header><div class=entry-content><p>Keyword SQL(Structured Query Language)는 데이터베이스를 관리하고 조작하기 위한 표준 언어로, 다양한 키워드를 통해 데이터 정의, 조작, 제어, 트랜잭션 관리 등을 수행한다.
데이터 조회 (Query) 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- SELECT: 데이터를 조회하는 기본 키워드 -- 지정된 컬럼의 데이터를 결과셋으로 반환 SELECT employee_id, first_name, salary FROM employees; -- FROM: 데이터를 가져올 테이블을 지정 -- 여러 테이블을 콤마로 구분하거나 JOIN을 사용할 수 있음 SELECT * FROM employees, departments; -- DISTINCT: 결과에서 중복된 행을 제거하는 데 사용 -- 기본 DISTINCT 사용 -- 부서별 unique한 직무 목록 조회 SELECT DISTINCT job_id FROM employees; -- 여러 컬럼에 DISTINCT 적용 -- 부서와 직무의 unique한 조합 조회 SELECT DISTINCT department_id, job_id FROM employees; -- COUNT와 함께 사용 -- 회사에 존재하는 직무 개수 조회 SELECT COUNT(DISTINCT job_id) as unique_jobs FROM employees; -- GROUP BY와 함께 사용 SELECT department_id, COUNT(DISTINCT job_id) as job_types FROM employees GROUP BY department_id; 결과 제한 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- LIMIT - 반환되는 결과의 최대 행 수를 제한합니다. SELECT * FROM employees LIMIT 10 -- 상위 10개 행만 반환 -- OFFSET - 결과의 시작 위치를 지정합니다. LIMIT와 함께 자주 사용됩니다. SELECT * FROM employees LIMIT 10 OFFSET 20 -- 21번째부터 30번째 행을 반환 -- FETCH - SQL 표준의 LIMIT와 유사한 기능을 합니다. SELECT * FROM employees FETCH FIRST 10 ROWS ONLY -- 페이지당 10개 항목, 3번째 페이지 조회 SELECT * FROM products ORDER BY name LIMIT 10 OFFSET 20; -- (페이지 번호 - 1) * 페이지 크기 = OFFSET 조건 연산자 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- WHERE: 조건절을 지정하여 특정 조건을 만족하는 데이터만 조회 -- AND, OR을 사용하여 여러 조건 조합 가능 SELECT * FROM employees WHERE salary > 50000 AND department_id = 10; -- IN: 값 목록 중 포함 여부 -- BETWEEN: 범위 조건 -- LIKE: 패턴 매칭 -- IS NULL: NULL 값 확인 SELECT * FROM employees WHERE department_id IN (10, 20, 30) AND salary BETWEEN 40000 AND 60000 AND first_name LIKE '김%' AND manager_id IS NOT NULL; -- CASE - 조건에 따라 다른 값을 반환합니다. -- WHEN - CASE 문에서 조건을 지정합니다. -- THEN - 조건이 참일 때 반환할 값을 지정합니다. -- ELSE - 모든 조건이 거짓일 때 반환할 값을 지정합니다. SELECT name, CASE WHEN age &lt; 20 THEN 'Young' WHEN age &lt; 60 THEN 'Adult' ELSE 'Senior' END as age_group FROM users; 정렬과 그룹화 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- GROUP BY: 지정된 컬럼을 기준으로 데이터를 그룹화 -- 주로 집계 함수와 함께 사용 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id; -- ORDER BY: 결과를 정렬 -- ASC(오름차순), DESC(내림차순) 지정 가능 SELECT * FROM employees ORDER BY salary DESC, first_name ASC; -- HAVING: GROUP BY로 그룹화된 데이터에 대한 조건 지정 -- WHERE는 개별 행에 대한 조건, HAVING은 그룹에 대한 조건 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 50000; 조인(Join) 관련 키워드 JOIN은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다. JOIN을 사용하면 여러 테이블의 데이터를 하나의 결과 집합으로 결합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 07:56:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;3111 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to keyword" href=https://buenhyden.github.io/posts/databases/rdbms/sql/syntax/keywords/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cardinality</h2></header><div class=entry-content><p>Cardinality Cardinality는 데이터베이스 분야에서 주로 두 가지 의미로 사용된다.
테이블 간의 관계에서의 Cardinality
이는 두 엔티티 간의 최대 연관성을 나타낸다.
주요 유형은 다음과 같습니다:
1:1 (일대일) 관계: 예를 들어, 사원과 사원증의 관계 1:N (일대다) 관계: 예를 들어, 교수와 학생의 관계 N:M (다대다) 관계: 예를 들어, 학생과 강좌의 관계 컬럼에 있는 고유한 값의 Cardinality
이는 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.
Cardinality의 정도에 따라 다음과 같이 분류할 수 있다:
높은 Cardinality: 주민등록번호, 이메일 주소와 같이 대부분의 값이 고유한 경우 중간 Cardinality: 우편번호, 도시 이름과 같이 일부 값이 고유하지만 많은 값이 반복되는 경우 낮은 Cardinality: 성별, 상태 코드와 같이 적은 수의 고유 값을 포함하는 경우 데이터베이스 성능에 여러 가지 중요한 영향을 미친다.
...</p></div><footer class=entry-footer><span title='2024-10-22 15:08:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;409 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cardinality" href=https://buenhyden.github.io/posts/databases/rdbms/sql/cardinality/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/53/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/55/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>