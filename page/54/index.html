<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Composite Pattern</h2></header><div class=entry-content><p>Composite Pattern 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 08:24:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Composite Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/composite-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bridge Pattern</h2></header><div class=entry-content><p>Bridge Pattern 복잡한 시스템에서 추상화(abstraction)와 구현(implementation)을 분리하여 독립적으로 변형과 확장이 가능하도록 하는 구조 패턴
TV 제조사가 다양하고(구현), 리모컨의 종류도 다양(추상화)하지만, 이들은 서로 독립적으로 발전하면서도 함께 잘 동작할 수 있다.
특징 추상화와 구현을 두 개의 독립적인 클래스 계층으로 분리합니다. 구현부에 대한 참조를 통해 추상화와 구현을 연결합니다. 런타임에 구현을 교체할 수 있는 유연성을 제공합니다. 사용사례 그래픽 시스템에서 다양한 플랫폼(Windows, macOS, Linux)에서 동작하는 다양한 도형(원, 사각형, 삼각형)을 그려야 할 때 여러 데이터베이스 시스템과 연동되는 다양한 타입의 로깅 시스템을 구현할 때 다양한 디바이스에서 실행되는 여러 종류의 사용자 인터페이스를 개발할 때 여러 종류의 메시지(이메일, SMS, 푸시알림)를 다양한 포맷(HTML, 텍스트, JSON)으로 전송해야 할 때 장점 추상화와 구현의 분리로 인한 높은 유연성과 확장성을 제공합니다. 새로운 추상화나 구현을 추가할 때 기존 코드를 수정하지 않아도 됩니다. 각 계층이 독립적으로 발전할 수 있어 시스템의 진화가 용이합니다. 구현 세부사항을 클라이언트로부터 숨길 수 있습니다. 단점 추상화와 구현 사이에 간접 계층이 추가되어 복잡도가 증가할 수 있습니다. 설계 초기에 브리지 패턴을 적용하지 않으면 나중에 리팩터링하기 어려울 수 있습니다. 작은 규모의 시스템에서는 오버엔지니어링이 될 수 있습니다. 주의사항 및 고려사항 브리지 패턴을 적용하기 전에 시스템이 정말로 이러한 유연성을 필요로 하는지 검토해야 합니다. 추상화와 구현 계층 사이의 의존성을 최소화하도록 인터페이스를 설계해야 합니다. 각 계층의 책임 범위를 명확히 정의하고, 단일 책임 원칙을 지키도록 해야 합니다. 성능에 민감한 시스템에서는 추가되는 간접 계층으로 인한 오버헤드를 고려해야 합니다. 브리지 패턴은 초기 설계 단계에서 적용하는 것이 가장 효과적입니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from abc import ABC, abstractmethod # Implementation interface class MessageSender(ABC): @abstractmethod def send(self, message: str, recipient: str) -> bool: pass # Concrete implementations class EmailSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending email to {recipient}") print(f"Email content: {message}") return True class SMSSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending SMS to {recipient}") print(f"SMS content: {message}") return True class PushNotificationSender(MessageSender): def send(self, message: str, recipient: str) -> bool: print(f"Sending push notification to device {recipient}") print(f"Notification content: {message}") return True # Abstraction class Message(ABC): def __init__(self, sender: MessageSender): self.sender = sender @abstractmethod def send(self, recipient: str) -> bool: pass # Refined Abstractions class SimpleMessage(Message): def __init__(self, sender: MessageSender, content: str): super().__init__(sender) self.content = content def send(self, recipient: str) -> bool: return self.sender.send(self.content, recipient) class HTMLMessage(Message): def __init__(self, sender: MessageSender, html_content: str): super().__init__(sender) self.html_content = html_content def send(self, recipient: str) -> bool: formatted_content = f"&lt;html>&lt;body>{self.html_content}&lt;/body>&lt;/html>" return self.sender.send(formatted_content, recipient) class EncryptedMessage(Message): def __init__(self, sender: MessageSender, content: str, encryption_key: str): super().__init__(sender) self.content = content self.encryption_key = encryption_key def send(self, recipient: str) -> bool: # Simulate encryption encrypted_content = f"ENCRYPTED[{self.content}] WITH KEY {self.encryption_key}" return self.sender.send(encrypted_content, recipient) # Message Factory for convenience class MessageFactory: @staticmethod def create_simple_message(sender: MessageSender, content: str) -> SimpleMessage: return SimpleMessage(sender, content) @staticmethod def create_html_message(sender: MessageSender, html_content: str) -> HTMLMessage: return HTMLMessage(sender, html_content) @staticmethod def create_encrypted_message( sender: MessageSender, content: str, key: str ) -> EncryptedMessage: return EncryptedMessage(sender, content, key) # Usage example if __name__ == "__main__": # Create senders email_sender = EmailSender() sms_sender = SMSSender() push_sender = PushNotificationSender() # Create message factory factory = MessageFactory() # Create and send different types of messages using different senders simple_email = factory.create_simple_message( email_sender, "Hello from Python!" ) simple_email.send("user@example.com") html_email = factory.create_html_message( email_sender, "&lt;h1>Hello&lt;/h1>&lt;p>This is HTML email&lt;/p>" ) html_email.send("user@example.com") encrypted_sms = factory.create_encrypted_message( sms_sender, "Secret message", "encryption_key_123" ) encrypted_sms.send("+1234567890") simple_push = factory.create_simple_message( push_sender, "New notification!" ) simple_push.send("device_token_123") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 // Implementation interface class LogStorage { save(logEntry) { throw new Error('save method must be implemented'); } retrieve(id) { throw new Error('retrieve method must be implemented'); } } // Concrete implementations class FileLogStorage extends LogStorage { constructor(filepath) { super(); this.filepath = filepath; this.logs = new Map(); console.log(`Initializing File Storage at ${filepath}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to file: ${this.filepath}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class DatabaseLogStorage extends LogStorage { constructor(connectionString) { super(); this.connectionString = connectionString; this.logs = new Map(); console.log(`Connecting to database: ${connectionString}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to database: ${this.connectionString}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } class CloudLogStorage extends LogStorage { constructor(cloudProvider, region) { super(); this.cloudProvider = cloudProvider; this.region = region; this.logs = new Map(); console.log(`Connecting to ${cloudProvider} in ${region}`); } save(logEntry) { const id = Date.now().toString(); this.logs.set(id, logEntry); console.log(`Saving to ${this.cloudProvider} cloud storage in ${this.region}`); console.log(`Log entry: ${JSON.stringify(logEntry)}`); return id; } retrieve(id) { return this.logs.get(id); } } // Abstraction class Logger { constructor(storage) { this.storage = storage; } log(message) { throw new Error('log method must be implemented'); } getLog(id) { return this.storage.retrieve(id); } } // Refined Abstractions class SimpleLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO' }; return this.storage.save(entry); } } class DetailedLogger extends Logger { log(message) { const entry = { timestamp: new Date().toISOString(), message: message, level: 'INFO', processId: process.pid, hostname: require('os').hostname(), memory: process.memoryUsage() }; return this.storage.save(entry); } } class SecurityLogger extends Logger { constructor(storage, encryptionKey) { super(storage); this.encryptionKey = encryptionKey; } log(message) { const entry = { timestamp: new Date().toISOString(), message: this.encrypt(message), level: 'SECURE', encryptionVersion: '1.0' }; return this.storage.save(entry); } encrypt(message) { // Simulate encryption return `ENCRYPTED[${message}] WITH KEY ${this.encryptionKey}`; } } // Usage example // Create different storage implementations const fileStorage = new FileLogStorage('/var/log/app.log'); const dbStorage = new DatabaseLogStorage('mongodb://localhost:27017/logs'); const cloudStorage = new CloudLogStorage('AWS', 'us-east-1'); // Create different types of loggers with different storage backends const simpleFileLogger = new SimpleLogger(fileStorage); const detailedDbLogger = new DetailedLogger(dbStorage); const secureCloudLogger = new SecurityLogger(cloudStorage, 'secret-key-123'); // Use the loggers const fileLogId = simpleFileLogger.log('Simple file log message'); console.log('Retrieved file log:', simpleFileLogger.getLog(fileLogId)); const dbLogId = detailedDbLogger.log('Detailed database log message'); console.log('Retrieved database log:', detailedDbLogger.getLog(dbLogId)); const cloudLogId = secureCloudLogger.log('Secure cloud log message'); console.log('Retrieved cloud log:', secureCloudLogger.getLog(cloudLogId)); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:14:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bridge Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/bridge-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decorator Pattern</h2></header><div class=entry-content><p>Decorator Pattern 객체에 동적으로 새로운 책임을 추가할 수 있게 해주는 구조적 디자인 패턴
“래퍼(wrapper)” 개념으로 각 데코레이터는 원본 객체를 감싸면서 추가 기능을 제공한다.
여러 데코레이터를 겹겹이 쌓을 수 있으며, 각 계층은 이전 계층의 기능을 확장한다.
특징 기존 객체의 코드를 수정하지 않고 새로운 기능을 추가할 수 있습니다. 상속 대신 구성(composition)을 사용하여 객체의 기능을 확장합니다. 객체를 여러 데코레이터로 감싸 기능을 조합할 수 있습니다. 사용사례 파일 입출력 시스템에서 압축, 암호화, 버퍼링 등의 기능을 조합할 때 웹 서비스에서 로깅, 캐싱, 인증 등의 기능을 동적으로 추가할 때 GUI 컴포넌트에 테두리, 스크롤바, 색상 등의 시각적 요소를 조합할 때 게임 캐릭터에 아이템, 버프, 상태 효과 등을 적용할 때 장점 객체의 기능을 동적으로 확장할 수 있어 매우 유연합니다. 단일 책임 원칙을 지키면서 기능을 조합할 수 있습니다. 상속을 통한 확장보다 더 유연한 방식을 제공합니다. 런타임에 객체의 행동을 변경할 수 있습니다. 단점 데코레이터를 너무 많이 사용하면 코드가 복잡해질 수 있습니다. 데코레이터들의 순서가 결과에 영향을 미칠 수 있어 주의가 필요합니다. 작은 객체들이 많이 생성되어 코드를 이해하기 어려울 수 있습니다. 주의사항 및 고려사항 데코레이터의 순서를 신중하게 고려해야 합니다. 예를 들어, 텍스트 처리에서 HTML 이스케이프를 마크다운 변환 전에 하면 원하는 결과를 얻을 수 없습니다. 데코레이터 체인이 너무 길어지지 않도록 주의해야 합니다. 필요한 경우 자주 사용되는 조합을 별도의 클래스로 만드는 것을 고려하세요. 데코레이터들 간의 상호작용을 고려해야 합니다. 한 데코레이터의 출력이 다른 데코레이터의 입력으로 적절한지 확인해야 합니다. 성능에 민감한 상황에서는 데코레이터 체인으로 인한 오버헤드를 고려해야 합니다. 디버깅이 어려울 수 있으므로, 로깅이나 모니터링 기능을 추가하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 from abc import ABC, abstractmethod from typing import List # Component interface class Coffee(ABC): """Base Coffee interface""" @abstractmethod def get_cost(self) -> float: pass @abstractmethod def get_ingredients(self) -> List[str]: pass @abstractmethod def get_description(self) -> str: pass # Concrete component class SimpleCoffee(Coffee): """Basic coffee implementation""" def get_cost(self) -> float: return 2.0 def get_ingredients(self) -> List[str]: return ["Coffee"] def get_description(self) -> str: return "Simple coffee" # Base decorator class CoffeeDecorator(Coffee): """Base decorator class""" def __init__(self, coffee: Coffee): self._coffee = coffee def get_cost(self) -> float: return self._coffee.get_cost() def get_ingredients(self) -> List[str]: return self._coffee.get_ingredients() def get_description(self) -> str: return self._coffee.get_description() # Concrete decorators class MilkDecorator(CoffeeDecorator): """Adds milk to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.5 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Milk"] def get_description(self) -> str: return f"{super().get_description()}, with steamed milk" class WhipDecorator(CoffeeDecorator): """Adds whipped cream to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.7 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Whipped Cream"] def get_description(self) -> str: return f"{super().get_description()}, topped with whipped cream" class CaramelDecorator(CoffeeDecorator): """Adds caramel to the coffee""" def get_cost(self) -> float: return super().get_cost() + 0.6 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Caramel"] def get_description(self) -> str: return f"{super().get_description()}, drizzled with caramel" class ExtraShotDecorator(CoffeeDecorator): """Adds an extra shot of espresso""" def get_cost(self) -> float: return super().get_cost() + 1.0 def get_ingredients(self) -> List[str]: return super().get_ingredients() + ["Extra Espresso Shot"] def get_description(self) -> str: return f"{super().get_description()}, with an extra shot" # Order management class CoffeeOrder: """Manages coffee orders and provides order summary""" def __init__(self): self.coffee = None def create_order(self) -> None: """Creates a new coffee order starting with simple coffee""" self.coffee = SimpleCoffee() def add_milk(self) -> None: self.coffee = MilkDecorator(self.coffee) def add_whip(self) -> None: self.coffee = WhipDecorator(self.coffee) def add_caramel(self) -> None: self.coffee = CaramelDecorator(self.coffee) def add_extra_shot(self) -> None: self.coffee = ExtraShotDecorator(self.coffee) def get_order_summary(self) -> str: """Generates a summary of the current order""" return f""" Order Summary: Description: {self.coffee.get_description()} Ingredients: {', '.join(self.coffee.get_ingredients())} Total Cost: ${self.coffee.get_cost():f} """ # Usage example if __name__ == "__main__": # Create a new order order = CoffeeOrder() order.create_order() # Customize the coffee with various additions order.add_milk() order.add_extra_shot() order.add_whip() order.add_caramel() # Print the order summary print(order.get_order_summary()) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 // Component interface class TextProcessor { constructor() { if (this.constructor === TextProcessor) { throw new Error("Abstract class cannot be instantiated"); } } process(text) { throw new Error("Method 'process' must be implemented"); } } // Concrete component class SimpleTextProcessor extends TextProcessor { process(text) { return text; } } // Base decorator class TextProcessorDecorator extends TextProcessor { constructor(processor) { super(); this._processor = processor; } process(text) { return this._processor.process(text); } } // Concrete decorators class CapitalizeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.toUpperCase(); } } class TrimDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText.trim(); } } class HTMLEscapeDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/&/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/>/g, "&amp;gt;") .replace(/"/g, "&amp;quot;") .replace(/'/g, "&amp;#039;"); } } class MarkdownToHTMLDecorator extends TextProcessorDecorator { process(text) { const processedText = this._processor.process(text); return processedText .replace(/\*\*(.*?)\*\*/g, '&lt;strong>$1&lt;/strong>') .replace(/\*(.*?)\*/g, '&lt;em>$1&lt;/em>') .replace(/\[(.*?)\]\((.*?)\)/g, '&lt;a href="$2">$1&lt;/a>') .replace(/^# (.*$)/gm, '&lt;h1>$1&lt;/h1>') .replace(/^## (.*$)/gm, '&lt;h2>$1&lt;/h2>'); } } class ValidationDecorator extends TextProcessorDecorator { constructor(processor, maxLength = 1000) { super(processor); this.maxLength = maxLength; } process(text) { if (!text) { throw new Error("Text cannot be empty"); } if (text.length > this.maxLength) { throw new Error(`Text length exceeds maximum limit of ${this.maxLength} characters`); } return this._processor.process(text); } } // Text processing manager class TextProcessingManager { constructor() { this.processor = new SimpleTextProcessor(); this.history = []; } addCapitalization() { this.processor = new CapitalizeDecorator(this.processor); return this; } addTrimming() { this.processor = new TrimDecorator(this.processor); return this; } addHTMLEscaping() { this.processor = new HTMLEscapeDecorator(this.processor); return this; } addMarkdownProcessing() { this.processor = new MarkdownToHTMLDecorator(this.processor); return this; } addValidation(maxLength) { this.processor = new ValidationDecorator(this.processor, maxLength); return this; } process(text) { const result = this.processor.process(text); this.history.push({ input: text, output: result, timestamp: new Date() }); return result; } getProcessingHistory() { return this.history; } } // Usage example const manager = new TextProcessingManager(); // Configure text processing chain manager .addValidation(2000) .addTrimming() .addMarkdownProcessing() .addHTMLEscaping(); // Process some text try { const input = ` # Welcome to Text Processing This is a **bold** and *italic* text example. [Click here](https://example.com) to learn more. `; const result = manager.process(input); console.log("Processed text:"); console.log(result); console.log("\nProcessing history:"); console.log(manager.getProcessingHistory()); } catch (error) { console.error("Error processing text:", error.message); } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:14:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1240 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decorator Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/decorator-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Facade Pattern</h2></header><div class=entry-content><p>Facade Pattern 복잡한 서브시스템에 대한 간단한 인터페이스를 제공하는 구조적 디자인 패턴
TV, 오디오, 조명 등 복잡한 홈시어터 시스템이 있을 때, 리모컨 하나로 이 모든 것을 간단히 제어할 수 있게 해주는 것처럼, 퍼사드 패턴은 복잡한 시스템을 간단한 인터페이스로 감싸주는 패턴
특징 복잡한 서브시스템을 감싸는 단순한 인터페이스를 제공합니다. 클라이언트와 서브시스템 간의 결합도를 낮춥니다. 고수준 인터페이스를 정의하여 서브시스템을 더 쉽게 사용할 수 있게 합니다. 사용사례 복잡한 라이브러리나 프레임워크를 간단하게 사용해야 할 때 레거시 코드를 새로운 인터페이스로 감싸야 할 때 서브시스템을 계층화할 때 장점 결합도 감소: 클라이언트는 복잡한 서브시스템 대신 Facade와만 상호작용하므로, 시스템 간의 결합도가 낮아집니다. 코드 가독성 향상: 복잡한 로직을 Facade 뒤로 숨김으로써 클라이언트 코드가 더 깔끔하고 이해하기 쉬워집니다. 유지보수성 증가: 서브시스템의 변경이 Facade 내부에 국한되므로, 클라이언트 코드를 수정할 필요가 없어집니다. 계층화된 구조: 복잡한 시스템을 계층화하여 관리할 수 있게 해줍니다. 단점 Facade 클래스가 과도한 책임을 지게 될 수 있습니다. 성능 저하가 발생할 수 있습니다. 서브시스템의 모든 기능을 사용할 수 없을 수 있습니다. 주의사항 및 고려사항 인터페이스 설계: Facade의 인터페이스는 가능한 한 단순하고 직관적이어야 합니다. 위 예제에서처럼 복잡한 프로세스를 하나의 메서드로 단순화하는 것이 좋습니다. 의존성 관리: Facade는 서브시스템 컴포넌트들과의 의존성을 잘 관리해야 합니다. 필요한 경우 의존성 주입을 사용하여 유연성을 확보할 수 있습니다. 테스트 용이성: Facade 패턴을 사용하면 복잡한 시스템을 테스트하기가 더 쉬워집니다. 단일 진입점을 통해 전체 시스템을 테스트할 수 있기 때문입니다. 확장성: 시스템이 발전함에 따라 새로운 기능을 추가해야 할 수 있습니다. Facade는 이러한 변화를 수용할 수 있도록 설계되어야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # 복잡한 서브시스템 클래스들 class VideoFile: def __init__(self, filename): self.filename = filename self.codec = self.detect_codec() def detect_codec(self): return self.filename.split(".")[1] class CompressionCodec: def __init__(self, type): self.type = type class MPEG4CompressionCodec(CompressionCodec): def __init__(self): super().__init__("mp4") class OGGCompressionCodec(CompressionCodec): def __init__(self): super().__init__("ogg") class CodecFactory: @staticmethod def extract_codec(file): type = file.codec if type == "mp4": return MPEG4CompressionCodec() else: return OGGCompressionCodec() class BitrateReader: @staticmethod def read(filename, codec): print(f"BitrateReader: reading file {filename} with codec {codec.type}") return f"video_data_{filename}" @staticmethod def convert(buffer, codec): print(f"BitrateReader: writing file with codec {codec.type}") return f"converted_data_{buffer}" # Facade 클래스 class VideoConverter: def convert(self, filename, target_format): video_file = VideoFile(filename) source_codec = CodecFactory.extract_codec(video_file) if target_format == "mp4": destination_codec = MPEG4CompressionCodec() else: destination_codec = OGGCompressionCodec() buffer = BitrateReader.read(filename, source_codec) result = BitrateReader.convert(buffer, destination_codec) return result # 클라이언트 코드 def main(): converter = VideoConverter() mp4 = converter.convert("funny-cats.ogg", "mp4") print(f"VideoConverter: conversion completed -> {mp4}") if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // 복잡한 서브시스템 클래스들 class VideoFile { constructor(filename) { this.filename = filename; this.codec = this.detectCodec(); } detectCodec() { return this.filename.split(".")[1]; } } class CompressionCodec { constructor(type) { this.type = type; } } class MPEG4CompressionCodec extends CompressionCodec { constructor() { super("mp4"); } } class OGGCompressionCodec extends CompressionCodec { constructor() { super("ogg"); } } class CodecFactory { static extractCodec(file) { const type = file.codec; if (type === "mp4") { return new MPEG4CompressionCodec(); } return new OGGCompressionCodec(); } } class BitrateReader { static read(filename, codec) { console.log(`BitrateReader: reading file ${filename} with codec ${codec.type}`); return `video_data_${filename}`; } static convert(buffer, codec) { console.log(`BitrateReader: writing file with codec ${codec.type}`); return `converted_data_${buffer}`; } } // Facade 클래스 class VideoConverter { convert(filename, targetFormat) { const videoFile = new VideoFile(filename); const sourceCodec = CodecFactory.extractCodec(videoFile); const destinationCodec = targetFormat === "mp4" ? new MPEG4CompressionCodec() : new OGGCompressionCodec(); const buffer = BitrateReader.read(filename, sourceCodec); const result = BitrateReader.convert(buffer, destinationCodec); return result; } } // 클라이언트 코드 function main() { const converter = new VideoConverter(); const mp4 = converter.convert("funny-cats.ogg", "mp4"); console.log(`VideoConverter: conversion completed -> ${mp4}`); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:14:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;684 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Facade Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/facade-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Proxy Pattern</h2></header><div class=entry-content><p>Proxy Pattern 객체에 대한 접근을 제어하기 위한 대리인(또는 대변인) 역할을 하는 객체를 제공하는 구조적 디자인 패턴
특징 실제 객체를 대신하여 그 객체에 대한 접근을 제어하는 대리 객체를 제공합니다. 프록시는 실제 객체와 동일한 인터페이스를 가지며, 클라이언트는 프록시를 통해 실제 객체에 접근합니다. 객체에 대한 접근을 제어하고 추가적인 기능을 제공할 수 있습니다. 사용사례 가상 프록시 (Virtual Proxy): 무거운 객체의 생성을 필요한 시점까지 지연시킵니다. 예를 들어, 고해상도 이미지를 로딩할 때 처음에는 저해상도 이미지를 보여주고, 실제로 필요할 때 고해상도 이미지를 로딩하는 방식입니다. 보호 프록시 (Protection Proxy): 객체에 대한 접근 권한을 제어합니다. 사용자의 권한에 따라 특정 메서드의 호출을 허용하거나 거부할 수 있습니다. 캐싱 프록시 (Caching Proxy): 비용이 많이 드는 작업의 결과를 캐시하고, 동일한 요청이 올 경우 캐시된 결과를 반환합니다. 로깅 프록시 (Logging Proxy): 메서드 호출과 매개변수들을 기록하여 로깅이나 디버깅에 활용합니다. 장점 보안 강화: 클라이언트가 직접 중요한 객체에 접근하는 것을 제어할 수 있습니다. 성능 최적화: 무거운 객체의 생성을 지연시키거나 결과를 캐싱함으로써 시스템의 성능을 향상시킬 수 있습니다. 로깅과 모니터링: 객체에 대한 접근을 감시하고 로깅할 수 있어 디버깅과 모니터링이 용이해집니다. 코드 분리: 부가적인 기능을 프록시에 구현함으로써 실제 객체는 자신의 핵심 기능에만 집중할 수 있습니다. 단점 코드의 복잡성이 증가할 수 있습니다. 프록시 객체로 인해 응답 시간이 늘어날 수 있습니다. 주의사항 및 고려사항 인터페이스 설계: 프록시와 실제 객체는 동일한 인터페이스를 구현해야 합니다. 이를 통해 클라이언트는 프록시와 실제 객체를 구분할 필요가 없습니다. 적절한 프록시 유형 선택: 사용 사례에 맞는 프록시 유형을 선택해야 합니다. 예를 들어, 보안이 중요하다면 보호 프록시를, 성능이 중요하다면 캐싱 프록시를 사용할 수 있습니다. 리소스 관리: 특히 캐싱 프록시를 사용할 때는 메모리 사용량을 고려해야 합니다. 캐시 크기를 제한하거나 오래된 항목을 제거하는 정책을 구현할 필요가 있을 수 있습니다. 스레드 안전성: 여러 스레드가 동시에 프록시에 접근할 수 있는 경우, 적절한 동기화 메커니즘을 구현해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from abc import ABC, abstractmethod from time import sleep # 추상 인터페이스 class YoutubeVideo(ABC): @abstractmethod def play(self) -> None: pass # 실제 비디오 객체 (무거운 리소스) class RealYoutubeVideo(YoutubeVideo): def __init__(self, video_id: str): self.video_id = video_id # 실제 초기화 과정을 시뮬레이션 self._load_video_from_server() def _load_video_from_server(self) -> None: print(f"Loading video {self.video_id} from YouTube servers…") sleep(2) # 네트워크 지연 시뮬레이션 print("Video loaded successfully") def play(self) -> None: print(f"Playing video {self.video_id}") # 프록시 객체 class YoutubeVideoProxy(YoutubeVideo): def __init__(self, video_id: str): self.video_id = video_id self._real_video = None self._access_count = 0 self._cache = {} def play(self) -> None: # 접근 로깅 self._access_count += 1 print(f"Access count for video {self.video_id}: {self._access_count}") # 지연 초기화 if self._real_video is None: print("Loading video on first access…") self._real_video = RealYoutubeVideo(self.video_id) # 실제 객체의 메서드 호출 self._real_video.play() def get_video_info(self) -> dict: # 캐싱 예시 if 'info' not in self._cache: print("Fetching video info from server…") sleep(1) # 네트워크 요청 시뮬레이션 self._cache['info'] = { 'title': f'Video {self.video_id}', 'duration': '10:00', 'likes': 1000 } return self._cache['info'] # 클라이언트 코드 def main(): # 프록시를 통한 비디오 접근 video = YoutubeVideoProxy("ABC123") # 비디오 정보 조회 (캐시 사용) print("First info request:") print(video.get_video_info()) print("\nSecond info request (cached):") print(video.get_video_info()) # 비디오 재생 (지연 초기화) print("\nFirst play request:") video.play() print("\nSecond play request:") video.play() if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // 인터페이스 역할을 하는 추상 클래스 class YoutubeVideo { play() { throw new Error('play method must be implemented'); } } // 실제 비디오 객체 (무거운 리소스) class RealYoutubeVideo extends YoutubeVideo { constructor(videoId) { super(); this.videoId = videoId; this._loadVideoFromServer(); } _loadVideoFromServer() { console.log(`Loading video ${this.videoId} from YouTube servers…`); // 네트워크 지연 시뮬레이션 const startTime = Date.now(); while (Date.now() - startTime &lt; 2000) {} console.log('Video loaded successfully'); } play() { console.log(`Playing video ${this.videoId}`); } } // 프록시 객체 class YoutubeVideoProxy extends YoutubeVideo { constructor(videoId) { super(); this.videoId = videoId; this._realVideo = null; this._accessCount = 0; this._cache = new Map(); } play() { // 접근 로깅 this._accessCount++; console.log(`Access count for video ${this.videoId}: ${this._accessCount}`); // 지연 초기화 if (!this._realVideo) { console.log('Loading video on first access…'); this._realVideo = new RealYoutubeVideo(this.videoId); } // 실제 객체의 메서드 호출 this._realVideo.play(); } getVideoInfo() { // 캐싱 예시 if (!this._cache.has('info')) { console.log('Fetching video info from server…'); // 네트워크 요청 시뮬레이션 const startTime = Date.now(); while (Date.now() - startTime &lt; 1000) {} this._cache.set('info', { title: `Video ${this.videoId}`, duration: '10:00', likes: 1000 }); } return this._cache.get('info'); } } // 클라이언트 코드 function main() { // 프록시를 통한 비디오 접근 const video = new YoutubeVideoProxy('ABC123'); // 비디오 정보 조회 (캐시 사용) console.log('First info request:'); console.log(video.getVideoInfo()); console.log('\nSecond info request (cached):'); console.log(video.getVideoInfo()); // 비디오 재생 (지연 초기화) console.log('\nFirst play request:'); video.play(); console.log('\nSecond play request:'); video.play(); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:14:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;871 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Proxy Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/proxy-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Adapter Pattern</h2></header><div class=entry-content><p>Adapter Pattern 호환되지 않는 인터페이스를 가진 객체들이 협력할 수 있도록 하는 구조적 디자인 패턴
한국의 220V 전기 제품을 미국에서 사용하기 위해 변환 어댑터를 사용하듯이, 소프트웨어에서도 호환되지 않는 인터페이스들을 함께 작동하도록 만들어주는 것이 어댑터 패턴의 핵심
특징 기존 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환합니다. 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 협력할 수 있게 합니다. ‘Wrapper’라고도 불립니다. 사용사례 레거시 시스템과 새로운 시스템을 통합할 때 서드파티 라이브러리를 사용할 때 기존 코드의 수정을 최소화하고 싶은 경우 여러 데이터 포맷을 처리해야 하는 경우 외부 API를 내부 시스템에 통합할 때 장점 기존 코드를 변경하지 않고도 새로운 기능을 추가할 수 있습니다 단일 책임 원칙을 지키면서 코드의 재사용성을 높일 수 있습니다 클래스 간의 결합도를 낮출 수 있습니다 기존 코드와 새로운 코드를 깔끔하게 분리할 수 있습니다 단점 새로운 클래스와 인터페이스가 추가되어 복잡도가 증가할 수 있습니다 때로는 많은 어댑터 클래스를 작성해야 할 수 있습니다 모든 요청이 어댑터를 통과해야 하므로 약간의 오버헤드가 발생할 수 있습니다 주의사항 및 고려사항 어댑터의 책임 범위를 명확히 해야 합니다. 어댑터는 단순히 인터페이스를 변환하는 역할만 해야 하며, 비즈니스 로직을 포함해서는 안 됩니다. 어댑터 패턴을 적용하기 전에 정말로 필요한지 검토해야 합니다. 때로는 기존 코드를 리팩터링하는 것이 더 나은 해결책일 수 있습니다. 어댑터가 처리하는 데이터 변환 과정에서 발생할 수 있는 예외 상황들을 적절히 처리해야 합니다. 양방향 어댑터를 만들 때는 순환 참조가 발생하지 않도록 주의해야 합니다. 성능에 민감한 부분에서는 어댑터로 인한 추가적인 메서드 호출이 성능에 영향을 미칠 수 있음을 고려해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 from abc import ABC, abstractmethod from typing import Dict # Target Interface class PaymentProcessor(ABC): @abstractmethod def process_payment(self, amount: float) -> bool: pass @abstractmethod def refund_payment(self, amount: float) -> bool: pass # Existing payment system (Adaptee) class StripePaymentSystem: def __init__(self, api_key: str): self.api_key = api_key def create_charge(self, amount: float, currency: str = "USD") -> Dict: # Simulate Stripe API call print(f"Stripe: Charging ${amount} using API key {self.api_key}") return {"success": True, "transaction_id": "str_123", "amount": amount} def create_refund(self, transaction_id: str) -> Dict: # Simulate Stripe API call print(f"Stripe: Refunding transaction {transaction_id}") return {"success": True, "refund_id": "ref_123"} # Another existing payment system (Adaptee) class PayPalAPI: def __init__(self, client_id: str): self.client_id = client_id def submit_payment(self, amount: float) -> Dict: # Simulate PayPal API call print(f"PayPal: Processing payment of ${amount} with client ID {self.client_id}") return {"status": "SUCCESS", "payment_id": "PAY123"} def reverse_payment(self, payment_id: str) -> Dict: # Simulate PayPal API call print(f"PayPal: Reversing payment {payment_id}") return {"status": "SUCCESS"} # Adapter for Stripe class StripeAdapter(PaymentProcessor): def __init__(self, stripe_processor: StripePaymentSystem): self.stripe = stripe_processor self.transaction_records = {} def process_payment(self, amount: float) -> bool: result = self.stripe.create_charge(amount) if result["success"]: self.transaction_records[amount] = result["transaction_id"] return True return False def refund_payment(self, amount: float) -> bool: transaction_id = self.transaction_records.get(amount) if not transaction_id: return False result = self.stripe.create_refund(transaction_id) return result["success"] # Adapter for PayPal class PayPalAdapter(PaymentProcessor): def __init__(self, paypal_processor: PayPalAPI): self.paypal = paypal_processor self.payment_records = {} def process_payment(self, amount: float) -> bool: result = self.paypal.submit_payment(amount) if result["status"] == "SUCCESS": self.payment_records[amount] = result["payment_id"] return True return False def refund_payment(self, amount: float) -> bool: payment_id = self.payment_records.get(amount) if not payment_id: return False result = self.paypal.reverse_payment(payment_id) return result["status"] == "SUCCESS" # Client code def process_order(processor: PaymentProcessor, amount: float): """Process an order using any payment processor""" if processor.process_payment(amount): print(f"Successfully processed payment of ${amount}") return True print(f"Failed to process payment of ${amount}") return False # Usage example if __name__ == "__main__": # Create payment processors stripe_processor = StripePaymentSystem(api_key="sk_test_123") paypal_processor = PayPalAPI(client_id="client_123") # Create adapters stripe_adapter = StripeAdapter(stripe_processor) paypal_adapter = PayPalAdapter(paypal_processor) # Process payments using different processors process_order(stripe_adapter, 100.00) process_order(paypal_adapter, 50.00) # Test refunds stripe_adapter.refund_payment(100.00) paypal_adapter.refund_payment(50.00) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 // Target interface (what the client expects) class DataAnalyzer { analyze(data) { throw new Error('analyze method must be implemented'); } getReport() { throw new Error('getReport method must be implemented'); } } // Existing CSV data processor (Adaptee) class CSVProcessor { constructor() { this.data = null; } loadCSV(csvData) { // Simulate processing CSV data console.log('Processing CSV data…'); this.data = csvData.split('\n').map(row => row.split(',')); return true; } generateStats() { if (!this.data) return null; // Simulate generating statistics return { rowCount: this.data.length, columnCount: this.data[0].length, format: 'CSV' }; } } // Existing JSON data processor (Adaptee) class JSONProcessor { constructor() { this.jsonData = null; } parseJSON(jsonString) { // Simulate parsing JSON data console.log('Parsing JSON data…'); this.jsonData = JSON.parse(jsonString); return { success: true, timestamp: new Date() }; } calculateMetrics() { if (!this.jsonData) return null; // Simulate calculating metrics return { size: JSON.stringify(this.jsonData).length, type: 'JSON', keys: Object.keys(this.jsonData) }; } } // Adapter for CSV Processor class CSVAdapter extends DataAnalyzer { constructor(csvProcessor) { super(); this.processor = csvProcessor; this.analysis = null; } analyze(data) { const success = this.processor.loadCSV(data); if (success) { this.analysis = this.processor.generateStats(); return true; } return false; } getReport() { if (!this.analysis) return null; return { type: 'CSV Analysis', entries: this.analysis.rowCount, fields: this.analysis.columnCount, format: this.analysis.format, timestamp: new Date() }; } } // Adapter for JSON Processor class JSONAdapter extends DataAnalyzer { constructor(jsonProcessor) { super(); this.processor = jsonProcessor; this.analysis = null; } analyze(data) { const result = this.processor.parseJSON(data); if (result.success) { this.analysis = this.processor.calculateMetrics(); return true; } return false; } getReport() { if (!this.analysis) return null; return { type: 'JSON Analysis', dataSize: this.analysis.size, format: this.analysis.type, availableFields: this.analysis.keys, timestamp: new Date() }; } } // Client code class DataAnalysisService { constructor(analyzer) { this.analyzer = analyzer; } processData(data) { if (this.analyzer.analyze(data)) { const report = this.analyzer.getReport(); console.log('Analysis Report:', report); return report; } console.log('Analysis failed'); return null; } } // Usage example const csvData = 'name,age,city\nJohn,New York\nJane,Boston'; const jsonData = JSON.stringify({ users: [ { name: 'John', age: 30, city: 'New York' }, { name: 'Jane', age: 25, city: 'Boston' } ] }); // Create processors and adapters const csvProcessor = new CSVProcessor(); const jsonProcessor = new JSONProcessor(); const csvAdapter = new CSVAdapter(csvProcessor); const jsonAdapter = new JSONAdapter(jsonProcessor); // Analyze both types of data using the same interface const analysisService = new DataAnalysisService(csvAdapter); analysisService.processData(csvData); const jsonAnalysisService = new DataAnalysisService(jsonAdapter); jsonAnalysisService.processData(jsonData); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:13:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1216 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Adapter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/structural-design-patterns/adapter-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Abstract Factory Pattern</h2></header><div class=entry-content><p>Abstract Factory Pattern 구체적인 클래스를 지정하지 않고도 관련된 객체들의 집합을 생성할 수 있게 해주는 생성 패턴
특징 제품군의 생성을 캡슐화합니다 관련된 객체들이 함께 동작하도록 보장합니다 구체적인 클래스에 의존하지 않고 인터페이스에 의존합니다 제품군을 쉽게 교체할 수 있습니다 사용사례 여러 제품군 중 하나를 선택해 시스템을 설정해야 할 때 관련된 객체들이 함께 사용되어야 할 때 제품에 대한 클래스 라이브러리를 제공하고 구현이 아닌 인터페이스만 노출하고 싶을 때 실제 예:
크로스 플랫폼 UI 컴포넌트 생성 다양한 데이터베이스 시스템 지원 여러 운영체제에 대한 서비스 구현 다양한 게임 캐릭터와 아이템 생성 문서 포맷 변환 시스템 장점 제품군의 일관성 보장 구체적인 클래스와의 결합도 감소 제품군 교체가 용이 새로운 제품 추가가 용이 단점 코드가 복잡해질 수 있음 새로운 종류의 제품을 추가하기 어려움 불필요한 추상화로 인한 오버헤드 가능성 주의사항 및 고려사항 확장성 고려 새로운 제품군 추가를 고려한 설계 인터페이스 설계 시 신중한 고려 복잡성 관리 적절한 추상화 수준 유지 명확한 책임 분리 성능 최적화 객체 생성 비용 고려 캐싱 전략 검토 테스트 용이성 목 객체 생성 방법 고려 테스트 시나리오 설계 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 from abc import ABC, abstractmethod # 추상 제품 클래스들 class Button(ABC): @abstractmethod def render(self): pass @abstractmethod def handle_click(self): pass class Checkbox(ABC): @abstractmethod def render(self): pass @abstractmethod def toggle(self): pass # 구체적인 제품 클래스들 - Light Theme class LightButton(Button): def render(self): return "밝은 테마 버튼을 렌더링합니다" def handle_click(self): return "밝은 테마 버튼 클릭을 처리합니다" class LightCheckbox(Checkbox): def render(self): return "밝은 테마 체크박스를 렌더링합니다" def toggle(self): return "밝은 테마 체크박스 상태를 토글합니다" # 구체적인 제품 클래스들 - Dark Theme class DarkButton(Button): def render(self): return "어두운 테마 버튼을 렌더링합니다" def handle_click(self): return "어두운 테마 버튼 클릭을 처리합니다" class DarkCheckbox(Checkbox): def render(self): return "어두운 테마 체크박스를 렌더링합니다" def toggle(self): return "어두운 테마 체크박스 상태를 토글합니다" # 추상 팩토리 class UIFactory(ABC): @abstractmethod def create_button(self) -> Button: pass @abstractmethod def create_checkbox(self) -> Checkbox: pass # 구체적인 팩토리들 class LightThemeFactory(UIFactory): def create_button(self) -> Button: return LightButton() def create_checkbox(self) -> Checkbox: return LightCheckbox() class DarkThemeFactory(UIFactory): def create_button(self) -> Button: return DarkButton() def create_checkbox(self) -> Checkbox: return DarkCheckbox() # 클라이언트 코드 class Application: def __init__(self, factory: UIFactory): self.factory = factory self.button = None self.checkbox = None def create_ui(self): self.button = self.factory.create_button() self.checkbox = self.factory.create_checkbox() def paint(self): print(self.button.render()) print(self.checkbox.render()) # 사용 예시 if __name__ == "__main__": # 밝은 테마 사용 print("밝은 테마 적용:") app = Application(LightThemeFactory()) app.create_ui() app.paint() print("\n어두운 테마 적용:") # 어두운 테마로 전환 app = Application(DarkThemeFactory()) app.create_ui() app.paint() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // 추상 제품 클래스들 class Vehicle { constructor() { if (this.constructor === Vehicle) { throw new Error("추상 클래스는 인스턴스화할 수 없습니다."); } } getSpecifications() { throw new Error("추상 메서드는 구현해야 합니다."); } } class Engine { constructor() { if (this.constructor === Engine) { throw new Error("추상 클래스는 인스턴스화할 수 없습니다."); } } getDetails() { throw new Error("추상 메서드는 구현해야 합니다."); } } // 구체적인 제품 클래스들 - 스포츠카 class SportsCar extends Vehicle { getSpecifications() { return "스포츠카: 고성능, 2인승"; } } class SportsEngine extends Engine { getDetails() { return "스포츠카 엔진: V8, 500hp"; } } // 구체적인 제품 클래스들 - SUV class SUV extends Vehicle { getSpecifications() { return "SUV: 실용성, 7인승"; } } class SUVEngine extends Engine { getDetails() { return "SUV 엔진: V6, 280hp"; } } // 추상 팩토리 class VehicleFactory { createVehicle() { throw new Error("추상 메서드는 구현해야 합니다."); } createEngine() { throw new Error("추상 메서드는 구현해야 합니다."); } } // 구체적인 팩토리들 class SportsCarFactory extends VehicleFactory { createVehicle() { return new SportsCar(); } createEngine() { return new SportsEngine(); } } class SUVFactory extends VehicleFactory { createVehicle() { return new SUV(); } createEngine() { return new SUVEngine(); } } // 클라이언트 코드 class CarDealer { constructor(factory) { this.factory = factory; } orderCar() { const vehicle = this.factory.createVehicle(); const engine = this.factory.createEngine(); console.log("새로운 차량 주문:"); console.log(vehicle.getSpecifications()); console.log(engine.getDetails()); } } // 사용 예시 function main() { console.log("스포츠카 주문:"); const sportsCarDealer = new CarDealer(new SportsCarFactory()); sportsCarDealer.orderCar(); console.log("\nSUV 주문:"); const suvDealer = new CarDealer(new SUVFactory()); suvDealer.orderCar(); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:09:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;849 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Abstract Factory Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/abstract-factory-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Builder Pattern</h2></header><div class=entry-content><p>Builder Pattern 복잡한 객체의 생성 과정과 표현 방법을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 생성 패턴
예를 들어, 자동차를 조립하는 과정을 생각해보면, 동일한 조립 과정을 통해 스포츠카나 SUV와 같은 다른 종류의 자동차를 만들 수 있다.
특징 복잡한 객체의 생성 과정을 단계별로 나눕니다. 생성 과정은 동일하지만 다양한 구성과 표현이 가능합니다. 객체의 생성과 조립을 분리합니다. 필수 값과 선택적 값을 구분하여 관리할 수 있습니다. 메서드 체이닝 (Method Chaining) 메서드 체이닝을 통해 직관적으로 객체를 구성할 수 있다.
객체의 메서드를 연속적으로 호출하는 프로그래밍 기법
...</p></div><footer class=entry-footer><span title='2024-09-24 06:09:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1712 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Builder Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/builder-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Prototype Pattern</h2></header><div class=entry-content><p>Prototype Pattern 기존 객체를 복제하여 새로운 객체를 생성하는 생성 패턴
특징 객체 생성 비용이 높거나 복잡한 경우에 유용합니다. 원본 객체의 정확한 복사본을 제공합니다. 클라이언트가 객체의 타입을 미리 알 수 없는 경우에 사용됩니다. 사용사례 데이터베이스에서 가져온 큰 객체를 여러 번 사용해야 할 때 GUI 애플리케이션에서 복사-붙여넣기 기능을 구현할 때 게임에서 비슷한 특성을 가진 캐릭터나 아이템을 생성할 때 설정이나 구성 객체를 약간씩 다르게 여러 개 만들어야 할 때 장점 복잡한 객체를 처음부터 생성하는 비용을 절약할 수 있습니다 런타임에 동적으로 객체를 추가하거나 삭제할 수 있습니다 새로운 객체를 만들 때 상속 대신 복제를 사용하여 유연성을 높일 수 있습니다 단점 순환 참조가 있는 복잡한 객체의 경우 복제가 어려울 수 있습니다 깊은 복사(Deep Copy)를 구현할 때 모든 중첩된 객체들도 복제 가능해야 합니다 주의사항 및 고려사항 깊은 복사와 얕은 복사를 구분하여 사용해야 합니다. 객체가 다른 객체를 참조하는 경우, 깊은 복사를 사용하지 않으면 예상치 못한 부작용이 발생할 수 있습니다. 복제 과정에서 생성자가 호출되지 않음을 주의해야 합니다. 필요한 경우 초기화 로직을 별도의 메서드로 분리하여 복제 후 호출해야 합니다. 프로토타입 등록과 관리를 위한 레지스트리나 팩토리 클래스를 만들어 중앙에서 관리하는 것이 좋습니다. 복제된 객체의 식별자나 유니크한 속성들은 복제 후에 새로운 값으로 설정해야 합니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from copy import deepcopy from typing import Dict, Any class Character: def __init__(self, name: str, level: int, stats: Dict[str, int]): self.name = name self.level = level self.stats = stats def clone(self) -> 'Character': """Create a deep copy of the character""" return deepcopy(self) def __str__(self) -> str: return f"Character(name={self.name}, level={self.level}, stats={self.stats})" class CharacterPrototype: """Prototype manager class that stores and creates character templates""" def __init__(self): self._characters: Dict[str, Character] = {} def register_character(self, name: str, character: Character): """Register a character template""" self._characters[name] = character def unregister_character(self, name: str): """Remove a character template""" del self._characters[name] def clone(self, name: str, **kwargs: Any) -> Character: """Clone a character and optionally modify its attributes""" prototype = self._characters.get(name) if not prototype: raise ValueError(f"Character prototype '{name}' not found") character = prototype.clone() # Update any attributes specified in kwargs for key, value in kwargs.items(): if hasattr(character, key): setattr(character, key, value) return character # Usage example if __name__ == "__main__": # Create prototype manager prototype_manager = CharacterPrototype() # Register base warrior template warrior = Character( name="Warrior", level=1, stats={"strength": 15, "agility": 10, "intelligence": 5} ) prototype_manager.register_character("warrior", warrior) # Clone warriors with different names and levels warrior1 = prototype_manager.clone("warrior", name="Bob", level=5) warrior2 = prototype_manager.clone("warrior", name="Alice", level=7) print(warrior1) # Character(name=Bob, level=5, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) print(warrior2) # Character(name=Alice, level=7, stats={'strength': 15, 'agility': 10, 'intelligence': 5}) Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class DocumentTemplate { constructor(type, content, metadata) { this.type = type; this.content = content; this.metadata = metadata; } clone() { // Deep clone the object const clonedMetadata = JSON.parse(JSON.stringify(this.metadata)); return new DocumentTemplate(this.type, this.content, clonedMetadata); } customize(updates) { Object.assign(this, updates); return this; } } class DocumentPrototypeRegistry { constructor() { this.prototypes = new Map(); } registerTemplate(name, template) { this.prototypes.set(name, template); } unregisterTemplate(name) { this.prototypes.delete(name); } createDocument(templateName, customization = {}) { const template = this.prototypes.get(templateName); if (!template) { throw new Error(`Template '${templateName}' not found`); } return template.clone().customize(customization); } } // Usage example const registry = new DocumentPrototypeRegistry(); // Register some document templates const letterTemplate = new DocumentTemplate( 'letter', 'Dear {recipient},\n\n{body}\n\nBest regards,\n{sender}', { created: new Date(), version: '1.0', style: 'formal' } ); registry.registerTemplate('business_letter', letterTemplate); // Create customized documents from template const myLetter1 = registry.createDocument('business_letter', { content: 'Dear John,\n\nThank you for your inquiry.\n\nBest regards,\nJane' }); const myLetter2 = registry.createDocument('business_letter', { content: 'Dear Mary,\n\nPlease find attached our proposal.\n\nBest regards,\nBob', metadata: { version: '1.1', style: 'semiformal' } }); console.log(myLetter1); console.log(myLetter2); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:09:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;699 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Prototype Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/creational-design-patterns/prototype-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Thread</h2></header><div class=entry-content><p>Thread Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.
하나의 프로세스는 여러 개의 Thread를 가질 수 있으며, 이들은 프로세스의 자원을 공유한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
Thread의 구성 요소 Thread는 다음과 같은 구성 요소를 가진다:
프로그램 카운터 레지스터 집합 스택 공간 Thread ID
이러한 요소들은 각 Thread의 독립적인 실행을 가능하게 한다. Thread의 특징 경량성: Thread는 프로세스에 비해 생성과 관리가 더 빠르고 효율적이다. 자원 공유: 같은 프로세스 내의 Thread들은 코드, 데이터, 파일 등의 자원을 공유한다. 병렬 실행: 멀티코어 시스템에서는 여러 Thread가 실제로 동시에 실행될 수 있다. 기능과 역할 기능 역할 장점 병렬 처리 - 동시에 여러 작업 수행
CPU 활용도 증가 - 성능 향상
- 응답성 개선 자원 공유 - 프로세스 자원 공유
- 효율적인 메모리 사용 - 메모리 절약
- 통신 비용 감소 비동기 처리 - 독립적인 작업 수행
- 이벤트 처리 - 응답성 향상
UI 처리 효율화 Thread의 종류 Thread는 크게 두 가지로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-23 23:32:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;654 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Thread" href=https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/thread/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/53/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/55/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>