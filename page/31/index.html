<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 클러스터링(Database Clustering)</h2></header><div class=entry-content><p>데이터베이스 클러스터링(Database Clustering) 하나의 데이터베이스를 여러 개의 서버 또는 인스턴스로 구성하여 운영하는 기술.
이 방식은 데이터베이스의 가용성, 성능, 그리고 확장성을 향상시키기 위해 사용된다..
데이터베이스 클러스터링(Database Clustering)은 하나의 데이터베이스를 여러 개의 서버 또는 인스턴스로 구성하여 운영하는 기술이다. 이 방식은 데이터베이스의 가용성, 성능, 그리고 확장성을 향상시키기 위해 사용된다.
클러스터링의 목적 고가용성(High Availability) 확보: 하나의 서버가 실패하더라도 다른 서버가 작업을 계속할 수 있어 서비스 중단을 최소화한다. 부하 분산(Load Balancing): 여러 서버로 작업을 분산시켜 전체적인 성능을 향상시킵니다[3]. 확장성(Scalability) 개선: 필요에 따라 서버를 추가하여 시스템의 처리 능력을 증가시킬 수 있습니다[2]. 구성 방식:
데이터베이스 클러스터링은 주로 두 가지 방식으로 구성된다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;290 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 클러스터링(Database Clustering)" href=https://buenhyden.github.io/posts/backend/database-systems/distributed-database/database-clustering/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 파티셔닝 (Database Partitioning)</h2></header><div class=entry-content><p>데이터베이스 파티셔닝 (Database Partitioning) 파티셔닝은 큰 테이블이나 인덱스를 더 작고 관리하기 쉬운 단위로 나누는 것.
정의와 목적 파티셔닝은 큰 테이블이나 인덱스를 더 작은 관리 가능한 단위인 ‘파티션’으로 나누는 것을 의미한다.
주요 목적은 다음과 같다:
성능 향상 가용성 증대 관리 용이성 개선 파티셔닝의 유형 수평 파티셔닝 (Horizontal Partitioning):
행 단위로 데이터를 분할 샤딩(Sharding)과 유사한 개념 수직 파티셔닝 (Vertical Partitioning):
열 단위로 데이터를 분할 자주 사용되는 컬럼을 별도로 저장 파티셔닝 방법 범위 분할 (Range Partitioning):
...</p></div><footer class=entry-footer><span title='2024-10-22 06:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;282 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 파티셔닝 (Database Partitioning)" href=https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-partitioning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>샤딩 (sharding)</h2></header><div class=entry-content><p>샤딩 (sharding) 대규모 데이터베이스 시스템에서 데이터를 수평적으로 분할하여 여러 서버에 분산 저장하는 기술.
각각의 분할된 데이터 조각을 ‘샤드(shard)‘라고 부른다.
이 기술은 데이터베이스의 성능, 확장성, 가용성을 향상시키는 데 중요한 역할을 한다.
예를 들어 전자상거래 사이트의 사용자 데이터를 지역별로 나누어 관리한다고 가정해보자.
서울 지역 사용자의 데이터는 샤드 A에, 부산 지역 사용자의 데이터는 샤드 B에 저장하는 식. 이렇게 하면 각 지역의 서버가 해당 지역 사용자의 데이터만 처리하면 되므로 시스템 부하를 분산할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;655 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 샤딩 (sharding)" href=https://buenhyden.github.io/posts/backend/database-systems/distributed-database/sharding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 캐싱 (Database Caching)</h2></header><div class=entry-content><p>데이터베이스 캐싱 (Database Caching) 데이터베이스 캐싱은 자주 사용되는 데이터를 빠르게 접근할 수 있는 메모리에 임시로 저장하는 기술.
정의와 목적 자주 액세스하는 데이터를 고속 메모리에 저장하여 빠른 검색 가능 데이터베이스 서버의 부하 감소 및 응답 시간 단축 주요 장점 성능 향상: 데이터 검색 속도 개선 서버 부하 감소: 반복적인 쿼리 처리 최소화 비용 절감: 데이터베이스 리소스 사용 효율화 사용자 경험 개선: 빠른 응답 시간 제공 작동 원리 캐시 히트: 요청 데이터가 캐시에 있어 즉시 반환 캐시 미스: 데이터가 캐시에 없어 원본 데이터베이스에서 조회 캐싱 전략 인-메모리 캐싱: RAM에 데이터 저장 (예: Redis, Memcached) 쿼리 결과 캐싱: 자주 실행되는 쿼리 결과 저장 객체 캐싱: 애플리케이션 레벨에서 객체 단위로 캐싱 주의사항 데이터 일관성 유지: 캐시와 원본 데이터 간 불일치 방지 적절한 캐시 갱신 정책 수립 필요 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 06:25:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;126 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 캐싱 (Database Caching)" href=https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-caching/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 쿼리 최적화 (Database Query Optimization)</h2></header><div class=entry-content><p>데이터베이스 쿼리 최적화 (Database Query Optimization) 데이터베이스 쿼리 최적화는 데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 중요한 프로세스이다.
쿼리 최적화의 목적 쿼리 응답 시간 단축 시스템 자원 사용 효율성 증대 전반적인 데이터베이스 성능 향상 사용자 경험 개선 주요 최적화 기법 인덱스 최적화 적절한 인덱스 생성 및 관리 복합 인덱스 활용 선택도가 높은 컬럼에 인덱스 생성 불필요한 인덱스 제거 1 2 3 4 5 6 7 8 9 -- 자주 사용되는 조건절에 대한 인덱스 생성 CREATE INDEX idx_orders_amount_date ON orders(total_amount, order_date); -- 위 인덱스를 활용하는 최적화된 쿼리 SELECT customers.name, orders.order_date, orders.total_amount FROM orders -- 인덱스를 가진 테이블을 먼저 참조 JOIN customers ON customers.id = orders.customer_id WHERE orders.total_amount > 1000 ORDER BY orders.order_date DESC; 쿼리 재작성 복잡한 쿼리 단순화 서브쿼리 최소화 및 조인으로 대체 WHERE 절 최적화 필요한 컬럼만 선택 (SELECT *) 테이블 조인 순서와 조인 유형을 적절히 선택 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 비효율적인 서브쿼리 SELECT * FROM customers WHERE id IN ( SELECT customer_id FROM orders WHERE total_amount > 1000 ); -- 더 효율적인 조인으로 변환 SELECT DISTINCT c.* FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.total_amount > 1000; 실행 계획 분석 쿼리 실행 계획 확인 및 분석 비효율적인 실행 계획 개선 쿼리 실행 계획은 데이터베이스가 쿼리를 어떻게 처리할지를 보여주는 로드맵과 같다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:23:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;512 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 쿼리 최적화 (Database Query Optimization)" href=https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-query-optimization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 인덱싱 (Database Indexing)</h2></header><div class=entry-content><p>데이터베이스 인덱싱 (Database Indexing) 인덱스는 책의 목차와 유사한 역할을 한다.
데이터베이스에서 인덱스를 사용하면 전체 테이블을 스캔하지 않고도 원하는 데이터를 빠르게 찾을 수 있다.
인덱스는 테이블의 하나 또는 여러 개의 컬럼을 기반으로 생성될 수 있습니다.
특징:
자동 정렬
인덱스는 항상 정렬된 상태를 유지한다. 새로운 데이터가 추가될 때마다 정렬된 순서를 유지하기 위해 재정렬이 발생한다. 독립적 저장
인덱스는 실제 데이터와 별도의 공간에 저장된다. 원본 데이터의 위치를 가리키는 포인터를 포함한다. 선택적 생성
모든 칼럼에 인덱스를 생성할 필요는 없다. 검색이 자주 발생하는 칼럼에 대해 선택적으로 생성한다. 장점:
...</p></div><footer class=entry-footer><span title='2024-10-22 02:11:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1714 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 인덱싱 (Database Indexing)" href=https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-indexing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 정규화 (Database Normalization)</h2></header><div class=entry-content><p>데이터베이스 정규화 (Database Normalization) 데이터베이스 정규화는 관계형 데이터베이스의 설계를 체계화하고 최적화하는 과정.
정규화의 정의와 목적 정규화는 데이터의 중복을 최소화하고, 데이터의 무결성을 보장하며, 데이터베이스 구조를 더 유연하게 만드는 것을 목표로 한다.
주요 목적은:
데이터 중복 최소화 데이터 무결성 향상 데이터베이스 구조의 유연성 증대 데이터 일관성 유지 데이터 갱신 이상 현상 방지 정규화 단계 정규화는 여러 단계로 이루어지며, 각 단계를 정규형(Normal Form)이라고 한다:
제1정규형(1NF): 각 컬럼이 원자값을 가지도록 한다. 즉, 하나의 컬럼에 여러 값이 들어있으면 안 된다.
...</p></div><footer class=entry-footer><span title='2024-10-22 02:06:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;447 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 정규화 (Database Normalization)" href=https://buenhyden.github.io/posts/backend/database-systems/database-optimization/database-normalization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache HTTP Server</h2></header><div class=entry-content><p>Apache HTTP Server Apache HTTP Server는 가장 널리 사용되는 오픈 소스 웹 서버 소프트웨어이다.
주요 특징 크로스 플랫폼 지원: Linux, Windows, macOS 등 다양한 운영 체제에서 실행 가능 모듈식 구조: 다양한 기능을 모듈로 추가/제거 가능 가상 호스팅: 하나의 서버에서 여러 웹사이트 호스팅 가능 보안 기능: SSL/TLS 지원, 접근 제어 등 다양한 프로그래밍 언어 지원: PHP, Perl, Python 등 주요 기능 모듈식 구조: 다양한 기능을 모듈로 추가/제거 가능하여 유연성 제공 가상 호스팅: 하나의 서버에서 여러 웹사이트 호스팅 가능 보안 기능: SSL/TLS 지원, 접근 제어, mod_security를 통한 침입 탐지 및 방지 다양한 프로그래밍 언어 지원: PHP, Perl, Python, Lua 등 지원 로드 밸런싱: 다양한 로드 밸런싱 메커니즘 제공 URL 재작성: mod_rewrite 모듈을 통한 URL 재작성 기능 압축 지원: mod_gzip을 통한 콘텐츠 압축으로 성능 향상 IPv6 지원: IPv6 호환성 제공 HTTP/2 지원: 최신 HTTP 프로토콜 지원 동적 설정:.htaccess 파일을 통한 디렉토리별 설정 지원 리버스 프록시: 캐싱 기능이 있는 리버스 프록시 제공 다양한 인증 방식: 비밀번호 기반, 디지털 인증서 등 지원 설치 방법 Ubuntu/Debian 기반:
...</p></div><footer class=entry-footer><span title='2024-10-21 11:53:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;671 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache HTTP Server" href=https://buenhyden.github.io/posts/backend/web-server/apache-http-server/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Caddy</h2></header><div class=entry-content><p>Caddy Caddy는 Go 언어로 작성된 현대적이고 강력한 오픈 소스 웹 서버이다.
주요 특징 자동 HTTPS: Let’s Encrypt를 통해 SSL/TLS 인증서를 자동으로 획득 및 갱신 간단한 설정: 직관적인 Caddyfile을 통한 쉬운 구성 HTTP/2 및 HTTP/3 지원 리버스 프록시 및 로드 밸런싱 기능 정적 파일 서빙에 최적화 설치 및 기본 사용법 설치:
Ubuntu/Debian:
1 2 3 4 5 sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list sudo apt update sudo apt install caddy 기본 설정:
/etc/caddy/Caddyfile 파일을 편집하여 설정한다.
...</p></div><footer class=entry-footer><span title='2024-10-21 08:44:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;570 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caddy" href=https://buenhyden.github.io/posts/backend/web-server/caddy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nginx</h2></header><div class=entry-content><p>Nginx Nginx는 고성능의 오픈 소스 웹 서버 소프트웨어로, 웹 서버, 리버스 프록시, 로드 밸런서 등 다양한 기능을 제공한다.
이벤트 기반 비동기 아키텍처를 사용하여 적은 리소스로도 많은 동시 연결을 처리할 수 있다.
Source: https://www.freecodecamp.org/news/an-introduction-to-nginx-for-developers-62179b6a458f/
주요 특징 비동기 이벤트 기반 아키텍처로 높은 동시성 처리 능력 낮은 메모리 사용량 정적 파일 서빙에 최적화 리버스 프록시 및 로드 밸런싱 기능 HTTP/2 및 HTTPS 지원 Nginx의 비동기 이벤트 기반 구조 마스터 프로세스와 워커 프로세스로 구성된다. 마스터 프로세스는 워커 프로세스를 관리하고, 워커 프로세스는 실제 요청을 처리한다. 각 워커 프로세스는 단일 스레드로 동작하며, 이벤트 루프를 실행한다. 워커 프로세스는 비동기적으로 여러 연결을 동시에 처리할 수 있다. 새로운 연결이 들어오면 이벤트로 처리되어 워커 프로세스에 할당된다. 요청은 상태 머신(주로 HTTP 상태 머신)에 할당되어 처리된다. 이 상태 머신은 요청을 어떻게 처리할지 지시한다. 워커 프로세스는 요청을 차단하지 않고 비동기적으로 처리한다. 이를 통해 한 워커 프로세스가 수천 개의 연결을 동시에 처리할 수 있다. 이벤트 기반 모델을 사용하여 새로운 클라이언트 요청과 같은 이벤트가 발생할 때까지 대기하다가, 이벤트가 발생하면 처리한다. 설치 방법 Ubuntu/Debian 기반:
...</p></div><footer class=entry-footer><span title='2024-10-21 08:42:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1017 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Nginx" href=https://buenhyden.github.io/posts/backend/web-server/nginx/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/30/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/32/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>