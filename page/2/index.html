<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TCPIP 4 Layers vs. OSI 7 Layers</h2></header><div class=entry-content><p>TCPIP 4 Layers vs. OSI 7 Layers 네트워크 통신을 이해하기 위한 두 가지 주요 참조 모델인 OSI 7계층과 TCP/IP 4계층 모델은 네트워크 통신과 프로토콜에 대한 개념적 프레임워크를 제공한다.
두 모델은 서로 다른 접근 방식과 구조를 가지고 있지만, 궁극적인 목표는 동일하다:
시스템 간의 효율적이고 신뢰할 수 있는 통신을 가능하게 하는 것
OSI 7계층 모델과 TCP/IP 4계층 모델은 각각 고유한 장점과 특성을 가지고 있다.
OSI 모델은 더 세분화되고 개념적인 접근을 제공하여 네트워크 통신의 복잡성을 이해하는 데 유용한 프레임워크를 제공한다. 반면 TCP/IP 모델은 실용적이고 구현 중심적인 접근으로 현대 인터넷의 기반을 형성했다.
...</p></div><footer class=entry-footer><span title='2024-10-19 02:11:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1523 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCPIP 4 Layers vs. OSI 7 Layers" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/tcp-ip-4layers/tcpip-4-layers-vs-osi-7-layers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬은 가장 간단하고 직관적인 정렬 알고리즘 중 하나이다.
이름에서 알 수 있듯이, 마치 물속에서 공기 방울이 떠오르는 것처럼 큰 값들이 배열의 끝으로 ‘부글부글’ 올라가는 모습을 연상시킨다.
이 알고리즘은 단순함 때문에 컴퓨터 과학 입문 과정에서 가장 먼저 배우는 정렬 알고리즘이지만, 실제 응용에서는 비효율성 때문에 잘 사용되지 않는다. 그럼에도 불구하고, 버블 정렬의 작동 방식과 특성을 이해하는 것은 다른 정렬 알고리즘의 기초를 다지는 데 중요하다.
버블 정렬은 가장 단순한 정렬 알고리즘 중 하나로, 구현이 쉽고 이해하기 직관적이다. 그러나 O(n²)의 시간 복잡도로 인해 대규모 데이터셋에서는 비효율적이며, 실제 응용에서는 퀵 정렬, 병합 정렬, 힙 정렬과 같은 더 효율적인 알고리즘들이 선호된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1341 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/types/bubble-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>선형 검색(Linear Search)</h2></header><div class=entry-content><p>순차 검색(Sequential Search / Linear Search) 순차 검색은 데이터 집합을 처음부터 끝까지 차례대로 하나씩 검색하는 방법.
이는 선형 검색(Linear Search)으로도 불리며, 리스트에서 순차적으로 탐색하면서 원하는 값을 찾아내는 알고리즘.
Source: https://www.tutorialspoint.com/data_structures_algorithms/linear_search_algorithm.htm
장점 구현이 매우 간단하고 직관적입니다. 데이터의 정렬 여부와 상관없이 사용할 수 있습니다. 단점 데이터의 양이 많아질수록 검색 시간이 선형적으로 증가합니다. 대규모 데이터셋에서는 비효율적입니다. 주의해야 할 점 데이터의 양이 많을 경우 검색 시간이 매우 길어질 수 있으므로 주의해야 합니다. 검색 종료 조건을 명확히 설정해야 합니다.
일반적으로 두 가지 조건이 있습니다: 검색 실패: 검색할 값을 발견하지 못하고 리스트의 끝을 지나간 경우 검색 성공: 리스트에서 검색할 값과 같은 요소를 발견한 경우 주로 사용하는 데이터 구조 순차 검색은 주로 배열이나 연결 리스트와 같은 선형 자료구조에서 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:31:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;774 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 선형 검색(Linear Search)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/search/types/linear-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Native Compiler</h2></header><div class=entry-content><p>Native Compiler Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러를 의미한다. 이러한 컴파일러는 작성된 코드가 동일한 환경 내에서 효율적으로 실행될 수 있도록 최적화하며, 주로 고성능 애플리케이션 개발에 활용된다.
네이티브 컴파일러는 소프트웨어 개발에서 가장 기본적이고 중요한 도구 중 하나이다. 같은 환경에서 개발과 실행이 이루어지는 대부분의 애플리케이션 개발에 있어 간편하고 효율적인 선택입니다. 특히 데스크톱 애플리케이션, 로컬 서버, 시스템 프로그래밍 등의 분야에서 네이티브 컴파일러의 역할은 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1620 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/types/native-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>논리값 (Boolean)</h2></header><div class=entry-content><p>논리값 (Boolean) Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.
Boolean 데이터 타입은 참(true)과 거짓(false)의 두 가지 값만을 가질 수 있는 데이터 타입으로, 수학자 George Boole의 이름을 따서 명명되었으며, 논리 연산과 조건문에서 주로 사용된다.
특징 오직 두 가지 값만 가짐: true 또는 false 조건문과 논리 연산에서 주로 사용됨 메모리 사용이 효율적 (일반적으로 1비트만으로도 표현이 가능하다(true = 1, false = 0). 하지만 실제 프로그래밍 언어에서는 메모리 정렬(alignment) 때문에 보통 1바이트를 사용) 특성 비교 연산의 결과로 자주 생성됨 제어 흐름을 결정하는 데 중요한 역할을 함 다른 데이터 타입으로부터 변환 가능 (예: 숫자 0은 false, 나머지는 true) 연산 종류 및 설명 논리 연산 AND (&&): 두 피연산자가 모두 true일 때만 true 반환 OR (||): 두 피연산자 중 하나라도 true이면 true 반환 NOT (!): 피연산자의 값을 반전 비교 연산 동등 비교 (==, ===) 부등 비교 (!=,!==) 대소 비교 (&lt;, >, &lt;=, >=) 실제 활용 사례 및 설명 조건문에서의 사용 플래그 변수로 사용 (예: 상태 체크) 데이터 유효성 검사 각 언어별 예시와 특징 각 언어의 특징적인 부분을 살펴보면:
...</p></div><footer class=entry-footer><span title='2024-10-07 07:33:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1120 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 논리값 (Boolean)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/boolean/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrency vs Parallelism</h2></header><div class=entry-content><p>동시성 (Concurrency) Vs 병렬성 (Parallelism) 동시성과 병렬성은 모두 여러 작업을 효율적으로 처리하기 위한 방법이지만, 그 접근 방식과 목적이 다르다.
동시성은 작업 관리와 응답성 향상에 중점을 두고, 병렬성은 전체적인 처리 속도 향상에 초점을 맞춘다.
실제 프로그래밍에서는 두 개념을 적절히 조합하여 사용하는 것이 효과적이다.
Source: &lt;https://www.codeproject.com/Articles/1267757/Concurrency-vs-Parallelism
동시성(Concurrency)은 여러 작업이 동시에 진행되는 것처럼 보이게 하는 개념으로, 단일 코어에서도 구현이 가능하며, 실제로는 작업들을 빠르게 전환하며 실행한다. 그래서, 실제로는 동시에 실행되지 않지만, 동시에 실행되는 것처럼 보인다.
이러한 작업들은 CPU가 여러 작업들을 빠르게 번갈아가며 처리하며, 이를 “컨텍스트 스위칭(Context Switching)“이라고 한다.
...</p></div><footer class=entry-footer><span title='2024-10-05 02:38:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;428 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrency vs Parallelism" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/concurrency-vs-parallelism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>클린 코드 (Clean Code)</h2></header><div class=entry-content><p>클린 코드 (Clean Code) 프로그램의 동작을 보장하면서도 가독성이 뛰어나고 유지보수가 쉬운 코드를 의미한다.
코드의 품질을 향상시켜 개발 속도를 높이고, 버그를 줄이며, 팀 내 협업을 원활하게 한다.
Robert C. Martin(일명 Uncle Bob)이 2008년에 출간한 “Clean Code: A Handbook of Agile Software Craftsmanship” 책을 통해 널리 알려졌다.
Clean Code의 중요성 가독성과 유지보수성 향상: 깨끗한 코드는 다른 개발자들이 쉽게 이해하고 수정할 수 있게 한다. 팀 협업 개선: 일관된 코딩 표준을 따르면 팀원 간 의사소통과 협업이 더 원활해진다. 디버깅과 문제 해결 용이: 명확하고 단순한 구조는 이슈를 더 쉽게 찾고 해결할 수 있게 한다. 코드 품질과 신뢰성 향상: 잘 구조화된 코드는 오류 발생 위험을 줄이고 더 높은 품질의 소프트웨어로 이어진다. 클린 코드를 작성하기 위한 주요 원칙 의미 있는 이름 사용 변수, 함수, 클래스 등의 이름은 그 목적과 기능을 명확히 나타내야 한다.
일관된 명명 규칙을 적용하고, 약어 사용은 자제한다.
...</p></div><footer class=entry-footer><span title='2024-09-19 05:44:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1710 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 클린 코드 (Clean Code)" href=https://buenhyden.github.io/posts/software-design-and-architecture/clean-code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ANSI</h2></header><div class=entry-content><p>ANSI “ANSI 인코딩"이라는 용어는 실제로 약간의 혼란을 불러일으키는 명칭이다.
엄밀히 말하면, ANSI(American National Standards Institute)는 표준을 개발하고 승인하는 미국 비영리 조직의 이름이지, 특정 문자 인코딩이 아니다. 그러나 이 용어는 일반적으로 Windows 운영 체제에서 사용되는 특정 8비트 코드 페이지 집합을 지칭한다.
실제로 “ANSI 인코딩"이라고 불리는 것은 다음과 같다:
Windows 코드 페이지: Windows에서 기본 8비트 문자 세트로 사용되는 인코딩 ISO-8859 계열의 확장: ASCII의 7비트를 8비트로 확장한 다양한 문자 세트 로컬 시스템의 기본 인코딩: Windows의 지역 설정에 따라 달라지는 인코딩 이러한 혼란은 Windows가 등장한 초기에 마이크로소프트가 당시 발전 중이던 ANSI 표준을 기반으로 문자 세트를 개발했기 때문에 발생했다. 그러나 이 문자 세트들은 결국 정식 ANSI 표준으로 채택되지 않았으나, 이름은 그대로 남게 되었다.
...</p></div><footer class=entry-footer><span title='2025-01-24 04:36:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;887 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ANSI" href=https://buenhyden.github.io/posts/computer-science/fundamentals/character-encodings/types/ansi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Branching Strategies</h2></header><div class=entry-content><p>Branching Strategies Branch and Bound(분기한정법)은 조합 최적화 문제를 해결하기 위한 알고리즘 패러다임으로, 가능한 해결책의 공간을 체계적으로 탐색하여 최적의 해를 찾는 방법이다.
이 알고리즘의 핵심 요소 중 하나가 바로 ‘분기 전략(Branching Strategies)‘이다.
분기 전략은 문제 공간을 어떻게 분할하고 탐색할 것인지를 결정하며, 이는 알고리즘의 효율성과 성능에 직접적인 영향을 미친다.
문제 구조를 이해하고 적절한 분기 전략을 선택하는 것은 효율적인 알고리즘 구현을 위해 필수적이다. 변수 기반, 제약 기반, 문제 특화 분기 등 다양한 전략을 이해하고, 문제의 특성에 맞게 적용하거나 조합하는 능력이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branching Strategies" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/branching-strategies/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Branch and Bound vs. Backtracking</h2></header><div class=entry-content><p>Back Tracking vs. Branch and Bound 백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.
두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.
백트래킹과 분기한정법은 조합 최적화 문제를 해결하기 위한 강력한 도구이다.
백트래킹은 제약 충족 문제에 더 적합하며, 가능한 모든 해결책이나 첫 번째 유효한 해결책을 찾는 데 중점을 둔다. 반면 분기한정법은 최적화 문제에 더 적합하며, 경계값을 사용하여 최적해를 효율적으로 찾는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2025-01-10 04:36:00 +0000 UTC'>January 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1458 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branch and Bound vs. Backtracking" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/branch-and-bound-vs-backtracking/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>