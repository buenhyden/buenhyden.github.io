<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬은 가장 간단하고 직관적인 정렬 알고리즘 중 하나이다.
이름에서 알 수 있듯이, 마치 물속에서 공기 방울이 떠오르는 것처럼 큰 값들이 배열의 끝으로 ‘부글부글’ 올라가는 모습을 연상시킨다.
이 알고리즘은 단순함 때문에 컴퓨터 과학 입문 과정에서 가장 먼저 배우는 정렬 알고리즘이지만, 실제 응용에서는 비효율성 때문에 잘 사용되지 않는다. 그럼에도 불구하고, 버블 정렬의 작동 방식과 특성을 이해하는 것은 다른 정렬 알고리즘의 기초를 다지는 데 중요하다.
버블 정렬은 가장 단순한 정렬 알고리즘 중 하나로, 구현이 쉽고 이해하기 직관적이다. 그러나 O(n²)의 시간 복잡도로 인해 대규모 데이터셋에서는 비효율적이며, 실제 응용에서는 퀵 정렬, 병합 정렬, 힙 정렬과 같은 더 효율적인 알고리즘들이 선호된다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/bubble-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Native Compiler</h2></header><div class=entry-content><p>Native Compiler Native Compiler는 소스 코드를 현재 컴파일러가 실행되고 있는 시스템의 운영체제와 하드웨어 아키텍처에 최적화된 기계어로 변환하는 컴파일러를 의미한다. 이러한 컴파일러는 작성된 코드가 동일한 환경 내에서 효율적으로 실행될 수 있도록 최적화하며, 주로 고성능 애플리케이션 개발에 활용된다.
네이티브 컴파일러는 소프트웨어 개발에서 가장 기본적이고 중요한 도구 중 하나이다. 같은 환경에서 개발과 실행이 이루어지는 대부분의 애플리케이션 개발에 있어 간편하고 효율적인 선택. 특히 데스크톱 애플리케이션, 로컬 서버, 시스템 프로그래밍 등의 분야에서 네이티브 컴파일러의 역할은 필수적이다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:30:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler" href=https://buenhyden.github.io/posts/computer-science-fundamentals/compilers-and-programming-language-theory/language-processor/compiler/types/native-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>논리값 (Boolean)</h2></header><div class=entry-content><p>논리값 (Boolean) Boolean은 컴퓨터 과학에서 가장 기본적인 데이터 타입 중 하나로, 단 두 가지 값만을 가질 수 있는 논리 데이터 타입이다.
Boolean 데이터 타입은 참(true)과 거짓(false)의 두 가지 값만을 가질 수 있는 데이터 타입으로, 수학자 George Boole의 이름을 따서 명명되었으며, 논리 연산과 조건문에서 주로 사용된다.
특징 오직 두 가지 값만 가짐: true 또는 false 조건문과 논리 연산에서 주로 사용됨 메모리 사용이 효율적 (일반적으로 1비트만으로도 표현이 가능하다(true = 1, false = 0). 하지만 실제 프로그래밍 언어에서는 메모리 정렬(alignment) 때문에 보통 1바이트를 사용) 특성 비교 연산의 결과로 자주 생성됨 제어 흐름을 결정하는 데 중요한 역할을 함 다른 데이터 타입으로부터 변환 가능 (예: 숫자 0은 false, 나머지는 true) 연산 종류 및 설명 논리 연산 AND (&&): 두 피연산자가 모두 true일 때만 true 반환 OR (||): 두 피연산자 중 하나라도 true이면 true 반환 NOT (!): 피연산자의 값을 반전 비교 연산 동등 비교 (==, ===) 부등 비교 (!=,!==) 대소 비교 (&lt;, >, &lt;=, >=) 실제 활용 사례 및 설명 조건문에서의 사용 플래그 변수로 사용 (예: 상태 체크) 데이터 유효성 검사 각 언어별 예시와 특징 각 언어의 특징적인 부분을 살펴보면:
...</p></div><footer class=entry-footer><span title='2024-10-07 07:33:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 논리값 (Boolean)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/boolean/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Flow</h2></header><div class=entry-content><p>Git Flow Git Flow 는 Vincent Driessen 이 2010 년 제안한 Git 브랜치 관리 전략으로, 프로젝트의 개발, 릴리스, 유지보수를 효과적으로 수행할 수 있도록 고안되었다. 각 브랜치의 역할을 명확히 정의하여 협업과 코드 품질을 향상시킨다. 주요 브랜치로는 main, develop, feature, release, hotfix 가 있으며, 각 브랜치는 특정 목적에 따라 생성되고 병합된다.
핵심 개념 브랜치 기반의 워크플로우 모델로, 각 브랜치가 명확한 목적과 생명주기를 가지고 있다. 이를 통해 기능 개발, 릴리즈 준비, 버그 수정 등의 작업을 체계적으로 관리할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;29 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/git-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git</h2></header><div class=entry-content><p>Git Git은 2005년 리누스 토르발스(Linus Torvalds)가 개발한 분산형 버전 관리 시스템으로, 코드 변경 이력을 체계적으로 추적하고 협업을 최적화한다. 각 개발자가 전체 저장소의 복사본을 로컬에 보유하며, 변경 사항을 로컬에서 커밋하고, 필요 시 원격 저장소와 동기화한다. 이를 통해 오프라인에서도 작업이 가능하며, 병합 및 분기 기능이 강력하여 협업에 유리하다.
Git의 핵심 설계 철학은 데이터를 일련의 스냅샷으로 저장하는 접근 방식으로, 다른 버전 관리 시스템과 차별화된다. 각 커밋은 프로젝트 파일의 전체 상태를 캡처하며, 변경되지 않은 파일은 이전 버전에 대한 링크로 효율적으로 저장된다. 이러한 구조는 빠른 성능, 데이터 무결성, 분산 작업 환경을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 07:28:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/vcs-theory/git-overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git Basic Commands</h2></header><div class=entry-content><p>Git Basic Commands Git Basic Commands는 버전 관리 시스템인 Git을 사용하기 위한 필수 명령어들의 집합입니다. 이 명령어들은 코드의 버전 관리, 협업, 이력 추적을 가능하게 하는 기본 도구이다. init, clone, add, commit, push, pull 등의 핵심 명령어들은 모든 Git 사용자가 일상적으로 사용하는 작업의 기반을 형성한다. 이러한 기본 명령어들을 이해하고 숙달하는 것은 효과적인 소프트웨어 개발과 팀 협업의 필수 요소이다.
핵심 개념 Git Basic Commands는 저장소 초기화, 변경사항 추적, 커밋 생성, 원격 저장소와의 동기화를 수행하는 기본 명령어들의 집합이다. 예를 들어, git add는 변경된 파일을 커밋 대상으로 지정하고, git commit은 실제로 변경 사항을 저장소에 기록한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 03:12:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Git Basic Commands" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/git-basic-commands/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Clean Code</h2></header><div class=entry-content><p>클린 코드 (Clean Code) 클린 코드는 단순히 작동하는 코드를 넘어, 이해하기 쉽고, 유지보수가 용이하며, 오류가 적고, 확장 가능한 코드를 의미한다.
로버트 C. 마틴(Robert C. Martin)의 저서 “Clean Code: A Handbook of Agile Software Craftsmanship"에서 체계적으로 정리된 이 개념은 오늘날 소프트웨어 개발의 핵심 가치로 자리 잡았다.
코드는 컴퓨터뿐만 아니라 다른 개발자들이 읽고 이해해야 하는 것이기 때문에, 클린 코드는 소프트웨어 개발 조직과 프로젝트의 장기적 성공에 중요한 역할을 한다.
클린 코드는 단순한 미학적 선호가 아니라 소프트웨어의 유지보수성, 확장성, 신뢰성을 위한 실질적인 접근 방식이다.
의미 있는 이름, 작고 집중된 함수, 적절한 주석, 일관된 형식, 적절한 추상화 등의 원칙을 따르면 더 나은 코드를 작성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-19 05:44:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Clean Code" href=https://buenhyden.github.io/posts/software-design-and-architecture/design-principles/clean-code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ANSI</h2></header><div class=entry-content><p>ANSI “ANSI 인코딩"이라는 용어는 실제로 약간의 혼란을 불러일으키는 명칭이다.
엄밀히 말하면, ANSI(American National Standards Institute)는 표준을 개발하고 승인하는 미국 비영리 조직의 이름이지, 특정 문자 인코딩이 아니다. 그러나 이 용어는 일반적으로 Windows 운영 체제에서 사용되는 특정 8비트 코드 페이지 집합을 지칭한다.
실제로 “ANSI 인코딩"이라고 불리는 것은 다음과 같다:
Windows 코드 페이지: Windows에서 기본 8비트 문자 세트로 사용되는 인코딩 ISO-8859 계열의 확장: ASCII의 7비트를 8비트로 확장한 다양한 문자 세트 로컬 시스템의 기본 인코딩: Windows의 지역 설정에 따라 달라지는 인코딩 이러한 혼란은 Windows가 등장한 초기에 마이크로소프트가 당시 발전 중이던 ANSI 표준을 기반으로 문자 세트를 개발했기 때문에 발생했다. 그러나 이 문자 세트들은 결국 정식 ANSI 표준으로 채택되지 않았으나, 이름은 그대로 남게 되었다.
...</p></div><footer class=entry-footer><span title='2025-01-24 04:36:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ANSI" href=https://buenhyden.github.io/posts/computer-science-fundamentals/fundamentals/encoding-and-decoding/character/types/ansi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Branching Strategies</h2></header><div class=entry-content><p>Branching Strategies Branch and Bound(분기한정법)은 조합 최적화 문제를 해결하기 위한 알고리즘 패러다임으로, 가능한 해결책의 공간을 체계적으로 탐색하여 최적의 해를 찾는 방법이다.
이 알고리즘의 핵심 요소 중 하나가 바로 ‘분기 전략(Branching Strategies)‘이다.
분기 전략은 문제 공간을 어떻게 분할하고 탐색할 것인지를 결정하며, 이는 알고리즘의 효율성과 성능에 직접적인 영향을 미친다.
문제 구조를 이해하고 적절한 분기 전략을 선택하는 것은 효율적인 알고리즘 구현을 위해 필수적이다. 변수 기반, 제약 기반, 문제 특화 분기 등 다양한 전략을 이해하고, 문제의 특성에 맞게 적용하거나 조합하는 능력이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-21 14:15:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branching Strategies" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/components/branching-strategies/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Branch and Bound vs. Backtracking</h2></header><div class=entry-content><p>Back Tracking vs. Branch and Bound 백트래킹(Backtracking)과 분기한정법(Branch and Bound)은 조합 최적화 문제를 해결하기 위한 두 가지 중요한 알고리즘 설계 패러다임이다.
두 기법 모두 모든 가능한 해결책을 체계적으로 탐색하지만, 그 접근 방식과 최적화 전략에는 중요한 차이가 있다.
백트래킹과 분기한정법은 조합 최적화 문제를 해결하기 위한 강력한 도구이다.
백트래킹은 제약 충족 문제에 더 적합하며, 가능한 모든 해결책이나 첫 번째 유효한 해결책을 찾는 데 중점을 둔다. 반면 분기한정법은 최적화 문제에 더 적합하며, 경계값을 사용하여 최적해를 효율적으로 찾는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2025-01-10 04:36:00 +0000 UTC'>January 10, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branch and Bound vs. Backtracking" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/problem-solving-techniques/branch-and-bound/branch-and-bound-vs-backtracking/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>