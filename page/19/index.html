<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.157.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json title=json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Django</h2></header><div class=entry-content><p>NodeJS vs. Django 웹 개발에서 백엔드 프레임워크를 선택하는 것은 프로젝트의 성공에 중요한 요소이다. Node.js와 Django는 각각 다른 철학, 접근 방식, 그리고 강점을 가진 인기 있는 두 가지 백엔드 기술이다.
Node.js와 Django는 각각 고유한 강점과 약점을 가진 강력한 백엔드 기술이다.
선택은 프로젝트의 요구사항, 팀의 전문성, 그리고 장기적인 목표에 따라 달라진다.
Node.js는 실시간 기능, 높은 동시성, 그리고 JavaScript의 일관성을 활용하려는 프로젝트에 적합하다.
빠른 프로토타이핑, 견고한 데이터 모델링, 내장된 관리 기능이 필요한 프로젝트에는 Django가 더 적합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:59:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to NodeJS vs. Django" href=https://buenhyden.github.io/posts/software-development/javascript-family/javascript/ecosystem--practice/runtime-environments/nodejs/nodejs-vs-django/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Django vs. Flask</h2></header><div class=entry-content><p>Django vs. Flask 비교 파이썬 환경에서 웹 개발을 시작할 때 가장 먼저 고민하게 되는 두 프레임워크인 Django와 Flask의 주요 차이점을 정리합니다.
핵심 개념 Django (Full-stack): “Batteries-included” 철학을 따르며, 인증, ORM, 어드민 패널 등 웹 개발에 필요한 모든 기능을 내장하고 있습니다. Flask (Micro-framework): 최소한의 기능만 제공하며, 필요한 확장 기능은 개발자가 직접 선택하여 추가하는 구조입니다. 주요 차이점 분석 특성 Django Flask 철학 전용 도구 세트 (Full-stack) 단순함과 유연성 (Micro) 학습 곡선 비교적 높음 (방대한 기능 때문) 낮음 (기초 파이썬 지식만으로 시작 가능) 프로젝트 구조 엄격하고 규격화됨 개발자가 자유롭게 구성 가능 적합한 사례 대규모 상용 서비스, 빠른 프로토타이핑 소규모 서비스, 마이크로서비스, 학습용 정리 및 학습 가이드 내용 정리 규격화된 개발: 다수의 개발자가 협업하거나 표준화된 구조가 중요한 경우 Django가 유리합니다. 유연한 실험: 특정 라이브러리를 직접 커스텀하거나 구조를 자유롭게 가져가고 싶을 때 Flask가 좋은 선택입니다. 용어 정리 용어 설명 ORM 객체 지향 언어와 관계형 데이터베이스를 연결해주는 기술로 Django의 강력한 핵심 기능 중 하나입니다. Batteries-included 별도의 설치 없이도 바로 사용할 수 있는 풍부한 표준 라이브러리를 갖추고 있다는 의미입니다. 참고 및 출처 Official Django Documentation Official Flask Documentation</p></div><footer class=entry-footer><span title='2024-12-22 03:44:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Django vs. Flask" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/web-frameworks/django/django-vs-flask/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>FastAPI vs. Django</h2></header><div class=entry-content><p>FastAPI vs. Django 비교 전통적인 웹 개발의 강자인 Django와 현대적인 고성능 API 개발의 신성 FastAPI를 비교 분석합니다.
핵심 개념 FastAPI: 파이썬 3.6+의 타입을 기반으로 구축된 현대적이고 빠른(고성능) 웹 프레임워크입니다. 비동기(Async) 처리에 최적화되어 있습니다. Django: 성숙하고 풍부한 기능을 갖춘 풀스택 프레임워크로, 대규모 애플리케이션 개발에 최적화된 “Batteries-included” 패키지입니다. 주요 차이점 분석 특성 FastAPI Django 주 목적 고성능 API 및 마이크로서비스 풀스택 웹 애플리케이션 비동기 지원 기본 지원 (Starlette & Pydantic 기반) Django 3.1부터 지원 추가 (점진적 도입 중) 데이터 검증 Pydantic을 활용한 자동 타입 검사 Django Forms 및 Serializers 활용 성능 매우 빠름 (Go/NodeJS와 대등할 정도) 표준적인 Python 웹 성능 수준 정리 및 학습 가이드 내용 정리 현대적 API 개발: 속도(성능)와 개발자의 생산성(자동 문서화 등)이 중요하다면 FastAPI가 현재 가장 매력적인 선택지입니다. 복잡한 비즈니스 로직: 어드민 페이지, 복잡한 DB 관계, 인증 시스템 등이 한 세트로 필요한 경우 Django의 생산성을 따라오기 어렵습니다. 용어 정리 용어 설명 Pydantic FastAPI의 데이터 유효성 검증과 설정 관리에 사용되는 파이썬 라이브러리입니다. ASGI 비동기 파이썬 웹 서버와 앱 간의 인터페이스로 FastAPI가 기본적으로 채택하고 있는 방식입니다. 참고 및 출처 FastAPI Documentation Django Project</p></div><footer class=entry-footer><span title='2024-12-22 03:44:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to FastAPI vs. Django" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/web-frameworks/fastapi/fastapi-vs-django/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>BunJS vs. NodeJS</h2></header><div class=entry-content><p>BunJS vs. NodeJS JavaScript는 원래 웹 브라우저에서만 실행되는 언어였지만, 서버 사이드 런타임의 등장으로 백엔드 개발에도 널리 사용되고 있다.
Node.js는 오랫동안 서버 사이드 JavaScript의 표준이었으나, Bun이라는 새로운 런타임이 등장하여 JavaScript 생태계에 변화를 가져오고 있다. 각기 다른 엔진과 설계 철학을 기반으로 개발되어 다양한 차이점을 보인다.
Node.js와 Bun은 각각 고유한 강점과 약점을 가진 JavaScript 런타임이다.
Node.js는 성숙한 생태계, 광범위한 호환성, 검증된 안정성을 제공하는 반면, Bun은 뛰어난 성능, 개선된 개발자 경험, 통합 도구를 제공한다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:43:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to BunJS vs. NodeJS" href=https://buenhyden.github.io/posts/software-development/javascript-family/javascript/ecosystem--practice/runtime-environments/bunjs/bunjs-vs-nodejs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Architectue Patterns</h2></header><div class=entry-content><p>Architectue Patterns 1. 주제의 분류 적절성 주제인 “Architectural Patterns” 는 “Computer Science and Engineering > Architecture Knowledge > Architectural Styles and Patterns” 에 속하며, 소프트웨어 아키텍처 설계의 핵심 개념 중 하나입니다.
1. 주제 분류의 적절성 “Architectural Patterns(아키텍처 패턴)” 은 “Computer Science and Engineering > Architecture Knowledge > Architectural Styles and Patterns” 분류에 매우 적합합니다. 아키텍처 패턴은 소프트웨어 아키텍처의 구조적 설계와 반복적으로 등장하는 문제에 대한 검증된 해결책을 제공하는 핵심 지식 체계로, 이 카테고리의 주요 주제에 해당합니다 [2][3][5].
...</p></div><footer class=entry-footer><span title='2024-12-21 05:26:00 +0000 UTC'>December 21, 2024</span>&nbsp;·&nbsp;<span>28 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Architectue Patterns" href=https://buenhyden.github.io/posts/software-development/architecture--design/overview/architectue-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Format</h2></header><div class=entry-content><p>Format 데이터 포맷은 정보를 구조화하고, 저장하며, 교환하는 표준화된 방식이다. 데이터 포맷은 IT 시스템 간의 효율적인 통신과 데이터 처리의 기반이 되며, 다양한 응용 프로그램과 시스템에서 데이터를 해석하고 활용하는 방식을 결정한다.
데이터 포맷은 현대 IT 환경에서 정보 교환과 저장의 핵심 요소이다. 적절한 데이터 포맷을 선택하고 효과적으로 구현하는 것은 시스템의 성능, 확장성, 유지보수성에 직접적인 영향을 미친다.
데이터 포맷의 기본 개념 데이터 포맷은 데이터를 표현하는 구조화된 양식으로, 다음과 같은 역할을 한다:
데이터 구조화: 원시 데이터를 의미 있는 형태로 구조화한다. 데이터 교환: 서로 다른 시스템 간에 데이터를 교환할 수 있게 한다. 데이터 저장: 정보를 효율적으로 저장하고 검색할 수 있게 한다. 데이터 표준화: 데이터 처리 방식을 표준화하여 호환성을 보장한다. 주요 데이터 포맷 유형 텍스트 기반 데이터 포맷 JSON (JavaScript Object Notation) JSON은 경량화된 데이터 교환 형식으로, 사람이 읽고 쓰기 쉬우며 기계가 파싱하고 생성하기 쉽다.
...</p></div><footer class=entry-footer><span title='2024-12-16 12:27:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;<span>16 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Format" href=https://buenhyden.github.io/posts/computer-science/data-fundamentals/data-types--formats/exchange-formats/__index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RFC 9457</h2></header><div class=entry-content><p>RFC 9457 RFC 9457은 그 후속 버전으로, HTTP API의 오류 응답을 구조화된 형식으로 전달하기 위한 표준이다.
이 문서는 RFC 7807을 대체하며, 이전 버전에서의 경험과 피드백을 반영하여 몇 가지 중요한 개선사항을 도입했다.
RFC 9457의 주요 개선사항 RFC 9457은 RFC 7807을 기반으로 다음과 같은 주요 개선점을 포함하고 있다.
문제 유형(type) 필드의 명확화
기존: type 필드는 문제의 유형을 식별하는 URI로 사용되었지만, 그 사용 방식이 모호할 수 있다. 개선: type 필드의 사용을 명확히 정의하고, 공용 레지스트리를 통해 표준화된 문제 유형을 관리하도록 권장하고 있다. 여러 문제의 표현 지원
...</p></div><footer class=entry-footer><span title='2024-12-15 14:25:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to RFC 9457" href=https://buenhyden.github.io/posts/software-development/platform-development/backend-development/api-development/api-styles/rest/restful-api/error-handling/rfc-9457/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RFC 7807</h2></header><div class=entry-content><p>RFC 7807: Problem Details for HTTP APIs RFC 7807은 HTTP API에서 오류 상황을 일관되고 기계가 처리하기 쉬운 방식으로 전달하기 위한 표준이다. 이 규격은 “Problem Details for HTTP APIs"라는 제목으로 2016년 3월에 공식 발표되었으며, HTTP API에서 발생한 오류 상황을 구조화된 JSON 또는 XML 형식으로 표현하는 방식을 정의한다.
발표: 2016년 3월
저자: Mark Nottingham 외
상태: Proposed Standard (표준화 단계의 공식 규격)
RFC 7807의 배경과 목적 HTTP API는 다양한 클라이언트와 통신하며, 여러 오류 상황에 직면한다. 전통적으로 각 API는 자체적인 오류 응답 형식을 정의했는데, 이로 인해 클라이언트 개발자는 API마다 다른 오류 처리 로직을 구현해야 했다.
...</p></div><footer class=entry-footer><span title='2024-12-15 14:24:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to RFC 7807" href=https://buenhyden.github.io/posts/software-development/platform-development/backend-development/api-development/api-styles/rest/restful-api/error-handling/rfc-7807/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DKIM (DomainKeys Identified Mail)</h2></header><div class=entry-content><p>DKIM (DomainKeys Identified Mail) DKIM은 이메일 인증을 위한 중요한 기술로, 이메일이 전송 과정에서 변조되지 않았으며 실제로 발신자가 주장하는 도메인에서 보낸 것임을 확인할 수 있게 해준다.
디지털 서명을 사용하여 이메일의 무결성과 출처를 검증하는 방식으로 작동한다.
DKIM은 현대 이메일 인증의 핵심 구성 요소로, 이메일이 전송 과정에서 변조되지 않았으며 실제로 주장하는 도메인에서 왔음을 보장한다. SPF 및 DMARC와 함께 사용할 때, DKIM은 피싱, 스푸핑 및 스팸으로부터 이메일 시스템을 보호하는 강력한 도구이다.
DKIM을 효과적으로 구현하려면 강력한 암호화 키, 적절한 서명 범위, 안전한 키 관리 및 정기적인 모니터링이 필요하다. 이러한 모범 사례를 따르면 이메일 보안을 강화하고 전달률을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-14 09:45:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to DKIM (DomainKeys Identified Mail)" href=https://buenhyden.github.io/posts/computer-science/core-protocols/application-layer/protocols/email/email-security/dkim/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DMARC (Domain-based Message Authentication, Reporting, and Conformance)</h2></header><div class=entry-content><p>DMARC (Domain-based Message Authentication, Reporting, and Conformance) DMARC는 이메일 인증 프로토콜로, SPF(Sender Policy Framework)와 DKIM(DomainKeys Identified Mail)을 기반으로 작동하는 포괄적인 이메일 보안 솔루션이다. 2012년에 공식적으로 도입된 DMARC는 도메인 소유자가 자신의 도메인에서 보내는 이메일을 보호하고, 다른 사람이 해당 도메인을 사칭하여 이메일을 보내는 것을 방지하는 메커니즘을 제공한다.
DMARC는 세 가지 핵심 기능을 제공한다:
인증 정책 설정: 도메인 소유자가 SPF 및 DKIM 인증이 실패할 경우 수신 서버가 어떻게 대응해야 하는지 명확한 지침을 제공할 수 있다. 정렬(Alignment) 확인: 이메일의 ‘From’ 헤더가 SPF 및 DKIM에서 인증된 도메인과 일치하는지 확인한다. 보고 기능: 도메인 소유자에게 자신의 도메인을 사용하여 전송된 모든 이메일(인증 성공 및 실패 모두)에 대한 상세한 보고서를 제공한다. DMARC의 중요성 DMARC는 현대 이메일 보안 인프라에서 다음과 같은 이유로 중요한 역할을 한다:
...</p></div><footer class=entry-footer><span title='2024-12-14 03:24:00 +0000 UTC'>December 14, 2024</span>&nbsp;·&nbsp;<span>8 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to DMARC (Domain-based Message Authentication, Reporting, and Conformance)" href=https://buenhyden.github.io/posts/computer-science/core-protocols/application-layer/protocols/email/email-security/dmarc/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/18/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/20/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>