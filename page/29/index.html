<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC API</h2></header><div class=entry-content><p>gRPC API gRPC(gRPC Remote Procedure Call)는 Google에서 개발한 오픈소스 원격 프로시저 호출(RPC) 시스템.
이 시스템은 효율적이고 빠른 서비스 간 통신을 제공하며, 다양한 프로그래밍 언어와 플랫폼에서 사용할 수 있다.
gRPC는 특히 다음과 같은 상황에서 유용하다:
마이크로서비스 아키텍처 서비스 간 효율적인 통신 강력한 타입 안정성 뛰어난 성능 실시간 통신이 필요한 시스템 채팅 애플리케이션 실시간 모니터링 게임 서버 모바일 애플리케이션 효율적인 데이터 전송 배터리 사용량 최적화 네트워크 대역폭 절약 gRPC의 주요 특징 Protocol Buffers 사용: gRPC는 데이터 직렬화를 위해 Protocol Buffers를 사용합니다. 이는 JSON이나 XML보다 더 작고 빠른 데이터 포맷을 제공합니다. HTTP/2 기반: HTTP/2 프로토콜을 사용하여 높은 성능과 낮은 지연 시간을 제공합니다. 양방향 스트리밍: 클라이언트와 서버 간의 양방향 스트리밍을 지원하여 실시간 데이터 교환이 가능합니다. 다양한 언어 지원: Java, Python, Go, C++, Ruby 등 다양한 프로그래밍 언어를 지원합니다. 강력한 타입 시스템: Protocol Buffers를 통해 강력한 타입 시스템을 제공하여 타입 안정성을 보장합니다. gRPC 작동 방식 서비스 정의:.proto 파일에 서비스와 메시지 구조를 정의합니다. 코드 생성: Protocol Buffer 컴파일러를 사용하여 서버와 클라이언트 코드를 자동으로 생성합니다. 서버 구현: 생성된 코드를 기반으로 서버 비즈니스 로직을 구현합니다. 클라이언트 구현: 생성된 클라이언트 코드를 사용하여 서버와 통신합니다. gRPC의 통신 유형 Unary RPC: 클라이언트가 단일 요청을 보내고 서버가 단일 응답을 반환합니다.
...</p></div><footer class=entry-footer><span title='2024-10-21 03:22:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;344 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gRPC API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/grpc-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RESTful API</h2></header><div class=entry-content><p>RESTful API(Representational State Transfer API) 웹 서비스를 설계하고 구현하기 위한 아키텍처 스타일
RESTful API는 HTTP 프로토콜을 기반으로 하며, 클라이언트와 서버 간의 통신을 위한 표준화된 방식을 제공한다.
RESTful API의 주요 특징 자원 중심 구조: URI를 통해 자원을 명확하게 표현합니다. HTTP 메서드 활용: GET, POST, PUT, DELETE 등의 HTTP 메서드를 사용하여 자원에 대한 CRUD 작업을 수행합니다. 무상태성(Stateless): 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 균일한 인터페이스: 일관된 방식으로 자원에 접근할 수 있습니다. 설계 원칙 자원 식별: URI를 통해 자원을 명확하게 식별합니다. HTTP 메서드 사용: 적절한 HTTP 메서드를 사용하여 자원에 대한 작업을 수행합니다. 자체 설명적 메시지: 요청과 응답은 자체적으로 이해할 수 있어야 합니다. HATEOAS(Hypermedia as the Engine of Application State): 응답에 관련 리소스의 링크를 포함합니다. 주요 제약 조건 클라이언트-서버 구조를 통해 관심사를 분리합니다. 이는 클라이언트와 서버가 독립적으로 발전할 수 있게 해줍니다. 예를 들어, 서버는 데이터 저장 방식을 변경할 수 있고, 클라이언트는 사용자 인터페이스를 개선할 수 있습니다. 무상태성(Stateless)을 유지합니다. 각 요청은 이전 요청과 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 이는 시스템의 확장성을 높여주지만, 매 요청마다 필요한 모든 정보를 포함해야 한다는 의미이기도 합니다. 캐시 가능성을 제공합니다. HTTP의 캐싱 메커니즘을 활용하여 성능을 개선할 수 있습니다. 예를 들어, 자주 변경되지 않는 사용자 프로필 이미지는 클라이언트에서 캐시할 수 있습니다. RESTful API 구현 예시 다음은 Node.js와 Express.js를 사용한 간단한 RESTful API 예제입니다:
...</p></div><footer class=entry-footer><span title='2024-10-21 03:21:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;482 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/restful-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOAP API</h2></header><div class=entry-content><p>SOAP API SOAP(Simple Object Access Protocol) API는 XML 기반의 메시지 교환 프로토콜.
분산 환경에서 데이터를 교환하기 위해 설계된 웹 서비스 통신 방식.
SOAP API의 주요 특징 XML 기반: 모든 SOAP 메시지는 XML 형식으로 구성됩니다. 프로토콜 독립성: HTTP, SMTP 등 다양한 프로토콜을 통해 전송될 수 있습니다. 표준화: 잘 정의된 표준을 따르며, 이는 다양한 플랫폼과 언어 간의 호환성을 보장합니다. 보안성: WS-Security와 같은 웹 서비스 보안 표준을 지원합니다. SOAP 메시지 구조 SOAP 메시지는 다음과 같은 요소로 구성됩니다:
...</p></div><footer class=entry-footer><span title='2024-10-21 03:21:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOAP API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/soap-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Process</h2></header><div class=entry-content><p>Process 프로세스는 실행 중인 프로그램의 인스턴스.
구체적으로는 운영체제가 관리하는 작업의 단위로, CPU 시간이나 메모리와 같은 시스템 자원을 할당받아 실행되는 프로그램의 동적인 실체를 의미한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
특징 독립성: 각 프로세스는 독립된 메모리 공간을 가진다. 동시성: 여러 프로세스가 동시에 실행될 수 있다. 상태 변화: 프로세스는 실행 중 여러 상태를 거친다. 기능과 역할 기능:
작업 단위: 운영체제가 관리하는 작업의 기본 단위입니다. 프로그램 코드 실행: 프로세스는 프로그램의 명령어들을 순차적으로 실행합니다. 자원 관리: 할당받은 시스템 자원을 효율적으로 사용하고 관리합니다. 프로세스 간 통신: 다른 프로세스와 정보를 교환하고 협력합니다. 역할:
...</p></div><footer class=entry-footer><span title='2024-10-20 23:32:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;720 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Process" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/process/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>소켓(Socket)</h2></header><div class=entry-content><p>소켓(Socket) 소켓은 네트워크 상에서 수행되는 두 프로그램 간의 양방향 통신 링크의 한쪽 끝 단을 의미한다.
소켓은 프로세스가 네트워크를 통해 데이터를 송수신하기 위한 실제적인 창구 역할을 한다.
운영체제는 소켓을 통해 네트워크 통신을 위한 인터페이스를 제공한다.
소켓의 구성 요소 소켓은 다음 세 가지 요소로 구성된다:
프로토콜: 데이터 전송을 위한 표준 집합 규칙 (예: TCP/IP, UDP/IP) IP 주소: 서버 또는 클라이언트의 주소 포트 번호: 통신을 사용하는 애플리케이션을 식별하는 번호 소켓의 특징 프로토콜, IP 주소, 포트 번호로 정의된다. 서버 소켓과 클라이언트 소켓으로 구분된다. 실시간 데이터 전송에 적합하다. 소켓 통신의 장점 실시간 양방향 통신이 가능하다. 서버와 클라이언트 간 지속적인 연결을 유지할 수 있다. 소켓 통신의 단점 HTTP 통신에 비해 구현이 복잡할 수 있다. 지속적인 연결 유지로 인한 리소스 소비가 있을 수 있다. 소켓의 종류 소켓은 크게 두 가지 유형으로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-20 16:30:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;561 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소켓(Socket)" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/socket/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>가상 메모리 (Virtual Memory)</h2></header><div class=entry-content><p>가상 메모리 (Virtual Memory) 가상 메모리(Virtual Memory)는 운영체제의 메모리 관리 기법 중 하나로, 물리적 메모리의 한계를 극복하고 더 큰 메모리 공간을 제공하는 기술이다.
실제 물리적 메모리(RAM)의 크기에 관계없이 프로그램이 사용할 수 있는 메모리 공간을 확장하며, 프로그램의 주소 공간을 실제 메모리에서 분리하여 가상 주소 공간을 제공한다.
가상 메모리가 필요한 이유:
메모리 제약 극복
프로그램의 크기가 실제 물리적 메모리보다 클 수 있다.
예를 들어 16GB RAM을 가진 컴퓨터에서 20GB가 필요한 프로그램을 실행할 수 있게 된다. 메모리 보호
각 프로세스는 자신만의 가상 주소 공간을 가지므로, 다른 프로세스의 메모리에 접근할 수 없다. 메모리 효율성
실제로 사용되는 부분만 물리적 메모리에 적재함으로써 메모리를 효율적으로 사용할 수 있다. Source: https://cse.poriyaan.in/topic/virtual-memory-50746/#google_vignette
...</p></div><footer class=entry-footer><span title='2024-10-20 13:37:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1121 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가상 메모리 (Virtual Memory)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>세그먼테이션 (Segmentation)</h2></header><div class=entry-content><p>세그먼테이션 (Segmentation) 세그먼테이션(Segmentation)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 논리적 단위인 세그먼트로 나누어 관리하는 방식이다.
세그먼테이션의 기본 개념을 이해하기 위해, 먼저 프로그램의 구조를 생각해보자.
일반적인 프로그램은 코드 영역, 데이터 영역, 스택 영역 등 서로 다른 목적을 가진 영역들로 구성된다.
세그먼테이션은 이러한 논리적 단위들을 각각의 세그먼트로 관리한다.
Source: https://www.geeksforgeeks.org/segmentation-in-operating-system/
세그먼테이션의 주요 구성 요소와 작동 방식 세그먼트 테이블(Segment Table):
1 2 3 4 5 6 7 8 9 10 struct SegmentTableEntry { uint32_t base; // 세그먼트의 시작 주소 uint32_t limit; // 세그먼트의 크기 bool present; // 메모리 존재 여부 struct { bool read; // 읽기 권한 bool write; // 쓰기 권한 bool execute; // 실행 권한 } protection; }; 주소 변환 과정:
논리적 주소는 다음과 같이 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-20 13:37:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;314 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 세그먼테이션 (Segmentation)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>페이징 (Paging)</h2></header><div class=entry-content><p>페이징 (Paging) 먼저 페이징이 필요한 배경을 이해해보자.
초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.
이는 두 가지 큰 문제를 발생시켰다:
큰 프로그램은 메모리에 적재하기 어려웠다. 메모리 단편화(fragmentation)가 심각했다.
이러한 문제를 해결하기 위해 페이징이 도입되었다. 페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 ‘페이지(page)‘라 하고, 물리적 메모리의 단위를 ‘프레임(frame)‘이라고 한다.
Source: https://www.geeksforgeeks.org/paging-in-operating-system/
페이징 시스템의 주요 구성 요소 페이지 테이블(Page Table):
...</p></div><footer class=entry-footer><span title='2024-10-20 13:37:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;509 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 페이징 (Paging)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queue</h2></header><div class=entry-content><p>메시지 큐(Message Queue) 프로세스 간 통신(IPC)의 메시지 큐(Message Queue)는 프로세스 간에 데이터를 교환하는 메커니즘이다.
메시지 큐는 커널 내에 저장된 메시지의 연결 리스트로, 고유한 식별자로 구분된다.
이는 프로세스들이 비동기적으로 통신할 수 있게 해주는 IPC 메커니즘이다.
메시지 크기 제한과 시스템 리소스 사용 등의 단점도 고려해야 한다.
적절한 사용 시나리오를 파악하고 효과적으로 활용하는 것이 중요하다.
Source: https://www.javatpoint.com/ipc-using-message-queues
메시지 큐의 특징 커널 관리: 메시지 큐는 커널에 의해 관리되어 안정성이 높고 동기화가 용이하다. FIFO 순서: 메시지는 일반적으로 선입선출(FIFO) 순서로 처리된다. 비동기 통신: 송신 프로세스와 수신 프로세스가 동시에 활성화될 필요가 없다. 메시지 구조: 각 메시지는 타입 필드, 길이, 실제 데이터로 구성된다. 프로세스 분리: 메시지 큐를 사용하면 프로세스들이 서로 직접 연결되지 않아도 된다. 메시지 큐의 주요 시스템 호출 ftok(): 고유한 키를 생성한다. msgget(): 메시지 큐를 생성하거나 기존 큐의 식별자를 반환한다. msgsnd(): 메시지를 큐에 추가한다. msgrcv(): 큐에서 메시지를 검색한다. msgctl(): 큐에 대한 다양한 작업을 수행한다. 메시지 큐 사용 방법 메시지 큐 생성:
...</p></div><footer class=entry-footer><span title='2024-10-20 12:03:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;246 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/message-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shared Memory</h2></header><div class=entry-content><p>공유 메모리(Shared Memory) 공유 메모리(Shared Memory)는 운영체제의 프로세스 간 통신(IPC) 기법 중 하나로, 여러 프로세스가 동시에 접근할 수 있는 메모리 영역이며, 커널에 의해 생성되고 관리되는 공통 메모리 공간이다.
이는 여러 프로세스가 동일한 물리적 메모리 영역에 접근할 수 있게 해주며, IPC 메커니즘 중에서 가장 빠른 통신 방법을 제공한다.
Source: https://www.geeksforgeeks.org/ipc-shared-memory/
작동 원리 프로세스가 커널에 공유 메모리 할당을 요청 커널이 해당 프로세스에 메모리 공간을 할당 이후 다른 프로세스들도 해당 메모리 영역에 접근 가능 공유 메모리의 생성과 관리 공유 메모리를 사용하는 일반적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-20 12:03:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;354 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Memory" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/ipc/shared-memory/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/28/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/30/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>