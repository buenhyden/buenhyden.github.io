<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback Vs Promise Vs Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:07:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;728 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback-vs-promise-vs-async-await/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking</h2></header><div class=entry-content><p>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking 카테고리 동기(Synchronous) 비동기(Asynchronous) Blocking Non-Blocking 핵심 개념 작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업을 시작하지 않음 작업들이 독립적으로 실행되며, 이전 작업의 완료를 기다리지 않고 다음 작업 수행 가능 호출된 함수가 작업을 완료할 때까지 제어권을 반환하지 않음 호출된 함수가 작업 완료 여부와 관계없이 즉시 제어권을 반환함 작업 처리 방식 순차적으로 작업을 처리하며, 각 작업이 완료된 후 다음 작업 시작 여러 작업이 동시에 처리될 수 있으며, 작업 완료 순서는 불확실할 수 있음 호출한 함수는 작업이 완료될 때까지 대기 상태 유지 호출한 함수는 작업 진행 중에도 다른 작업 수행 가능 제어 흐름 프로그램의 제어 흐름이 순차적이고 예측 가능함 제어 흐름이 비선형적이며, 콜백이나 이벤트로 처리 제어권이 호출된 함수에 완전히 넘어감 제어권이 호출한 함수에 즉시 반환됨 결과 처리 작업 완료 후 바로 결과를 반환받아 처리 콜백 함수, Promise, async/await 등을 통해 결과 처리 결과를 직접 반환받아 처리 상태 확인이나 콜백을 통해 결과 처리 주요 특징 - 코드의 실행 순서가 명확함
- 직관적인 코드 흐름
- 단순한 구현 - 작업의 병렬 처리 가능
- 복잡한 이벤트 처리
- 높은 확장성 - 자원을 점유하며 대기
- 단순한 구현
- 예측 가능한 실행 - 자원의 효율적 활용
- 복잡한 구현
- 높은 동시성 에러 처리 try-catch 블록으로 즉시 에러 처리 가능 Promise의 catch나 async/await의 try-catch로 처리 동기적 에러 처리 가능 비동기적 에러 처리 메커니즘 필요 성능 특성 - 단순 작업에서 오버헤드 적음
- 순차 처리로 인한 대기 시간 발생 - 동시 처리로 인한 전체 처리 시간 감소
- 컨텍스트 스위칭 오버헤드 - I/O 작업에서 성능 저하
- 리소스 독점 - 리소스 효율적 활용
- 높은 처리량 적합한 사용 사례 - 간단한 계산 작업
- 메모리 내 데이터 처리
- 순차적 처리 필요 작업 - 네트워크 요청
- 대용량 파일 처리
- 독립적 실행 가능 작업 - CPU 연산 작업
- 간단한 파일 작업
- 메모리 작업 - I/O 작업
- 네트워크 통신
- 대용량 처리 실행 순서 코드 작성 순서와 실행 순서가 동일 실행 순서가 코드 작성 순서와 다를 수 있음 작업 완료 순서가 예측 가능 작업 완료 순서가 불확실 자원 활용 단일 자원을 순차적으로 사용 여러 자원을 동시에 효율적으로 활용 자원을 독점적으로 사용 자원을 공유하여 사용 응답성 작업 완료 전까지 다른 작업 불가 여러 작업의 동시 처리로 높은 응답성 대기 시간 동안 응답 불가 지속적인 응답 가능 디버깅 코드 흐름 추적이 용이함 비동기 로직으로 인한 디버깅 어려움 문제 발생 지점 파악 쉬움 문제 발생 지점 추적 어려움 확장성 수직적 확장에 제한적 수평적/수직적 확장 용이 동시 처리 능력 제한적 높은 동시성 처리 가능 데이터 일관성 데이터 일관성 보장이 쉬움 경쟁 조건 고려 필요 순차적 처리로 일관성 보장 동시성 제어 메커니즘 필요 추가적인 고려사항:
...</p></div><footer class=entry-footer><span title='2024-10-06 12:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1302 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/synchronous-and-asynchronous-and-blocking-and-non-blocking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock and Mutex</h2></header><div class=entry-content><p>Lock and Mutex Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.
특성 Mutex Lock 기본 개념 상호 배제를 위한 동기화 객체로, 소유권 개념이 있음 일반적인 동기화 메커니즘으로, 단순한 잠금/해제 기능 소유권 소유권 개념이 있어 획득한 스레드만 해제 가능 소유권 개념이 없어 다른 스레드도 해제 가능 재진입성 보통 재진입 가능 (같은 스레드가 여러 번 획득 가능) 구현에 따라 재진입 가능할 수 있음 용도 스레드 간 엄격한 상호 배제가 필요한 경우 간단한 동기화가 필요한 일반적인 상황 성능 소유권 검사 등으로 인한 오버헤드 존재 상대적으로 가벼운 오버헤드, 단 구현에 따라 다름 에러 처리 소유권 위반 시 예외 발생 가능 단순한 실패/성공 여부만 반환 구현 복잡도 상대적으로 복잡한 구현 단순한 구현, 그러나 고급 기능 추가 시 복잡해질 수 있음 적용 범위 프로세스 내 스레드 간 동기화 프로세스 내 또는 프로세스 간 동기화에 사용 가능 우선순위 상속 우선순위 상속 지원 가능 일반적으로 지원하지 않음, 구현에 따라 다를 수 있음 교착상태 처리 소유권 추적으로 교착상태 감지 용이 기본적인 교착상태 감지만 가능 에러 검사 상세한 에러 검사 및 보고 기능 기본적인 에러 검사, 구현에 따라 확장 가능 메모리 사용 소유권 정보 저장으로 추가 메모리 필요 최소한의 메모리 사용 유연성 엄격한 규칙으로 유연성 제한 상대적으로 유연한 사용 가능 디버깅 소유권 정보로 디버깅 용이 디버깅이 상대적으로 어려움, 구현에 따라 다를 수 있음 사용 예시 데이터베이스 트랜잭션, 파일 시스템 접근 간단한 공유 자원 보호, 카운터 타임아웃 지원 보통 타임아웃 기능 내장 구현에 따라 타임아웃 지원 가능 복구 기능 비정상 종료 시 자동 복구 지원 구현에 따라 자동 복구 기능 추가 가능 중첩 사용 재진입성으로 중첩 사용 가능 구현에 따라 중첩 사용 가능, 주의 필요 시스템 수준 주로 커널 수준에서 구현 사용자 수준 및 커널 수준 모두에서 구현 가능 표준화 POSIX 표준으로 잘 정의됨 구현에 따라 동작이 다를 수 있음 성능 특성 경쟁 상황에서 성능 저하 가능 스핀락 구현 시 짧은 대기 시간에 효율적 공정성 일반적으로 공정성 메커니즘 내장 구현에 따라 공정성 보장 여부가 다름 실제 구현 시에는 고려할 사항 동시성 요구사항 (얼마나 많은 스레드가 동시에 접근하는가) 성능 요구사항 (응답 시간, 처리량 등) 리소스 사용량 (메모리, CPU 사용률) 오류 처리 및 복구 요구사항 데드록 방지 필요성 플랫폼 및 운영체제의 지원 여부 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-05 11:25:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;359 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock and Mutex" href=https://buenhyden.github.io/posts/computer-science/lock-and-mutex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis와 Valkey</h2></header><div class=entry-content><p>Redis와 Valkey Redis는 원래 오픈소스 프로젝트로 시작되었지만, 최근 라이선스 정책을 변경하여 더 이상 완전한 오픈소스가 아니다. 이에 반해 Valkey는 Redis의 오픈소스 정신을 계승하기 위해 만들어진 프로젝트로, Linux Foundation의 관리 하에 있다.
특징 Valkey Redis 라이선스 BSD 3-clause 오픈 소스 Redis Source Available (제한적 오픈 소스) 커뮤니티 지원 AWS, Oracle 등이 지원하는 커뮤니티 주도 Redis Inc.가 상업적으로 지원 멀티스레딩 I/O 및 명령 실행을 위한 향상된 멀티스레드 아키텍처 대부분의 작업이 단일 스레드 복제 이중 채널 복제 마스터-슬레이브 복제 및 Redis Cluster 지원 확장성 자동 클러스터 장애 조치 및 개선된 확장성 클러스터링 및 샤딩 지원 관찰 가능성 상세한 모니터링을 위한 슬롯별 메트릭 제공 기본적인 모니터링 및 메트릭 RDMA 지원 RDMA에 대한 실험적 지원 기본 RDMA 지원 없음 플랫폼 지원 Linux, macOS, OpenBSD, NetBSD, FreeBSD Windows, Linux, macOS 개발 초점 높은 처리량과 낮은 지연 시간 고성능 및 데이터 지속성 기능 세트 Redis 7.2.4 기반, 일부 고급 기능 부족 더 광범위한 기능 세트 (JSON, TimeSeries 등) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 01:34:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;154 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Redis와 Valkey" href=https://buenhyden.github.io/posts/databases/nosql/key-value/redis%EC%99%80-valkey/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>마이그레이션 (Migration)</h2></header><div class=entry-content><p>마이그레이션 (Migration) 마이그레이션(Migration)은 IT 분야에서 데이터, 시스템, 애플리케이션 등을 한 환경에서 다른 환경으로 이동하는 과정을 의미한다.
마이그레이션은 기존 시스템 환경에서 새로운 환경으로 전환하는 것을 의미한다.
주요 목적은 비즈니스 선진화와 비용 절감, 시스템 성능 향상, 보안 강화 등이다.
마이그레이션의 유형 데이터 마이그레이션: 데이터를 한 스토리지에서 다른 스토리지로 이동. 애플리케이션 마이그레이션: 소프트웨어를 새로운 환경으로 이동. 클라우드 마이그레이션: 온프레미스에서 클라우드로, 또는 클라우드 간 이동. 비즈니스 프로세스 마이그레이션: 비즈니스 운영 방식 최적화를 위한 이동. 마이그레이션 전략 (6R) Rehost (리호스팅): 애플리케이션 구조 변경 없이 클라우드로 전환 Replatform (리플랫폼): 클라우드 환경의 일부 서비스를 활용하여 전환 Refactor (리팩터): 클라우드 환경에 적합하게 애플리케이션 구조 변경 Repurchase (리퍼체이스): 기존 시스템을 SaaS로 대체 Retire (리타이어): 기존 시스템 폐기 Retain (리테인): 현 상태 유지 마이그레이션 과정 계획: 요구사항 분석, 목표 설정, 전략 수립 실행: 데이터 또는 시스템 이전 검증: 이전된 데이터나 시스템의 정확성 및 성능 확인 주의사항 데이터 손실 위험: 마이그레이션 중 데이터 손실 가능성 고려 보안: 데이터 암호화 및 보안 조치 필요 호환성: 새 환경과의 호환성 확인 성능: 마이그레이션 후 성능 저하 가능성 고려 비용: 예상치 못한 추가 비용 발생 가능성 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-19 15:05:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;174 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 마이그레이션 (Migration)" href=https://buenhyden.github.io/posts/backend/scalability/migration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC</h2></header><div class=entry-content><p>RESTful API Vs GraphQL API Vs Webhook Vs Server-sent Events Vs Websocket Vs WebRTC API의 여러 유형인 RESTful API, GraphQL API, Webhook, Server-sent Events, WebSocket, WebRTC에 대해 정리하고 비교 분석해보자.
RESTful API는 HTTP 프로토콜을 기반으로 하는 웹 서비스 아키텍처이다. 리소스를 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 리소스를 조작한다. 클라이언트-서버 모델을 따르며, 상태를 저장하지 않는 특징이 있다.
GraphQL은 페이스북에서 개발한 쿼리 언어 및 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청할 수 있게 해준다. 단일 엔드포인트를 사용하며, 클라이언트가 쿼리를 정의하여 필요한 데이터만 받을 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-19 06:08:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;309 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API vs GraphQL API vs Webhook vs Server-sent Events vs Websocket vs WebRTC" href=https://buenhyden.github.io/posts/backend/api-design/restful-api-vs-graphql-api-vs-webhook-vs-server-sent-events-vs-websocket-vs-webrtc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Webhook vs Server-Sent Events</h2></header><div class=entry-content><p>Webhook Vs Server-Sent Events Webhook과 Server-Sent Events(SSE)는 실시간 데이터 전송을 위한 웹 기술이다.
Webhook은 특정 이벤트가 발생했을 때 HTTP POST 요청을 통해 다른 애플리케이션에 실시간으로 데이터를 전송하는 방식으로, 애플리케이션 간 실시간 통신을 가능하게 하며, 이벤트 기반 업데이트를 제공한다.
Server-Sent Events (SSE)은 서버에서 클라이언트로 단방향 실시간 데이터 스트림을 제공하는 기술로, 서버가 클라이언트에게 지속적으로 업데이트를 푸시할 수 있게 한다.
두 기술 모두 실시간 데이터 전송을 위해 사용되지만, 각각의 특성에 따라 적절한 상황에서 선택하여 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-19 06:04:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;180 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Webhook vs Server-Sent Events" href=https://buenhyden.github.io/posts/backend/api-design/webhook-vs-server-sent-events/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg Vs pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:29:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;602 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud vs. On-Premise</h2></header><div class=entry-content><p>Cloud Vs On-Premise Cloud와 On-Premise는 기업의 IT 인프라를 구축하고 관리하는 두 가지 주요 방식을 설명하는 개념이다.
이 두 방식은 데이터 저장, 애플리케이션 호스팅, 그리고 전반적인 IT 리소스 관리에 있어 근본적인 차이를 보인다.
비교 항목 On-Premise 클라우드 초기 구축 비용 - 서버, 네트워크 장비 등 높은 초기 투자 필요
- 데이터센터 구축 비용 발생
- 소프트웨어 라이선스 구매 필요 - 초기 투자 비용 최소화
- 필요한 만큼만 시작 가능
- 하드웨어 구매 불필요 운영 비용 - 예측 가능한 고정 비용
- 전담 IT 인력 필요
- 전기, 냉각 등 관리 비용 발생 - 사용량 기반 과금
- 탄력적인 비용 구조
- 운영 인력 최소화 가능 확장성 - 물리적 인프라 확장 필요
- 확장 시 많은 시간과 비용 소요
- 사전 용량 계획 중요 - 필요에 따라 즉시 확장 가능
- 자동 확장/축소 지원
- 글로벌 확장 용이 보안 - 물리적 보안 직접 통제
- 데이터 위치 완벽 통제
- 자체 보안 정책 수립 가능 - 서비스 제공자의 보안 정책 따름
- 공유 인프라 사용
- 데이터 위치 선택 제한적 유지보수 - 모든 유지보수 직접 담당
- 정기적인 하드웨어 교체 필요
- 패치/업그레이드 직접 관리 - 서비스 제공자가 유지보수 담당
- 자동 업데이트/패치 적용
- 최신 기술 자동 적용 커스터마이징 - 완전한 커스터마이징 자유
- 하드웨어/소프트웨어 직접 선택
- 특수 요구사항 수용 용이 - 제한된 커스터마이징
- 제공되는 서비스 내에서 선택
- 표준화된 서비스 위주 가용성 - 자체 인프라로 안정성 확보
- 인터넷 연결 없이도 운영 가능
- 장애 대응 직접 수행 - 서비스 제공자의 SLA 따름
- 인터넷 연결 필수
- 여러 지역 동시 운영 가능 데이터 주권 - 완벽한 데이터 통제권 보유
- 물리적 데이터 위치 확실
- 규제 준수 용이 - 데이터 주권 일부 제한
- 국가간 데이터 이동 가능
- 규제 준수 확인 필요 접근성 - 내부 네트워크 중심
- 원격 접속 별도 구성 필요
- 물리적 접근 통제 가능 - 언제 어디서나 접근 가능
- 다양한 디바이스 지원
- 글로벌 접근성 우수 재해 복구 - 별도의 재해복구 센터 필요
- 높은 구축/운영 비용
- 복구 절차 직접 수행 - 자동화된 백업/복구
- 여러 지역 복제 용이
- 신속한 재해 복구 적합한 상황 - 높은 보안이 필요한 경우
- 특수한 규제 준수 필요
- 레거시 시스템 운영 - 빠른 시작이 필요한 경우
- 유연한 확장성 필요
- 글로벌 서비스 제공 실제로는 많은 기업들이 두 방식의 장점을 모두 활용하는 하이브리드 형태를 채택하고 있다.
기업의 특성, 요구사항, 예산 등을 종합적으로 고려하여 적절한 방식을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-10 10:33:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;399 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud vs. On-Premise" href=https://buenhyden.github.io/posts/devops/cloud/cloud-vs-on-premise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shared Database vs Shared Database Per Service</h2></header><div class=entry-content><p>Shared Database Vs Shared Database Per Service MSA(Microservices Architecture)에서 Shared Database와 Shared Database Per Service 패턴은 데이터 관리 전략의 일환으로 활용되며, 각각의 특징과 적용 시나리오가 뚜렷하게 구분된다.
두 패턴 모두 단일 데이터베이스 의존성으로 인한 리스크가 존재하므로, 장기적 관점에서는 Database Per Service로의 전환을 고려해야 한다. 특히 클라우드 환경(AWS RDS, Aurora)에서는 논리적 분리가 용이하나, 트랜잭션 격리와 확장성 측면에서 trade-off를 신중히 평가해야 한다.
Shared Database 패턴 정의 및 특징 여러 마이크로서비스가 단일 데이터베이스를 공유하며, 서비스 간 자유로운 테이블 접근 허용. 직접적인 ACID 트랜잭션을 통해 데이터 일관성 유지. 간단한 아키텍처로 시작 단계에서 빠른 개발 가능. 동작 방식 1 2 3 4 5 -- OrderService가 CustomerService의 테이블 직접 접근 예시 BEGIN TRANSACTION; SELECT CREDIT_LIMIT FROM CUSTOMERS WHERE CUSTOMER_ID = 123; INSERT INTO ORDERS (CUSTOMER_ID, AMOUNT) VALUES (123, 50000); COMMIT; 서비스 간 스키마 변경 시 협업 필요 (예: Customer 테이블 컬럼 추가 → OrderService 코드 수정). 장단점 장점 단점 - 복잡한 분산 트랜잭션 불필요 - 서비스 간 강한 결합성 발생 - 데이터 조인 및 통합 쿼리 용이 - 단일 데이터베이스 병목 현상 (SPOF) - 기존 모놀리식 시스템 전환 용이 - 스키마 변경 시 전체 서비스 영향도 검토 필요 적합한 시나리오 소규모 팀에서 신속한 프로토타이핑 필요 시. 레거시 시스템을 MSA로 점진적 전환하는 과정에서 임시 활용. 강한 ACID 트랜잭션 요구사항이 있는 금융/결제 시스템. Shared Database Per Service 패턴 정의 및 특징 단일 물리적 데이터베이스 인스턴스를 공유하지만, 서비스별 논리적 분리 (스키마/테이블 격리). 핫 테이블(Hot Table) 방지를 통해 성능 저하 최소화. 하위 호환성 유지가 필수적이며, 스키마 변경 시 모든 서비스 영향도 검토. 동작 방식 1 2 3 -- Sales 서비스: sales_db.sales_table -- Customer 서비스: sales_db.customer_table (논리적 분리) GRANT SELECT, INSERT ON sales_db.customer_table TO 'customer_service'@'%'; IAM 정책 또는 DB 권한 제어를 통해 서비스별 접근 범위 제한. 장단점 장점 단점 - 물리적 인프라 비용 절감 - 여전히 런타임 결합성 존재 - 부분적 스키마 독립성 보장 - 장기적 유지보수 복잡성 증가 - 데이터 중복 최소화 - 확장성 제약 (CPU/IO 리소스 경쟁) 적합한 시나리오 제한된 리소스 환경에서 다중 서비스 운영 필요 시. 기존 데이터 레이어 재설계 없이 MSA 도입 시. 규제 준수 요구사항으로 단일 데이터베이스 유지해야 하는 경우. 비교 분석표 항목 공유 데이터베이스 (Shared Database) 서비스별 전용 데이터베이스 (Database per Service) 데이터 격리 수준 테이블 수준 공유 스키마/테이블 논리적 분리 데이터 일관성 유지 ACID 트랜잭션을 통해 데이터 일관성을 쉽게 유지할 수 있습니다. 분산된 데이터로 인해 데이터 일관성 유지가 복잡해질 수 있으며, 이를 위해 사가(Saga) 패턴 등의 사용이 필요할 수 있습니다. 스키마 변경 영향도 모든 서비스 영향 관련 서비스만 영향 결합도 높음 (직접 테이블 접근) 중간 (권한 제어를 통한 제한적 접근) 서비스 독립성 데이터베이스 스키마 변경 시 여러 서비스 간 조율이 필요하여 서비스 간 결합도가 높아집니다. 각 서비스가 독립적인 데이터베이스를 소유하므로 서비스 간 결합도가 낮아 독립적인 개발, 배포, 확장이 가능합니다. 데이터베이스 선택 모든 서비스가 동일한 데이터베이스를 사용하므로 개별 서비스의 특수한 데이터 저장 요구 사항을 충족하기 어렵습니다. 각 서비스는 자신의 요구에 맞는 데이터베이스 유형을 선택할 수 있어 폴리글랏 퍼시스턴스(Polyglot Persistence)를 구현할 수 있습니다. 운영 복잡성 단일 데이터베이스를 관리하므로 운영이 단순합니다. 여러 개의 데이터베이스를 관리해야 하므로 운영 복잡성이 증가합니다. 트랜잭션 관리 로컬 ACID 트랜잭션 가능.
단일 데이터베이스 내에서 트랜잭션을 관리하므로 구현이 용이합니다. 로컬 ACID 트랜잭션 가능.
분산 트랜잭션 관리가 필요할 수 있으며, 이는 구현의 복잡성을 증가시킵니다. 확장성 단일 데이터베이스의 확장에 한계가 있을 수 있으며, 특정 서비스의 확장이 다른 서비스에 영향을 미칠 수 있습니다. 각 서비스가 독립적으로 확장 가능하므로 시스템 전체의 확장성이 향상됩니다. 보안 모든 서비스가 전체 데이터 접근 가능 권한 제어로 접근 범위 제한 패턴 선택 가이드 Shared Database 선택 시: 개발 초기 단계에서 빠른 출시를 목표로 할 때. 팀 규모가 작고 데이터 복잡도가 낮은 경우. Shared Database Per Service 선택 시: 기존 모놀리식 DB를 유지하며 MSA를 도입해야 할 때. 데이터 중복을 최소화해야 하지만 완전 분리가 어려운 경우. Database Per Service 권장 시: 대규모 시스템에서 완전한 독립성과 확장성이 필요할 때. 서비스별 폴리글랏 퍼시스턴스 적용이 필요한 경우. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 08:02:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;612 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Database vs Shared Database Per Service" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/database/shared-database-vs-shared-database-per-service/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>