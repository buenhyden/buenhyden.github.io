<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.157.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json title=json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dirty Read</h2></header><div class=entry-content><p>Dirty Read Dirty Read 는 한 트랜잭션이 커밋하지 않은 변경을 다른 트랜잭션이 읽는 현상으로, 잘못된 집계·오판·롤백 후 부정합을 초래한다.
대부분의 실무에서는 정확성 우선 업무에는 금지하고, 로그·집계처럼 정확성 요구가 낮은 영역에만 제한적으로 허용한다.
완화책으로는 MVCC 기반 스냅샷 격리 (RCSI/SI), 읽기 전용 리플리카 (CQRS), 쿼리 힌트·화이트리스트 적용, 모니터링 및 재현 테스트가 있다.
DB 엔진별 동작이 다르니 적용 전 반드시 벤더별 테스트와 정책 문서화를 수행하라.
Dirty Read 개념·관계·실무 적용 Dirty Read 는 아직 확정되지 않은 (커밋되지 않은) 변경을 읽는 상황 을 말한다.
이로 인해 나중에 원 트랜잭션이 취소되면 읽은 값이 허위가 되어 잘못된 계산·보고가 발생할 수 있다.
따라서 대부분 운영 시스템은 기본적으로 Dirty Read 를 차단하는 READ COMMITTED 이상을 사용하고, 로그·모니터링 등 정확성에 덜 민감한 경로만 별도 복제본이나 스냅샷을 통해 읽도록 분리한다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:48:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;<span>48 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Dirty Read" href=https://buenhyden.github.io/posts/computer-science/data-operations/transaction-management/transaction/transaction-isolation/concurrency-anomalies/dirty-read/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Serializable</h2></header><div class=entry-content><p>Serializable Serializable 은 트랜잭션 동시성에서 가장 강한 격리 수준으로, 실행 결과가 어떤 순차적 실행과 같도록 보장해 Dirty Read·Non-Repeatable Read·Phantom 등 모든 이상현상을 차단한다.
구현 방식은 잠금 (Strict 2PL), MVCC 기반의 직렬성 검증 (SSI), 또는 낙관적 검증 (OCC) 등이며, 분산 환경에서는 2PC·분산 합의·외부 시계 같은 추가 메커니즘이 필요하다.
실무에서는 데이터 무결성이 절대적일 때 우선 적용하되 성능 저하·교착·재시도 비용을 인덱스 튜닝, 트랜잭션 단축, 백오프/재시도 설계, 부분적 격리 상향 (핵심 경로만) 으로 완화하는 것이 핵심 전략이다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:47:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;<span>32 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Serializable" href=https://buenhyden.github.io/posts/computer-science/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/serializable/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Read Committed</h2></header><div class=entry-content><p>Read Committed Read Committed(읽기 커밋) 는 실무에서 널리 쓰이는 기본 격리 수준으로, 항상 커밋된 데이터만 읽게 해 Dirty Read 를 차단한다.
다만 트랜잭션 내 여러 문장은 서로 다른 시점의 커밋 상태를 볼 수 있어 Non-repeatable Read 와 Phantom이 발생할 수 있다.
내부 구현은 DB 마다 달라 (PostgreSQL/Oracle 은 MVCC 스냅샷 기반, SQL Server 는 기본 락 기반에 RCSI 옵션 존재) 동일 명칭이라도 동작이 다르므로 DB 별로 테스트·검증해야 한다.
일반 웹·OLTP 는 Read Committed 가 성능·정합성의 균형이지만, 회계·결제 등 강한 일관성이 필요한 도메인에서는 Repeatable Read 나 Serializable 을 사용하는 것이 추천된다.
운영 시 장기 트랜잭션 회피, 락 대기·데드락 모니터링, 읽기 풀 설계로 위험을 완화하는 것이 추천된다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;<span>33 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Read Committed" href=https://buenhyden.github.io/posts/computer-science/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-committed/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Read Uncommitted</h2></header><div class=entry-content><p>Read Uncommitted Read Uncommitted(읽기 미확정) 는 트랜잭션 격리에서 가장 낮은 수준으로, 다른 트랜잭션의 커밋되지 않은 변경 (Dirty Read) 을 허용해 읽기 처리량을 최대화하려는 목적이다.
SQL 표준상 정의되지만, 많은 상용 DB 는 이를 진짜로 지원하지 않거나 내부적으로 Read Committed 로 승격하기 때문에 기대 동작을 DB 별로 확인해야 한다.
실무에서는 로그 집계·대략적 통계·탐색 쿼리처럼 정확성보다 속도가 우선인 경우에만 제한적으로 사용하며, 읽기 전용 커넥션 분리·금지 쿼리 목록·롤백 탐지·재검증 같은 가드레일을 반드시 둬야 안전하다.
읽기 성능이 필요하면 레플리카 기반 읽기, MVCC 스냅샷 격리 또는 샘플링을 우선 고려하는 편이 바람직하다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;<span>28 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Read Uncommitted" href=https://buenhyden.github.io/posts/computer-science/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-uncommitted/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Repeatable Read</h2></header><div class=entry-content><p>Repeatable Read Repeatable Read(반복 읽기) 는 트랜잭션 내에서 같은 조회가 항상 동일한 결과를 반환하도록 보장해 재현성을 확보한다.
구현은 MVCC(스냅샷 기반) 또는 잠금 (범위·next-key) 방식으로 나뉘며, 두 방식은 가시성·충돌 처리·성능 특성이 다르다.
RR 은 Dirty Read 와 Non-repeatable Read 를 방지하지만 Phantom(범위 삽입/삭제) 은 엔진별로 다르게 처리된다.
따라서 금융·결산 같은 재현성이 중요한 워크로드에 유리하되, 실제 적용 전 DB 별 동작 확인, 재현 테스트, 성능·교착 검증, 필요 시 부분적 상향 (Serializable) 또는 리포트 분리가 필요하다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;<span>33 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Repeatable Read" href=https://buenhyden.github.io/posts/computer-science/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/repeatable-read/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Anycast</h2></header><div class=entry-content><p>애니캐스트 (Anycast) 애니캐스트는 단일 송신자로부터 네트워크상에서 논리적으로 동일한 주소를 가진 여러 수신자 중 가장 가깝거나 효율적인 경로에 있는 단일 수신자에게 데이터를 전달하는 통신 방식입니다.
핵심 개념 일대일 통신 (One-to-Nearest): 여러 후보 중 물리적/논리적으로 가장 가까운 노드 하나와 통신합니다. 부하 분산: 전 세계적으로 분산된 서버(예: DNS, CDN)에서 트래픽을 지역별로 최적화하여 처리할 때 필수적입니다. 기초 이해 (Foundation Understanding) 유니캐스트 vs 애니캐스트: 유니캐스트가 특정 목적지 주소를 가진 하나의 장비와 1:1로 통신한다면, 애니캐스트는 동일한 주소를 공유하는 여러 장비 중 최적의 경로에 있는 하나와 통신을 시도합니다. 정리 및 학습 가이드 내용 정리 DNS 시스템: 클라우드플레어(1.1.1.1)나 구글 DNS(8.8.8.8)가 전 세계 어디서든 빠른 응답을 줄 수 있는 비결이 바로 애니캐스트입니다. CDN 서비스: 대용량 콘텐츠를 사용자에게 가장 가까운 서버에서 전송하여 지연 시간을 최소화합니다. 가용성: 특정 서버가 다운되어도 라우팅 프로토콜(BGP 등)이 자동으로 다음으로 가까운 서버를 찾아 연결해주므로 장애 대응에 유리합니다. 용어 정리 용어 설명 BGP 애니캐스트 구현에서 가장 널리 사용되는 외부 게이트웨이 프로토콜입니다. Latency 애니캐스트를 통해 최소화하려는 핵심 지표인 지연 시간입니다. 참고 및 출처 RFC 1546: Host Anycasting Service Cloudflare: What is Anycast?</p></div><footer class=entry-footer><span title='2025-09-05 05:48:00 +0000 UTC'>September 5, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Anycast" href=https://buenhyden.github.io/posts/computer-science/core-protocols/internet-layer/internet-protocol/ip-fundamentals/delivery-modes/anycast/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Broadcast</h2></header><div class=entry-content><p>브로드캐스트 (Broadcast) 브로드캐스트는 단일 송신자로부터 동일한 로컬 네트워크(서브넷) 내의 모든 장치에게 데이터를 전달하는 통신 방식입니다.
핵심 개념 일대다 통신 (One-to-All): 특정 네트워크 세그먼트 내의 모든 노드가 데이터를 수신합니다. 제한적 전달: 대규모 네트워크(인터넷 전체)로 확산되지 않도록 라우터에 의해 차단되는 것이 일반적입니다. 기초 이해 (Foundation Understanding) 브로드캐스트 주소: IPv4에서는 해당 네트워크의 가장 마지막 주소(예: 192.168.0.255)를 예약하여 사용합니다. 정리 및 학습 가이드 내용 정리 상호 발견 (Discovery): 새로운 장치가 네트워크에 접속했을 때 주변 장치를 찾거나 정보를 알릴 때 유용합니다. (예: ARP, DHCP 요청) 트래픽 부하: 모든 장치가 패킷을 처리해야 하므로 과도한 브로드캐스트는 네트워크 성능 저하(브로드캐스트 스톰)를 유발할 수 있습니다. IPv6에서의 변화: IPv6에서는 브로드캐스트 대신 더 효율적인 멀티캐스트 방식을 사용합니다. 용어 정리 용어 설명 ARP IP 주소를 MAC 주소로 변환하기 위해 브로드캐스트를 사용하는 대표적인 프로토콜입니다. DHCP 자신의 IP를 모르는 클라이언트가 서버를 찾기 위해 브로드캐스트를 사용합니다. 참고 및 출처 Cisco: Broadcast Addresses TechTarget: What is a Network Broadcast?</p></div><footer class=entry-footer><span title='2025-09-05 05:48:00 +0000 UTC'>September 5, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Broadcast" href=https://buenhyden.github.io/posts/computer-science/core-protocols/internet-layer/internet-protocol/ip-fundamentals/delivery-modes/broadcast/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multicast</h2></header><div class=entry-content><p>멀티캐스트 (Multicast) 멀티캐스트는 단일 송신자로부터 **네트워크상의 특정 그룹(관심 있는 수신자들)**에게 데이터를 전달하는 통신 방식입니다.
핵심 개념 일대다 그룹 통신 (One-to-Many Group): 필요한 사람들에게만 보냄으로써 브로드캐스트보다 효율적입니다. 리소스 최적화: 송신자는 데이터를 한 번만 보내고, 네트워크 장비(스위치/라우터)가 수신자의 위치에 따라 데이터를 복제하여 전달합니다. 기초 이해 (Foundation Understanding) 멀티캐스트 주소: IPv4에서는 D 클래스 주소(224.0.0.0 ~ 239.255.255.255)를 사용합니다. 정리 및 학습 가이드 내용 정리 대역폭 절약: 실시간 스트리밍(IPTV), 화상 회의 등 다수가 동일한 데이터를 받는 경우 네트워크 부하를 획기적으로 줄여줍니다. 그룹 관리 (IGMP): 호스트가 특정 멀티캐스트 그룹에 가입하거나 탈퇴하기 위해 IGMP(Internet Group Management Protocol)를 사용합니다. 분산 시스템: 대규모 분산 환경에서 클러스터 노드 간의 상태 동기화나 시스템 발견에 사용됩니다. 용어 정리 용어 설명 IGMP 멀티캐스트 그룹의 멤버십을 관리하기 위한 프로토콜입니다. Class D 멀티캐스트 전용으로 할당된 IP 주소 대역입니다. 참고 및 출처 Microsoft Learn: Multicast Overview RFC 1112: Host Extensions for IP Multicasting</p></div><footer class=entry-footer><span title='2025-09-05 05:48:00 +0000 UTC'>September 5, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Multicast" href=https://buenhyden.github.io/posts/computer-science/core-protocols/internet-layer/internet-protocol/ip-fundamentals/delivery-modes/multicast/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Unicast</h2></header><div class=entry-content><p>유니캐스트 (Unicast) 유니캐스트는 네트워크상에서 단일 송신자와 단일 수신자 간의 1:1 통신 방식을 의미합니다. 우리가 인터넷을 사용할 때 가장 흔하게 발생하는 통신 형태입니다.
핵심 개념 일대일 통신 (One-to-One): 특정 목적지 주소를 가진 하나의 대상에게만 데이터를 전송합니다. 가장 범용적인 방식: 웹 서핑, 이메일 전송, 파일 다운로드 등 대부분의 인터넷 서비스가 유니캐스트 기반으로 동작합니다. 기초 이해 (Foundation Understanding) 식별: 수신자의 IP 주소를 목적지로 지정하여 패킷을 보냅니다. 네트워크상의 다른 장치들은 자신의 주소가 아니면 이 패킷을 무시합니다. 정리 및 학습 가이드 내용 정리 신뢰성: TCP 프로토콜과 결합하여 데이터의 정확한 전달을 보장하기 쉽습니다. 트래픽 효율: 목적지가 명확하므로 네트워크 전체에 불필요한 부하를 주지 않습니다. 하지만 동시에 많은 사용자에게 동일한 데이터를 보낼 때는(예: 라이브 방송) 서버와 네트워크에 큰 부담이 될 수 있습니다. 확장성 제어: 대량의 수신자에게 데이터를 보낼 때는 유니캐스트보다 멀티캐스트나 애니캐스트가 더 효율적일 수 있습니다. 용어 정리 용어 설명 Point-to-Point 두 노드 사이의 직접적인 연결을 통한 유니캐스트 통신의 한 형태입니다. Destination IP 패킷이 도달해야 할 최종 목적지 장비의 고유 주소입니다. 참고 및 출처 Computer Hope: What is Unicast? Wikipedia: Unicast</p></div><footer class=entry-footer><span title='2025-09-05 05:48:00 +0000 UTC'>September 5, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Unicast" href=https://buenhyden.github.io/posts/computer-science/core-protocols/internet-layer/internet-protocol/ip-fundamentals/delivery-modes/unicast/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker</h2></header><div class=entry-content><p>Event Broker 이벤트 브로커는 이벤트 기반 아키텍처에서 이벤트 발행자 (Producer) 와 구독자 (Consumer) 사이의 이벤트 메시지 흐름을 중개하는 미들웨어이다.
분산 마이크로서비스 환경에서 데이터 흐름의 실시간성, 비동기성, 확장성을 확보할 수 있도록 지원한다. 대용량 실시간 데이터 처리와 시스템 간의 결합도 감소, 장애 격리 및 이벤트 아카이빙 등 다양한 장점으로 인해 오늘날 IT 인프라에서 매우 중요한 역할을 차지한다.
이벤트 브로커는 Pub/Sub, 스트리밍, 다양한 QoS, 보안, 트랜잭션, 확장성, 장애 복구 등 다양한 기능을 제공하며, 시스템 간 결합도를 낮추고, 실시간 데이터 분배와 비동기 처리를 지원한다.
...</p></div><footer class=entry-footer><span title='2025-07-18 05:58:00 +0000 UTC'>July 18, 2025</span>&nbsp;·&nbsp;<span>39 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Event Broker" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/message-infrastructure/message-brokers-vs-event-brokers/event-broker/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>