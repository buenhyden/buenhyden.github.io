<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Pattern vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern</h2></header><div class=entry-content><p>Event-Driven Pattern Vs Event Sourcing Pattern Vs Publisher-Subscriber Pattern Vs Producer-Consumer Pattern Event Sourcing Pattern, Publisher-Subscriber Pattern, Event-Driven Architecture, Producer-Consumer Pattern은 모두 소프트웨어 아키텍처에서 중요한 역할을 하는 패턴들이며, 서로 밀접한 관계를 가지고 있다.
이들의 관계를 다음과 같이 설명할 수 있다:
Event-Driven Architecture (EDA)와 다른 패턴들의 관계:
EDA는 이벤트 중심의 시스템 설계를 위한 상위 수준의 아키텍처 스타일. Publisher-Subscriber Pattern과 Producer-Consumer Pattern은 EDA를 구현하는 데 사용되는 구체적인 통신 모델이다. Event Sourcing Pattern은 EDA의 한 구현 방식으로 볼 수 있으며, 이벤트를 저장하고 관리하는 방법을 제공한다. Publisher-Subscriber Pattern과 Producer-Consumer Pattern의 관계:
...</p></div><footer class=entry-footer><span title='2024-11-19 03:37:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Pattern vs Event Sourcing Pattern vs Publisher-Subscriber Pattern vs Producer-Consumer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/event-driven-pattern-vs-event-sourcing-pattern-vs-publisher-subscriber-pattern-vs-producer-consumer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Scenario Testing vs Use Case Testing</h2></header><div class=entry-content><p>Scenario Testing vs. Use Case Testing Scenario Testing과 Use Case Testing은 소프트웨어 테스팅 기법으로, 사용자 관점에서 시스템의 기능과 동작을 검증하는 데 사용된다.
두 기법은 유사한 점이 있지만, 접근 방식과 세부 사항에서 차이가 있다.
비교 항목 Scenario Testing Use Case Testing 정의 실제 사용자의 행동과 상황을 기반으로 한 현실적인 시나리오를 통해 시스템을 테스트하는 방법 사용자와 시스템 간의 상호작용을 구조화된 형식으로 정의하고 테스트하는 방법 테스트 관점 사용자 중심적이며, 실제 업무 상황과 맥락을 중요시함 시스템 중심적이며, 기능적 정확성과 완전성을 중요시함 목적 실제 사용 환경에서의 시스템 동작을 검증 시스템의 기능적 요구사항을 검증 구조화 정도 자유로운 형식으로, 스토리텔링 방식의 서술적 구조 체계적이고 형식적인 구조 (기본 흐름, 대체 흐름, 예외 흐름) 테스트 범위 여러 기능이나 프로세스를 걸쳐 있는 end-to-end 시나리오 주로 단일 기능이나 프로세스에 초점 테스트 설계 자유로운 형식으로 다양한 “가정” 상황을 포함 유스케이스 문서의 기본 흐름과 대체 흐름을 따름 테스트 케이스 도출 다양한 소스(사용자 피드백, 시장 조사 등)에서 시나리오 개발 유스케이스 문서에서 직접 테스트 케이스를 도출 상황 맥락 사용자의 동기, 감정, 환경 등 풍부한 맥락 정보 포함 객관적이고 기술적인 상호작용 위주의 맥락 문서화 방식 서술적이고 이야기 형식의 문서화 구조화되고 단계별로 정형화된 문서화 적합한 상황 사용자 경험이 중요한 애플리케이션, 복잡한 업무 프로세스 명확한 기능 요구사항이 있는 시스템, 트랜잭션 기반 애플리케이션 테스트 설계 난이도 실제 사용자 경험에 대한 이해가 필요하며, 창의적인 시나리오 도출이 중요 체계적인 분석과 문서화 능력이 필요하며, 기술적 이해가 중요 유지보수성 시나리오 수정이 비교적 자유롭고 유연함 구조화된 형식으로 인해 변경 관리가 체계적 재사용성 특정 상황에 특화된 시나리오로 재사용이 제한적 표준화된 형식으로 인해 재사용이 용이 커버리지 측정 시나리오 기반의 정성적 측정이 주로 이루어짐 흐름 기반의 정량적 측정이 가능 테스트 자동화 복잡한 시나리오로 인해 자동화가 어려울 수 있음 구조화된 형식으로 인해 자동화가 비교적 용이 장점 예상치 못한 오류 발견에 효과적, 사용자 경험 개선에 도움 요구사항 검증에 효과적, 체계적인 테스트 가능 단점 모든 가능한 시나리오를 고려하기 어려움 유스케이스 문서의 품질에 의존적 실제 프로젝트에서는 이 두 방법을 상호 보완적으로 사용하는 것이 효과적이다.
예를 들어, Use Case Testing으로 기본적인 기능 정확성을 검증하고, Scenario Testing으로 실제 사용 환경에서의 사용성과 통합성을 검증하는 방식으로 활용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-05 17:12:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Scenario Testing vs Use Case Testing" href=https://buenhyden.github.io/posts/quality-assurance/testing-techniques/manual-testing/test-cases-and-scenarios/scenario-testing-vs-use-case-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Kafka vs RabbitMQ</h2></header><div class=entry-content><p>Kafka vs. RabbitMQ Apache Kafka와 RabbitMQ는 모두 분산 메시징 시스템이지만 설계 목적, 아키텍처, 활용 사례에서 뚜렷한 차이를 보인다.
기본 개념 항목 Apache Kafka RabbitMQ 유형 분산 이벤트 스트리밍 플랫폼 메시지 브로커 (AMQP 구현) 주요 목적 대규모 실시간 데이터 스트리밍 및 처리 유연한 메시지 라우팅과 비동기 통신 지원 데이터 처리 로그 기반 스트림 (메시지 재생 가능) 큐 기반 메시지 (소비 후 삭제) Kafka는 LinkedIn에서 개발되어 나중에 Apache 재단으로 이관된 분산 이벤트 스트리밍 플랫폼이다. 주로 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계되었다.
...</p></div><footer class=entry-footer><span title='2024-10-22 11:41:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Kafka vs RabbitMQ" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/messaging-systems/event-streaming-platforms/kafka/kafka-vs-rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Paging vs Segmentation</h2></header><div class=entry-content><p>Paging vs. Segmentation Paging과 Segmentation은 운영체제의 메모리 관리 기법이다.
Paging:
프로세스의 주소 공간을 고정 크기의 페이지로 나누어 관리한다. 물리적 메모리를 같은 크기의 프레임으로 나눈다. 외부 단편화 문제를 해결하고 메모리 할당을 단순화한다. Segmentation:
프로세스를 논리적 단위인 세그먼트로 나누어 관리한다. 각 세그먼트의 크기는 가변적이다. 프로그램의 논리적 구조를 반영하여 메모리를 관리한다. Paging과 Segmentation 비교 특성 Paging Segmentation 분할 단위 고정 크기 페이지 가변 크기 세그먼트 주소 변환 페이지 테이블 사용 세그먼트 테이블 사용 외부 단편화 없음 발생 가능 내부 단편화 발생 가능 거의 없음 메모리 활용 효율적 유연함 구현 복잡도 상대적으로 간단 복잡함 공유와 보호 페이지 단위 세그먼트 단위 사용자 관점 투명함 프로그램 구조 반영 할당/해제 속도 빠름 상대적으로 느림 테이블 크기 큼 작음 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-05 08:24:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Paging vs Segmentation" href=https://buenhyden.github.io/posts/computer-science/software-and-systems/operating-systems/memory-management/techniques/paging-vs-segmentation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Callback vs Promise vs Async/Await</h2></header><div class=entry-content><p>Callback vs. Promise vs. Async/Await JavaScript의 비동기 처리 방식은 프로그램의 실행 흐름을 막지 않고 다른 작업을 수행할 수 있게 해주는 중요한 기능이다.
주요 비동기 처리 방식에는 콜백(Callbacks), 프로미스(Promises), 그리고 async/await가 있다.
특성 콜백 (Callback) Promise Async/Await 정의 다른 함수의 인자로 전달되어 특정 시점에 실행되는 함수 비동기 작업의 최종 완료 또는 실패를 나타내는 객체 Promise를 기반으로 비동기 코드를 동기 코드처럼 작성할 수 있게 해주는 문법 도입 시기 JavaScript 초기부터 사용 ES6 (2015) ES8 (2017) 문법 function(err, result) { … } new Promise((resolve, reject) => { … }) async function() { await … } 에러 처리 콜백 함수의 첫 번째 인자로 에러 객체 전달 .catch() 메서드 사용 try-catch 구문 사용 장점 - 간단한 비동기 처리에 적합
- 모든 환경에서 지원 - 체이닝 가능
- 에러 처리 용이
- 병렬 처리 가능 (Promise.all) - 동기 코드와 유사한 구조
- 가독성 향상
- 직관적인 에러 처리 단점 - 콜백 지옥 발생 가능
- 에러 처리 복잡 - 약간의 학습 곡선 존재
- 브라우저 지원 고려 필요 - 항상 Promise를 반환
- 오래된 환경에서 지원 안 됨 비동기 처리 방식 콜백 함수를 통해 결과 처리 then() 메서드를 통해 결과 처리 await 키워드로 결과를 기다림 중첩 처리 콜백 안에 콜백을 계속 넣어야 함 .then() 체이닝으로 처리 일반적인 동기 코드처럼 작성 가능 병렬 처리 복잡한 로직 필요 Promise.all() 사용 Promise.all()과 함께 사용 순차적 처리 콜백 중첩으로 처리 .then() 체이닝으로 처리 일반 동기 코드처럼 작성 타입스크립트 통합 타입 추론이 어려움 제네릭을 통해 타입 안정성 확보 가장 타입 안정적 테스트 용이성 테스트 작성이 복잡할 수 있음 테스트 작성이 비교적 쉬움 가장 테스트 작성이 쉬움 디버깅 콜백 중첩으로 인해 어려움 스택 트레이스가 깔끔함 동기 코드와 유사해 가장 쉬움 메모리 사용 콜백 중첩 시 메모리 사용량 증가 체이닝으로 인한 약간의 오버헤드 일반적으로 가장 효율적 취소 가능성 직접 구현 필요 취소 불가능 (별도 구현 필요) 취소 불가능 (별도 구현 필요) 구현 예시 콜백 함수 (Callbacks) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 콜백 함수를 사용한 비동기 처리 예시 function fetchData(callback) { // 데이터를 가져오는 비동기 작업 시뮬레이션 setTimeout(() => { const data = { id: 1, name: "John" }; callback(null, data); // 성공시 첫 번째 인자는 null }, 1000); } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 하지만 콜백 방식은 여러 비동기 작업을 연달아 처리해야 할 때 “콜백 지옥"이라는 문제가 발생합니다:
...</p></div><footer class=entry-footer><span title='2024-11-23 09:07:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback vs Promise vs Async/Await" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/fundamentals/asynchronous/callback-vs-promise-vs-async-await/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Streaming vs Polling</h2></header><div class=entry-content><p>Streaming vs. Polling Streaming과 polling은 실시간 데이터 전송을 위해 사용되는 두 가지 주요 기술입니다. 각각의 특징과 차이점을 자세히 살펴보겠습니다.
Streaming Streaming은 데이터를 연속적으로 전송하는 방식입니다.
주요 특징 연속적인 데이터 흐름: 서버에서 클라이언트로 데이터를 지속적으로 전송합니다. 실시간성: 데이터가 생성되는 즉시 전송되어 높은 실시간성을 제공합니다. 효율적인 대역폭 사용: 필요한 데이터만 전송하므로 대역폭을 효율적으로 사용합니다. 지속적인 연결: 클라이언트와 서버 간 연결이 유지됩니다. 사용 사례 비디오/오디오 스트리밍 실시간 주식 시세 정보 라이브 이벤트 중계 Polling Polling은 클라이언트가 주기적으로 서버에 데이터를 요청하는 방식입니다.
...</p></div><footer class=entry-footer><span title='2024-10-20 08:44:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Streaming vs Polling" href=https://buenhyden.github.io/posts/backend/backend-fundamentals/backend-basics/request-response-cycle/streaming/streaming-vs-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동기(Synchronous) vs. 비동기(Asynchronous) and Blocking vs. Non-Blocking</h2></header><div class=entry-content><p>동기(Synchronous)와 비동기(Asynchronous) 그리고 Blocking와 Non-Blocking 카테고리 동기(Synchronous) 비동기(Asynchronous) Blocking Non-Blocking 핵심 개념 작업이 순차적으로 실행되며, 이전 작업이 완료될 때까지 다음 작업을 시작하지 않음 작업들이 독립적으로 실행되며, 이전 작업의 완료를 기다리지 않고 다음 작업 수행 가능 호출된 함수가 작업을 완료할 때까지 제어권을 반환하지 않음 호출된 함수가 작업 완료 여부와 관계없이 즉시 제어권을 반환함 작업 처리 방식 순차적으로 작업을 처리하며, 각 작업이 완료된 후 다음 작업 시작 여러 작업이 동시에 처리될 수 있으며, 작업 완료 순서는 불확실할 수 있음 호출한 함수는 작업이 완료될 때까지 대기 상태 유지 호출한 함수는 작업 진행 중에도 다른 작업 수행 가능 제어 흐름 프로그램의 제어 흐름이 순차적이고 예측 가능함 제어 흐름이 비선형적이며, 콜백이나 이벤트로 처리 제어권이 호출된 함수에 완전히 넘어감 제어권이 호출한 함수에 즉시 반환됨 결과 처리 작업 완료 후 바로 결과를 반환받아 처리 콜백 함수, Promise, async/await 등을 통해 결과 처리 결과를 직접 반환받아 처리 상태 확인이나 콜백을 통해 결과 처리 주요 특징 - 코드의 실행 순서가 명확함
- 직관적인 코드 흐름
- 단순한 구현 - 작업의 병렬 처리 가능
- 복잡한 이벤트 처리
- 높은 확장성 - 자원을 점유하며 대기
- 단순한 구현
- 예측 가능한 실행 - 자원의 효율적 활용
- 복잡한 구현
- 높은 동시성 에러 처리 try-catch 블록으로 즉시 에러 처리 가능 Promise의 catch나 async/await의 try-catch로 처리 동기적 에러 처리 가능 비동기적 에러 처리 메커니즘 필요 성능 특성 - 단순 작업에서 오버헤드 적음
- 순차 처리로 인한 대기 시간 발생 - 동시 처리로 인한 전체 처리 시간 감소
- 컨텍스트 스위칭 오버헤드 - I/O 작업에서 성능 저하
- 리소스 독점 - 리소스 효율적 활용
- 높은 처리량 적합한 사용 사례 - 간단한 계산 작업
- 메모리 내 데이터 처리
- 순차적 처리 필요 작업 - 네트워크 요청
- 대용량 파일 처리
- 독립적 실행 가능 작업 - CPU 연산 작업
- 간단한 파일 작업
- 메모리 작업 - I/O 작업
- 네트워크 통신
- 대용량 처리 실행 순서 코드 작성 순서와 실행 순서가 동일 실행 순서가 코드 작성 순서와 다를 수 있음 작업 완료 순서가 예측 가능 작업 완료 순서가 불확실 자원 활용 단일 자원을 순차적으로 사용 여러 자원을 동시에 효율적으로 활용 자원을 독점적으로 사용 자원을 공유하여 사용 응답성 작업 완료 전까지 다른 작업 불가 여러 작업의 동시 처리로 높은 응답성 대기 시간 동안 응답 불가 지속적인 응답 가능 디버깅 코드 흐름 추적이 용이함 비동기 로직으로 인한 디버깅 어려움 문제 발생 지점 파악 쉬움 문제 발생 지점 추적 어려움 확장성 수직적 확장에 제한적 수평적/수직적 확장 용이 동시 처리 능력 제한적 높은 동시성 처리 가능 데이터 일관성 데이터 일관성 보장이 쉬움 경쟁 조건 고려 필요 순차적 처리로 일관성 보장 동시성 제어 메커니즘 필요 추가적인 고려사항:
...</p></div><footer class=entry-footer><span title='2024-10-06 12:30:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동기(Synchronous) vs. 비동기(Asynchronous) and Blocking vs. Non-Blocking" href=https://buenhyden.github.io/posts/computer-science/fundamentals/synchronous-and-asynchronous-and-blocking-and-non-blocking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock and Mutex</h2></header><div class=entry-content><p>Lock and Mutex Lock과 Mutex는 둘 다 여러 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 도구이다. 한 스레드가 자원을 사용할 때 다른 스레드의 접근을 막는 것이다.
특성 Mutex Lock 기본 개념 상호 배제를 위한 동기화 객체로, 소유권 개념이 있음 일반적인 동기화 메커니즘으로, 단순한 잠금/해제 기능 소유권 소유권 개념이 있어 획득한 스레드만 해제 가능 소유권 개념이 없어 다른 스레드도 해제 가능 재진입성 보통 재진입 가능 (같은 스레드가 여러 번 획득 가능) 구현에 따라 재진입 가능할 수 있음 용도 스레드 간 엄격한 상호 배제가 필요한 경우 간단한 동기화가 필요한 일반적인 상황 성능 소유권 검사 등으로 인한 오버헤드 존재 상대적으로 가벼운 오버헤드, 단 구현에 따라 다름 에러 처리 소유권 위반 시 예외 발생 가능 단순한 실패/성공 여부만 반환 구현 복잡도 상대적으로 복잡한 구현 단순한 구현, 그러나 고급 기능 추가 시 복잡해질 수 있음 적용 범위 프로세스 내 스레드 간 동기화 프로세스 내 또는 프로세스 간 동기화에 사용 가능 우선순위 상속 우선순위 상속 지원 가능 일반적으로 지원하지 않음, 구현에 따라 다를 수 있음 교착상태 처리 소유권 추적으로 교착상태 감지 용이 기본적인 교착상태 감지만 가능 에러 검사 상세한 에러 검사 및 보고 기능 기본적인 에러 검사, 구현에 따라 확장 가능 메모리 사용 소유권 정보 저장으로 추가 메모리 필요 최소한의 메모리 사용 유연성 엄격한 규칙으로 유연성 제한 상대적으로 유연한 사용 가능 디버깅 소유권 정보로 디버깅 용이 디버깅이 상대적으로 어려움, 구현에 따라 다를 수 있음 사용 예시 데이터베이스 트랜잭션, 파일 시스템 접근 간단한 공유 자원 보호, 카운터 타임아웃 지원 보통 타임아웃 기능 내장 구현에 따라 타임아웃 지원 가능 복구 기능 비정상 종료 시 자동 복구 지원 구현에 따라 자동 복구 기능 추가 가능 중첩 사용 재진입성으로 중첩 사용 가능 구현에 따라 중첩 사용 가능, 주의 필요 시스템 수준 주로 커널 수준에서 구현 사용자 수준 및 커널 수준 모두에서 구현 가능 표준화 POSIX 표준으로 잘 정의됨 구현에 따라 동작이 다를 수 있음 성능 특성 경쟁 상황에서 성능 저하 가능 스핀락 구현 시 짧은 대기 시간에 효율적 공정성 일반적으로 공정성 메커니즘 내장 구현에 따라 공정성 보장 여부가 다름 실제 구현 시에는 고려할 사항 동시성 요구사항 (얼마나 많은 스레드가 동시에 접근하는가) 성능 요구사항 (응답 시간, 처리량 등) 리소스 사용량 (메모리, CPU 사용률) 오류 처리 및 복구 요구사항 데드록 방지 필요성 플랫폼 및 운영체제의 지원 여부 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-05 11:25:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock and Mutex" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/concurrency/control/lock/lock-and-mutex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis와 Valkey</h2></header><div class=entry-content><p>Redis와 Valkey Redis는 원래 오픈소스 프로젝트로 시작되었지만, 최근 라이선스 정책을 변경하여 더 이상 완전한 오픈소스가 아니다. 이에 반해 Valkey는 Redis의 오픈소스 정신을 계승하기 위해 만들어진 프로젝트로, Linux Foundation의 관리 하에 있다.
특징 Valkey Redis 라이선스 BSD 3-clause 오픈 소스 Redis Source Available (제한적 오픈 소스) 커뮤니티 지원 AWS, Oracle 등이 지원하는 커뮤니티 주도 Redis Inc.가 상업적으로 지원 멀티스레딩 I/O 및 명령 실행을 위한 향상된 멀티스레드 아키텍처 대부분의 작업이 단일 스레드 복제 이중 채널 복제 마스터-슬레이브 복제 및 Redis Cluster 지원 확장성 자동 클러스터 장애 조치 및 개선된 확장성 클러스터링 및 샤딩 지원 관찰 가능성 상세한 모니터링을 위한 슬롯별 메트릭 제공 기본적인 모니터링 및 메트릭 RDMA 지원 RDMA에 대한 실험적 지원 기본 RDMA 지원 없음 플랫폼 지원 Linux, macOS, OpenBSD, NetBSD, FreeBSD Windows, Linux, macOS 개발 초점 높은 처리량과 낮은 지연 시간 고성능 및 데이터 지속성 기능 세트 Redis 7.2.4 기반, 일부 고급 기능 부족 더 광범위한 기능 세트 (JSON, TimeSeries 등) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 01:34:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Redis와 Valkey" href=https://buenhyden.github.io/posts/backend/databases/nosql/key-value/redis%EC%99%80-valkey/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)</h2></header><div class=entry-content><p>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program) 클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)은 한국인터넷진흥원(KISA)에서 주관하는 클라우드 서비스의 보안성을 평가하고 인증하는 제도.
이 제도는 클라우드 서비스 이용자의 정보보호를 강화하고 클라우드 서비스의 안정성과 신뢰성을 검증하기 위해 도입되었다.
CSAP의 주요 특징 인증 유형: CSAP는 다음과 같은 유형으로 분류된다:
IaaS (Infrastructure as a Service) SaaS (Software as a Service) DaaS (Desktop as a Service) 인증 등급: 2022년 12월 29일, 과학기술정보통신부는 CSAP 인증 기준을 개선하여 3단계 등급 체계(상, 중, 하)를 도입함.
...</p></div><footer class=entry-footer><span title='2024-09-19 11:39:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)" href=https://buenhyden.github.io/posts/security/governance-and-management/compliance-and-regulations/cloud-security-assurance-program/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>