<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Read Uncommitted</h2></header><div class=entry-content><p>Read Uncommitted Read Uncommitted(읽기 미확정) 는 트랜잭션 격리에서 가장 낮은 수준으로, 다른 트랜잭션의 커밋되지 않은 변경 (Dirty Read) 을 허용해 읽기 처리량을 최대화하려는 목적이다.
SQL 표준상 정의되지만, 많은 상용 DB 는 이를 진짜로 지원하지 않거나 내부적으로 Read Committed 로 승격하기 때문에 기대 동작을 DB 별로 확인해야 한다.
실무에서는 로그 집계·대략적 통계·탐색 쿼리처럼 정확성보다 속도가 우선인 경우에만 제한적으로 사용하며, 읽기 전용 커넥션 분리·금지 쿼리 목록·롤백 탐지·재검증 같은 가드레일을 반드시 둬야 안전하다.
읽기 성능이 필요하면 레플리카 기반 읽기, MVCC 스냅샷 격리 또는 샘플링을 우선 고려하는 편이 바람직하다.
...</p></div><footer class=entry-footer><span title='2025-09-12 03:46:00 +0000 UTC'>September 12, 2025</span>&nbsp;·&nbsp;28 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Read Uncommitted" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/transaction/transaction-isolation/transaction-isolation-levels/read-uncommitted/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pessimistic vs. Optimistic Locking</h2></header><div class=entry-content><p>Pessimistic vs. Optimistic Locking Pessimistic Locking은 충돌을 우려해 먼저 락을 거는 방식으로, 데이터 무결성이 중요한 환경에서 적합하다. Optimistic Locking은 충돌 가능성이 낮다고 보고 사후 검증을 통해 일관성을 보장한다. 시스템 요구사항과 성능 특성에 따라 선택된다.
등장 배경 및 발전 과정 Pessimistic Locking은 초기 RDBMS + ACID 보장 요구에서 발전했으며, 충돌 회피를 위한 보수적 접근 방식이 정립되었으며, Optimistic Locking은 낮은 충돌 환경을 가정한 성능 중심 전략으로, 분산 시스템, 웹/모바일 기반 환경에서 발전해왔다.
...</p></div><footer class=entry-footer><span title='2025-08-04 03:58:00 +0000 UTC'>August 4, 2025</span>&nbsp;·&nbsp;40 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pessimistic vs. Optimistic Locking" href=https://buenhyden.github.io/posts/data--database-systems/data-operations/transaction-management/concurrency-control/locking/locking-strategy/pessimistic-vs-optimistic-locking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker</h2></header><div class=entry-content><p>Event Broker 이벤트 브로커는 이벤트 기반 아키텍처에서 이벤트 발행자 (Producer) 와 구독자 (Consumer) 사이의 이벤트 메시지 흐름을 중개하는 미들웨어이다.
분산 마이크로서비스 환경에서 데이터 흐름의 실시간성, 비동기성, 확장성을 확보할 수 있도록 지원한다. 대용량 실시간 데이터 처리와 시스템 간의 결합도 감소, 장애 격리 및 이벤트 아카이빙 등 다양한 장점으로 인해 오늘날 IT 인프라에서 매우 중요한 역할을 차지한다.
이벤트 브로커는 Pub/Sub, 스트리밍, 다양한 QoS, 보안, 트랜잭션, 확장성, 장애 복구 등 다양한 기능을 제공하며, 시스템 간 결합도를 낮추고, 실시간 데이터 분배와 비동기 처리를 지원한다.
...</p></div><footer class=entry-footer><span title='2025-07-18 05:58:00 +0000 UTC'>July 18, 2025</span>&nbsp;·&nbsp;38 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Broker" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-brokers-vs-event-brokers/event-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Broker</h2></header><div class=entry-content><p>Message Broker 메시지 브로커는 다양한 애플리케이션, 서비스, 시스템 간 메시지 교환을 중개하는 미들웨어로, 비동기 통신, 결합도 감소, 확장성, 신뢰성, 장애 복원력 등 백엔드 시스템에 필수적인 역할을 한다. 메시지 큐 (Queue), 토픽 (Topic), 교환기 (Exchange) 등 다양한 구조를 통해 Point-to-Point, Publish/Subscribe 등 다양한 패턴을 지원하며, RabbitMQ, Kafka, ActiveMQ, Amazon SQS 등 다양한 솔루션이 존재한다. 메시지 브로커는 마이크로서비스, IoT, 실시간 데이터 처리, 대용량 트래픽 분산 등 다양한 분야에서 활용된다.
Source: https://ademcatamak.medium.com/what-is-message-broker-4f6698c73089
...</p></div><footer class=entry-footer><span title='2025-07-18 05:58:00 +0000 UTC'>July 18, 2025</span>&nbsp;·&nbsp;39 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Broker" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-brokers-vs-event-brokers/message-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Architecture Styles and Patterns</h2></header><div class=entry-content><p>Architecture Styles and Patterns Architecture Styles and Patterns 는 애플리케이션 및 분산 시스템에서 반복적으로 나타나는 설계 구조를 체계화한 개념으로, 소프트웨어 시스템의 구조, 컴포넌트 간 상호작용, 데이터 흐름, 확장성, 유지보수성 등 시스템의 근간을 결정한다.
아키텍처 스타일은 응용 시스템의 전체 구조를 포괄하는 추상적 설계 지침 (예: 레이어드, 이벤트 드리븐, 마이크로서비스 등) 이며, 아키텍처 패턴은 이러한 스타일을 실제 구현 수준에서 구체화한 설계 템플릿이다. 스타일은 전체 조직 구조를 정의하며, 패턴은 모듈간 상호작용 및 컴포넌트 분리 방식 등 설계 상세를 제공한다. 각각은 요구사항에 따라 성능, 확장성, 유지보수성, 응답성, 보안 등 품질 속성에 대한 타협점을 설명하며, 실무에서는 이를 조합하거나 상황에 맞춰 커스터마이징하는 전략이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-06-14 07:18:00 +0000 UTC'>June 14, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Architecture Styles and Patterns" href=https://buenhyden.github.io/posts/system-architecture--design/overview/architecture-styles--patterns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Design Methodology</h2></header><div class=entry-content><p>Design Methodology Design Methodology 는 " 무엇을 " 만드는지를 " 어떻게 " 구현 가능한 설계 산출물로 구체화하는 체계다. 프로세스 (분석→아키텍처→세부 설계), 표기 (UML·DFD 등), 원칙 (SOLID·단계적 세분화), 지원 도구 (CASE, CI/CD) 로 구성된다. 구조적·객체지향·도메인·모델 구동형 등 다양한 유형이 있으며, 각 방법론은 목표 품질, 팀 규모, 도메인 복잡도, 변경 빈도에 따라 선택·혼합된다. 올바른 선택과 지속적 피드백이 생산성과 유지보수성을 크게 좌우한다.
핵심 개념 설계 방법론 (Design Methodology) 은 문제 해결을 위한 체계적인 절차와 원칙, 도구의 집합이다. 이는 단순히 도구나 기법이 아니라, 문제 정의, 해결책 탐색, 평가, 반복을 포함하는 일련의 프로세스와 철학을 의미한다.
주요 관점은 사용자 중심 (User-centric), 반복 (Iterative), 협업 (Collaborative), 실험 (Experimental) 이다.
...</p></div><footer class=entry-footer><span title='2025-06-06 16:29:00 +0000 UTC'>June 6, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Design Methodology" href=https://buenhyden.github.io/posts/system-architecture--design/design-fundamentals/design-methodology/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GRASP vs. SOLID</h2></header><div class=entry-content><p>GRASP vs. SOLID GRASP 와 SOLID 는 상호 보완적인 객체지향 설계 원칙으로, GRASP 는 " 누가 무엇을 해야 하는가 " 에 대한 구체적인 책임 할당 패턴을 제공하고, SOLID 는 " 어떻게 설계해야 하는가 " 에 대한 포괄적인 설계 원칙을 제시한다. 두 원칙 모두 낮은 결합도, 높은 응집도, 확장성, 유지보수성을 목표로 하며, 현대 소프트웨어 개발에서 필수적인 설계 가이드라인이다.
핵심 개념 구분 항목 정의/설명 설계 목적 및 효과 GRASP 정의 객체지향 설계에서 책임 할당과 객체 간 협력을 효과적으로 하기 위한 9 가지 설계 패턴 세트 책임 분산, 구조적 안정성 확보, 결합도 최소화 핵심 패턴 - Information Expert
- Creator
- Controller
- Low Coupling
- High Cohesion
- Polymorphism
- Pure Fabrication
- Indirection
- Protected Variations 객체 간 책임 할당 원칙, 협력 방식 정의 주요 설계 방향 객체에 적절한 책임 부여, 변화에 강한 유연한 구조 설계 응집도 ↑, 결합도 ↓, 변경 영향 최소화 SOLID 정의 객체지향 설계에서 유지보수성과 확장성을 높이기 위한 5 가지 원칙을 나타내는 약어 확장 가능하고 견고한 소프트웨어 구조 확립 핵심 원칙 - SRP (단일 책임 원칙)
- OCP (개방 - 폐쇄 원칙)
- LSP (리스코프 치환 원칙)
- ISP (인터페이스 분리 원칙)
- DIP (의존 역전 원칙) 클래스와 모듈 단위의 구조 품질 향상 주요 설계 방향 변화에 유연한 클래스 설계, 테스트 용이성 강화, 인터페이스 기반 추상화 유지보수성 ↑, 재사용성 ↑, 확장성 ↑ GRASP vs. SOLID 비교 GRASP 와 SOLID 는 객체지향 설계에서 서로 다른 측면을 강조한다. GRASP 는 객체에 책임을 어떻게 할당할지를 중심으로 하며, SOLID 는 클래스 설계의 원칙을 통해 코드의 유연성과 유지보수성을 강조한다.
...</p></div><footer class=entry-footer><span title='2025-06-03 03:02:00 +0000 UTC'>June 3, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GRASP vs. SOLID" href=https://buenhyden.github.io/posts/software-development--engineering/fundamentals/programming-principles/design-principles/grasp/grasp-vs-solid/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Failback vs. Fail Over</h2></header><div class=entry-content><p>Failback vs. Fail Over Failover 와 Failback 은 고가용성과 재해 복구 전략에서 중요한 이중 절차이다. 페일오버 (Failover) 는 Active-Passive/Active-Active 구성에서 장애 감지 후 트래픽 전환을 수행하며, AWS ELB, Kubernetes Pod 재배치 등에 적용된다. 페일백 (Failback) 은 데이터 동기화 검증 후 점진적 복구를 수행하며, DB 복제본 재동기화, 클라우드 리전 복구 시나리오에서 활용된다.
설계 방식에 따라 RTO(Recovery Time Objective) 와 RPO(Recovery Point Objective) 에 큰 영향을 미친다.
2025 년 현재 AI 기반 자동 전환 알고리즘과 블록체인 검증 기술이 접목되는 추세이다.
...</p></div><footer class=entry-footer><span title='2025-05-18 12:46:00 +0000 UTC'>May 18, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Failback vs. Fail Over" href=https://buenhyden.github.io/posts/system-architecture--design/distributed-systems/reliability--resilience/recovery-patterns/fallback/failback-vs-fail-over/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Load Shifting vs. Load Balancing</h2></header><div class=entry-content><p>Load Shifting vs. Load Balancing 네트워크와 시스템 관리에서 부하 관리는 시스템의 안정성과 효율성을 유지하는 핵심 요소이다. 특히 로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.
로드 밸런싱(Load Balancing) 로드 밸런싱은 네트워크 트래픽이나 작업 부하를 여러 서버나 리소스에 고르게 분산시키는 기술이다. 이는 주로 실시간으로 이루어지며, 시스템의 전체적인 성능과 가용성을 향상시키는 것이 목적이다.
주요 특징 목적: 시스템 성능 최적화, 가용성 향상, 응답 시간 개선 타이밍: 실시간 또는 거의 실시간으로 작동 분배 방식: 여러 리소스에 작업을 균등하게 분산 적용 사례: 웹 서버 클러스터, 데이터베이스 클러스터, 컴퓨팅 그리드 로드 밸런싱 알고리즘 라운드 로빈(Round Robin): 순차적으로 각 서버에 요청을 할당한다.
...</p></div><footer class=entry-footer><span title='2025-04-04 02:45:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Shifting vs. Load Balancing" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-load-balancing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OAuth 2.0 vs. OpenID Connect</h2></header><div class=entry-content><p>OAuth 2.0 vs. OpenID Connect 개요 및 역사적 배경 OAuth 2.0 OAuth 2.0은 2012년에 IETF(Internet Engineering Task Force)에서 RFC 6749로 표준화된 인가(Authorization) 프레임워크이다. 이는 2007년에 발표된 OAuth 1.0의 후속 버전으로, 더 단순하고 확장 가능한 구현을 목표로 개발되었다. OAuth 2.0은 애플리케이션이 사용자 데이터에 접근할 수 있는 권한을 안전하게 위임하는 메커니즘을 제공한다.
OpenID Connect OpenID Connect(OIDC)는 2014년 OpenID Foundation에서 공식 발표한 OAuth 2.0 위에 구축된 ID 인증 레이어이다. OAuth 2.0이 주로 인가에 초점을 맞추고 있는 반면, OpenID Connect는 인증(Authentication)과 신원 확인 기능을 추가했다. OIDC는 이전 버전인 OpenID 2.0의 복잡성을 해결하고, OAuth 2.0과의 호환성을 제공하기 위해 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-03 14:02:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth 2.0 vs. OpenID Connect" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/oauth-2.x/oauth-20-vs-openid-connect/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/9/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/11/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>