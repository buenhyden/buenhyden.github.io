<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Poetry Libraries</h2></header><div class=entry-content><p>Poetry Libraries Poetry는 파이썬 라이브러리를 효율적으로 관리하고 배포할 수 있도록 지원하는 도구로 라이브러리를 설치 가능하게 만들기 위해 다음과 같은 절차를 따를 수 있다.
버전 관리 모든 프로젝트에 PEP 440을 준수하는 버전 번호를 요구한다. 버전 번호의 일관성을 유지하고, 패키지 관리 시스템과의 호환성을 보장한다.
1.0.0-hotfix과 같은 형식은 PEP 440과 호환되지 않는다. 1.0.0-post1 또는 1.0.0.post1과 같은 형식을 사용할 수 있다. PEP 440
파이썬 패키지의 버전 식별과 의존성 명시를 의한 표준을 정의한 문서. 파이썬 패키지의 버전 번호를 일관되게 관리하고, 패키지 간의 의존성을 명확하게 지정하여 호환성을 보장하는 데 목적이 있다. 버전 식별자 형식 1 [N!]N(.N)*[{a|b|rc}N][.postN][.devN] 각 요소의 설명 - N!: 에포크(epoch) 번호로, 버전 체계의 중대한 변경을 나타냄. - N(.N)*: 릴리스 번호로, 주 버전, 부 버전, 패치 버전 등을 포함. - {a|b|rc}N: 사전 릴리스(pre-release)로, 알파(a), 베타(b), 릴리스 후보(rc) 등을 나타낸다. - .postN: 포스트 릴리스(post-release)로, 버전 이후의 수정 사항을 나타낸다. - .devN: 개발 릴리스(development release)로, 개발 중인 버전을 나타낸다.
...</p></div><footer class=entry-footer><span title='2024-11-27 13:46:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Poetry Libraries" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-libraries/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Poetry Managing dependencies</h2></header><div class=entry-content><p>Poetry Managing Dependencies Poetry는 의존성을 효율적으로 관리하기 위해 다양한 기능을 제공한다.
의존성 그룹을 활용하기 위해 개발, 테스트, 문서화 등 목적에 따라 의존성을 체계적으로 분류할 수 있다.
의존성 그룹 설정 의존성 그룹을 정의하려면 pyproject.toml 파일에 다음과 같이 섹션을 추가한다.
&lt;group_name>은 그룹의 이름을 의미하며, 예를 들어 테스트 관련 의존성은 test 그룹으로 정의할 수 있다.
1 2 3 4 5 6 7 [tool.poetry.group.&lt;group_name>.dependencies] 패키지명 = "버전" # example [tool.poetry.group.test.dependencies] pytest = "^6.0.0" pytest-mock = "*" 의존성 그룹 설치 poetry install 명령어를 실행하면 모든 비선택적 그룹의 의존성이 설치된다.
...</p></div><footer class=entry-footer><span title='2024-11-27 13:46:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Poetry Managing dependencies" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-managing-dependencies/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Poetry Usage</h2></header><div class=entry-content><p>Poetry Usage 프로젝트 설정 poetry new 프로젝트명으로 새 프로젝트 생성 pyproject.toml 파일이 프로젝트와 의존성 관리의 중심 Python 버전 지정은 지원하려는 버전을 명시하는 것 의존성 지정 pyproject.toml의 [tool.poetry.dependencies] 섹션에 의존성 명시 poetry add 패키지명으로 의존성 추가 가능 가상 환경 사용 Poetry는 기본적으로 가상 환경을 생성하고 관리 poetry run으로 가상 환경 내에서 명령 실행 poetry shell로 가상 환경 활성화 버전 제약 조건 예: ^2.1은 2.1.0 이상 3.0.0 미만 버전 허용 의존성 설치 poetry install로 의존성 설치 poetry.lock 파일이 없으면 생성, 있으면 해당 버전으로 설치 poetry.lock 파일은 버전 관리에 포함하는 것이 좋음 의존성 업데이트 poetry update로 최신 버전으로 업데이트 운영 모드 기본 패키지 모드와 비패키지 모드 존재 비패키지 모드는 의존성 관리만을 위한 모드 기존 프로젝트 초기화 poetry init으로 기존 프로젝트에 Poetry 설정 추가 가능 참고 및 출처 Poetry Basic usage | Documentation | Poetry - Python dependency management and packaging made easy
...</p></div><footer class=entry-footer><span title='2024-11-27 13:46:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Poetry Usage" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/poetry/poetry-usage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>The pyproject.toml file</h2></header><div class=entry-content><p>The pyproject.toml File Python 프로젝트의 구성 정보와 빌드 시스템 요구 사항을 정의하는 표준화된 구성 파일.
TOML 형식을 사용하며 프로젝트의 메타데이터와 의존성을 중앙 집중적으로 관리한다.
주요 장점:
특정 빌드 시스템에 종속되지 않는 표준화된 설정 파일. TOML 형식을 사용하여 가독성이 높고 관리가 용이하다. 프로젝트의 모든 설정을 한 곳에서 관리할 수 있어 편리하다. pyproject.toml은 PEP 518, PEP 621 등의 파이썬 표준 제안에 의해 정의되었으며, 현대적인 파이썬 프로젝트 관리에 필수적인 요소로 자리잡고 있다.
역할 프로젝트 메타데이터 관리:
- 프로젝트 이름, 버전, 설명, 저자 등의 기본 정보를 포함한다.
- 라이선스, 키워드, 프로젝트 URL 등의 추가 정보도 저장할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-27 06:54:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to The pyproject.toml file" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/the-pyproject.toml-file/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rye</h2></header><div class=entry-content><p>Rye Rye는 파이썬 프로젝트와 패키지 관리를 위한 통합 솔루션으로, 2022년 11월에 Pynecone이라는 이름으로 처음 공개되었으나, 2023년 6월에 Rye로 이름이 변경되었다.
Rye는 파이썬 개발자들이 겪는 다양한 환경 설정 및 관리 문제를 해결하기 위해 설계되었다.
주요 특징 통합 환경 관리: Rye는 파이썬 설치, 프로젝트 초기화, 의존성 관리, 가상 환경 설정 등을 단일 도구로 통합한다. pyproject.toml 기반: 프로젝트 구성을 위해 현대적인 pyproject.toml 파일을 사용한다. 빠른 성능: Rust로 작성되어 기존 도구들보다 훨씬 빠른 성능을 제공한다. 다목적성: 복잡한 프로젝트, 모노레포, 글로벌 도구 설치 등 다양한 시나리오를 지원한다. 자동화된 가상 환경: 프로젝트별로 독립적인 가상 환경을 자동으로 생성하고 관리한다. 설치 및 사용 Rye는 다양한 운영 체제에서 쉽게 설치할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-27 04:19:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rye" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/package-managers/rye/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PEP 20–The Zen of Python</h2></header><div class=entry-content><p>PEP 20–The Zen of Python 파이썬의 철학과 디자인 원칙을 담고 있다.
파이썬 인터프리터에서 import this를 실행하면 볼 수 있다.
1. Beautiful is Better than Ugly. (아름다움이 추한 것보다 낫다) 코드는 보기 좋고 이해하기 쉽게 작성해야 한다.
1 2 3 4 5 6 7 8 # 아름다운 코드 names = ['Alice', 'Bob', 'Charlie'] for name in names: print(f"Hello, {name}!") # 추한 코드 x=['Alice','Bob','Charlie'] for i in range(len(x)):print("Hello, "+x[i]+"!") 2. Explicit is Better than Implicit. (명시적이 암시적인 것보다 낫다) 코드의 의도를 명확히 표현해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 20–The Zen of Python" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-20-the-zen-of-python/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PEP 257–Docstring Conventions</h2></header><div class=entry-content><p>PEP 257–Docstring Conventions Python 코드의 docstring 작성에 대한 규칙과 관례를 정의한 문서
정의
모듈, 함수, 클래스, 메서드 정의의 첫 번째 문장으로 오는 문자열 리터럴로, 해당 객체의 doc 특별 속성이 된다. 작성 대상
모든 모듈, 모듈이 내보내는 모든 함수와 클래스, 공개 메서드(생성자 포함)에 docstring을 작성해야 한다. 형식
항상 """삼중 큰따옴표"""를 사용한다.
한 줄 docstring과 여러 줄 docstring 두 가지 형식이 있다. 한 줄 Docstring 명확한 경우에 사용합니다. 마침표로 끝나는 구문으로 작성합니다. 함수/메서드의 효과를 명령형으로 설명합니다. 여러 줄 Docstring 요약 줄, 빈 줄, 자세한 설명 순으로 구성됩니다. 클래스 docstring 다음에는 빈 줄을 삽입합니다. 기본 규칙 1 2 3 4 5 6 7 def function(arg1, arg2): """한 줄 설명. 여러 줄에 걸친 자세한 설명. 매개변수와 반환값 설명. """ pass 모듈, 함수, 클래스별 Docstring 내용 모듈 내보내는 클래스, 예외, 함수 등을 나열
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 257–Docstring Conventions" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-257docstring-conventions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PEP 3000–Python 3000</h2></header><div class=entry-content><p>PEP 3000–Python 3000 Python 3000 개발 과정과 특징을 설명한다.
Python 3000, Python 3.0, Py3k는 모두 같은 프로젝트를 지칭한다.
PEP 번호 체계 : 3000-3099는 메타 PEP, 3100-3999는 기능 PEP 타임라인 : Python 2.6과 3.0의 동시 출시 계획을 포함. 호환성과 전환: Python 3.0은 2.x와 하위 호환성이 없다. Python 2.6은 “Py3k 경고 모드"와 일부 3.0 기능을 지원. 2to3 도구를 통해 2.x 코드를 3.0으로 변환할 수 있다. 개발 모델: 2.6과 3.0을 동시 지원하는 프로젝트를 위한 권장 개발 방법을 제시. 구현 언어: Python 3000은 C로 구현되며, Python 2 코드베이스에서 진화합니다. Python2와 Python3의 비교 문법 차이 기능 Python 2 Python 3 print문 print "Hello" print("Hello") 정수 나눗셈 5/2 → 2 5/2 → 2.5 예외 처리 except Error, e except Error as e range 리스트 반환 이터레이터 반환 문자열 포맷팅 % 연산자 중심 f-strings, format() 메서드 유니코드 표현 방식 항목 Python 2 Python 3 기본 문자열 ASCII Unicode (UTF-8) 유니코드 선언 u"문자열" 기본 지원 바이트 문자열 str bytes 인코딩 처리 명시적 처리 필요 자동 처리 국제화 지원 제한적 완전 지원 성능 차이 항목 Python 2 Python 3 실행 속도 기준 10-15% 향상 메모리 관리 GC 기본 향상된 GC 멀티스레딩 GIL 제한 GIL 개선 비동기 처리 제한적 async/await 지원 최적화 기본 향상된 최적화 메모리 사용량 차이 항목 Python 2 Python 3 기본 객체 크기 기준 20-30% 감소 문자열 처리 더 많은 메모리 최적화된 메모리 컬렉션 리스트 중심 메모리 효율적인 뷰 캐시 처리 기본 향상된 캐시 메모리 해제 덜 효율적 더 효율적 5. 파일 입출력 성능 차이 항목 Python 2 Python 3 기본 I/O 상대적 느림 15-20% 향상 텍스트 처리 ASCII 중심 유니코드 최적화 버퍼링 기본 향상된 버퍼링 비동기 I/O 제한적 완전 지원 대용량 파일 처리 제한적 효율적 처리 라이브러리 지원 차이 특징 Python 2 Python 3 표준 라이브러리 기본적인 모듈 제공 개선된 모듈 및 새로운 모듈 추가 (예: asyncio, statistics) 서드파티 라이브러리 지원 일부 레거시 라이브러리만 지원 대부분의 주요 라이브러리가 지원 (예: TensorFlow, PyTorch) 새로운 라이브러리 개발 거의 없음 활발히 진행 중 유니코드 관련 라이브러리 제한적 지원 향상된 지원 레거시 라이브러리 호환성 높음 일부 호환되지 않을 수 있음 라이브러리 업데이트 빈도 낮음 (지원 종료) 높음 (지속적인 개선) AI/ML 라이브러리 지원 제한적 광범위 웹 개발 프레임워크 일부 구버전만 지원 최신 버전 지원 (예: Django, Flask) 데이터 과학 라이브러리 제한적 지원 폭넓은 지원 (예: pandas, numpy 최신 버전) 보안 관련 라이브러리 업데이트 중단 지속적인 보안 업데이트 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 3000–Python 3000" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3000python-3000/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PEP 3333–Python Web Server Gateway Interface V1.0.1</h2></header><div class=entry-content><p>PEP 3333–Python Web Server Gateway Interface V1.0.1 Python Web Server Gateway Interface (WSGI) 버전 1.0.1을 정의한 문서.
PEP 333의 개정판으로, Python 3 지원을 개선하고 몇 가지 오랜 de facto 수정사항을 반영
PEP 3333은 PEP 333을 Python 3 시대에 맞게 업데이트한 버전이다.
주요 변경사항과 특징 Python 3 지원: 문자열 처리가 유니코드로 변경됨 environ 딕셔너리의 문자열은 str 타입이어야 함 응답 본문은 bytes 타입이어야 함 새로운 보안 고려사항: 헤더 인젝션 방지 안전한 문자열 처리 미들웨어 체이닝: 여러 미들웨어를 연결하여 요청/응답 처리 파이프라인 구성 가능 파일 핸들링: wsgi.input과 wsgi.errors를 통한 표준화된 입출력 처리 WSGI (Web Server Gateway Interface) 웹 서버와 Python 웹 어플리케이션 또는 프레임워크 간의 표준 인터페이스를 정의한다.
...</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 3333–Python Web Server Gateway Interface V1.0.1" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-3333python-web-server-gateway-interface-v1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PEP 484–Type Hints</h2></header><div class=entry-content><p>PEP 484–Type Hints Python에 타입 힌트(Type Hints)를 도입하여 함수의 인자와 반환값에 대한 타입을 명시할 수 있도록 하는 표준을 정의
Python 3.5부터 도입됨.
코드의 가독성을 높이고 정적 타입 분석 도구가 코드를 검사할 수 있도록 돕는다.
PEP 484는 Python의 동적 타이핑 특성을 유지하면서, 타입 힌트를 통해 코드의 품질과 유지보수성을 향상시키는 것을 목표로 한다.
주요 내용 함수 주석을 통한 타입 힌트 함수 인자와 반환값에 대한 타입 정보를 제공하여 코드의 의도를 명확히 한다. 예를 들어, 문자열을 인자로 받고 문자열을 반환하는 함수는 다음과 같이 정의할 수 있다. 1 2 3 4 def greeting(name: str) -> str: return 'Hello ' + name` # `name: str`: `name` 인자는 문자열이어야 함을 나타냅니다. # `-> str`: 함수가 문자열을 반환함을 나타냅니다. 정적 타입 검사 타입 힌트는 런타임에 강제되지 않으며, 정적 분석 도구(예: mypy)를 사용하여 코드의 타입 일관성을 검사할 수 있다. 이는 코드 작성 시 오류를 미리 발견하고 수정할 수 있게 도와준다. 타입 힌트 모듈 typing 모듈을 통해 다양한 타입 힌트를 제공한다. 예를 들어, 리스트, 딕셔너리와 같은 컨테이너 타입 및 제네릭(Generic) 타입을 지원한다. 유연한 사용 타입 힌트는 선택 사항이며, Python은 여전히 동적 타이핑 언어로 남아 있다. 즉, 모든 함수에 타입 힌트를 추가할 필요는 없다. 예제 간단한 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 1. 기본적인 타입 힌트 사용 def greeting(name: str) -> str: # name 파라미터는 문자열(str) 타입이어야 함을 나타냄 # -> str 은 함수가 문자열을 반환함을 나타냄 return f"Hello, {name}!" # 2. 여러 기본 타입들의 사용 def calculate_total(quantity: int, price: float) -> float: # quantity는 정수(int), price는 실수(float) 타입 # 반환값은 실수(float) 타입 return quantity * price # 3. 리스트 타입 힌트 사용 from typing import List def get_first_name(names: List[str]) -> str: # names는 문자열 리스트임을 나타냄 # List[str]은 모든 요소가 문자열인 리스트를 의미 return names[0] if names else "" # 4. 옵셔널 타입 사용 from typing import Optional def find_user(user_id: Optional[int]) -> Optional[str]: # user_id는 정수이거나 None일 수 있음을 나타냄 # 반환값도 문자열이거나 None일 수 있음 if user_id is None: return None return f"User_{user_id}" 복잡한 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 from typing import Dict, Tuple, Union, Callable # 5. 딕셔너리와 복합 타입 def process_user_data( user_info: Dict[str, Union[str, int]] ) -> Tuple[str, int]: # Dict[str, Union[str, int]]는 # - 키는 문자열이고 # - 값은 문자열 또는 정수인 딕셔너리를 의미 # Tuple[str, int]는 문자열과 정수로 구성된 튜플을 반환한다는 의미 name = user_info.get("name", "") age = user_info.get("age", 0) return name, age # 6. 함수 타입 힌트 def apply_operation( func: Callable[[int, int], int], x: int, y: int ) -> int: # Callable[[int, int], int]는 # - 두 개의 정수를 입력받고 # - 정수를 반환하는 함수를 의미 return func(x, y) # 7. 제네릭 타입 from typing import TypeVar, Sequence T = TypeVar('T') # 제네릭 타입 변수 정의 def first_element(sequence: Sequence[T]) -> Optional[T]: # Sequence[T]는 임의의 타입 T로 이루어진 시퀀스를 의미 # Optional[T]는 T 타입 또는 None을 반환할 수 있음을 의미 return sequence[0] if sequence else None 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-26 13:46:00 +0000 UTC'>November 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PEP 484–Type Hints" href=https://buenhyden.github.io/posts/programming-languages/python/pep/pep-484type-hints/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/27/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/29/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>