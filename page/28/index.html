<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>UWSGI</h2></header><div class=entry-content><p>UWSGI uWSGI는 파이썬 웹 애플리케이션을 위한 강력하고 유연한 애플리케이션 서버이다.
WSGI(Web Server Gateway Interface) 프로토콜을 구현하여 웹 서버와 파이썬 웹 애플리케이션 간의 표준화된 인터페이스를 제공한다.
적절한 설정과 튜닝을 통해 고성능, 안정성, 확장성을 제공하여 프로덕션 환경에서 파이썬 웹 애플리케이션을 효과적으로 운영할 수 있게 해준다.
uWSGI의 주요 특징 다양한 프로토콜 지원: HTTP, FastCGI, SCGI 등 여러 프로토콜을 지원한다. 고성능: 멀티 프로세싱과 멀티스레딩을 지원하여 높은 동시성과 성능을 제공한다. 유연성: 다양한 설정 옵션을 통해 세밀한 성능 튜닝이 가능한다. 플러그인 아키텍처: C, C++, Python 등 다양한 언어로 플러그인을 개발할 수 있어 확장성이 뛰어나다. 프로세스 관리: 마스터 프로세스가 워커 프로세스를 효율적으로 관리한다. uWSGI의 장점 높은 성능: 효율적인 리소스 관리로 높은 처리량을 제공한다. 안정성: 마스터 프로세스가 워커 프로세스를 관리하여 안정적인 운영이 가능하다. 유연성: 다양한 설정 옵션으로 다양한 환경에 적응할 수 있다. 확장성: 플러그인 아키텍처를 통해 기능을 확장할 수 있다. uWSGI의 작동 방식 웹 서버(예: Nginx)가 클라이언트로부터 요청을 받는다. 웹 서버는 이 요청을 uWSGI 서버로 전달한다. uWSGI는 요청을 파이썬 애플리케이션(예: Django, Flask)에 전달한다. 파이썬 애플리케이션이 요청을 처리하고 응답을 생성한다. uWSGI는 이 응답을 웹 서버로 반환하고, 웹 서버는 최종적으로 클라이언트에게 응답을 전송한다. uWSGI의 로드밸런싱 uWSGI는 내장된 로드 밸런싱 기능을 제공하여 여러 워커 프로세스 간에 요청을 효율적으로 분산시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-30 03:36:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UWSGI" href=https://buenhyden.github.io/posts/programming-languages/python/library/web-application-server/uwsgi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>pydantic</h2></header><div class=entry-content><p>Pydantic Pydantic은 Python에서 데이터 검증과 설정 관리를 위한 강력한 라이브러리이다.
이 라이브러리는 타입 힌트를 사용하여 데이터 모델을 정의하고 자동으로 데이터를 검증한다.
주요 특징:
타입 힌트 기반 데이터 검증: Pydantic은 Python의 타입 힌트를 활용하여 데이터의 구조와 타입을 명확하게 정의한다. 자동 데이터 변환: 입력된 데이터를 적절한 타입으로 자동 변환한다. 예를 들어, 문자열로 입력된 숫자를 정수형으로 변환할 수 있다. 유효성 검사: 데이터가 정의된 규칙에 맞지 않을 경우 명확한 오류 메시지를 제공한다. JSON 직렬화 및 역직렬화: 모델 객체를 JSON으로 쉽게 변환하거나 JSON 데이터를 모델 객체로 변환할 수 있다. 사용 방법:
Pydantic을 사용하기 위한 기본적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-30 03:01:00 +0000 UTC'>November 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to pydantic" href=https://buenhyden.github.io/posts/programming-languages/python/library/static-typing/pydantic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ruff</h2></header><div class=entry-content><p>Ruff Rust로 작성된 고성능 Python 린터이자 코드 포매터.
정적 분석을 통해 코드의 스타일 및 오류를 검토하고 잠재적 문제를 조기에 발견할 수 있도록 돕는다. 코드 스타일과 오류 탐지를 위한 기본 규칙 세트를 포함하고 있다. 기본적으로 PEP8 스타일 가이드를 기반으로 하며, 불필요한 공백, 잘못된 들여쓰기, 코드 복잡도 등 다양한 문제를 다룬다. 다양한 플러그인을 지원하며, 특정 코드 스타일이나 검사 규칙에 맞춘 프리셋을 불러올 수 있다. 특징 속도: 기존 린터들보다 10~100배 빠르다. 다기능성: Flake8, isort, pyupgrade, Black 등 여러 도구를 대체할 수 있다. 800개 이상의 린트 규칙을 지원. 자동 수정: 많은 린트 문제를 자동으로 수정할 수 있다. 설정 용이성: pyproject.toml 파일을 통해 쉽게 설정할 수 있다. 에디터 통합: VS code, Neovim, PyCharm 등 다양한 에디터와 통합 CI/CD 통합: Github Actions와 같은 CI/CD 환경에서 Ruff를 사용하여 코드 품질을 자동으로 검사할 수 있다. 모노레포 친화적: 프로젝트 내 여러 수준에서 설정 파일을 가질 수 있다. Jupyter 노트북 지원: Jupyter Notebook도 린트 및 포맷할 수 있다. 커스터마이징: 규칙 선택, 무시, 수정 가능 여부 등을 세밀하게 제어할 수 있다. 캐싱: 변경되지 않은 파일은 다시 분석하지 않아 실행시 더욱 빠르다 지속적인 개발: 활발한 개발과 커뮤니티 지원으로 계속 발전중 설치 방법 PyPI를 통한 설치 PyPI에서 ruff라는 이름으로 제공
...</p></div><footer class=entry-footer><span title='2024-11-28 08:18:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ruff" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/ruff/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>autopep8</h2></header><div class=entry-content><p>Autopep8 Python 코드를 PEP 8 스타일 가이드라인에 맞게 자동으로 포맷팅해주는 도구.
PEP 8은 Python 코드의 가독성과 일관성을 높이기 위한 스타일 가이드로, Python 커뮤니티에서 널리 받아들여지는 표준이다.
장점:
유연성과 사용자 정의 가능성이 높다. 코드의 일관성을 유지하는 데 도움이 된다. 단점:
때로는 import 문을 과도하게 정렬하여 문제를 일으킬 수 있다. 들여쓰기를 완벽하게 강제하지 않을 수 있다. 사용예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 원본 코드 (포맷팅 전) def badly_formatted_function ( x,y ,z = 100 ): """이 함수는 의도적으로 나쁜 포맷팅을 가진 예시입니다""" result=x+ y+z if result>50: print( "결과가 50보다 큽니다!") elif result&lt;0: print("결과가 음수입니다!") else:print( "결과가 0에서 50 사이입니다.") return result # list comprehension with bad formatting numbers=[ i for i in range( 10 )if i%2==0] # autopep8 실행 후의 코드 def badly_formatted_function(x, y, z=100): """이 함수는 의도적으로 나쁜 포맷팅을 가진 예시입니다""" result = x + y + z if result > 50: print("결과가 50보다 큽니다!") elif result &lt; 0: print("결과가 음수입니다!") else: print("결과가 0에서 50 사이입니다.") return result # list comprehension with proper formatting numbers = [i for i in range(10) if i % 2 == 0] autopep8은 파이썬 코드를 PEP 8 스타일 가이드에 맞게 자동으로 포맷팅해주는 도구입니다. 주요 특징과 사용법은 다음과 같습니다:
...</p></div><footer class=entry-footer><span title='2024-11-28 03:04:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to autopep8" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/autopep8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Black</h2></header><div class=entry-content><p>Black Black은 파이썬을 위한 강력하고 엄격한 코드 포매터.
“The Uncompromising Code Formatter"라는 모토를 가지고 있으며, 코드 스타일에 관한 논쟁을 줄이고 개발자들이 더 중요한 작업에 집중할 수 있도록 돕는 것을 목표로 한다.
주요 특징 일관성: Black은 모든 프로젝트에서 일관된 코드 스타일을 제공한다. 자동화: 코드를 자동으로 포맷팅하여 개발자의 수동 작업을 줄인다. PEP 8 호환: Python의 공식 스타일 가이드인 PEP 8을 따르지만, 일부 규칙은 더 엄격하다. 최소한의 설정: 설정 옵션이 제한적이어서 팀 내 스타일 논쟁을 줄인다. 빠른 실행: 대규모 코드베이스에서도 빠르게 작동한다. 핵심 원칙 줄 길이 제한 기본적으로 88자로 제한된다. (이는 PEP 8의 79자보다 더 관대합니다) 긴 줄은 자동으로 여러 줄로 나뉜다. 괄호 안의 요소들은 수직으로 정렬된다. 일관된 문자열 따옴표 사용 기본적으로 큰따옴표(")를 선호한다. 문자열 내에 따옴표가 있는 경우 자동으로 적절한 따옴표를 선택한다. 공백과 들여쓰기 항상 4칸 들여쓰기를 사용한다. 연산자 주변에 일관된 공백을 추가한다. 쉼표 뒤에 항상 공백을 추가한다. 설치 및 사용 pip를 통해 쉽게 설치할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-28 03:04:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Black" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/black/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Flake8</h2></header><div class=entry-content><p>Flake8 Flake8은 파이썬 코드를 위한 강력한 린팅(linting) 도구.
코드 스타일을 체크하고 잠재적인 버그를 감지하는 데 사용된다.
주요 특징 PEP 8 준수: Flake8은 파이썬의 공식 스타일 가이드인 PEP 8을 기반으로 코드를 분석한다. 통합 도구: PyFlakes, pycodestyle, McCabe 복잡도 체커를 하나로 통합한 도구이다. 확장성: 다양한 플러그인을 지원하여 기능을 확장할 수 있다. 빠른 실행 속도: 대규모 코드베이스에서도 빠르게 작동한다. ### 검사하는 주요 항목들 Flake8은 다양한 종류의 코드 품질 문제를 검사한다:
PyFlakes를 통한 논리적 오류 검사: 사용되지 않는 임포트 참조되지 않는 변수 문법 오류 이름 공간 관련 문제 pycodestyle을 통한 PEP 8 준수 검사: 들여쓰기 줄 길이 공백 사용 명명 규칙 임포트 순서 McCabe 복잡도 검사: 함수와 메서드의 복잡도 측정 너무 복잡한 코드 블록 식별 리팩토링이 필요한 부분 감지 설치 및 기본 사용법 Flake8은 pip를 통해 쉽게 설치할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-28 03:04:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Flake8" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/flake8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAPF(Yet Another Python Formatter)</h2></header><div class=entry-content><p>YAPF(Yet Another Python Formatter) Google에서 개발한 파이썬 코드 포매터.
이는 마치 전문 편집자가 문서의 형식을 일관되게 정리하는 것처럼, 파이썬 코드의 스타일을 자동으로 정리해주는 도구이다.
YAPF는 코드의 논리는 그대로 유지하면서, 가독성과 일관성을 높이는 방식으로 코드를 재구성한다.
주요 특징 다양한 스타일 지원: PEP 8, Google, Facebook 등 사전 정의된 스타일을 제공한다. 높은 구성 가능성: 사용자가 세부적인 포맷팅 규칙을 설정할 수 있다. 강력한 재포맷팅: PEP 8을 준수하는 코드도 더 나은 가독성을 위해 재구성한다. 장점 높은 유연성과 구성 가능성 다양한 내장 스타일 제공 단점 설정의 복잡성 때로는 비결정적인 포맷팅 결과 작동 방식 이해하기 YAPF는 파이썬 코드를 다음과 같은 단계로 처리한다:
...</p></div><footer class=entry-footer><span title='2024-11-28 03:04:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAPF(Yet Another Python Formatter)" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/yapf/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pylint</h2></header><div class=entry-content><p>Pylint Pylint는 파이썬 코드의 품질을 검사하고 개선하는데 도움을 주는 강력한 정적 코드 분석 도구.
장점 포괄적인 검사: 다양한 유형의 문제를 감지한다. 사용자 정의: 규칙을 커스터마이징할 수 있다. IDE 통합: 많은 개발 환경에 통합되어 있다. 단점 때때로 과도하게 엄격할 수 있다. 초기 설정이 복잡할 수 있다. 출력 형식 오류 코드, 행 번호, 문제 설명 등을 포함한 상세한 보고서를 제공한다. 주요 기능과 예시 코딩 스타일 검사:
파이썬의 공식 스타일 가이드인 PEP 8을 기준으로 코드 스타일을 검사한다.
...</p></div><footer class=entry-footer><span title='2024-11-28 03:03:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pylint" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/linter-and-formatter/pylint/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CGI</h2></header><div class=entry-content><p>CGI(Common Gateway Interface) Python의 CGI(Common Gateway Interface)는 웹 서버와 외부 프로그램 간의 통신을 위한 표준 인터페이스.
Python에서 CGI를 사용하면 동적 웹 콘텐츠를 생성할 수 있다.
https://www.geeksforgeeks.org/what-is-cgi-in-python/
주요 특징 웹 서버와 Python 프로그램 간의 통신 방식을 정의합니다. 클라이언트의 요청을 처리하고 동적으로 HTML 페이지를 생성합니다. 환경 변수와 표준 입출력을 통해 데이터를 주고받습니다. 프로그램의 구조 셔뱅 라인: #!/usr/bin/python3 필요한 모듈 임포트: import cgi CGI 필드 스토리지 객체 생성: form = cgi.FieldStorage() HTTP 헤더 출력: print(‘Content-type: text/html\n’) HTML 콘텐츠 생성 및 출력 장점 간단하고 이해하기 쉬운 구조 다양한 프로그래밍 언어 지원 웹 서버와 독립적으로 동작 단점 요청마다 새로운 프로세스를 생성하여 리소스 사용량이 많음 대규모 애플리케이션에서는 성능 저하 발생 가능 예시 코드 1 2 3 4 5 6 7 8 #!/usr/bin/python3 import cgi form = cgi.FieldStorage() name = form.getvalue('name', 'World') print('Content-type: text/html\n') print(f'&lt;html>&lt;body>&lt;h1>Hello, {name}!&lt;/h1>&lt;/body>&lt;/html>') 이 코드는 사용자의 이름을 입력받아 인사말을 출력하는 간단한 CGI 프로그램.
...</p></div><footer class=entry-footer><span title='2024-11-28 03:02:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CGI" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/gateway-interface/cgi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WSGI</h2></header><div class=entry-content><p>WSGI(Web Server Gateway Interface) 파이썬 웹 애플리케이션과 웹 서버 간의 표준 인터페이스를 정의하는 규약이다.
WSGI는 웹 서버와 웹 애플리케이션 사이에서 중개자 역할을 하며, 파이썬 웹 개발에서 중요한 역할을 담당한다.
웹 서버와 파이썬 애플리케이션의 관계를 생각해보면,
웹 서버(예: Apache, Nginx)는 HTTP 요청을 받아서 처리해야 하고, 파이썬 애플리케이션은 비즈니스 로직을 실행해야 한다. 이 둘을 연결하는 중간자 역할로 WSGI가 등장한다.
WSGI는 2003년 PEP 333에서 처음 제안되었고, 현재는 PEP 3333에서 파이썬 3를 위해 업데이트되었다.
WSGI는 웹 서버와 파이썬 웹 애플리케이션 사이의 표준 인터페이스를 정의한다.
표준화된 인터페이스가 있기 때문에, 어떤 WSGI 서버든 어떤 WSGI 애플리케이션이든 서로 호환되어 동작할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-28 03:02:00 +0000 UTC'>November 28, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WSGI" href=https://buenhyden.github.io/posts/programming-languages/python/advanced/gateway-interface/wsgi/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/27/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/29/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>