<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.143.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Integer</h2></header><div class=entry-content><p>정수 (Integer) 정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.
특징과 특성 고정된 크기의 메모리 사용 빠른 연산 속도 범위의 제한 (오버플로우 가능성) 직접적인 산술 연산 지원 종류 byte
범위: -128 ~ 127 8비트 비트 구성: 1비트 부호 + 7비트 값 특징: 가장 작은 정수 타입 메모리 효율적이지만 표현 범위가 제한적 주로 작은 범위의 데이터나 문자 표현에 사용 short
범위: -32,768 ~ 32,767 16비트 비트 구성: 1비트 부호 + 15비트 값 특징: 8비트보다 넓은 범위 표현 가능 메모리 사용량과 표현 범위의 균형이 좋음 작은 정수 값을 다룰 때 효율적 int
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Integer" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/integer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>문자 (Character)과 문자열 (String)</h2></header><div class=entry-content><p>문자 (Character) 단일 문자를 표현하는 데이터 타입이다. 각 프로그래밍 언어별로 character의 구현과 사용 방식이 다소 다르다.
Character는 단일 문자를 나타내는 데이터 타입으로, 일반적으로 문자, 숫자, 특수 문자, 공백 등을 포함할 수 있다.
특징 고정 크기: 대부분의 언어에서 character는 고정된 메모리 크기를 가진다. 유니코드 지원: 많은 현대 프로그래밍 언어에서 유니코드 문자를 지원한다. 정수형과의 호환성: 대부분의 언어에서 character는 정수형으로 변환 가능하다. 특성 불변성: 많은 언어에서 character는 불변(immutable) 타입이다. 순서성: ASCII 또는 유니코드 값을 기반으로 순서를 가진다. 단일 값: 하나의 문자만을 저장할 수 있다. 연산 종류 및 설명 비교 연산: 문자 간 대소 비교가 가능하다. 산술 연산: 정수형으로 변환하여 산술 연산이 가능하다. 형변환: 정수형이나 문자열로의 변환이 가능하다. 실제 활용 사례 및 설명 Java Java에서는 ‘char’ 키워드를 사용하여 character를 선언한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;542 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 문자 (Character)과 문자열 (String)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/character-and-string/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>부동 소수점 (Float)</h2></header><div class=entry-content><p>부동 소수점 (Float) 부동 소수점은 실수를 (부호) × (가수) × (밑수)^(지수) 형태로 표현하는 방식이다.
‘부동’은 소수점이 움직인다는 의미로, 넓은 범위의 실수를 표현할 수 있다.
특징 IEEE 754 표준을 따름 부호, 지수, 가수 부분으로 구성 IEEE 754 표준에 따른 부동 소수점 종류 Half Precision
이 형식은 가장 작은 부동 소수점 표현 방식.
16비트를 사용한다.
1비트는 부호, 5비트는 지수부, 10비트는 가수부로 구성된다.
주로 그래픽스나 머신러닝에서 메모리를 절약하기 위해 사용된다.
약 3자리의 십진 정밀도를 제공하며, ±6.1 × 10⁻⁵에서 ±6.5 × 10⁴까지의 범위를 표현할 수 있다.
예시:
Python: 1 2 3 import numpy as np x = np.float16(3.14) print(x) # 3.14 JavaScript: JavaScript는 기본적으로 Half Precision을 지원하지 않는다. 외부 라이브러리를 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;540 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부동 소수점 (Float)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/primitive/float/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>이진 트리 (Binary Tree)</h2></header><div class=entry-content><p>이진 트리 (Binary Tree) 이진 트리는 각 노드가 최대 두 개의 자식 노드를 가질 수 있는 트리 데이터 구조로, 계층적 데이터를 정렬된 방식으로 저장하고 조직하는 데 사용된다.
이 자식 노드들은 일반적으로 왼쪽 자식과 오른쪽 자식으로 불린다.
특징 각 노드는 최대 두 개의 자식을 가질 수 있다. 노드의 깊이는 루트 노드로부터 해당 노드까지의 간선 수이다. 트리의 높이는 루트에서 가장 먼 리프까지의 간선 수이다. 이진 트리의 리프 노드 수는 항상 두 자식을 가진 노드 수보다 1만큼 많다. 장점 효율적인 검색: 이진 검색 알고리즘을 사용할 수 있어 검색이 빠르다. 순서화된 순회: 중위, 전위, 후위 순회 등 다양한 순회 방법을 제공한다. 메모리 효율성: 다른 트리 구조에 비해 상대적으로 메모리 효율적이다. 구현 용이성: 이해하고 구현하기 쉬워 다양한 응용 분야에서 사용된다. 응용 데이터베이스 인덱싱 파일 시스템 구현 우선순위 큐 구현 심볼 테이블 관리 결정 트리 (의사결정 분석에 사용) 표현식 파싱 (컴파일러 설계) 네트워크 데이터 라우팅 동작 원리 검색: 루트에서 시작하여 찾고자 하는 값과 비교하며 왼쪽 또는 오른쪽으로 이동한다. 삽입: 적절한 위치를 찾아 새 노드를 추가한다. 삭제: 노드를 제거하고 트리의 속성을 유지하도록 재구성한다. 트리 순회(Tree Traversal) 전위 순회(Preorder): 노드 방문 -> 왼쪽 서브트리 -> 오른쪽 서브트리 중위 순회(Inorder): 왼쪽 서브트리 -> 노드 방문 -> 오른쪽 서브트리 후위 순회(Postorder): 왼쪽 서브트리 -> 오른쪽 서브트리 -> 노드 방문 레벨 순서 순회(Level-order): 각 레벨별로 왼쪽에서 오른쪽으로 순회 구성 요소 노드(Node): 데이터를 저장하는 기본 단위 데이터 필드: 실제 저장하는 값 왼쪽 자식 포인터: 왼쪽 자식 노드를 가리키는 참조 오른쪽 자식 포인터: 오른쪽 자식 노드를 가리키는 참조 루트: 트리의 최상위 노드. 리프: 자식이 없는 노드. 간선(Edge): 노드들을 연결하는 선 부모 노드와 자식 노드를 연결 방향성을 가짐 (부모에서 자식으로) 구현 방식 이진 트리는 일반적으로 연결된 노드를 사용하여 구현되지만, 배열을 사용하여 표현할 수도 있다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:05:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;618 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 트리 (Binary Tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/basic/binary-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Exception Handling</h2></header><div class=entry-content><p>예외 처리 (Exception Handling) 예외 처리(Exception Handling)는 프로그램 실행 중 발생할 수 있는 예기치 못한 상황을 관리하는 중요한 프로그래밍 개념이다.
예외 처리란 프로그램 실행 중 발생할 수 있는 예상치 못한 오류 상황에 대비하여 코드를 작성하는 것으로, 프로그램의 비정상적인 종료를 방지하고 정상적인 실행 상태를 유지하는 것을 목적으로 한다.
예외 처리의 중요성 프로그램 안정성 향상: 예외 처리를 통해 프로그램이 갑작스럽게 종료되는 것을 방지한다. 디버깅 용이성: 예외 발생 시 로그를 남겨 문제의 원인을 쉽게 파악할 수 있다. 사용자 경험 개선: 오류 발생 시 사용자에게 적절한 메시지를 제공할 수 있다. 예외 처리 방법 대부분의 프로그래밍 언어에서는 try-catch 블록을 사용하여 예외를 처리한다:
...</p></div><footer class=entry-footer><span title='2024-10-06 15:08:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;183 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Exception Handling" href=https://buenhyden.github.io/posts/programming-languages/concepts/exception-handling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>조건문 (Conditional Statements)</h2></header><div class=entry-content><p>조건문 (Conditional Statements) 프로그래밍에서 조건문(Conditional Statements)은 프로그램의 흐름을 제어하는 중요한 구조이다.
조건문은 특정 조건이 참(true)인지 거짓(false)인지에 따라 다른 코드 블록을 실행하도록 하는 프로그래밍 구조로, 이를 통해 프로그램은 다양한 상황에 대응할 수 있게 된다.
주요 조건문 종류 if 문:
가장 기본적인 조건문. 조건이 참일 때 특정 코드 블록을 실행한다. if-else 문:
조건이 참일 때와 거짓일 때 각각 다른 코드 블록을 실행한다. else if 문:
여러 조건을 순차적으로 검사할 때 사용한다. switch 문:
...</p></div><footer class=entry-footer><span title='2024-10-06 15:08:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;157 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조건문 (Conditional Statements)" href=https://buenhyden.github.io/posts/programming-languages/concepts/conditional-statements/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>반복문(Iteration)</h2></header><div class=entry-content><p>반복문(Iteration) 프로그래밍에서 반복문(Iteration)은 특정 코드 블록을 여러 번 실행하는 제어 구조이다.
반복문은 프로그램에서 같은 작업을 여러 번 수행해야 할 때 사용한다.
이를 통해 코드의 중복을 줄이고 효율적으로 작업을 처리할 수 있다.
주요 반복문 종류 for 문:
정해진 횟수만큼 반복할 때 주로 사용. 초기화, 조건, 증감식을 한 줄에 표현한다. while 문:
조건이 참인 동안 계속해서 반복한다. 반복 횟수가 정해지지 않았을 때 유용하다. do-while 문:
while 문과 비슷하지만, 최소 한 번은 실행된다. 반복문의 구성 요소 초기화: 반복문에서 사용할 변수를 초기화한다. 조건식: 반복을 계속할지 결정하는 조건을 설정한다. 반복 실행문: 조건이 참일 때 실행되는 코드 블록이다. 증감식: 반복 변수를 변경하여 언젠가 조건이 거짓이 되도록 한다. 반복문의 장점 코드 재사용: 같은 코드를 여러 번 작성하지 않아도 된다. 효율성: 대량의 데이터나 반복적인 작업을 효율적으로 처리할 수 있다. 가독성: 반복되는 작업을 간결하게 표현할 수 있다. 주의사항 무한 루프: 조건식이 항상 참이 되지 않도록 주의해야 한다. 성능: 중첩된 반복문은 성능에 영향을 줄 수 있으므로 필요한 경우에만 사용한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 15:06:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;152 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 반복문(Iteration)" href=https://buenhyden.github.io/posts/programming-languages/concepts/iteration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>재귀 (Recursion)</h2></header><div class=entry-content><p>재귀 (Recursion) 재귀(Recursion)는 컴퓨터 프로그래밍에서 함수가 자기 자신을 호출하여 문제를 해결하는 방식으로, 큰 문제를 동일한 형태의 작은 문제로 나누어 해결하는 방법이다.
재귀 함수는 다음과 같은 두 가지 주요 부분으로 구성된다:
기본 조건 (Base Case): 재귀 호출을 멈추는 조건 재귀 호출 (Recursive Case): 함수가 자기 자신을 호출하는 부분 재귀의 작동 원리 재귀 함수가 호출될 때마다 새로운 함수의 복사본이 만들어져 실행된다.
이 과정은 기본 조건에 도달할 때까지 계속된다.
예를 들어, 팩토리얼을 계산하는 재귀 함수를 살펴보자:
...</p></div><footer class=entry-footer><span title='2024-10-06 15:05:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;489 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 재귀 (Recursion)" href=https://buenhyden.github.io/posts/programming-languages/concepts/recursion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>가비지 컬렉션 (Garbage Collection, GC)</h2></header><div class=entry-content><p>가비지 컬렉션 (Garbage Collection, GC) 프로그래밍 언어의 메모리 관리 기법 중 하나로, 프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용하지 않는 영역을 자동으로 찾아내어 해제하는 기능
주요 특징 자동 메모리 관리: 프로그래머가 명시적으로 메모리를 해제할 필요가 없다. 메모리 누수 방지: 사용하지 않는 객체를 자동으로 제거하여 메모리 누수를 예방한다. 개발 생산성 향상: 메모리 관리에 대한 부담을 줄여 개발자가 비즈니스 로직에 집중할 수 있게 한다. 실행 시간 오버헤드: 가비지 컬렉션 프로세스가 실행되는 동안 프로그램의 성능에 영향을 줄 수 있다. 기본 원리 도달 가능성(Reachability): 프로그램의 루트(예: 전역 변수, 스택의 지역 변수)로부터 참조 체인을 따라 도달할 수 있는 객체는 “살아있는” 객체로 간주된다. 표시(Mark): GC는 먼저 모든 살아있는 객체를 표시한다. 수집(Sweep): 표시되지 않은 객체들은 “가비지"로 간주되어 메모리에서 해제된다. 주요 알고리즘 참조 카운팅(Reference Counting): 각 객체에 대한 참조 수를 추적하여 참조 수가 0이 되면 해당 객체를 수집합니다. 마크-스윕(Mark-and-Sweep): 루트에서 접근 가능한 모든 객체를 마크하고, 마크되지 않은 객체를 수집합니다. 세대별 수집(Generational Collection): 객체를 새로운 객체와 오래된 객체로 분류하여 효율적으로 관리합니다. 각 언어별 가비지 컬렉션의 특징 특징 Java Python JavaScript 기본 알고리즘 세대별 GC (Generational GC) 참조 카운팅 + 세대별 GC 표시-소거 (Mark-and-Sweep) 메모리 구분 Young Generation (Eden, S0, S1), Old Generation 3세대 (young, middle, old) Heap (New Space, Old Space) GC 종류 Serial, Parallel, CMS, G1, ZGC 참조 카운팅 GC, 세대별 GC V8 엔진의 자동 GC 수동 제어 System.gc() (권장하지 않음) gc.collect() 불가능 약한 참조 지원 WeakReference, SoftReference weakref 모듈 WeakMap, WeakSet 순환 참조 처리 자동 처리 순환 참조 감지기로 처리 자동 처리 GC 일시 중지 Stop-the-World (ZGC 제외) 참조 카운팅은 즉시 수행 증분식 GC로 최소화 튜닝 옵션 JVM 파라미터로 다양한 튜닝 가능 gc 모듈로 제한적 튜닝 엔진 내부에서 자동 최적화 메모리 모니터링 JVM 도구로 상세 모니터링 가능 gc 모듈로 제한적 모니터링 개발자 도구로 제한적 모니터링 각 언어별 가비지 컬렉션 장단점 장단점 Java Python Javascript 장점 - 매우 성숙하고 최적화된 GC 알고리즘
- 다양한 GC 알고리즘 선택 가능
- 세밀한 튜닝 가능 - 참조 카운팅으로 즉시 메모리 해제
- 간단한 구현
- 예측 가능한 동작 - 완전히 자동화된 메모리 관리
- 개발자 개입 최소화
- 증분식 GC로 성능 최적화 단점 - Stop-the-World로 인한 성능 영향
- 복잡한 튜닝 필요
- 메모리 오버헤드 - 순환 참조 처리에 추가 비용
- 참조 카운팅 오버헤드
- 멀티스레딩에서의 성능 영향 - 제어 불가능
- 메모리 사용 예측 어려움
- 브라우저마다 다른 구현 Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class GCDemo { public void createObjects() { // 강한 참조 StringBuilder builder = new StringBuilder(); // 약한 참조 WeakReference&lt;StringBuilder> weakBuilder = new WeakReference&lt;>(new StringBuilder()); // System.gc()를 호출하면 GC가 실행될 수 있지만, // 보장되지는 않습니다 System.gc(); } } Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import gc class CircularRef: def __init__(self): self.ref = None def __del__(self): print("객체가 삭제됨") # 순환 참조 생성 a = CircularRef() b = CircularRef() a.ref = b b.ref = a # 참조 카운트 확인 print(sys.getrefcount(a)) # 2 (변수 a와 b.ref) # 명시적으로 GC 실행 gc.collect() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 // 표시-소거(Mark-and-Sweep) 알고리즘의 대상이 되는 객체 let user = { name: "John" }; // 객체에 대한 참조를 제거 user = null; // WeakMap을 사용한 약한 참조 예시 const weakMap = new WeakMap(); let key = {}; weakMap.set(key, "data"); key = null; // key 객체는 GC의 대상이 됨 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-06 10:19:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;554 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가비지 컬렉션 (Garbage Collection, GC)" href=https://buenhyden.github.io/posts/programming-languages/concepts/garbage-collection/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>인터프리터(Interpreter)</h2></header><div class=entry-content><p>인터프리터(Interpreter) 프로그래밍 언어의 소스 코드를 직접 실행하는 프로그램 또는 환경
기능과 역할 인터프리터의 주요 기능은 다음과 같다:
소스 코드 해석: 프로그래머가 작성한 코드를 한 줄씩 읽고 해석한다. 즉시 실행: 해석된 코드를 바로 실행한다. 대화형 환경 제공: 코드를 즉시 실행하고 결과를 확인할 수 있는 환경을 제공한다. 특징과 장점 즉시 실행: 코드 수정 후 바로 실행이 가능하다. 대화형 모드: 많은 인터프리터 언어는 대화형 모드를 제공한다. 플랫폼 독립성: 대부분 플랫폼에 독립적으로 실행 가능하다. 디버깅 용이성: 오류가 발생한 즉시 실행을 중지하여 디버깅이 쉽다. 작동 과정 이해하기 예를 들어, 다음과 같은 파이썬 코드가 있다고 생각해보자:
...</p></div><footer class=entry-footer><span title='2024-10-06 05:32:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;425 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 인터프리터(Interpreter)" href=https://buenhyden.github.io/posts/programming-languages/concepts/interpreter/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/42/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/44/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>