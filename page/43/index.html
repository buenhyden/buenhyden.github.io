<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Media Access Control Address (MAC Address)</h2></header><div class=entry-content><p>Media Access Control Address(MAC Address) 네트워크 장비를 식별하기 위한 고유한 하드웨어 주소.
구조 48비트(6바이트) 길이의 주소로, 16진수 형식으로 표현된다.
주로 6개의 2자리 16진수 그룹으로 표시되며, 콜론(:), 하이픈(-), 또는 점(.)으로 구분된다.
1 2 3 4 5 class MACAddress: def __init__(self, address): # MAC 주소 예시: "00:1A:2B:3C:4D:5E" self.oui = address[:8] # 조직 고유 식별자 (앞 3바이트) self.nic = address[9:] # 네트워크 인터페이스 식별자 (뒤 3바이트) MAC 주소의 첫 24비트(3바이트)는 OUI(Organizationally Unique Identifier)로, IEEE에서 제조업체에 할당하는 고유 번호 나머지 24비트는 제조업체가 각 장치에 할당하는 고유 번호. 용도 로컬 네트워크 내에서 장치를 고유하게 식별한다. 데이터 링크 계층(OSI 모델의 2계층)에서 사용된다. 네트워크 통신에서 데이터 패킷의 송신자와 수신자를 식별한다. 특징 제조업체에 의해 할당되며, 전 세계적으로 고유하다. 하드웨어에 고정되어 있어 일반적으로 변경할 수 없다. LAN 환경에서 장치 간 통신에 사용된다. IP 주소와의 차이 MAC 주소는 물리적 주소로, 로컬 네트워크 내에서만 사용된다. IP 주소는 논리적 주소로, 인터넷 상에서 전역적으로 사용된다. 기능 네트워크 진단 및 문제 해결에 사용된다. 네트워크 보안(MAC 주소 필터링 등)에 활용될 수 있다. MAC 주소의 종류 유니캐스트 주소 특정 단일 장치를 위한 주소.
...</p></div><footer class=entry-footer><span title='2024-10-16 12:19:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Media Access Control Address (MAC Address)" href=https://buenhyden.github.io/posts/networking-and-communication/network-fundamentals/basic-concepts/addressing-fundamentals/physical/mac-address/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Packet</h2></header><div class=entry-content><p>Packet (패킷, 네트워크 패킷) 패킷은 네트워크에서 데이터를 주고받을 때 사용되는 형식화된 데이터 블록이다.
주요 목적은 다음과 같다:
효율적인 데이터 전송 네트워크 대역폭의 효율적 사용 오류 검출 및 복구 용이성 네트워크 혼잡 방지 패킷을 사용하는 이유는? 패킷이 모두 대상에 도착하는 한 동일한 대상에 대해 서로 다른 네트워크 경로를 사용할 수 있음을 의미한다. 특정 프로토콜에서 패킷은 각 패킷이 다른 경로를 사용하여 도착하더라도 올바른 순서로 최종 목적지에 도착해야 한다. 여러 컴퓨터의 패킷이 기본적으로 임의의 순서로 동일한 선로를 통해 이동할 수 있다. 동일한 네트워킹 장비를 통해 동시에 여러 연결을 수행할 수 있다. 그 결과로 수십억 개의 장치가 인터넷에서 동시에 데이터를 교환할 수 있다. 패킷의 구조 패킷은 일반적으로 세 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Packet" href=https://buenhyden.github.io/posts/networking-and-communication/protocol-architecture/osi-model/layer-overview/network-layer/packet/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Routing</h2></header><div class=entry-content><p>Routing 데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.
네트워크 계층(3계층)에서 이루어지는 핵심 기능으로, 라우터가 패킷의 목적지 IP 주소를 확인하고 최적의 경로를 결정한다.
주요 특징 경로 결정: 라우팅 테이블을 참조하여 최적의 경로를 선택한다. 네트워크 연결: 서로 다른 네트워크를 연결하여 통신을 가능하게 한다. 패킷 전달: 선택된 경로를 통해 패킷을 다음 홉으로 전달한다. 중요성 효율적인 데이터 전송을 가능하게 한다. 네트워크의 안정성과 확장성을 향상시킨다. 트래픽 관리와 로드 밸런싱에 기여한다. 라우팅 방식 정적 라우팅: 관리자가 수동으로 라우팅 테이블을 구성한다.
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Routing" href=https://buenhyden.github.io/posts/networking-and-communication/protocol-architecture/osi-model/layer-overview/network-layer/routing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network Hop</h2></header><div class=entry-content><p>Network Hop 네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.
홉은 데이터 패킷이 한 네트워크 지점에서 다음 지점으로 이동할 때마다 발생합니다.
각 홉은 패킷이 목적지에 도달하기 위해 거치는 중간 단계를 나타낸다. 주요 역할은 다음과 같다:
경로 결정: 각 홉에서 라우터는 패킷의 다음 목적지를 결정한다. 네트워크 성능 측정: 홉 수는 네트워크의 복잡성과 데이터 전송 경로의 길이를 나타낸다. 패킷 전달: 각 홉은 패킷을 다음 네트워크 장비로 전달하는 역할을 한다. 홉 카운트(Hop Count) 홉 카운트는 패킷이 출발지에서 목적지까지 거치는 홉의 총 개수를 의미한다. 이는 네트워크 경로의 길이를 측정하는 중요한 지표이다.
...</p></div><footer class=entry-footer><span title='2024-10-16 09:19:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Hop" href=https://buenhyden.github.io/posts/networking-and-communication/protocol-architecture/osi-model/layer-overview/network-layer/network-hop/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프래그먼테이션 (Fragmentation)</h2></header><div class=entry-content><p>프래그먼테이션 (Fragmentation) Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.
이는 다음과 같은 목적을 가진다:
다양한 MTU를 가진 네트워크 간의 통신 가능 네트워크 성능 향상 대역폭 활용도 개선 프래그먼테이션이 필요한 이유 네트워크마다 처리할 수 있는 최대 패킷 크기가 다르다.
이를 MTU(Maximum Transmission Unit)라고 한다.
예를 들어:
이더넷의 MTU: 1500 바이트 PPP의 MTU: 576 바이트 Wi-Fi의 MTU: 2304 바이트
만약 4000 바이트 크기의 데이터를 MTU가 1500 바이트인 이더넷 네트워크로 전송하려면, 이 데이터는 반드시 더 작은 조각들로 나뉘어야 한다. Fragmentation의 작동 방식 프래그먼트 생성 원본 패킷은 여러 개의 작은 프래그먼트로 나뉜다.
각 프래그먼트는:
...</p></div><footer class=entry-footer><span title='2024-10-16 02:40:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프래그먼테이션 (Fragmentation)" href=https://buenhyden.github.io/posts/networking-and-communication/protocol-architecture/osi-model/layer-overview/network-layer/fragmentation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Types of Sorting Algorithm</h2></header><div class=entry-content><p>Sorting Algorithms 비교 정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다.
정렬 알고리즘은 시간 복잡도, 공간 복잡도, 안정성, 실행 속도 등의 성능 차이로 인해 다양한 방식이 존재한다.
각 정렬 알고리즘은 고유한 특성과 작동 방식을 가지고 있습니다. 여기서는 6가지 주요 정렬 알고리즘을 공통된 예시 배열 [8, 5, 2, 6, 9, 3, 1, 4, 7]을 사용하여 비교 분석하겠습니다.
정렬 알고리즘 비교 각 정렬 알고리즘은 고유한 특성과 장단점을 가지고 있으며, 적용 상황에 따라 최적의 선택이 달라진다:
...</p></div><footer class=entry-footer><span title='2024-10-15 04:16:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Sorting Algorithm" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting-and-searching/comparison--of-sorting-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>환원 가능성 (Reducibility)</h2></header><div class=entry-content><p>환원 가능성 (Reducibility) 환원 가능성(Reducibility)은 이론 컴퓨터 과학, 특히 계산 복잡도 이론에서 핵심적인 개념으로, 문제들 간의 상대적 난이도를 비교하고 분류하는 강력한 도구이다.
환원 가능성은 계산 복잡도 이론의 핵심 개념으로, 문제들 간의 상대적 난이도를 이해하는 데 필수적인 도구이다.
이는 NP-완전성 증명, 알고리즘 설계, 복잡도 클래스 구조화 등 다양한 이론적, 실용적 목적으로 활용된다.
환원 가능성의 연구는 여전히 활발하게 진행 중이며, 양자 계산, 평균 케이스 복잡도, 매개변수화된 복잡도 등 새로운 계산 모델과 복잡도 측정 방식에 맞춰 계속 발전하고 있다. 이러한 개념의 이해는 컴퓨터 과학의 근본적인 질문인 “어떤 문제가 효율적으로 해결 가능한가?“에 대한 통찰을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-13 12:03:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 환원 가능성 (Reducibility)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/mathematical-and-theoretical-foundations/computational-complexity/complexity-classes/reducibility/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모이제이션 (Memoization)</h2></header><div class=entry-content><p>메모이제이션 (Memoization) 메모이제이션은 “기억하다"라는 뜻의 라틴어 ‘memorandum’에서 유래했다.
이 기법은 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장해두고 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 방식이다.
실생활에 비유해보면, 책을 보다가 모르는 단어를 사전에서 찾았을 때
메모이제이션 미사용: 같은 단어가 나올 때마다 매번 사전을 찾음 메모이제이션 사용: 찾은 단어의 의미를 메모장에 적어두고, 다시 나오면 메모장을 참고
로 이해 가능하다. 메모이제이션의 작동 원리 함수가 호출될 때 입력값을 확인한다. 해당 입력값에 대한 결과가 이미 저장되어 있다면, 저장된 결과를 즉시 반환한다. 저장된 결과가 없다면, 함수를 실행하고 그 결과를 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 def memoized_function(n, memo={}): # 1. 이미 계산된 값인지 확인 if n in memo: return memo[n] # 2. 새로운 값 계산 result = ... # 계산 로직 # 3. 계산된 값을 저장 memo[n] = result # 4. 결과 반환 return result 메모이제이션의 장점 실행 속도 향상: 중복 계산을 피함으로써 프로그램의 실행 속도를 크게 높일 수 있다. 자원 효율성: 계산 비용이 높은 작업의 결과를 재사용함으로써 컴퓨터 자원을 효율적으로 사용할 수 있다. 메모이제이션의 사용 예시 가장 대표적인 예시로 피보나치 수열 계산을 들 수 있다.
일반적인 재귀 함수로 구현하면 중복 계산이 많이 발생하지만, 메모이제이션을 적용하면 성능을 크게 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 11:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모이제이션 (Memoization)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/overview/approaches/top-down-approach/memoization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>테이블레이션(Tabulation)</h2></header><div class=entry-content><p>테이블레이션(Tabulation) Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.
Tabulation은 ‘표를 만든다’는 의미로, 문제의 해결 과정을 표 형태로 정리하는 기법이다. 이 방법은 작은 부분 문제(subproblem)부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 상향식(bottom-up) 접근 방식을 사용합니다.
Tabulation의 작동 원리 문제 정의: 해결하고자 하는 문제와 그 부분 문제들을 명확히 정의한다. 표 초기화: 부분 문제의 결과를 저장할 표(보통 배열이나 리스트)를 만든다. 기본 케이스 설정: 가장 작은 부분 문제에 대한 해답을 표에 채운다. 반복적 계산: 작은 부분 문제부터 시작하여 큰 문제로 나아가며 표를 채운다. 최종 결과 도출: 표의 마지막 항목이 전체 문제의 해답이 된다. Tabulation의 예시: 피보나치 수열 피보나치 수열을 계산하는 예시
...</p></div><footer class=entry-footer><span title='2024-10-13 11:21:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테이블레이션(Tabulation)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/overview/approaches/bottom-up-approach/tabulation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비결정성 (Non-determinism)</h2></header><div class=entry-content><p>비결정성 (Non-determinism) 알고리즘이나 시스템에서 동일한 입력에 대해 매번 다른 과정을 거쳐 다른 결과를 도출할 수 있는 특성
특징 다중 선택: 각 단계에서 여러 가능한 다음 단계 중 하나를 임의로 선택할 수 있다. 병렬 처리: 여러 가능한 경로를 동시에 탐색할 수 있는 개념적 모델을 제공한다. 결정성과의 차이: 결정성 알고리즘은 각 단계에서 다음 단계가 유일하게 결정되는 반면, 비결정성 알고리즘은 그렇지 않다. 비결정성 알고리즘 비결정성 알고리즘은 다음과 같은 특징을 가진다.
실행 경로의 다양성: 동일한 입력에 대해 여러 가능한 실행 경로가 존재한다. 비결정도: 각 단계에서 선택 가능한 다음 단계의 최대 개수를 비결정도라고 한다. 계산 능력: 비결정성 알고리즘과 결정성 알고리즘의 계산 능력은 동일하다. 응용 NP 문제: 비결정성 알고리즘으로 다항식 시간 내에 해결 가능한 결정형 문제를 NP 문제라고 한다. 유한 오토마타: 비결정적 유한 오토마타(NFA)는 탐색과 백트래킹 기법을 통해 모든 가능한 선택을 시도한다. 탐색 및 백트래킹 알고리즘: 비결정성은 여러 가지 경우를 순차적으로 계산하며 최적값을 갱신하는 백트래킹 기법의 모델로 사용된다. 장점 간결한 표현: 복잡한 언어나 시스템을 비결정성을 통해 더 간결하게 정의할 수 있다. 논증 간소화: 비결정성을 통해 공식적인 논증을 간단히 할 수 있다. 모델링 유연성: 실제 세계의 불확실성이나 복잡성을 모델링하는 데 유용하다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import random import threading # 결정적인 함수의 예 def deterministic_sum(a, b): return a + b # 항상 같은 입력에 대해 같은 결과 # 비결정적인 함수의 예 def non_deterministic_choice(options): return random.choice(options) # 매번 다른 결과가 나올 수 있음 # 비결정적인 멀티스레딩 예제 shared_counter = 0 lock = threading.Lock() def increment_counter(): global shared_counter current = shared_counter # 의도적으로 경쟁 조건을 만듦 threading.Thread(target=lambda: None).start() shared_counter = current + 1 def run_concurrent_increments(n): threads = [] for _ in range(n): t = threading.Thread(target=increment_counter) threads.append(t) t.start() for t in threads: t.join() return shared_counter 다양한 상황에서 발생할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-13 09:18:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비결정성 (Non-determinism)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/mathematical-and-theoretical-foundations/non-determinism/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/42/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/44/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>