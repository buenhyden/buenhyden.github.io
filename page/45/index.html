<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로시저 (Procedure)</h2></header><div class=entry-content><p>프로시저 (Procedure) 데이터베이스 프로시저(Database Procedure)는 데이터베이스 내에 저장되고 실행되는 일련의 SQL 문들의 집합으로,
자주 사용하는 SQL 명령어들을 하나의 작은 프로그램으로 미리 작성해두고 필요할 때 호출하여 사용하는 것이다.
SQL Server에서의 프로시저 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 -- 주문 처리를 위한 저장 프로시저 생성 CREATE PROCEDURE ProcessOrder @OrderID int, @CustomerID int, @TotalAmount decimal(10,2) AS BEGIN -- 트랜잭션 시작 BEGIN TRANSACTION TRY -- 주문 정보 입력 INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount) VALUES (@OrderID, @CustomerID, GETDATE(), @TotalAmount) -- 재고 수량 업데이트 UPDATE Inventory SET Quantity = Quantity - 1 WHERE ProductID IN ( SELECT ProductID FROM OrderDetails WHERE OrderID = @OrderID ) -- 고객 포인트 업데이트 UPDATE Customers SET Points = Points + (@TotalAmount * 0.01) WHERE CustomerID = @CustomerID -- 트랜잭션 완료 COMMIT TRANSACTION CATCH -- 오류 발생 시 롤백 ROLLBACK TRANSACTION -- 오류 정보 반환 SELECT ERROR_MESSAGE() AS ErrorMessage END END -- 프로시저 사용 예시 EXEC ProcessOrder @OrderID = 1001, @CustomerID = 500, @TotalAmount = 150000 프로시저의 주요 특징과 장점 성능 최적화
프로시저는 최초 실행 시 컴파일되어 캐시에 저장되므로, 반복 실행 시 더 빠른 성능을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-10-24 09:05:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로시저 (Procedure)" href=https://buenhyden.github.io/posts/tools-reference/database-systems/rdbms/sql/sql-advanced/stored-procedures-and-functions/procedure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>keyword</h2></header><div class=entry-content><p>Keyword SQL(Structured Query Language)는 데이터베이스를 관리하고 조작하기 위한 표준 언어로, 다양한 키워드를 통해 데이터 정의, 조작, 제어, 트랜잭션 관리 등을 수행한다.
데이터 조회 (Query) 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- SELECT: 데이터를 조회하는 기본 키워드 -- 지정된 컬럼의 데이터를 결과셋으로 반환 SELECT employee_id, first_name, salary FROM employees; -- FROM: 데이터를 가져올 테이블을 지정 -- 여러 테이블을 콤마로 구분하거나 JOIN을 사용할 수 있음 SELECT * FROM employees, departments; -- DISTINCT: 결과에서 중복된 행을 제거하는 데 사용 -- 기본 DISTINCT 사용 -- 부서별 unique한 직무 목록 조회 SELECT DISTINCT job_id FROM employees; -- 여러 컬럼에 DISTINCT 적용 -- 부서와 직무의 unique한 조합 조회 SELECT DISTINCT department_id, job_id FROM employees; -- COUNT와 함께 사용 -- 회사에 존재하는 직무 개수 조회 SELECT COUNT(DISTINCT job_id) as unique_jobs FROM employees; -- GROUP BY와 함께 사용 SELECT department_id, COUNT(DISTINCT job_id) as job_types FROM employees GROUP BY department_id; 결과 제한 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- LIMIT - 반환되는 결과의 최대 행 수를 제한합니다. SELECT * FROM employees LIMIT 10 -- 상위 10개 행만 반환 -- OFFSET - 결과의 시작 위치를 지정합니다. LIMIT와 함께 자주 사용됩니다. SELECT * FROM employees LIMIT 10 OFFSET 20 -- 21번째부터 30번째 행을 반환 -- FETCH - SQL 표준의 LIMIT와 유사한 기능을 합니다. SELECT * FROM employees FETCH FIRST 10 ROWS ONLY -- 페이지당 10개 항목, 3번째 페이지 조회 SELECT * FROM products ORDER BY name LIMIT 10 OFFSET 20; -- (페이지 번호 - 1) * 페이지 크기 = OFFSET 조건 연산자 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- WHERE: 조건절을 지정하여 특정 조건을 만족하는 데이터만 조회 -- AND, OR을 사용하여 여러 조건 조합 가능 SELECT * FROM employees WHERE salary > 50000 AND department_id = 10; -- IN: 값 목록 중 포함 여부 -- BETWEEN: 범위 조건 -- LIKE: 패턴 매칭 -- IS NULL: NULL 값 확인 SELECT * FROM employees WHERE department_id IN (10, 20, 30) AND salary BETWEEN 40000 AND 60000 AND first_name LIKE '김%' AND manager_id IS NOT NULL; -- CASE - 조건에 따라 다른 값을 반환합니다. -- WHEN - CASE 문에서 조건을 지정합니다. -- THEN - 조건이 참일 때 반환할 값을 지정합니다. -- ELSE - 모든 조건이 거짓일 때 반환할 값을 지정합니다. SELECT name, CASE WHEN age &lt; 20 THEN 'Young' WHEN age &lt; 60 THEN 'Adult' ELSE 'Senior' END as age_group FROM users; 정렬과 그룹화 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- GROUP BY: 지정된 컬럼을 기준으로 데이터를 그룹화 -- 주로 집계 함수와 함께 사용 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id; -- ORDER BY: 결과를 정렬 -- ASC(오름차순), DESC(내림차순) 지정 가능 SELECT * FROM employees ORDER BY salary DESC, first_name ASC; -- HAVING: GROUP BY로 그룹화된 데이터에 대한 조건 지정 -- WHERE는 개별 행에 대한 조건, HAVING은 그룹에 대한 조건 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 50000; 조인(Join) 관련 키워드 JOIN은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다. JOIN을 사용하면 여러 테이블의 데이터를 하나의 결과 집합으로 결합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 07:56:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to keyword" href=https://buenhyden.github.io/posts/tools-reference/database-systems/rdbms/sql/syntax/keywords/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cardinality</h2></header><div class=entry-content><p>Cardinality Cardinality는 데이터베이스 분야에서 주로 두 가지 의미로 사용된다.
테이블 간의 관계에서의 Cardinality
이는 두 엔티티 간의 최대 연관성을 나타낸다.
주요 유형은 다음과 같습니다:
1:1 (일대일) 관계: 예를 들어, 사원과 사원증의 관계 1:N (일대다) 관계: 예를 들어, 교수와 학생의 관계 N:M (다대다) 관계: 예를 들어, 학생과 강좌의 관계 컬럼에 있는 고유한 값의 Cardinality
이는 특정 컬럼에 존재하는 고유한 값의 개수를 의미한다.
Cardinality의 정도에 따라 다음과 같이 분류할 수 있다:
높은 Cardinality: 주민등록번호, 이메일 주소와 같이 대부분의 값이 고유한 경우 중간 Cardinality: 우편번호, 도시 이름과 같이 일부 값이 고유하지만 많은 값이 반복되는 경우 낮은 Cardinality: 성별, 상태 코드와 같이 적은 수의 고유 값을 포함하는 경우 데이터베이스 성능에 여러 가지 중요한 영향을 미친다.
...</p></div><footer class=entry-footer><span title='2024-10-22 15:08:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cardinality" href=https://buenhyden.github.io/posts/system-design/database-systems/data-modeling/cardinality/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 파티셔닝 (Database Partitioning)</h2></header><div class=entry-content><p>데이터베이스 파티셔닝 (Database Partitioning) 파티셔닝은 큰 테이블이나 인덱스를 더 작고 관리하기 쉬운 단위로 나누는 것.
정의와 목적 파티셔닝은 큰 테이블이나 인덱스를 더 작은 관리 가능한 단위인 ‘파티션’으로 나누는 것을 의미한다.
주요 목적은 다음과 같다:
성능 향상 가용성 증대 관리 용이성 개선 파티셔닝의 유형 수평 파티셔닝 (Horizontal Partitioning):
행 단위로 데이터를 분할 샤딩(Sharding)과 유사한 개념 수직 파티셔닝 (Vertical Partitioning):
열 단위로 데이터를 분할 자주 사용되는 컬럼을 별도로 저장 파티셔닝 방법 범위 분할 (Range Partitioning):
...</p></div><footer class=entry-footer><span title='2024-10-22 06:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 파티셔닝 (Database Partitioning)" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/data-architecture-and-persistence/partitioning-strategies/partitioning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>샤딩 (sharding)</h2></header><div class=entry-content><p>샤딩 (sharding) 대규모 데이터베이스 시스템에서 데이터를 수평적으로 분할하여 여러 서버에 분산 저장하는 기술.
각각의 분할된 데이터 조각을 ‘샤드(shard)‘라고 부른다.
이 기술은 데이터베이스의 성능, 확장성, 가용성을 향상시키는 데 중요한 역할을 한다.
예를 들어 전자상거래 사이트의 사용자 데이터를 지역별로 나누어 관리한다고 가정해보자.
서울 지역 사용자의 데이터는 샤드 A에, 부산 지역 사용자의 데이터는 샤드 B에 저장하는 식. 이렇게 하면 각 지역의 서버가 해당 지역 사용자의 데이터만 처리하면 되므로 시스템 부하를 분산할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:27:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 샤딩 (sharding)" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/data-architecture-and-persistence/partitioning-strategies/horizontal-partitioning/sharding/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 인덱싱 (Database Indexing)</h2></header><div class=entry-content><p>데이터베이스 인덱싱 (Database Indexing) 인덱스는 책의 목차와 유사한 역할을 한다.
데이터베이스에서 인덱스를 사용하면 전체 테이블을 스캔하지 않고도 원하는 데이터를 빠르게 찾을 수 있다.
인덱스는 테이블의 하나 또는 여러 개의 컬럼을 기반으로 생성될 수 있습니다.
특징:
자동 정렬
인덱스는 항상 정렬된 상태를 유지한다. 새로운 데이터가 추가될 때마다 정렬된 순서를 유지하기 위해 재정렬이 발생한다. 독립적 저장
인덱스는 실제 데이터와 별도의 공간에 저장된다. 원본 데이터의 위치를 가리키는 포인터를 포함한다. 선택적 생성
모든 칼럼에 인덱스를 생성할 필요는 없다. 검색이 자주 발생하는 칼럼에 대해 선택적으로 생성한다. 장점:
...</p></div><footer class=entry-footer><span title='2024-10-22 02:11:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 인덱싱 (Database Indexing)" href=https://buenhyden.github.io/posts/system-design/database-systems/storage-and-indexing/indexing/database-indexing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud Networking</h2></header><div class=entry-content><p>Cloud Networking 클라우드 네트워킹은 클라우드 컴퓨팅 환경에서 리소스들을 연결하고 통신할 수 있게 해주는 인프라를 의미한다.
기존의 물리적 네트워크와 달리, 가상화 기술을 기반으로 하여 더욱 유연하고 확장성 있는 네트워크 구성이 가능하다.
클라우드 서비스의 안정적인 제공과 효율적인 리소스 관리를 위해서는 견고한 네트워크 인프라가 필수적이다.
기본 개념 클라우드 네트워킹은 클라우드 기반 서비스를 사용하여 조직의 직원, 리소스 및 애플리케이션을 연결하는 기업 네트워크를 배포하는 것.
이는 가상 라우터, 방화벽, 네트워크 관리 소프트웨어 등으로 구성된 WAN(Wide Area Network)이다.
...</p></div><footer class=entry-footer><span title='2024-10-20 17:39:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud Networking" href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/cloud-networking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>네트워크 기능 가상화(Network Functions Virtualization, NFV)</h2></header><div class=entry-content><p>네트워크 기능 가상화(Network Functions Virtualization, NFV) NFV는 전통적으로 전용 하드웨어 장비에서 실행되던 네트워크 기능들을 가상화하여 소프트웨어로 구현하는 네트워크 아키텍처 개념이다.
이를 통해 범용 서버에서 가상 네트워크 기능(VNF)을 실행할 수 있게 된다.
주요 구성요소 가상화된 네트워크 기능(VNF): 소프트웨어로 구현된 네트워크 기능 NFV 인프라(NFVI): VNF를 실행하기 위한 하드웨어 및 소프트웨어 환경 NFV 관리 및 오케스트레이션(MANO): VNF와 NFVI를 관리하고 조율하는 프레임워크 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class NFVArchitecture: def __init__(self): # NFVI (NFV Infrastructure) self.compute_resources = VirtualCompute() self.network_resources = VirtualNetwork() self.storage_resources = VirtualStorage() # VNF (Virtual Network Functions) self.network_functions = { "firewall": VirtualFirewall(), "load_balancer": VirtualLoadBalancer(), "router": VirtualRouter() } # MANO (Management and Orchestration) self.orchestrator = NFVOrchestrator() self.vnf_manager = VNFManager() self.infrastructure_manager = InfrastructureManager() class VirtualNetworkFunction: def __init__(self, function_type): self.type = function_type self.status = "initialized" self.resources = {} def deploy(self, resources): """가상 네트워크 기능 배포""" self.resources = resources self.status = "deployed" def scale(self, factor): """자원 스케일링""" self.resources = { k: v * factor for k, v in self.resources.items() } 장점 하드웨어 비용 절감 유연성과 확장성 향상 신규 서비스 출시 시간 단축 운영 효율성 증대 자동화를 통한 관리 간소화 구현 과제와 해결 방안 성능 최적화
가상화로 인한 성능 저하를 최소화하기 위한 전략들:
...</p></div><footer class=entry-footer><span title='2024-10-20 02:06:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 네트워크 기능 가상화(Network Functions Virtualization, NFV)" href=https://buenhyden.github.io/posts/networking-and-communication/layered-network-models/evolved-architectures/sdn-nfv-architecture/network-functions-virtualization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)</h2></header><div class=entry-content><p>소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN) 네트워크의 제어 기능을 네트워크 장비에서 분리하여 소프트웨어 기반 컨트롤러로 중앙집중화하는 네트워크 아키텍처.
목적 네트워크 리소스 최적화 변화하는 비즈니스 요구사항에 신속한 대응 네트워크 관리 및 구성의 간소화 특징 제어 평면 (Control Plane) 과 데이터 평면 (Data Plane) 의 분리: 네트워크 장비의 제어 기능 (라우팅 결정 등) 을 별도의 소프트웨어 컨트롤러로 분리. 중앙집중식 관리: 전체 네트워크를 단일 지점에서 관리할 수 있어 효율성이 향상. 프로그래밍 가능성: API 를 통해 네트워크 동작을 프로그래밍할 수 있어 유연성이 증가 개방형 표준: 표준화된 프로토콜과 인터페이스를 사용하여 다양한 벤더의 장비를 통합 관리할 수 있음. 계층 구조 애플리케이션 계층 (Application Layer) 네트워크 서비스, 비즈니스 애플리케이션 API 를 통한 네트워크 제어 ↕ Northbound API 제어 계층 (Control Layer) SDN 컨트롤러 네트워크 정책 및 제어 로직 ↕ Southbound API (OpenFlow 등) 인프라 계층 (Infrastructure Layer) 스위치, 라우터 등 네트워크 장비 패킷 전송 및 처리 장점 유연성과 민첩성: 네트워크 구성을 신속하게 변경할 수 있다. 비용 절감: 하드웨어 의존도를 줄여 CAPEX 와 OPEX 를 절감할 수 있다. 중앙집중식 관리: 네트워크 전체를 단일 지점에서 관리할 수 있다. 보안 강화: 중앙에서 일관된 보안 정책을 적용할 수 있음. 단점 단일 장애 지점: 중앙 컨트롤러에 문제가 생기면 전체 네트워크에 영향을 줌. 성능 저하 가능성: 네트워크 규모가 커지면 컨트롤러의 부하가 증가할 수 있음. 보안 취약점: 중앙 컨트롤러가 공격 대상이 될 수 있음. 기업의 지출을 구분하는 두 가지 주요 카테고리
...</p></div><footer class=entry-footer><span title='2024-10-20 02:00:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소프트웨어 정의 네트워킹 (Software-Defined Networking, SDN)" href=https://buenhyden.github.io/posts/networking-and-communication/layered-network-models/evolved-architectures/sdn-nfv-architecture/software-defined-networking/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RDMA</h2></header><div class=entry-content><p>RDMA (Remote Direct Memory Access) 네트워크 상의 한 컴퓨터에서 다른 컴퓨터의 메모리에 직접 접근할 수 있게 해주는 기술로, CPU의 개입 없이 데이터를 전송할 수 있는 고성능 네트워크 기술
주요 특징:
낮은 지연 시간(Low Latency): CPU 개입 없이 메모리 간 직접 데이터 전송이 가능하므로, 전송 지연 시간이 매우 짧다. 높은 대역폭(High Bandwidth): 데이터 복사 과정이 없기 때문에 빠르고 효율적으로 대량의 데이터를 처리할 수 있다. 낮은 CPU 사용률(Low CPU Utilization): 데이터 전송 작업이 네트워크 어댑터(NIC)에서 이루어지기 때문에 CPU는 다른 작업에 집중할 수 있다. 제로-카피(Zero-Copy): 데이터가 중간 버퍼링 없이 메모리에서 바로 전송되므로, 데이터 복사로 인한 오버헤드가 없다. 효율성(Efficiency): 운영 체제와 CPU의 개입을 최소화하여 시스템 전체의 효율성을 높인다. 장점:
...</p></div><footer class=entry-footer><span title='2024-10-20 01:36:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RDMA" href=https://buenhyden.github.io/posts/networking-and-communication/fundamentals/rdma/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/44/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/46/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>