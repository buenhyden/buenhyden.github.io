<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hoisting</h2></header><div class=entry-content><p>Hoisting 호이스팅(Hoisting)은 JavaScript 엔진이 코드를 실행하기 전에 변수, 함수, 클래스 또는 임포트의 선언부를 스코프의 최상단으로 끌어올리는 것처럼 동작하는 JavaScript의 메커니즘으로, 이름 그대로 ‘끌어올린다(hoist)‘는 의미를 가진다.
그러나 실제로 코드가 물리적으로 재배치되는 것은 아니다. 이는 JavaScript 엔진의 컴파일 과정에서 일어나는 일종의 추상적 개념이다.
호이스팅은 JavaScript의 핵심 메커니즘 중 하나로, 코드의 실행 방식에 영향을 미친다.
효과적인 JavaScript 개발자가 되기 위해서는 호이스팅의 개념과 다양한 선언 방식에 따른 차이점을 이해하는 것이 중요하다.
모던 JavaScript에서는 let과 const를 사용하여 변수를 선언하고, 함수 표현식을 활용하는 것이 호이스팅으로 인한 예기치 않은 동작을 방지하는 데 도움이 된다. 또한, 모든 변수를 스코프의 최상단에서 선언하는 습관을 들이면 호이스팅으로 인한 혼란을 최소화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-25 14:17:00 +0000 UTC'>December 25, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hoisting" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/hoisting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Variable Declarations</h2></header><div class=entry-content><p>Variable Declarations JavaScript에서 변수 선언(Variable Declarations)은 프로그램에서 데이터를 저장하고 참조하는 데 사용되는 중요한 개념이다. 변수 선언 방식에 따라 변수의 **유효 범위(Scope)**와 재할당 가능 여부 등이 결정된다.
ES6(ECMAScript 2015) 이전에는 var 키워드만을 사용하여 변수를 선언했으나, 이후 let과 const 키워드가 도입되어 보다 다양한 변수 선언이 가능해졌다.
JavaScript에서는 주로 세 가지 키워드를 사용하여 변수를 선언한다:
var 키워드 사용 let 키워드 사용 const 키워드 사용 Var 키워드 var는 JavaScript의 가장 오래된 변수 선언 방식이다.
...</p></div><footer class=entry-footer><span title='2024-12-25 14:17:00 +0000 UTC'>December 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Variable Declarations" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/variable-declarations/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>변수 명명 규칙(Variable Naming Rules)</h2></header><div class=entry-content><p>변수 명명 규칙(Variable Naming Rules) JavaScript의 변수 명명 규칙(Variable Naming Rules)은 코드의 가독성과 유지보수성을 높이는 데 중요한 역할을 한다.
좋은 변수 이름을 사용하면 코드를 처음 보는 사람도 더 쉽게 이해할 수 있고, 나중에 자신이 작성한 코드를 다시 볼 때도 의도를 빠르게 파악할 수 있다.
필수 규칙 (문법적 제약) 변수 이름에는 다음과 같은 필수 규칙이 적용된다:
문자, 숫자, 밑줄(_), 달러 기호($)만 사용 가능하다.
1 2 3 let userName = "John"; // 올바른 이름 let user_name = "John"; // 올바른 이름 let $price = 100; // 올바른 이름 변수 이름은 숫자로 시작할 수 없다 (문자, 밑줄, 또는 달러 기호로 시작해야 한다).
...</p></div><footer class=entry-footer><span title='2024-12-25 14:17:00 +0000 UTC'>December 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 변수 명명 규칙(Variable Naming Rules)" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/naming-rules/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Type Casting</h2></header><div class=entry-content><p>Type Casting 파이썬에서는 다양한 내장 함수를 사용하여 데이터 타입을 변환할 수 있다.
데이터 타입을 변환할 때에는
문자열을 숫자로 변환할 때는 해당 문자열이 유효한 숫자 형식이어야 한다. 실수를 정수로 변환할 때는 소수점 이하가 버려진다. 복잡한 데이터 구조(리스트, 딕셔너리 등)를 변환할 때는 주의가 필요하다.
등을 주의해야 한다. 정수로 변환 (int())
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 정수형 변환 float_num = 3.14 int_num = int(float_num) # 3 (소수점 이하 버림) # 실수형 변환 a = float("10.5") # 문자열을 실수로 integer = 5 # 정수를 실수로 float_num = float(integer) # 5.0 b = float(10) # 문자열을 숫자로 변환 str_num = "123" number = int(str_num) # 123 float_num = float("3.14") # 3.14 # 진수 변환 binary_str = "1010" decimal = int(binary_str, 2) # 10 (2진수를 10진수로) hex_str = "1A" decimal = int(hex_str, 16) # 26 (16진수를 10진수로) 문자열로 변환 (str())
...</p></div><footer class=entry-footer><span title='2024-12-24 13:23:00 +0000 UTC'>December 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Type Casting" href=https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/data-types/type-casting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. FastAPI</h2></header><div class=entry-content><p>NodeJS vs. FastAPI 현대 웹 개발에서 백엔드 기술 선택은 프로젝트의 성공에 중요한 요소이다.
Node.js와 FastAPI는 각각 JavaScript와 Python 생태계에서 인기 있는 백엔드 기술로, 서로 다른 접근 방식과 강점을 가지고 있다.
Node.js는 오랜 기간 동안 검증된 기술로, 방대한 생태계와 JavaScript를 백엔드에서도 사용할 수 있는 일관성을 제공한다. 실시간 애플리케이션과 I/O 집약적 작업에 특히 뛰어나다.
FastAPI는 비교적 새로운 프레임워크이지만, 현대적인 Python 기능을 최대한 활용하여 빠른 개발 속도, 뛰어난 개발자 경험, 자동 문서화와 데이터 검증을 제공한다. Python의 데이터 과학 생태계와 통합이 필요한 프로젝트에 특히 적합하다.
...</p></div><footer class=entry-footer><span title='2024-12-22 10:38:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. FastAPI" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-fastapi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Flask</h2></header><div class=entry-content><p>NodeJS vs. Flask Node.js와 Flask는 현대 웹 애플리케이션 개발에 널리 사용되는 두 가지 인기 있는 백엔드 기술이다.
이 두 기술은 각각 다른 언어(JavaScript vs Python), 다른 철학, 그리고 서로 다른 접근 방식을 가지고 있다.
Node.js와 Flask는 각각 고유한 강점과 약점을 가진 강력한 백엔드 기술이다.
선택은 프로젝트의 요구사항, 팀의 전문성, 그리고 장기적인 목표에 따라 달라진다.
Node.js는 실시간 기능, 높은 동시성, 그리고 JavaScript의 일관성을 활용하려는 프로젝트에 적합하다.
특히 I/O 집약적인 애플리케이션과 실시간 웹 애플리케이션에서 강점을 보인다.
...</p></div><footer class=entry-footer><span title='2024-12-22 10:38:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. Flask" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-flask/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ES Modules vs. CommonJS</h2></header><div class=entry-content><p>ES Modules vs. CommonJS 자바스크립트 애플리케이션이 복잡해지면서 코드를 모듈화하는 방법이 중요해졌다.
이에 두 가지 주요 모듈 시스템인 CommonJS와 ES Modules가 등장했다.
이 두 시스템은 각각 고유한 특성과 사용 사례를 가지고 있다.
JavaScript 모듈 시스템의 선택은 프로젝트의 요구 사항, 타겟 환경, 그리고 기존 코드베이스에 크게 의존한다.
최신 프로젝트에서는 ES Modules의 채택이 증가하는 추세이지만, CommonJS는 Node.js 생태계에서 여전히 중요한 역할을 하고 있다.
두 시스템의 장단점을 이해하고, 필요에 따라 적절한 시스템을 선택하거나 하이브리드 접근 방식을 채택하는 것이 좋다. 또한, 점진적으로 ES Modules로 마이그레이션하는 전략을 고려할 수 있으며, 이를 통해 모던 JavaScript의 이점을 활용하면서 기존 코드의 호환성도 유지할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-22 04:26:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ES Modules vs. CommonJS" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/es-modules-vs-commonjs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Django</h2></header><div class=entry-content><p>NodeJS vs. Django 웹 개발에서 백엔드 프레임워크를 선택하는 것은 프로젝트의 성공에 중요한 요소이다. Node.js와 Django는 각각 다른 철학, 접근 방식, 그리고 강점을 가진 인기 있는 두 가지 백엔드 기술이다.
Node.js와 Django는 각각 고유한 강점과 약점을 가진 강력한 백엔드 기술이다.
선택은 프로젝트의 요구사항, 팀의 전문성, 그리고 장기적인 목표에 따라 달라진다.
Node.js는 실시간 기능, 높은 동시성, 그리고 JavaScript의 일관성을 활용하려는 프로젝트에 적합하다.
빠른 프로토타이핑, 견고한 데이터 모델링, 내장된 관리 기능이 필요한 프로젝트에는 Django가 더 적합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:59:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. Django" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-django/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>BunJS vs. NodeJS</h2></header><div class=entry-content><p>BunJS vs. NodeJS JavaScript는 원래 웹 브라우저에서만 실행되는 언어였지만, 서버 사이드 런타임의 등장으로 백엔드 개발에도 널리 사용되고 있다.
Node.js는 오랫동안 서버 사이드 JavaScript의 표준이었으나, Bun이라는 새로운 런타임이 등장하여 JavaScript 생태계에 변화를 가져오고 있다. 각기 다른 엔진과 설계 철학을 기반으로 개발되어 다양한 차이점을 보인다.
Node.js와 Bun은 각각 고유한 강점과 약점을 가진 JavaScript 런타임이다.
Node.js는 성숙한 생태계, 광범위한 호환성, 검증된 안정성을 제공하는 반면, Bun은 뛰어난 성능, 개선된 개발자 경험, 통합 도구를 제공한다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:43:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BunJS vs. NodeJS" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/bunjs/bunjs-vs-nodejs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>지연 초기화(Lazy Initialization)</h2></header><div class=entry-content><p>지연 초기화 (Lazy Initialization) 4. 전체 개요 (250 자 내외) 지연 초기화는 성능 최적화를 위한 핵심 디자인 패턴으로, 객체 생성을 지연시켜 메모리 사용량을 줄이고 애플리케이션 시작 시간을 단축한다. 프록시 패턴을 활용한 구현, 스레드 안전성 보장, ORM 에서의 지연 로딩, 웹에서의 이미지 지연 로딩 등 다양한 영역에서 활용된다. 적절한 사용 시 성능 향상을 가져오지만, 잘못 사용하면 오히려 성능 저하를 일으킬 수 있어 신중한 적용이 필요하다. 단, 멀티스레드 환경의 동시 초기화 이슈와 디버깅 난이도 증가를 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-12-18 10:42:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;26 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지연 초기화(Lazy Initialization)" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/software-design-patterns/performance-optimization/lazy-initialization/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/24/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/26/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>