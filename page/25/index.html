<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.143.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cause-Effect Graphing</h2></header><div class=entry-content><p>원인-결과 그래프 검사(Cause-Effect Graph Testing) 원인-결과 그래프 검사(Cause-Effect Graph Testing)는 블랙박스 테스트 기법 중 하나로, 입력 조건(원인)과 출력 결과(결과) 사이의 관계를 체계적으로 분석하고 모델링하여 효과적인 테스트 케이스를 도출하는 방법.
원인-결과 그래프 검사는 입력 데이터 간의 관계와 출력에 미치는 영향을 그래프로 표현하여 분석하는 기법.
이 방법은 여러 입력 조건을 결합해서 하나 이상의 결과를 얻는 것으로, 복잡한 입력 환경을 고려할 수 있는 장점이 있다.
원인-결과 그래프 검사의 목적 복잡한 입력 값들 간의 관계를 체계적으로 분석 입력 조건에 따른 출력의 적절성 확인 효율성이 높은 테스트 케이스 선정 원인-결과 그래프 검사의 절차 원인과 결과 식별: 요구사항 명세서, 설계서, 프로그램에서 원인(입력 조건)과 결과(출력 조건)를 찾아 식별한다. 그래프 작성: 원인과 결과를 연결하는 boolean 그래프를 작성한다. 이 그래프는 AND, OR, NOT 같은 boolean 연산자를 사용하여 원인과 결과 간의 논리적 관계를 표현한다. 제약 조건 표시: 불가능한 원인 조합 또는 결과 조합을 나타내는 제약(constraints)을 그래프에 표시한다. 의사결정 테이블 작성: 원인-결과 그래프를 의사결정 테이블(decision table)로 변환한다. 테스트 케이스 도출: 의사결정 테이블의 각 열을 테스트 케이스로 변환한다. 그래프의 구성 요소 원인-결과 그래프는 다음과 같은 기본 요소들로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-02 09:58:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cause-Effect Graphing" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/cause-effect-graphing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decision Table Testing</h2></header><div class=entry-content><p>결정 테이블 테스팅 (Decision Table Testing) 결정 테이블 테스팅은 복잡한 비즈니스 로직이나 시스템의 동작을 테스트하기 위한 체계적인 방법.
여러 조건(conditions)과 그에 따른 행동(actions)의 모든 가능한 조합을 표 형태로 정리하여 테스트 케이스를 도출하는 기법.
예를 들어, 온라인 쇼핑몰의 할인 정책을 테스트한다고 생각해보자.
회원 등급(일반/VIP), 구매 금액(5만원 이상/미만), 프로모션 코드 사용 여부에 따라 다른 할인율이 적용된다면, 이러한 여러 조건의 조합을 결정 테이블로 정리하여 체계적으로 테스트할 수 있다.
결정 테이블의 구성 요소 결정 테이블은 네 가지 주요 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-02 09:58:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;585 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decision Table Testing" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/decision-table-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>State Transition Testing</h2></header><div class=entry-content><p>상태 전이 테스팅(State Transition Testing) 상태 전이 테스트는 시스템이나 객체의 상태 변화를 모델링하고, 이벤트에 따른 상태 전이와 그 결과를 검증하는 기법이다.
이 방법은 시스템의 현재 상황(Conditions)과 이전 이력(History)을 반영하는 상태(States) 및 그 변화(Transition)에 따라 시스템이 어떻게 동작하는지를 테스트한다.
상태 전이 테스트의 목적 시스템의 모든 가능한 상태와 전이를 식별하고 테스트 유효한 상태 전이뿐만 아니라 유효하지 않은 전이도 테스트 상태 변화에 따른 시스템의 반응과 출력을 검증 상태 전이 테스트의 주요 구성 요소 시스템의 상태 전이를 테스트하기 위해서는 다음 요소들을 이해하고 정의해야 한다:
...</p></div><footer class=entry-footer><span title='2024-11-02 09:58:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;483 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to State Transition Testing" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/state-transition-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>분류 트리 방법 (Classification Tree Method)</h2></header><div class=entry-content><p>분류 트리 방법 (Classification Tree Method, CTM) CTM은 1993년 Grimm과 Grochtmann에 의해 개발된 테스트 설계 방법으로, 소프트웨어의 테스트 관련 측면을 체계적으로 분류하고 조합하여 테스트 케이스를 생성한다.
분류 트리 방법은 테스트 대상 시스템의 입력 도메인을 여러 분류(Classifications)로 나누고, 각 분류 아래에 클래스(Classes)들을 정의하는 방식으로 작동한다.
여기서 분류는 테스트할 특성이나 매개변수를 의미하고, 클래스는 그 특성이 가질 수 있는 구체적인 값들을 의미한다.
예를 들어, 온라인 쇼핑몰의 주문 시스템을 테스트한다고 가정해보자:
분류: 결제 방법
...</p></div><footer class=entry-footer><span title='2024-11-02 09:58:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;238 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 분류 트리 방법 (Classification Tree Method)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/classification-tree-method/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Equivalence Partitioning</h2></header><div class=entry-content><p>동등 분할(Equivalence Partitioning) 동등 분할은 입력 또는 출력 데이터를 의미 있는 그룹으로 나누어 테스트하는 기법.
이 방법의 핵심 아이디어는 같은 그룹에 속한 데이터는 프로그램에서 동일한 방식으로 처리될 것이라는 가정에 기반한다.
따라서 각 그룹에서 대표값만 테스트함으로써 효율적으로 테스트를 수행할 수 있다.
예를 들어,
학생의 시험 점수(0-100점)를 등급(A, B, C, D, F)으로 변환하는 프로그램을 생각해보자.
이 경우 점수 범위를 다음과 같이 분할할 수 있다:
유효 분할:
90-100점: A등급 80-89점: B등급 70-79점: C등급 60-69점: D등급 0-59점: F등급 무효 분할:
...</p></div><footer class=entry-footer><span title='2024-11-02 09:57:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;524 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Equivalence Partitioning" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/equivalence-partitioning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Scenario Testing</h2></header><div class=entry-content><p>시나리오 테스팅 (Scenario Testing) 시나리오 테스팅은 실제 상황을 시뮬레이션하여 소프트웨어를 검증하는 강력한 기술이다. 개별 기능에 초점을 맞춘 기존 테스트 케이스와 달리 시나리오 테스트에서는 일련의 이벤트나 상호 작용이 발생할 때 시스템이 어떻게 작동하는지 검사한다.
주요 특징 사용자 중심 접근: 실제 사용자의 관점에서 소프트웨어를 테스트한다. 전체 흐름 검증: 개별 기능이 아닌 전체 사용 흐름을 테스트한다. 현실적인 상황 재현: 실제 사용 환경과 유사한 상황을 시뮬레이션한다. 비기술적 언어 사용: 비기술적인 사용자도 이해할 수 있는 언어로 작성된다. 장점 사용자 경험 개선: 실제 사용자의 관점에서 테스트하므로 사용자 불편이나 흐름의 단절을 발견할 수 있다. 종합적인 결함 발견: 기능 간 상호작용에서 발생하는 결함을 발견할 수 있다. 예기치 못한 문제 파악: 다양한 상황을 미리 시뮬레이션하여 잠재적인 오류와 리스크를 발견할 수 있다. 팀 간 협업 강화: 비기술적 이해관계자도 시나리오를 이해하기 쉬워 협업이 용이하다. 적용 방법 시나리오 정의: 테스트할 주요 시나리오를 식별한다. 테스트 데이터 준비: 실제 환경에서 발생할 수 있는 모든 상황을 포괄하는 데이터를 준비한다. 시나리오 실행: 정의된 시나리오에 따라 테스트를 수행한다. 결과 분석: 시나리오 실행 결과를 분석하고 문제점을 식별한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-02 09:57:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;162 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Scenario Testing" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/scenario-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>조합 테스트 설계 기법 (Combinatorial Test Design Techniques)</h2></header><div class=entry-content><p>조합 테스트 설계 기법 (Combinatorial Test Design Techniques) 조합 테스트 설계는 입력 매개변수의 다양한 조합을 사용하여 소프트웨어 애플리케이션을 테스트하는 방법이다.
이 기법은 모든 가능한 입력 조합을 테스트하는 대신 최적화된 조합을 선택하여 테스트 범위를 최대화하고 테스트 케이스 수를 최소화한다.
실제 테스트 설계 시에는 다음과 같은 단계를 따르는 것이 좋다:
테스트 대상 식별
먼저 어떤 요소들을 테스트할 것인지 명확히 한다.
각 요소가 가질 수 있는 값들도 정의한다. 제약조건 파악
일부 조합은 현실적으로 불가능하거나 의미가 없을 수 있다.
예를 들어, 특정 운영체제 버전에서는 5G를 지원하지 않을 수 있다. 테스트 방법 선택
시스템의 중요도와 가용 자원을 고려하여 적절한 테스트 방법을 선택한다. 테스트 케이스 생성
선택한 방법에 따라 테스트 케이스를 생성한다.
이때 자동화 도구를 활용하면 더욱 효율적이다. 주요 특징 수학적 기반: 직교 배열(Orthogonal Arrays)과 같은 수학적 개념을 활용한다. 효율성: 적은 수의 테스트 케이스로 넓은 범위의 입력 조합을 커버한다. 리스크 감소: 특정 입력 조합에서 발생할 수 있는 결함을 효과적으로 찾아낸다. 자동화 가능: 특수한 알고리즘이나 도구를 사용하여 테스트 케이스를 자동으로 생성할 수 있다. 주요 기법 페어와이즈 테스팅(Pairwise Testing): 모든 가능한 입력 매개변수 쌍의 조합을 테스트한다. N-방향 테스팅(N-way Testing): 페어와이즈를 확장하여 3개 이상의 매개변수 조합을 고려한다. 직교 배열 테스팅(Orthogonal Array Testing): 수학적 직교 배열을 사용하여 효율적인 테스트 조합을 생성한다. 올페어 알고리즘(AllPairs Algorithm): 각 변수 쌍에 대한 모든 값 조합을 효율적으로 테스트한다. 장점 테스트 케이스 수 감소: 효율적인 조합으로 필요한 테스트 케이스 수를 줄인다. 높은 결함 검출률: 다양한 입력 조합을 테스트하여 더 많은 결함을 발견할 수 있다. 시간과 비용 절감: 적은 수의 테스트로 넓은 범위를 커버하여 테스트 시간과 비용을 줄인다. 조기 결함 발견: 개발 초기 단계에서 결함을 식별할 수 있다. 한계점 복잡한 시스템에서의 적용 어려움: 매개변수가 많은 복잡한 시스템에서는 구현이 어려울 수 있다. 모든 결함 검출 불가능: 특정 시퀀스나 의존성이 필요한 결함은 놓칠 수 있다. 정확한 입력 데이터 필요: 효과적인 테스트를 위해서는 정확하고 완전한 입력 데이터가 필요하다. 조합 테스트를 더욱 효과적으로 수행하기 위한 팁 우선순위 설정:
모든 조합을 테스트할 수 없다면, 중요도나 위험도를 기준으로 우선순위를 정한다.
예를 들어, 사용자가 가장 많이 사용하는 조합이나 문제가 발생했을 때 영향이 큰 조합을 먼저 테스트한다.
...</p></div><footer class=entry-footer><span title='2024-11-02 09:42:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;393 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조합 테스트 설계 기법 (Combinatorial Test Design Techniques)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/combinatorial-test-design-techniques/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>체크리스트 기반 테스팅 (Checklist-based Testing)</h2></header><div class=entry-content><p>체크리스트 기반 테스팅 (Checklist-based Testing) Checklist-based Testing은 테스트 대상의 중요한 항목들을 체크리스트로 만들어 이를 기반으로 테스트를 수행하는 경험 기반 테스트 기법이다.
숙련된 테스터가 제품 검증을 위한 일련의 규칙이나 기준, 또는 참고/확인/기억해야 하는 상위수준 아이템 목록을 사용한다.
주요 특징 구조화된 접근 방식: 테스트 과정에 체계적인 구조를 제공한다. 일관성과 반복성: 모든 테스터가 동일한 단계를 따르고 동일한 항목을 확인하도록 보장한다. 중요 항목 누락 방지: 체크리스트를 통해 중요한 테스트 항목을 놓치지 않도록 한다. 경험 활용: 테스터의 경험과 지식을 체크리스트에 반영하여 활용한다. 적용 분야 Checklist-based Testing은 다양한 테스트 유형에 적용될 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-02 08:09:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;506 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 체크리스트 기반 테스팅 (Checklist-based Testing)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/checklist-based-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>랜덤 테스팅(Random Testing)</h2></header><div class=entry-content><p>랜덤 테스팅 (Random Testing) 랜덤 테스팅은 테스트 대상 시스템에 임의로 생성된 데이터를 입력하여 프로그램의 동작을 검증하는 기법이다.
이는 통계적 테스팅 또는 몬테카를로 테스팅으로도 알려져 있다.
실제 예시를 통해 더 자세히 살펴보자.
숫자 정렬 프로그램을 테스트한다고 가정해보자.
전통적인 테스트 방식에서는 미리 정해진 테스트 케이스(예: [1,2,3] 또는 [3,2,1])를 사용할 것.
하지만 랜덤 테스팅에서는 무작위로 생성된 숫자 배열을 사용한다.
이를 통해 개발자가 미처 생각하지 못한 경우의 수를 테스트할 수 있다.
랜덤 테스팅의 실제 적용 과정을 단계별로 살펴보자:
...</p></div><footer class=entry-footer><span title='2024-11-02 07:24:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;415 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 랜덤 테스팅(Random Testing)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/specification-based-test/random-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>탐색적 테스팅(Exploratory Testing)</h2></header><div class=entry-content><p>탐색적 테스팅(Exploratory Testing) 탐색적 테스팅(Exploratory Testing)은 소프트웨어 테스팅의 한 접근 방식으로, 테스터의 창의성, 경험, 직관을 활용하여 소프트웨어를 자유롭게 탐색하며 결함을 발견하는 과정이다. 이 방법은 사전에 정의된 테스트 케이스에 의존하지 않고, 테스트 설계와 실행을 동시에 수행하는 특징이 있다.
주요 특징 테스터 중심: 테스터의 경험, 지식, 창의력을 최대한 활용한다. 유연성: 미리 정의된 테스트 케이스 없이도 즉시 테스트를 시작할 수 있다. 학습과 실행의 동시 진행: 소프트웨어를 사용하면서 동시에 새로운 테스트 시나리오를 생성한다. 발견 중심: 문서화보다는 결함 발견과 해결에 집중한다. 핵심 구성 요소 테스트 차터: 테스트의 목적과 범위를 정의하는 간단한 문서. 시간 제한(Time Boxing): 정해진 시간 동안 집중적으로 테스트를 수행한다. 테스트 노트: 테스트 중 발견한 사항과 아이디어를 기록한다. 요약 보고(Debriefing): 테스트 결과와 발견된 이슈를 팀과 공유한다. 장점 속도와 비용 효율성: 사전 준비가 적어 빠르게 테스트를 시작할 수 있다. 예상치 못한 버그 발견: 정형화된 테스트로는 찾기 어려운 버그를 발견할 수 있다. 사용성 개선: 사용자 관점에서 제품을 평가할 수 있다. 요구사항 변화에 대응: 애자일 개발 환경에 적합하다. 단점 주관성: 테스터의 개인 능력에 크게 의존한다. 테스트 범위 확인 어려움: 체계적인 계획이 없어 테스트 범위를 정확히 파악하기 어렵다. 관리와 통제의 어려움: 테스트의 양과 질을 관리하기 어려울 수 있다. 적용 사례 예를 들어, MP3 플레이어 앱을 테스트할 때 다음과 같은 탐색적 테스팅을 수행할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-02 07:23:00 +0000 UTC'>November 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;215 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 탐색적 테스팅(Exploratory Testing)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/exploratory-testing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/24/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/26/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>