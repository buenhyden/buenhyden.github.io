<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>변수 명명 규칙(Variable Naming Rules)</h2></header><div class=entry-content><p>변수 명명 규칙(Variable Naming Rules) JavaScript의 변수 명명 규칙(Variable Naming Rules)은 코드의 가독성과 유지보수성을 높이는 데 중요한 역할을 한다.
좋은 변수 이름을 사용하면 코드를 처음 보는 사람도 더 쉽게 이해할 수 있고, 나중에 자신이 작성한 코드를 다시 볼 때도 의도를 빠르게 파악할 수 있다.
필수 규칙 (문법적 제약) 변수 이름에는 다음과 같은 필수 규칙이 적용된다:
문자, 숫자, 밑줄(_), 달러 기호($)만 사용 가능하다.
1 2 3 let userName = "John"; // 올바른 이름 let user_name = "John"; // 올바른 이름 let $price = 100; // 올바른 이름 변수 이름은 숫자로 시작할 수 없다 (문자, 밑줄, 또는 달러 기호로 시작해야 한다).
...</p></div><footer class=entry-footer><span title='2024-12-25 14:17:00 +0000 UTC'>December 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 변수 명명 규칙(Variable Naming Rules)" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/variables/naming-rules/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Type Casting</h2></header><div class=entry-content><p>Type Casting 파이썬에서는 다양한 내장 함수를 사용하여 데이터 타입을 변환할 수 있다.
데이터 타입을 변환할 때에는
문자열을 숫자로 변환할 때는 해당 문자열이 유효한 숫자 형식이어야 한다. 실수를 정수로 변환할 때는 소수점 이하가 버려진다. 복잡한 데이터 구조(리스트, 딕셔너리 등)를 변환할 때는 주의가 필요하다.
등을 주의해야 한다. 정수로 변환 (int())
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 정수형 변환 float_num = 3.14 int_num = int(float_num) # 3 (소수점 이하 버림) # 실수형 변환 a = float("10.5") # 문자열을 실수로 integer = 5 # 정수를 실수로 float_num = float(integer) # 5.0 b = float(10) # 문자열을 숫자로 변환 str_num = "123" number = int(str_num) # 123 float_num = float("3.14") # 3.14 # 진수 변환 binary_str = "1010" decimal = int(binary_str, 2) # 10 (2진수를 10진수로) hex_str = "1A" decimal = int(hex_str, 16) # 26 (16진수를 10진수로) 문자열로 변환 (str())
...</p></div><footer class=entry-footer><span title='2024-12-24 13:23:00 +0000 UTC'>December 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Type Casting" href=https://buenhyden.github.io/posts/programming-languages/python/basic-syntax/data-types/type-casting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. FastAPI</h2></header><div class=entry-content><p>NodeJS vs. FastAPI 현대 웹 개발에서 백엔드 기술 선택은 프로젝트의 성공에 중요한 요소이다.
Node.js와 FastAPI는 각각 JavaScript와 Python 생태계에서 인기 있는 백엔드 기술로, 서로 다른 접근 방식과 강점을 가지고 있다.
Node.js는 오랜 기간 동안 검증된 기술로, 방대한 생태계와 JavaScript를 백엔드에서도 사용할 수 있는 일관성을 제공한다. 실시간 애플리케이션과 I/O 집약적 작업에 특히 뛰어나다.
FastAPI는 비교적 새로운 프레임워크이지만, 현대적인 Python 기능을 최대한 활용하여 빠른 개발 속도, 뛰어난 개발자 경험, 자동 문서화와 데이터 검증을 제공한다. Python의 데이터 과학 생태계와 통합이 필요한 프로젝트에 특히 적합하다.
...</p></div><footer class=entry-footer><span title='2024-12-22 10:38:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. FastAPI" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-fastapi/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Flask</h2></header><div class=entry-content><p>NodeJS vs. Flask Node.js와 Flask는 현대 웹 애플리케이션 개발에 널리 사용되는 두 가지 인기 있는 백엔드 기술이다.
이 두 기술은 각각 다른 언어(JavaScript vs Python), 다른 철학, 그리고 서로 다른 접근 방식을 가지고 있다.
Node.js와 Flask는 각각 고유한 강점과 약점을 가진 강력한 백엔드 기술이다.
선택은 프로젝트의 요구사항, 팀의 전문성, 그리고 장기적인 목표에 따라 달라진다.
Node.js는 실시간 기능, 높은 동시성, 그리고 JavaScript의 일관성을 활용하려는 프로젝트에 적합하다.
특히 I/O 집약적인 애플리케이션과 실시간 웹 애플리케이션에서 강점을 보인다.
...</p></div><footer class=entry-footer><span title='2024-12-22 10:38:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. Flask" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-flask/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ES Modules vs. CommonJS</h2></header><div class=entry-content><p>ES Modules vs. CommonJS 자바스크립트 애플리케이션이 복잡해지면서 코드를 모듈화하는 방법이 중요해졌다.
이에 두 가지 주요 모듈 시스템인 CommonJS와 ES Modules가 등장했다.
이 두 시스템은 각각 고유한 특성과 사용 사례를 가지고 있다.
JavaScript 모듈 시스템의 선택은 프로젝트의 요구 사항, 타겟 환경, 그리고 기존 코드베이스에 크게 의존한다.
최신 프로젝트에서는 ES Modules의 채택이 증가하는 추세이지만, CommonJS는 Node.js 생태계에서 여전히 중요한 역할을 하고 있다.
두 시스템의 장단점을 이해하고, 필요에 따라 적절한 시스템을 선택하거나 하이브리드 접근 방식을 채택하는 것이 좋다. 또한, 점진적으로 ES Modules로 마이그레이션하는 전략을 고려할 수 있으며, 이를 통해 모던 JavaScript의 이점을 활용하면서 기존 코드의 호환성도 유지할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-22 04:26:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ES Modules vs. CommonJS" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/es-modules-vs-commonjs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NodeJS vs. Django</h2></header><div class=entry-content><p>NodeJS vs. Django 웹 개발에서 백엔드 프레임워크를 선택하는 것은 프로젝트의 성공에 중요한 요소이다. Node.js와 Django는 각각 다른 철학, 접근 방식, 그리고 강점을 가진 인기 있는 두 가지 백엔드 기술이다.
Node.js와 Django는 각각 고유한 강점과 약점을 가진 강력한 백엔드 기술이다.
선택은 프로젝트의 요구사항, 팀의 전문성, 그리고 장기적인 목표에 따라 달라진다.
Node.js는 실시간 기능, 높은 동시성, 그리고 JavaScript의 일관성을 활용하려는 프로젝트에 적합하다.
빠른 프로토타이핑, 견고한 데이터 모델링, 내장된 관리 기능이 필요한 프로젝트에는 Django가 더 적합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:59:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to NodeJS vs. Django" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/nodejs/nodejs-vs-django/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>BunJS vs. NodeJS</h2></header><div class=entry-content><p>BunJS vs. NodeJS JavaScript는 원래 웹 브라우저에서만 실행되는 언어였지만, 서버 사이드 런타임의 등장으로 백엔드 개발에도 널리 사용되고 있다.
Node.js는 오랫동안 서버 사이드 JavaScript의 표준이었으나, Bun이라는 새로운 런타임이 등장하여 JavaScript 생태계에 변화를 가져오고 있다. 각기 다른 엔진과 설계 철학을 기반으로 개발되어 다양한 차이점을 보인다.
Node.js와 Bun은 각각 고유한 강점과 약점을 가진 JavaScript 런타임이다.
Node.js는 성숙한 생태계, 광범위한 호환성, 검증된 안정성을 제공하는 반면, Bun은 뛰어난 성능, 개선된 개발자 경험, 통합 도구를 제공한다.
...</p></div><footer class=entry-footer><span title='2024-12-22 03:43:00 +0000 UTC'>December 22, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to BunJS vs. NodeJS" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/runtime-environments/bunjs/bunjs-vs-nodejs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>지연 초기화(Lazy Initialization)</h2></header><div class=entry-content><p>지연 초기화(Lazy Initialization) 지연 초기화(Lazy Initialization)는 객체 생성, 값 계산, 또는 기타 비용이 많이 드는 프로세스를 실제로 필요할 때까지 연기하는 프로그래밍 기법이다.
지연 초기화는 리소스 사용을 최적화하고 애플리케이션의 시작 시간을 개선하는 강력한 도구이지만 무분별한 적용은 오히려 코드를 복잡하게 만들고 성능 문제를 야기할 수 있다.
지연 초기화의 기본 개념 지연 초기화는 객체나 리소스의 초기화를 그것이 실제로 필요할 때까지 미루는 설계 패턴이다.
이는 “필요할 때까지 만들지 말라"는 원칙에 기반한다.
기본 원리 즉시 초기화(Eager Initialization): 객체가 생성될 때 모든 의존성과 리소스를 즉시 초기화 지연 초기화(Lazy Initialization): 객체의 특정 부분이 실제로 사용될 때 해당 부분만 초기화 지연 초기화가 유용한 상황 비용이 많이 드는 연산: 메모리 사용량이 큰 객체, 계산 비용이 높은 값, 데이터베이스 연결 등 사용되지 않을 수 있는 컴포넌트: 애플리케이션의 모든 실행 경로에서 필요하지 않은 리소스 초기화 의존성 문제 해결: 순환 참조 같은 의존성 문제를 해결하기 위한 방법 지연 초기화의 구현 패턴 기본 지연 초기화 패턴 가장 단순한 형태의 지연 초기화 구현.
...</p></div><footer class=entry-footer><span title='2024-12-18 10:42:00 +0000 UTC'>December 18, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지연 초기화(Lazy Initialization)" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/lazy-initialization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>UML</h2></header><div class=entry-content><p>UML(Unified Modeling Language) UML(Unified Modeling Language)은 시스템, 소프트웨어, 비즈니스 프로세스를 시각적으로 모델링하기 위한 표준화된 범용 모델링 언어이다. 1990년대 중반에 Grady Booch, James Rumbaugh, Ivar Jacobson(종종 “삼총사"라고 불림)에 의해 개발되었으며, 현재는 OMG(Object Management Group)에서 관리하고 있다.
UML은 객체지향 프로그래밍의 개념이 확산되면서 소프트웨어 설계와 구조를 표현하는 공통 언어의 필요성에 의해 탄생했다. 프로그래밍 언어나 개발 방법론과 무관하게 사용할 수 있으며, 시스템의 다양한 측면을 표현할 수 있는 여러 다이어그램 유형을 제공한다.
UML은 현재 버전 2.5.1(2017년 12월 발표)까지 발전해왔으며, 소프트웨어 개발 과정에서 다음과 같은 역할을 한다:
...</p></div><footer class=entry-footer><span title='2024-12-16 12:56:00 +0000 UTC'>December 16, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to UML" href=https://buenhyden.github.io/posts/software-design-and-architecture/architecture-documentation-and-modeling/uml-modeling/uml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RFC 9457</h2></header><div class=entry-content><p>RFC 9457 RFC 9457은 그 후속 버전으로, HTTP API의 오류 응답을 구조화된 형식으로 전달하기 위한 표준이다.
이 문서는 RFC 7807을 대체하며, 이전 버전에서의 경험과 피드백을 반영하여 몇 가지 중요한 개선사항을 도입했다.
RFC 9457의 주요 개선사항 RFC 9457은 RFC 7807을 기반으로 다음과 같은 주요 개선점을 포함하고 있다.
문제 유형(type) 필드의 명확화
기존: type 필드는 문제의 유형을 식별하는 URI로 사용되었지만, 그 사용 방식이 모호할 수 있다. 개선: type 필드의 사용을 명확히 정의하고, 공용 레지스트리를 통해 표준화된 문제 유형을 관리하도록 권장하고 있다. 여러 문제의 표현 지원
...</p></div><footer class=entry-footer><span title='2024-12-15 14:25:00 +0000 UTC'>December 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RFC 9457" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/resource-style/rest/error-handling/rfc-9457/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/24/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/26/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>