<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PBAC</h2></header><div class=entry-content><p>정책 기반 접근 제어(Policy-Based Access Control, PBAC) 중앙에서 정의된 정책들을 기반으로 접근 권한을 결정하는 접근 제어 방식.
각 정책은 “누가”, “무엇을”, “어떤 조건에서” 할 수 있는지를 정의하며, 이러한 정책들은 프로그래밍 방식으로 표현되고 평가된다.
현대적인 클라우드 환경이나 마이크로서비스 아키텍처에서 특히 유용하다.
AWS IAM, Azure RBAC 등의 클라우드 서비스들이 PBAC를 구현한 대표적인 예시.
작동 방식:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class Policy { constructor(name, conditions, effect) { this.name = name; this.conditions = conditions; this.effect = effect; // 'allow' 또는 'deny' } evaluate(context) { try { // 모든 조건을 평가 return this.conditions.every(condition => condition(context)); } catch (error) { console.error(`Policy evaluation error: ${error.message}`); return false; } } } class PolicyEngine { constructor() { this.policies = new Map(); } addPolicy(policy) { this.policies.set(policy.name, policy); } evaluateAccess(context) { let finalDecision = false; for (const policy of this.policies.values()) { const matches = policy.evaluate(context); if (matches) { finalDecision = policy.effect === 'allow'; // 명시적인 거부 정책이 있으면 즉시 거부 if (policy.effect === 'deny') { return false; } } } return finalDecision; } } // 정책 조건 예시들 const conditions = { isWorkingHours: (context) => { const hour = context.time.getHours(); return hour >= 9 && hour &lt; 18; }, isInternalNetwork: (context) => { return context.ipAddress.startsWith('192.168.'); }, hasRole: (role) => (context) => { return context.user.roles.includes(role); }, hasPermission: (permission) => (context) => { return context.user.permissions.includes(permission); } }; // 정책 엔진 사용 예시 const policyEngine = new PolicyEngine(); // HR 문서 접근 정책 const hrDocumentPolicy = new Policy( 'HR_Document_Access', [ conditions.isWorkingHours, conditions.isInternalNetwork, conditions.hasRole('HR'), conditions.hasPermission('read_hr_documents') ], 'allow' ); // 주말 접근 제한 정책 const weekendRestrictionPolicy = new Policy( 'Weekend_Restriction', [ (context) => { const day = context.time.getDay(); return day === 0 || day === 6; } ], 'deny' ); policyEngine.addPolicy(hrDocumentPolicy); policyEngine.addPolicy(weekendRestrictionPolicy); // 접근 시도 예시 const accessContext = { user: { name: 'Alice', roles: ['HR'], permissions: ['read_hr_documents'] }, time: new Date('2024-12-17T14:00:00'), // 평일 오후 2시 ipAddress: '192.168.1.100', resource: 'employee_records' }; const hasAccess = policyEngine.evaluateAccess(accessContext); console.log(`Access granted: ${hasAccess}`); 주요 특징 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 중앙 집중식 관리: 정책을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 컨텍스트 인식: 사용자 신원, 리소스 특성, 시간, 위치 등 다양한 컨텍스트 정보를 고려한다. 동적 평가: 접근 요청 시 실시간으로 정책을 평가하여 결정을 내린다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 정책 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 일관성 유지: 중앙에서 관리되는 정책으로 전체 시스템의 일관성을 보장한다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AdvancedPolicyEngine { constructor() { this.policies = new Map(); this.auditLog = []; } addPolicy(policy) { this.policies.set(policy.name, policy); } async evaluateAccess(context) { const decisions = []; const startTime = Date.now(); try { for (const policy of this.policies.values()) { const decision = { policyName: policy.name, effect: policy.effect, matches: await policy.evaluate(context), timestamp: new Date() }; decisions.push(decision); if (decision.matches && policy.effect === 'deny') { this.logDecision(context, decisions, 'denied'); return false; } } const finalDecision = decisions.some(d => d.matches && d.effect === 'allow'); this.logDecision(context, decisions, finalDecision ? 'allowed' : 'denied'); return finalDecision; } catch (error) { this.logError(context, error); throw error; } } logDecision(context, decisions, result) { const logEntry = { timestamp: new Date(), user: context.user.name, resource: context.resource, action: context.action, decisions: decisions, finalResult: result, contextSnapshot: { …context } }; this.auditLog.push(logEntry); } logError(context, error) { const errorEntry = { timestamp: new Date(), type: 'error', user: context.user.name, error: error.message, stack: error.stack, context: { …context } }; this.auditLog.push(errorEntry); } getAuditLog(filters = {}) { return this.auditLog.filter(entry => { return Object.entries(filters).every(([key, value]) => entry[key] === value ); }); } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PBAC" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authorization/authorization-models/pbac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ABAC</h2></header><div class=entry-content><p>속성 기반 접근 제어 (Attribute-Based Access Control, ABAC) ABAC는 주체(사용자), 객체(리소스), 작업, 환경 조건의 속성을 조합하여 접근 제어 정책을 정의한다.
이를 통해 매우 세분화되고 유연한 접근 제어가 가능하다.
의료, 금융, 정부 등 복잡한 보안 요구사항을 가진 분야에서 유용하게 활용될 수 있다.
주요 특징 유연성: 다양한 속성 조합을 통해 복잡한 접근 제어 정책을 수용할 수 있다. 세분화: 사용자 역할뿐만 아니라 다양한 속성을 고려하여 더 정교한 접근 제어가 가능하다. 동적 정책: 실시간 속성 변화에 따라 접근 제어 결정을 동적으로 수행할 수 있다. 확장성: 새로운 속성을 쉽게 추가하여 정책을 확장할 수 있다. ABAC의 주요 구성 요소 속성: 주체, 객체, 환경 조건에 대한 특성을 정의한다. 주체(Subject) 속성 사용자 ID, 이름, 직급, 부서, 보안 등급 근속 연수, 자격증, 교육 이수 여부 소속 조직, 프로젝트 참여 이력 객체(Object/Resource) 속성 데이터 분류, 보안 레벨 소유자, 작성일, 만료일 프로젝트 코드, 부서 코드 데이터 타입, 크기, 형식 행동(Action) 속성 읽기, 쓰기, 삭제, 수정 승인, 거부, 이관 다운로드, 공유, 인쇄 환경(Environment) 속성 접근 시간, 위치 네트워크 종류(내부/외부) 디바이스 종류, 보안 상태 현재 위험 수준 정책 모델: 속성들의 조합으로 접근 제어 규칙을 정의한다. 아키텍처 모델: ABAC 시스템의 구현 방식을 정의한다. ABAC의 장점 높은 유연성과 세분화된 접근 제어 가능 동적이고 컨텍스트 인식적인 정책 적용 가능 새로운 사용자나 리소스에 대해 개별 권한 설정 없이 속성만으로 접근 제어 가능 ABAC의 단점 구현 및 관리의 복잡성 성능 영향: 많은 속성을 평가해야 하므로 처리 시간이 길어질 수 있음 정책 설계의 어려움: 복잡한 속성 조합으로 인한 예기치 않은 결과 발생 가능성 모범 사례 정책 설계
...</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ABAC" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authorization/authorization-models/abac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RBAC</h2></header><div class=entry-content><p>규칙 기반 접근 제어(Rule-Based Access Control, RBAC) RBAC는 “만약 ~라면 ~할 수 있다"와 같은 형태의 규칙들을 사용하여 접근 권한을 제어한다.
각 규칙은 조건부와 결과부로 구성되며, 시스템은 이러한 규칙들을 순차적으로 평가하여 접근 허용 여부를 결정한다.
클라우드 환경, 마이크로서비스 아키텍처, IoT 시스템 등 동적이고 복잡한 환경에서 특히 유용하며, 보안 요구사항이 높고 빠르게 변화하는 조직에 적합하다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Rule { constructor(condition, consequence) { // 규칙의 조건부(if)와 결과부(then)를 정의합니다 this.condition = condition; this.consequence = consequence; } evaluate(context) { // 주어진 컨텍스트에 대해 규칙을 평가합니다 if (this.condition(context)) { return this.consequence; } return null; } } class RuleEngine { constructor() { this.rules = []; } addRule(rule) { // 새로운 규칙을 규칙 엔진에 추가합니다 this.rules.push(rule); } evaluateAccess(context) { // 모든 규칙을 순차적으로 평가합니다 for (const rule of this.rules) { const result = rule.evaluate(context); if (result !== null) { return result; } } // 기본적으로는 접근을 거부합니다 return false; } } 주요 특징 규칙 기반 결정: 사용자의 속성, 리소스의 특성, 환경 조건 등을 고려한 규칙을 설정하여 접근 권한을 결정한다. 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 동적 평가: 접근 요청 시 실시간으로 규칙을 평가하여 결정을 내린다. 중앙 집중식 관리: 규칙을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 규칙 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 투명성: 규칙이 명시적으로 정의되어 있어 접근 제어 결정의 이유를 쉽게 이해할 수 있다. 단점 복잡성: 규칙이 많아지면 관리가 복잡해질 수 있다. 성능 영향: 많은 규칙을 평가해야 할 경우 처리 시간이 길어질 수 있다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:46:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RBAC" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authorization/authorization-models/rbac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Black-box Test and White-box Test</h2></header><div class=entry-content><p>Black-box Test and White-box Test Black-box Testing(블랙박스 테스팅)은 소프트웨어의 내부 구조나 동작 원리를 모르는 상태에서 진행하는 테스트 방식이다.
마치 불투명한 상자 안을 들여다볼 수 없는 것처럼, 테스터는 입력값을 넣고 그에 따른 출력값만을 확인한다.
예를 들어, 계산기 애플리케이션을 테스트할 때 “2+2"를 입력했을 때 “4"가 출력되는지만 확인하고, 그 계산 과정이 어떤 알고리즘으로 이루어지는지는 고려하지 않는다.
Black-box Testing의 주요 특징은 다음과 같다:
사용자 관점에서의 테스트가 가능하다. 실제 사용자들이 소프트웨어를 사용하는 방식과 유사하게 테스트할 수 있다. 테스터가 코드에 대한 지식이 없어도 테스트를 수행할 수 있다. 경계값 분석, 동등 분할, 결정 테이블 등의 기법을 활용할 수 있다. 반면 White-box Testing(화이트박스 테스팅)은 소프트웨어의 내부 로직을 알고 있는 상태에서 진행하는 테스트이다.
투명한 상자처럼 내부 구조를 모두 볼 수 있어, 코드의 특정 부분이 어떻게 작동하는지 세세하게 테스트할 수 있다.
예를 들어, 로그인 기능을 테스트할 때 비밀번호 암호화 과정, 데이터베이스 접근 방식, 예외 처리 등의 내부 로직을 모두 확인한다.
...</p></div><footer class=entry-footer><span title='2024-11-05 02:29:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Black-box Test and White-box Test" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/testing-fundamentals/test-design-techniques/black-box-test-and-white-box-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>시스템 테스트 (System test)</h2></header><div class=entry-content><p>시스템 테스트 (System test) 시스템 테스트는 소프트웨어 개발 주기의 후반부에 수행되는 중요한 테스트 단계이다.
이는 개발된 소프트웨어 시스템 전체를 검사하는 과정으로, 모든 개별 모듈과 구성 요소가 통합된 후 전체 시스템이 예상대로 작동하는지 확인한다.
온라인 쇼핑몰의 시스템 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 온라인 쇼핑몰 시스템 테스트 예시 def test_complete_shopping_flow(): # 1. 사용자 시나리오 테스트 # 회원가입부터 상품 구매까지 전체 프로세스 user = register_new_user("test@example.com", "password123") login_result = login(user.email, user.password) # 상품 검색 및 장바구니 추가 search_results = search_products("노트북") cart = add_to_cart(search_results[0].id) # 주문 및 결제 프로세스 order = create_order(cart.id) payment_result = process_payment(order.id, "신용카드") # 전체 프로세스가 완료되었는지 확인 assert order.status == "결제완료" assert inventory.check_stock(search_results[0].id) == "재고감소" assert notification.order_confirmation_sent == True # 2. 시스템 부하 테스트 concurrent_users = simulate_multiple_users(1000) system_response = measure_system_performance(concurrent_users) assert system_response.average_response_time &lt; 2.0 # 2초 이내 응답 특징과 목적 시스템 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-04 06:01:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 시스템 테스트 (System test)" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/testing-fundamentals/testing-levels/system/system-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>기본 테스팅 (Fundamental Testing)</h2></header><div class=entry-content><p>기본 테스팅 (Fundamental Testing) Fundamental testing은 소프트웨어 테스팅의 기본적인 프로세스와 원칙을 의미한다.
이는 소프트웨어의 품질을 보장하기 위한 체계적인 접근 방식을 제공한다.
Fundamental testing process는 다음과 같은 주요 단계로 구성된다:
계획 및 통제 (Planning and Control)
테스트의 범위, 목표, 위험을 결정한다. 필요한 리소스를 식별하고 일정을 수립한다. 분석 및 설계 (Analysis and Design)
테스트 조건을 식별한다. 테스트 케이스를 설계한다. 테스트 환경을 준비한다. 구현 및 실행 (Implementation and Execution)
테스트 케이스를 우선순위화하고 실행한다. 결과를 기록하고 결함을 보고한다. 종료 기준 평가 및 보고 (Evaluating Exit Criteria and Reporting)
...</p></div><footer class=entry-footer><span title='2024-11-04 04:05:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 기본 테스팅 (Fundamental Testing)" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/foundations/principles-and-glossary/testing-concepts/fundamental-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>통합 테스트 (Integration Test)</h2></header><div class=entry-content><p>통합 테스트 (Integration Test) 통합 테스트는 소프트웨어 개발 과정에서 개별적으로 테스트된 모듈들을 결합하여 전체 시스템으로서의 상호작용을 검증하는 과정이다.
이는 마치 퍼즐 조각들을 맞추는 것과 비슷하다. 각 조각(모듈)이 잘 만들어졌더라도, 모든 조각이 함께 어울려 전체 그림을 완성하는지 확인하는 과정이라고 생각하면 된다.
특징과 목적 통합 테스트의 주요 특징과 목적은 다음과 같다:
모듈 간 상호작용 검증 인터페이스 오류 발견 시스템 전체 기능 확인 데이터 흐름 검증 예를 들어, 온라인 쇼핑몰을 개발한다고 가정해보자다.
로그인 모듈, 상품 검색 모듈, 장바구니 모듈, 결제 모듈이 각각 잘 작동하더라도, 이들이 함께 연동되어 고객이 상품을 검색하고 장바구니에 담아 결제까지 완료할 수 있는지 확인하는 것이 통합 테스트의 목적이다.
...</p></div><footer class=entry-footer><span title='2024-11-04 02:14:00 +0000 UTC'>November 4, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 통합 테스트 (Integration Test)" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/testing-fundamentals/testing-levels/system-integration/integration-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>부하 테스트(Load Testing)</h2></header><div class=entry-content><p>부하 테스트(Load Testing) 부하 테스트는 소프트웨어 시스템이 예상되는 사용자 부하 하에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.
이는 실제 사용 환경과 유사한 조건에서 시스템의 성능을 평가한다.
특징과 목적 시스템의 최대 운영 용량 파악 성능 병목 현상 식별 확장성 및 안정성 검증 사용자 경험 개선 테스트 범위 부하 테스트는 다음과 같은 범위를 포함한다:
웹 애플리케이션 데이터베이스 시스템 네트워크 인프라 서버 리소스 (CPU, 메모리, 디스크 I/O) 수행 시점 부하 테스트는 주로 다음 시점에 수행된다:
...</p></div><footer class=entry-footer><span title='2024-11-03 14:24:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 부하 테스트(Load Testing)" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/testing-fundamentals/testing-types/non-functional-testing/performance-testing/load-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>스트레스 테스트 (Stress Testing)</h2></header><div class=entry-content><p>스트레스 테스트 (Stress Testing) 스트레스 테스트는 소프트웨어 시스템을 극한의 조건에서 테스트하여 그 한계를 파악하는 성능 테스트의 한 유형이다.
이는 시스템이 정상적인 운영 범위를 넘어선 상황에서 어떻게 동작하는지를 평가한다.
웹 애플리케이션의 스트레스 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import time from locust import HttpUser, task, between class StressTestUser(HttpUser): wait_time = between(0.1, 0.5) # 매우 짧은 대기 시간 @task def stress_test_scenario(self): """극한 상황 시뮬레이션""" # 대용량 데이터 요청 with self.client.get("/api/products", params={"page_size": 1000}, catch_response=True) as response: # 응답 검증 if response.elapsed.total_seconds() > 5.0: response.failure("응답 시간 초과") elif response.status_code != 200: response.failure(f"에러 발생: {response.status_code}") # 시스템 복구 능력 테스트 time.sleep(0.1) # 잠시 대기 # 후속 요청으로 시스템 회복 확인 recovery_response = self.client.get("/api/health") assert recovery_response.status_code == 200 특징과 목적 스트레스 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-03 14:24:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스트레스 테스트 (Stress Testing)" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/testing-fundamentals/testing-types/non-functional-testing/performance-testing/stress-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>전문화된 테스팅 (Specialized Testing)</h2></header><div class=entry-content><p>전문화된 테스팅 (Specialized Testing) Specialized Testing은 소프트웨어 테스팅의 한 분야로, 특정 영역이나 기능에 초점을 맞춘 심층적인 테스트 방식이다.
이는 일반적인 테스팅 방법으로는 발견하기 어려운 문제점들을 식별하고 해결하는 데 중점을 둔다.
Specialized Testing의 주요 특징 특정 영역 집중: 성능, 보안, 호환성 등 특정 측면에 집중한다. 심층적 분석: 일반 테스트보다 더 깊이 있는 분석을 수행한다. 전문 지식 활용: 해당 분야의 전문가들이 테스트를 수행한다. Specialized Testing의 종류 성능 테스팅: 부하 테스트, 스트레스 테스트, 확장성 테스트 등을 포함한다. 보안 테스팅: 취약점 식별 및 보안 위협에 대한 대응을 테스트한다. 호환성 테스팅: 다양한 환경에서의 소프트웨어 작동을 확인한다. 모바일 앱 테스팅: 모바일 기기 특성을 고려한 테스트를 수행한다. AI/ML 테스팅: 인공지능과 머신러닝 알고리즘의 정확성을 검증한다. IoT 테스팅: 사물인터넷 기기와의 연동을 테스트한다. Specialized Testing의 중요성 품질 향상: 특정 영역에 대한 깊이 있는 테스트로 소프트웨어 품질을 크게 개선한다. 위험 감소: 초기에 문제를 발견하여 출시 후 발생할 수 있는 문제를 예방한다. 사용자 만족도 증가: 특정 기능의 완성도를 높여 사용자 경험을 개선한다. Specialized Testing을 효과적으로 수행하기 위한 주요 고려사항들 테스트 환경 구성
실제 환경과 유사한 테스트 환경을 구성하여 정확한 결과를 얻을 수 있도록 한다. 테스트 데이터 준비
다양한 시나리오를 커버할 수 있는 테스트 데이터를 준비한다. 모니터링 및 측정
테스트 중 시스템의 다양한 지표를 지속적으로 모니터링하고 측정한다. 결과 분석 및 개선
테스트 결과를 철저히 분석하고, 발견된 문제점에 대한 개선 방안을 도출한다. 전문화된 테스팅 (Specialized Testing)의 유형 테스트 유형 목적 수행 시점 핵심 지표 주요 도구 테스트 범위 검증 대상 자동화 수준 성능 테스팅 성능 병목 현상 식별 및 성능 요구사항 충족 확인 주요 릴리스 전 응답 시간, 처리량, 오류율 JMeter, LoadRunner 다양한 조건에서 애플리케이션의 속도, 응답성, 안정성 테스트 기능성, 성능, 확장성 도구에 따라 완전 또는 부분 자동화 가능 보안 테스팅 소프트웨어 애플리케이션의 취약점 및 보안 약점 발견 개발 중 및 소프트웨어 수명 주기 전반 취약점 수, 심각도, 오탐지율, 해결 시간 SAST, DAST, 침투 테스팅 도구 애플리케이션, 네트워크, 시스템의 취약점 평가 데이터의 기밀성, 무결성, 가용성 도구에 따라 완전 또는 부분 자동화 가능 호환성 테스팅 다양한 플랫폼에서 소프트웨어 정상 작동 확인 및 사용자 만족도 향상 애플리케이션이 안정화된 소프트웨어 테스팅 단계 다양한 기기에서의 성능 안정성, 기능성, 응답성 BrowserStack, LambdaTest 다양한 운영 체제, 브라우저, 하드웨어 구성, 네트워크 조건에서 테스트 다양한 환경에서의 기능성, 성능, 사용자 경험 요구사항에 따라 수동 및 자동화 가능 사용성 테스팅 사용성 문제 식별 및 제품의 효과성, 효율성, 만족도 평가 제품 수명 주기의 다양한 단계(초기 개발 및 출시 전 포함) 성공률, 작업 소요 시간, 오류율, 사용자 만족도 Maze, UserTesting UI 및 전반적인 사용자 경험 평가 기능성 및 사용자 만족도 상황에 따라 완전 자동화 또는 수동 가능 회귀 테스팅 의도치 않은 결함 탐지, 안정성 보장, 위험 감소, 지속적 테스팅 촉진 소프트웨어 개발 수명 주기 전반(특히 코드 변경 또는 버그 수정 후) 테스트 실행 시간, 테스트 커버리지, 결함 탐지율 Selenium, Katalon, Tricentis Testim 기존 기능 검증 및 새로운 기능 테스트 핵심 기능이 예상대로 작동하는지 확인 완전 자동화, 부분 자동화 또는 수동 가능 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-03 04:10:00 +0000 UTC'>November 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 전문화된 테스팅 (Specialized Testing)" href=https://buenhyden.github.io/posts/software-engineering/quality-assurance-and-testing/testing-fundamentals/testing-types/specialized-testing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/34/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/36/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>