<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>서브넷팅 (Subnetting)</h2></header><div class=entry-content><p>서브넷팅 (Subnetting) 서브넷팅(Subnetting)은 네트워크를 더 작은 단위의 네트워크로 분할하는 기술이다.
이 기술은 IP 주소의 효율적인 사용과 네트워크 관리를 개선하기 위해 사용된다.
서브넷팅은 하나의 IP 클래스를 효율적으로 이용하기 위해 Host ID 구간을 분할하여 원래 정의된 Network ID와 함께 Network ID로 사용하는 네트워크 관리 기법이다.
서브넷팅을 통해 분할된 네트워크를 서브넷(Subnet)라고 한다.
주요 목적 IP 주소 낭비 방지 브로드캐스트 도메인의 크기 축소 네트워크 성능 향상 보안성 강화 서브넷팅의 장점 네트워크 관리 용이성 향상 고급 네트워크 보안 구현 가능 네트워크 트래픽 감소 ISP로부터 추가 IP 주소 요청 필요성 감소 서브넷 (Subnet) 서브넷은 ‘Sub Network’의 줄임말로, 더 큰 네트워크의 논리적인 부분집합을 의미한다.
이는 마치 큰 건물을 여러 개의 사무실로 나누는 것과 비슷한데, 각 사무실(서브넷)은 자신만의 공간을 가지면서도 전체 건물(네트워크)의 일부로 기능한다.
...</p></div><footer class=entry-footer><span title='2024-10-17 13:09:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 서브넷팅 (Subnetting)" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/internet-layer/internet-protocol/ip-fundamentals/subnetting--vlsm/subnetting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DNS 캐싱 (DNS Caching)</h2></header><div class=entry-content><p>DNS 캐싱 (DNS Caching) DNS 캐싱은 이전에 조회한 도메인 이름과 IP 주소의 매핑 정보를 임시로 저장하는 메커니즘이다.
이를 통해 매번 전체 DNS 조회 과정을 거치지 않고도 빠르게 도메인 이름을 IP 주소로 변환할 수 있다.
DNS 캐싱은 인터넷 성능 최적화에 중요한 역할을 하며, 적절한 관리를 통해 효율적이고 안전한 네트워크 환경을 유지할 수 있다.
작동 방식 DNS 서버나 클라이언트 장치가 도메인 이름에 대한 IP 주소를 조회하면, 그 결과를 캐시에 저장한다. 이후 동일한 도메인에 대한 요청이 있을 때, 캐시된 정보를 사용하여 빠르게 응답한다. 캐시 위치 DNS 캐싱 (DNS Caching)은 브라우저, 운영체제, 라우터, ISP 의 DNS 서버 등 다양한 단계에서 발생한다.
...</p></div><footer class=entry-footer><span title='2024-10-17 07:30:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DNS 캐싱 (DNS Caching)" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/network-services/dns/dns-fundamentals/caching/dns-caching/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Packet</h2></header><div class=entry-content><p>Packet (패킷, 네트워크 패킷) 패킷은 네트워크에서 데이터를 주고받을 때 사용되는 형식화된 데이터 블록이다.
주요 목적은 다음과 같다:
효율적인 데이터 전송 네트워크 대역폭의 효율적 사용 오류 검출 및 복구 용이성 네트워크 혼잡 방지 패킷을 사용하는 이유는? 패킷이 모두 대상에 도착하는 한 동일한 대상에 대해 서로 다른 네트워크 경로를 사용할 수 있음을 의미한다. 특정 프로토콜에서 패킷은 각 패킷이 다른 경로를 사용하여 도착하더라도 올바른 순서로 최종 목적지에 도착해야 한다. 여러 컴퓨터의 패킷이 기본적으로 임의의 순서로 동일한 선로를 통해 이동할 수 있다. 동일한 네트워킹 장비를 통해 동시에 여러 연결을 수행할 수 있다. 그 결과로 수십억 개의 장치가 인터넷에서 동시에 데이터를 교환할 수 있다. 패킷의 구조 패킷은 일반적으로 세 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Packet" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/packet/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Routing</h2></header><div class=entry-content><p>Routing 데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.
네트워크 계층(3계층)에서 이루어지는 핵심 기능으로, 라우터가 패킷의 목적지 IP 주소를 확인하고 최적의 경로를 결정한다.
주요 특징 경로 결정: 라우팅 테이블을 참조하여 최적의 경로를 선택한다. 네트워크 연결: 서로 다른 네트워크를 연결하여 통신을 가능하게 한다. 패킷 전달: 선택된 경로를 통해 패킷을 다음 홉으로 전달한다. 중요성 효율적인 데이터 전송을 가능하게 한다. 네트워크의 안정성과 확장성을 향상시킨다. 트래픽 관리와 로드 밸런싱에 기여한다. 라우팅 방식 정적 라우팅: 관리자가 수동으로 라우팅 테이블을 구성한다.
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Routing" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/routing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network Hop</h2></header><div class=entry-content><p>Network Hop 네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.
홉은 데이터 패킷이 한 네트워크 지점에서 다음 지점으로 이동할 때마다 발생합니다.
각 홉은 패킷이 목적지에 도달하기 위해 거치는 중간 단계를 나타낸다. 주요 역할은 다음과 같다:
경로 결정: 각 홉에서 라우터는 패킷의 다음 목적지를 결정한다. 네트워크 성능 측정: 홉 수는 네트워크의 복잡성과 데이터 전송 경로의 길이를 나타낸다. 패킷 전달: 각 홉은 패킷을 다음 네트워크 장비로 전달하는 역할을 한다. 홉 카운트(Hop Count) 홉 카운트는 패킷이 출발지에서 목적지까지 거치는 홉의 총 개수를 의미한다. 이는 네트워크 경로의 길이를 측정하는 중요한 지표이다.
...</p></div><footer class=entry-footer><span title='2024-10-16 09:19:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Hop" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/network-hop/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프래그먼테이션 (Fragmentation)</h2></header><div class=entry-content><p>프래그먼테이션 (Fragmentation) Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.
이는 다음과 같은 목적을 가진다:
다양한 MTU를 가진 네트워크 간의 통신 가능 네트워크 성능 향상 대역폭 활용도 개선 프래그먼테이션이 필요한 이유 네트워크마다 처리할 수 있는 최대 패킷 크기가 다르다.
이를 MTU(Maximum Transmission Unit)라고 한다.
예를 들어:
이더넷의 MTU: 1500 바이트 PPP의 MTU: 576 바이트 Wi-Fi의 MTU: 2304 바이트
만약 4000 바이트 크기의 데이터를 MTU가 1500 바이트인 이더넷 네트워크로 전송하려면, 이 데이터는 반드시 더 작은 조각들로 나뉘어야 한다. Fragmentation의 작동 방식 프래그먼트 생성 원본 패킷은 여러 개의 작은 프래그먼트로 나뉜다.
각 프래그먼트는:
...</p></div><footer class=entry-footer><span title='2024-10-16 02:40:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프래그먼테이션 (Fragmentation)" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/network-models/osi-model/layer-overview/network-layer/fragmentation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Types of Sorting Algorithm</h2></header><div class=entry-content><p>Sorting Algorithms 비교 정렬(Sorting) 알고리즘은 데이터를 특정 순서(오름차순/내림차순)로 정렬하는 알고리즘이다.
정렬 알고리즘은 시간 복잡도, 공간 복잡도, 안정성, 실행 속도 등의 성능 차이로 인해 다양한 방식이 존재한다.
각 정렬 알고리즘은 고유한 특성과 작동 방식을 가지고 있습니다. 여기서는 6가지 주요 정렬 알고리즘을 공통된 예시 배열 [8, 5, 2, 6, 9, 3, 1, 4, 7]을 사용하여 비교 분석하겠습니다.
정렬 알고리즘 비교 각 정렬 알고리즘은 고유한 특성과 장단점을 가지고 있으며, 적용 상황에 따라 최적의 선택이 달라진다:
...</p></div><footer class=entry-footer><span title='2024-10-15 04:16:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Types of Sorting Algorithm" href=https://buenhyden.github.io/posts/data-structures--algorithms/comparison-guides/algorithm-comparisons/sorting-algorithm-comparison/comparison--of-sorting-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>메모이제이션 (Memoization)</h2></header><div class=entry-content><p>메모이제이션 (Memoization) 메모이제이션은 “기억하다"라는 뜻의 라틴어 ‘memorandum’에서 유래했다.
이 기법은 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장해두고 필요할 때 다시 계산하지 않고 저장된 값을 사용하는 방식이다.
실생활에 비유해보면, 책을 보다가 모르는 단어를 사전에서 찾았을 때
메모이제이션 미사용: 같은 단어가 나올 때마다 매번 사전을 찾음 메모이제이션 사용: 찾은 단어의 의미를 메모장에 적어두고, 다시 나오면 메모장을 참고
로 이해 가능하다. 메모이제이션의 작동 원리 함수가 호출될 때 입력값을 확인한다. 해당 입력값에 대한 결과가 이미 저장되어 있다면, 저장된 결과를 즉시 반환한다. 저장된 결과가 없다면, 함수를 실행하고 그 결과를 저장한 후 반환한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 def memoized_function(n, memo={}): # 1. 이미 계산된 값인지 확인 if n in memo: return memo[n] # 2. 새로운 값 계산 result = ... # 계산 로직 # 3. 계산된 값을 저장 memo[n] = result # 4. 결과 반환 return result 메모이제이션의 장점 실행 속도 향상: 중복 계산을 피함으로써 프로그램의 실행 속도를 크게 높일 수 있다. 자원 효율성: 계산 비용이 높은 작업의 결과를 재사용함으로써 컴퓨터 자원을 효율적으로 사용할 수 있다. 메모이제이션의 사용 예시 가장 대표적인 예시로 피보나치 수열 계산을 들 수 있다.
일반적인 재귀 함수로 구현하면 중복 계산이 많이 발생하지만, 메모이제이션을 적용하면 성능을 크게 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-13 11:22:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 메모이제이션 (Memoization)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/memoization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>테이블레이션(Tabulation)</h2></header><div class=entry-content><p>테이블레이션(Tabulation) Tabulation은 프로그래밍에서 동적 프로그래밍(Dynamic Programming)의 한 기법으로, 복잡한 문제를 해결하기 위해 사용되는 방법이다.
Tabulation은 ‘표를 만든다’는 의미로, 문제의 해결 과정을 표 형태로 정리하는 기법이다. 이 방법은 작은 부분 문제(subproblem)부터 시작하여 점진적으로 더 큰 문제를 해결해 나가는 상향식(bottom-up) 접근 방식을 사용합니다.
Tabulation의 작동 원리 문제 정의: 해결하고자 하는 문제와 그 부분 문제들을 명확히 정의한다. 표 초기화: 부분 문제의 결과를 저장할 표(보통 배열이나 리스트)를 만든다. 기본 케이스 설정: 가장 작은 부분 문제에 대한 해답을 표에 채운다. 반복적 계산: 작은 부분 문제부터 시작하여 큰 문제로 나아가며 표를 채운다. 최종 결과 도출: 표의 마지막 항목이 전체 문제의 해답이 된다. Tabulation의 예시: 피보나치 수열 피보나치 수열을 계산하는 예시
...</p></div><footer class=entry-footer><span title='2024-10-13 11:21:00 +0000 UTC'>October 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 테이블레이션(Tabulation)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/basic-algorithmic-paradigms/dynamic-programming/dp-principles/memoization-vs-tabulation/tabulation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cuckoo Hash Table</h2></header><div class=entry-content><p>Cuckoo Hash Table Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.
특징 다중 해시 함수: 일반적으로 두 개 이상의 해시 함수를 사용한다. 결정적 성능: 최악의 경우에도 일정한 시간 복잡도를 보장한다. 동적 재배치: 충돌 발생 시 기존 항목을 다른 위치로 이동시킨다. 장점 빠른 검색 속도: O(1) 시간 복잡도로 검색 연산을 수행한다. 공간 효율성: 높은 로드 팩터를 유지할 수 있다. 삭제 연산 지원: Bloom Filter와 달리 효율적인 삭제가 가능하다. 단점 삽입 연산의 복잡성: 최악의 경우 무한 루프에 빠질 수 있어 재해싱이 필요할 수 있다. 구현의 복잡성: 일반 해시 테이블에 비해 구현이 더 복잡하다. 응용 데이터베이스 인덱싱 네트워크 라우팅 테이블 캐시 시스템 스팸 필터링 동작 원리 삽입:
...</p></div><footer class=entry-footer><span title='2024-10-09 12:57:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cuckoo Hash Table" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/hash-based-structures/advanced-hashing/cuckoo-hashing/cuckoo-hash-table/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/34/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/36/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>