<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Key Authentication</h2></header><div class=entry-content><p>API Key Authentication API Key Authentication은 마이크로서비스 아키텍처(MSA)에서 보안을 위해 사용되는 중요한 인증 방식이다.
API Key Authentication은 클라이언트가 API에 접근할 때 고유한 식별자(API 키)를 사용하여 인증하는 방식이다. 이 키는 서버에서 생성하여 클라이언트에게 제공되며, 클라이언트는 API 요청 시 이 키를 포함시켜 자신의 신원을 증명한다.
API Key Authentication은 구현이 간단하고 사용하기 쉽다는 장점이 있지만, 보안 측면에서는 제한적이다. 따라서 중요한 데이터나 높은 보안이 요구되는 서비스에는 OAuth2나 JWT와 같은 더 강력한 인증 방식을 고려해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Key Authentication" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/security/api-key-authentication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CORS</h2></header><div class=entry-content><p>CORS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 CORS(Cross-Origin Resource Sharing)는 매우 중요한 역할을 한다.
CORS는 웹 브라우저에서 구현된 보안 메커니즘으로, 다른 출처(도메인, 프로토콜, 포트)의 리소스에 접근할 수 있도록 허용하는 체계이다. 이는 동일 출처 정책(Same-Origin Policy)의 제한을 안전하게 우회할 수 있게 해준다.
CORS는 MSA 환경에서 안전하고 유연한 리소스 공유를 가능하게 하는 핵심 메커니즘으로 올바르게 구현된 CORS는 마이크로서비스 간의 안전한 통신을 보장하며, 전체 시스템의 보안을 강화한다.
CORS의 작동 원리 브라우저가 다른 출처로 HTTP 요청을 보낼 때 Origin 헤더를 추가한다. 서버는 Access-Control-Allow-Origin 헤더로 응답하여 해당 출처의 접근을 허용할지 결정한다. 브라우저는 이 헤더를 확인하여 요청을 허용하거나 차단한다. Origin의 정의
Origin은 다음 세 가지 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CORS" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/security/cors/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mutual TLS</h2></header><div class=entry-content><p>Mutual TLS 마이크로서비스 아키텍처(MSA) 패턴의 보안 측면에서 Mutual TLS(mTLS)는 매우 중요한 역할을 한다.
mTLS는 마이크로서비스 아키텍처에서 보안을 강화하는 핵심 기술로, 서비스 간 통신의 신뢰성과 안전성을 크게 향상시킨다. 적절히 구현된 mTLS는 MSA 환경에서 강력한 보안 계층을 제공하여 전체 시스템의 안정성을 높이는 데 기여한다.
Mutual TLS는 상호 TLS 또는 양방향 TLS라고도 불린다. 이는 클라이언트와 서버 간의 통신에서 양쪽 모두가 서로의 신원을 확인하는 인증 방식이다.
https://www.cloudflare.com/ko-kr/learning/access-management/what-is-mutual-tls/
일반 TLS와의 차이점 일반 TLS: 서버만 인증서를 제공하고 클라이언트가 서버의 신원을 확인한다. mTLS: 서버와 클라이언트 모두 인증서를 제공하고 서로의 신원을 확인한다. mTLS의 작동 원리 mTLS는 다음과 같은 단계로 작동한다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutual TLS" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/security/mutual-tls/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OAuth2/OIDC (OpenID Connect)</h2></header><div class=entry-content><p>OAuth2/OIDC (OpenID Connect) MSA(Microservice Architecture) 패턴의 보안 측면에서 OAuth2와 OIDC(OpenID Connect)는 매우 중요한 역할을 한다. 이 두 프로토콜은 분산 시스템에서의 인증과 권한 부여를 효과적으로 처리할 수 있게 해준다.
OAuth 2.0과 OIDC를 적절히 활용하면 MSA 환경에서 안전하고 효율적인 인증 및 권한 부여 시스템을 구축할 수 있다. 이는 마이크로서비스 간의 안전한 통신과 사용자 데이터 보호에 큰 도움이 된다.
OAuth 2.0 OAuth 2.0은 권한 부여를 위한 업계 표준 프로토콜이다.
주요 특징은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth2/OIDC (OpenID Connect)" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/security/oauth2-oidc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rate Limiting</h2></header><div class=entry-content><p>Rate Limiting Rate Limiting은 MSA(Microservices Architecture) 환경에서 시스템 보안과 안정성을 유지하기 위한 핵심 기술로, 과도한 트래픽으로 인한 서비스 장애 방지와 악성 공격 차단을 목표로 한다.
클라이언트/서비스 간 요청 처리량을 제어하는 메커니즘으로, 특히 API 기반 마이크로서비스 통신에서 중요하다.
Rate Limiting은 단순 트래픽 제어를 넘어 마이크로서비스 생태계의 안전벨트 역할을 수행한다.
2025년 현재, 주요 클라우드 제공업체들은 AI 기반 예측 차단 기능을 표준으로 제공하며, 이는 시스템 보안 설계 시 필수 요소로 자리잡았다. 효과적 구현을 위해서는 서비스 특성에 맞는 알고리즘 선택과 지속적 모니터링 체계 수립이 관건이다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rate Limiting" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/performance-and-rate-limiting/rate-limiting/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Secret Management</h2></header><div class=entry-content><p>Secret Management Secret Management는 MSA(Microservices Architecture) 환경에서 민감한 자격 증명(API 키, 데이터베이스 비밀번호, 토큰 등)을 안전하게 저장, 관리, 배포하는 핵심 보안 메커니즘이다.
분산 시스템의 특성상 각 서비스가 독립적으로 동작하기 때문에 중앙 집중식 보안 관리가 필수적이다.
Secret Management는 MSA 보안의 핵심 인프라로, 올바른 도구 선택과 체계적인 정책 수립이 필수적이다.
2025년 현재 AI 기반 이상 탐지 기능이 도입되며, 지속적인 모니터링과 자동화가 강화되는 추세이다.
시크릿 관리의 중요성 보안 강화: 시크릿이 노출되면 악의적인 사용자가 시스템에 무단 접근하거나 데이터를 탈취할 수 있다. 규제 준수: 산업 표준과 규제는 민감한 정보의 안전한 관리를 요구한다. 운영 효율성: 중앙에서 시크릿을 관리하면 변경 시 각 서비스나 애플리케이션을 수정할 필요 없이 일괄적으로 업데이트할 수 있다. Secret Management의 핵심 기능 암호화 저장: 모든 비밀 정보는 AES-256 또는 **KMS(Key Management Service)**를 통해 암호화되어 저장된다.
...</p></div><footer class=entry-footer><span title='2024-11-18 12:08:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Secret Management" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/security/secret-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Access Token</h2></header><div class=entry-content><p>Access Token Access Token은 마이크로서비스 아키텍처(MSA)에서 인증과 권한 부여를 위해 사용되는 보안 메커니즘이다.
Access Token은 사용자의 인증 정보를 담고 있는 암호화된 문자열이다. 이 토큰은 클라이언트가 서버의 보호된 리소스에 접근할 수 있는 권한을 증명하는 데 사용된다.
Access Token은 MSA 환경에서 효율적이고 안전한 인증 메커니즘을 제공한다.
그러나 적절한 구현과 보안 조치가 필수적이며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
Access Token의 특징 유한한 수명: 보통 짧은 유효 기간(예: 1시간)을 가진다. Stateless: 서버에 상태를 저장하지 않아 확장성이 높다. 암호화: 대개 JWT(JSON Web Token) 형식으로 구현된다. 포함 정보: 사용자 ID, 권한 범위, 만료 시간 등을 포함할 수 있다. Access Token의 동작 방식 사용자 인증: 사용자가 로그인하면 서버는 Access Token을 발급한다. 토큰 저장: 클라이언트는 받은 토큰을 안전하게 저장한다(예: 로컬 스토리지). 요청 시 사용: API 요청 시 Authorization 헤더에 토큰을 포함시킨다. 서버 검증: 서버는 토큰의 유효성을 검사하고 요청을 처리한다. Access Token의 장점 확장성: Stateless 특성으로 서버 확장이 용이하다. 보안성: 암호화된 정보로 중요 데이터를 안전하게 전송한다. 효율성: 매 요청마다 사용자 정보를 조회할 필요가 없다. Access Token의 단점 토큰 탈취 위험: XSS 공격 등으로 토큰이 탈취될 수 있다. 제한된 정보량: 토큰 크기 제한으로 포함할 수 있는 정보가 제한적이다. Access Token과 Refresh Token 보안 강화를 위해 Access Token과 함께 Refresh Token을 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-18 11:22:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Access Token" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/security/access-token/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Consumer-side contract test</h2></header><div class=entry-content><p>Consumer-side Contract Test Consumer-side contract test는 마이크로서비스 아키텍처(MSA)의 테스팅 패턴 중 하나로, 서비스 간 상호작용을 검증하는 중요한 방법이다.
Consumer-side contract test는 서비스 소비자(consumer)가 제공자(provider)와의 상호작용에 대한 기대치를 정의하고 검증하는 테스트이다. 이 테스트는 실제 제공자 서비스 대신 모의(mock) 제공자를 사용하여 수행된다.
Consumer-side contract test는 MSA 환경에서 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진한다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.
주요 특징 소비자 중심: 소비자의 요구사항과 기대치에 초점을 맞춘다. 격리된 테스트: 실제 제공자 없이 테스트를 수행할 수 있다. 빠른 피드백: 통합 문제를 조기에 발견할 수 있다. 계약 생성: 테스트 결과로 소비자와 제공자 간의 계약(contract)이 생성된다. 구현 단계 모의 제공자 설정: 소비자는 예상되는 요청과 응답을 정의한 모의 제공자를 생성한다. 테스트 작성: 소비자는 모의 제공자와의 상호작용을 테스트하는 코드를 작성한다. 테스트 실행: 작성된 테스트를 실행하여 소비자 코드가 예상대로 동작하는지 확인한다. 계약 생성: 테스트 실행 결과를 바탕으로 계약 파일(예: Pact 파일)이 생성된다. 계약 공유: 생성된 계약을 제공자와 공유한다(예: Pact Broker를 통해). 장점 빠른 개발 주기: 실제 제공자 없이 테스트할 수 있어 개발 속도가 향상된다. 명확한 기대치 설정: 소비자의 요구사항이 명확히 문서화된다. 독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다. 조기 오류 감지: 통합 문제를 초기 단계에서 발견할 수 있다. 주의사항 과도한 모의: 실제 제공자의 동작과 차이가 있을 수 있으므로 주의가 필요하다. 유지보수: 계약이 변경될 때마다 테스트를 업데이트해야 한다. 완전성 부족: 전체 시스템 동작을 검증하지는 않으므로 다른 테스트 방법과 병행해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-18 10:59:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Consumer-side contract test" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-and-quality/consumer-side-contract-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Consumer-Driven Contract Testing</h2></header><div class=entry-content><p>Consumer-Driven Contract Testing Consumer-Driven Contract Testing(CDC)은 마이크로서비스 아키텍처(MSA)의 중요한 테스팅 패턴 중 하나이다.
이 패턴은 서비스 소비자(consumer)와 제공자(provider) 간의 상호작용을 검증하는 방법이다.
CDC는 소비자의 기대치에 따라 제공자의 호환성을 보장하는 계약 테스트 유형이다. 소비자가 제공자에 대한 기대사항을 정의하고, 이를 계약으로 생성하여 제공자와 공유한다.
CDC는 서비스 간 상호작용을 효과적으로 검증하고, 개발 팀 간의 명확한 커뮤니케이션을 촉진하는 강력한 테스팅 방법이다. 이를 통해 개발자들은 더 안정적이고 유연한 마이크로서비스를 구축할 수 있다.
주요 특징 소비자 중심: 소비자가 테스트의 주도권을 가진다. 실제 시나리오 기반: 실제 소비자들이 사용하는 시나리오로 서비스를 테스트한다. 격리된 테스트: 전체 시스템을 구동하지 않고 개별 컴포넌트 간 상호작용을 테스트한다. 구현 단계 소비자 테스트 작성: 소비자는 제공자 목(mock)을 사용하여 통합 테스트를 작성한다. 계약 생성: 테스트 실행 결과로 계약 파일(예: Pact)이 생성된다. 계약 공유: 생성된 계약을 중앙 저장소(Contract Broker)에 저장한다. 제공자 검증: 제공자는 계약을 가져와 자신의 구현과 비교하여 검증한다. 장점 빠른 피드백: 통합 문제를 조기에 발견할 수 있다. 독립적인 개발: 소비자와 제공자 팀이 독립적으로 작업할 수 있다. 불필요한 기능 방지: 실제 사용되는 부분만 테스트되어 효율적이다. 주의사항 계약은 정적 문서가 아닌 실행 가능한 테스트 케이스 모음. 계약은 모든 가능한 상태를 설명하는 것이 아니라 구체적인 요청/응답 쌍을 정의. 도구 Pact: CDC 테스팅을 위한 대표적인 도구. Testsigma: CDC 테스팅을 지원하는 또 다른 도구. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-18 03:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Consumer-Driven Contract Testing" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-and-quality/consumer-driven-contract-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service Component Test</h2></header><div class=entry-content><p>Service Component Test Service Component Test Pattern은 마이크로서비스 아키텍처(MSA)에서 개별 서비스 컴포넌트를 테스트하기 위한 중요한 패턴이다.
Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 격리된 환경에서 테스트하는 방법이다.
이 패턴의 목적은 각 서비스가 독립적으로 올바르게 작동하는지 확인하는 것이다.
Service Component Test Pattern은 마이크로서비스의 개별 컴포넌트를 효과적으로 테스트할 수 있게 해주는 중요한 패턴이다. 이를 통해 개발자는 자신이 담당하는 서비스의 품질을 높이고, 전체 시스템의 안정성을 향상시킬 수 있다.
주요 특징 격리성: 각 서비스 컴포넌트를 다른 서비스나 외부 의존성으로부터 격리하여 테스트한다. 경량성: 전체 시스템을 구동하지 않고 개별 서비스만을 테스트하므로 빠르고 효율적이다. 집중성: 특정 서비스의 비즈니스 로직과 기능에 집중하여 테스트한다. 반복 가능성: 테스트를 쉽게 반복할 수 있어 지속적 통합(CI) 환경에 적합하다. 구현 방법 테스트 환경 설정:
...</p></div><footer class=entry-footer><span title='2024-11-18 03:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service Component Test" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/test-and-quality/service-component-test/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/34/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/36/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>