<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.7"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Back Pressure</h2></header><div class=entry-content><p>Back Pressure 1. 주제의 분류 적합성 “Back Pressure(배압)” 는 시스템 설계 (System Design) 에서 비동기 (Asynchronism) 및 흐름 제어 (Flow Control) 의 핵심 개념으로, “Computer Science and Engineering > System Design > Fundamentals > Asynchronism” 분류가 매우 적절합니다. 실제로 네트워크, 분산 시스템, 리액티브 프로그래밍 등 다양한 IT 인프라와 소프트웨어 아키텍처에서 필수적으로 다루는 기본 원리입니다 [1][2][3][15].
1. 주제 분류 검토 현재 분류: “Computer Science and Engineering” > “System Design” > “Fundamentals” > “Asynchronism”
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Back Pressure" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/asynchronous-processing/asynchronism/back-pressure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bulkhead</h2></header><div class=entry-content><p>Bulkhead Bulkhead 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 복원력과 장애 격리를 향상시키기 위해 사용되는 디자인 패턴이다.
Bulkhead 패턴은 선박의 격벽(bulkhead)에서 이름을 따왔다.
선박에서 격벽은 선체를 여러 구획으로 나누어 한 구획에 물이 차더라도 전체 선박이 침몰하지 않도록 하는 역할을 한다. 마찬가지로, 소프트웨어 시스템에서 Bulkhead 패턴은 시스템의 각 부분을 격리하여 한 부분의 실패가 전체 시스템으로 확산되는 것을 방지한다.
이 패턴을 효과적으로 사용하려면 시스템의 특성과 요구사항을 잘 이해하고, 적절한 격리 수준을 결정하는 것이 중요하다. Bulkhead 패턴을 통해 마이크로서비스 아키텍처의 안정성과 복원력을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bulkhead" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/bulkhead/bulkhead/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache-Aside</h2></header><div class=entry-content><p>Cache-Aside Cache-aside 패턴은 마이크로서비스 아키텍처(MSA)에서 시스템의 신뢰성(Reliability)을 향상시키기 위해 사용되는 중요한 캐싱 전략이다.
Cache-aside 패턴은 애플리케이션이 데이터를 읽을 때 먼저 캐시를 확인하고, 캐시에 데이터가 없을 경우 데이터베이스에서 데이터를 가져와 캐시에 저장하는 방식이다.
이 패턴은 “Lazy Loading” 또는 “Look Aside” 패턴으로도 알려져 있다.
Cache-aside 패턴은 MSA 환경에서 시스템의 성능과 신뢰성을 향상시키는 효과적인 방법이다. 하지만 적절한 구현과 관리가 필요하며, 시스템의 요구사항에 맞게 신중하게 설계해야 한다.
https://learn.microsoft.com/ko-kr/azure/architecture/patterns/cache-aside
동작 방식 애플리케이션이 데이터를 요청한다. 캐시를 먼저 확인한다. 캐시에 데이터가 있으면(캐시 히트) 즉시 반환한다. 캐시에 데이터가 없으면(캐시 미스) 데이터베이스에서 데이터를 조회한다. 데이터베이스에서 가져온 데이터를 캐시에 저장한다. 데이터를 애플리케이션에 반환한다. 구현 시 고려사항 캐시 일관성: 데이터베이스의 데이터가 변경될 때 캐시를 업데이트하거나 무효화해야 한다. TTL(Time To Live) 설정: 캐시된 데이터의 유효 기간을 설정하여 오래된 데이터 문제를 방지한다. 캐시 크기 관리: 메모리 사용량을 고려하여 적절한 캐시 크기를 설정해야 한다. 동시성 제어: 여러 요청이 동시에 같은 데이터를 요청할 때의 처리 방법을 고려해야 한다. 장점 성능 향상: 자주 접근하는 데이터를 빠르게 제공할 수 있다. 데이터베이스 부하 감소: 캐시를 통해 데이터베이스 쿼리 수를 줄일 수 있다. 유연성: 캐시와 데이터베이스를 독립적으로 확장할 수 있다. 장애 대응: 캐시 서버에 문제가 생겨도 데이터베이스를 통해 서비스를 계속할 수 있다. 단점 초기 지연: 캐시 미스 시 데이터베이스 조회로 인한 지연이 발생할 수 있다. 데이터 일관성 관리: 캐시와 데이터베이스 간의 일관성을 유지하는 것이 복잡할 수 있다. 추가적인 복잡성: 캐시 관리 로직이 애플리케이션에 추가되어 복잡성이 증가할 수 있다. 사용 예시 동시성 처리와 오류 복구를 포함한 버전
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache-Aside" href=https://buenhyden.github.io/posts/system-and-software-architecture/implementation/caching/cache-strategy/cache-aside/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Fail Fast</h2></header><div class=entry-content><p>Fail Fast Fail Fast는 MSA의 신뢰성을 높이는 중요한 패턴이다.
잠재적인 문제를 조기에 발견하고 빠르게 대응함으로써 전체 시스템의 안정성과 신뢰성을 향상시킬 수 있다.
Fail Fast는 시스템에서 문제가 발생했을 때 즉시 실패를 보고하고 정상 작동을 중지하는 설계 원칙이다.
이는 잠재적인 오류를 조기에 감지하고 빠르게 대응하여 시스템의 안정성을 높이는 데 목적이 있다.
이 패턴을 효과적으로 적용하기 위해서는 철저한 모니터링과 로깅, 적절한 알림 시스템, 그리고 자동화된 복구 메커니즘이 함께 구현되어야 한다. 또한 각 서비스의 특성에 맞는 임계값과 정책을 설정하고, 지속적으로 이를 개선해 나가는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-17 12:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Fail Fast" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/performance-and-rate-limiting/fail-fast/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Anti-Corruption Layer</h2></header><div class=entry-content><p>Anti-Corruption Layer Anti-Corruption Layer (ACL) 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 서로 다른 도메인 모델이나 통신 프로토콜을 가진 시스템 간의 통합을 위해 사용된다.
ACL은 서로 다른 시스템 간의 통신을 위한 번역 계층 역할을 한다.
주요 목적은 다음과 같다:
시스템 격리: 외부 시스템의 복잡성으로부터 내부 시스템을 보호한다. 도메인 모델 보존: 각 시스템의 고유한 도메인 모델을 유지한다. 데이터 변환: 서로 다른 데이터 모델 간의 변환을 담당한다. ACL 패턴을 효과적으로 사용하려면 시스템 간의 경계를 명확히 정의하고, 변환 로직을 신중하게 설계해야 한다.
또한, 시스템 변경에 따른 ACL의 업데이트와 유지보수 계획을 수립하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-17 10:07:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Anti-Corruption Layer" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/other/anti-corruption-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circuit Breaker</h2></header><div class=entry-content><p>Circuit Breaker 서킷 브레이커 패턴(Circuit Breaker Pattern)은 마이크로서비스 아키텍처에서 시스템의 안정성과 복원력을 향상시키기 위해 사용되는 디자인 패턴이다.
이 패턴의 주요 목적은 서비스 간 장애 전파를 방지하고, 시스템의 전반적인 안정성을 유지하는 것이다.
서킷 브레이커 패턴은 전기 회로의 차단기에서 착안한 개념이다.
전기 회로에서 과부하가 발생하면 차단기가 작동하여 전류를 차단하듯이, 소프트웨어 시스템에서도 특정 서비스에 문제가 발생했을 때 해당 서비스로의 호출을 차단한다.
서킷 브레이커 패턴을 효과적으로 사용하면 마이크로서비스 아키텍처에서 장애의 전파를 방지하고, 시스템의 전반적인 안정성과 복원력을 크게 향상시킬 수 있다. 이 패턴은 특히 외부 서비스에 의존성이 높은 시스템에서 매우 유용하며, 적절히 구현하면 사용자 경험을 크게 개선할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-17 10:05:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circuit Breaker" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/circuit-breaker/circuit-breaker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Timeout Pattern</h2></header><div class=entry-content><p>Timeout Pattern Timeout Pattern은 마이크로서비스 간 통신에서 응답 지연이나 실패를 관리하기 위한 전략이다.
이 패턴은 서비스가 다른 서비스로부터의 응답을 무한정 기다리지 않도록 하여 시스템의 안정성과 응답성을 향상시킨다.
Timeout Pattern은 MSA 환경에서 서비스 간 통신의 신뢰성을 높이고 시스템의 전반적인 안정성을 향상시키는 중요한 전략이다. 적절히 구현된 Timeout Pattern은 마이크로서비스 아키텍처의 장점을 극대화하고 잠재적인 문제를 최소화하는 데 큰 도움이 된다.
타임아웃 패턴의 필요성 MSA 환경에서는 여러 서비스가 네트워크를 통해 상호 작용하므로, 다음과 같은 이유로 타임아웃 패턴이 필요하다:
...</p></div><footer class=entry-footer><span title='2024-11-17 02:21:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Timeout Pattern" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/timeout/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Retry Pattern</h2></header><div class=entry-content><p>Retry Pattern Retry Pattern은 일시적인 오류가 발생했을 때 동일한 작업을 자동으로 재시도하여 시스템의 안정성과 신뢰성을 향상시키는 패턴이다.
특히 네트워크 문제나 일시적인 서비스 장애와 같은 상황에서 유용하다.
Retry Pattern은 MSA 환경에서 시스템의 신뢰성을 높이는 중요한 패턴이다.
일시적인 오류에 대해 자동으로 대응함으로써 서비스의 안정성을 향상시킬 수 있다. 그러나 적절한 구현과 신중한 사용이 필요하며, 다른 패턴들(예: Circuit Breaker)과 함께 사용하여 더 강력한 신뢰성을 확보할 수 있다.
Retry Pattern의 주요 특징 재시도 횟수: 최대 재시도 횟수를 지정하여 무한 루프를 방지한다. 재시도 간격: 재시도 사이의 대기 시간을 설정하여 시스템에 과부하를 주지 않도록 한다. 백오프 전략: 재시도 간격을 점진적으로 늘리는 전략으로, 시스템의 회복 시간을 고려한다. 조건부 재시도: 특정 오류 코드나 예외 유형에 따라 재시도 여부를 결정한다. Retry Pattern 구현 방법 Spring Retry 사용: Spring 기반 애플리케이션에서는 @Retryable 어노테이션을 사용하여 간단히 구현할 수 있다. Resilience4j 사용: 더 복잡한 재시도 로직을 구현할 때 사용할 수 있는 라이브러리이다. 커스텀 구현: 특정 요구사항에 맞춰 직접 재시도 로직을 구현할 수 있다. 재시도 패턴 구현 시 고려사항 재시도 패턴을 효과적으로 구현하기 위해 다음과 같은 요소를 고려해야 한다:
...</p></div><footer class=entry-footer><span title='2024-11-17 02:18:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Retry Pattern" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/reliability/retry/retry/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Strangler Application</h2></header><div class=entry-content><p>Strangler Application Strangler Application 패턴은 마이크로서비스 아키텍처로의 전환을 위한 중요한 리팩토링 전략이다.
Strangler Application 패턴은 기존의 모놀리식 애플리케이션을 점진적으로 새로운 마이크로서비스 기반 시스템으로 대체하는 방법이다.
이 패턴의 이름은 호주의 열대우림에서 볼 수 있는 스트랭글러 무화과나무에서 유래했다. 이 나무는 숙주 나무를 감싸고 자라다가 결국 숙주를 대체하는데, 이와 유사하게 새로운 서비스가 기존 시스템을 점진적으로 대체한다.
Strangler Application 패턴은 레거시 시스템을 현대화하는 효과적인 방법으로, 리스크를 관리하면서 점진적으로 마이크로서비스 아키텍처로 전환할 수 있게 해준다. 이 패턴을 통해 기업은 기존 시스템의 가치를 유지하면서 새로운 기술과 아키텍처의 이점을 활용할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-17 01:20:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Strangler Application" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/other/strangler-application/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API Composition</h2></header><div class=entry-content><p>API Composition API Composition 패턴은 마이크로서비스 아키텍처(MSA)에서 디자인 패턴 중 하나이다.
이 패턴은 여러 마이크로서비스의 데이터를 조합하여 클라이언트에게 단일 응답으로 제공하는 방식이다.
API Composition은 여러 마이크로서비스의 API 응답을 집계하여 단일 API 엔드포인트로 제공하는 패턴이다.
이를 통해 클라이언트는 복잡한 데이터 요구사항을 단일 요청으로 처리할 수 있다.
API Composition 패턴은 마이크로서비스 아키텍처에서 데이터 접근을 간소화하고 클라이언트 경험을 개선하는 강력한 도구이나 구현 시 성능과 복잡성을 고려해야 하며, 시스템의 요구사항에 따라 적절히 적용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-16 10:52:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to API Composition" href=https://buenhyden.github.io/posts/system-and-software-architecture/architecture/architectue-patterns/data-management/api-composition/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/34/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/36/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>