<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데커 알고리즘 (Dekker's Algorithm)</h2></header><div class=entry-content><p>데커 알고리즘 (Dekker’s Algorithm) 데커 알고리즘(Dekker’s Algorithm)은 두 프로세스 간 **상호 배제(Mutual Exclusion)**를 보장하기 위해 1965년 네덜란드의 수학자 Theodorus Dekker가 개발한 최초의 소프트웨어 상호 배제(mutual exclusion) 알고리즘이다.
이 알고리즘은 두 개의 프로세스가 공유 자원에 동시에 접근하는 것을 방지하여 경쟁 상태(race condition)를 해결하는 방법을 제시한다.
공유 자원에 대한 안전한 접근을 위해 **플래그(flag)**와 턴(turn) 변수를 활용하며, 하드웨어적 명령어 없이 소프트웨어만으로 구현 가능하다.
데커 알고리즘은 상호 배제 문제 해결의 역사적 중요성을 가지지만, 현대 시스템에서는 **세마포어(Semaphore)**나 **뮤텍스(Mutex)**와 같은 더 효율적인 동기화 기법이 주로 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;445 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데커 알고리즘 (Dekker's Algorithm)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/dekkers-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)</h2></header><div class=entry-content><p>램포트의 빵집 알고리즘 (Lamport’s Bakery Algorithm) 램포트의 빵집 알고리즘(Lamport’s Bakery Algorithm)은 N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.
램포트의 빵집 알고리즘은 병행 프로그래밍의 이론적 토대를 제공했지만, 현대 시스템에서는 주로 하드웨어 지원 동기화 기법이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.
핵심 원리 번호표 시스템 각 프로세스는 임계 영역 진입 전 고유한 번호표를 받는다. 번호표는 단조 증가(monotonically increasing) 방식으로 발급되며, 동시 접근 시 프로세스 ID로 우선순위 결정한다. 단조 증가(monotonically increasing)란 함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질을 의미한다. 즉, 감소하는 구간 없이 유지되거나 증가하는 경우를 말한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;507 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/lamports-bakery-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>피터슨 알고리즘 (Peterson's Algorithm)</h2></header><div class=entry-content><p>피터슨 알고리즘 (Peterson’s Algorithm) 피터슨 알고리즘(Peterson’s Algorithm)은 두 프로세스의 **상호 배제(Mutual Exclusion)**를 보장하기 위한 소프트웨어 기반 동기화 알고리즘이다.
1981년 개리 피터슨(Gary L. Peterson)이 제안한 이 알고리즘은 간결성과 이론적 엄밀성으로 운영체제 및 병행 프로그래밍 분야에서 널리 연구된다.
피터슨 알고리즘은 이론적 완결성을 인정받지만, 현대 시스템에서는 주로 하드웨어 기반 동기화 기법(예: TAS, CAS)이 사용됩니다. 그러나 병행 프로그래밍의 근본 원리를 이해하는 데 여전히 핵심적인 역할을 한다.
핵심 구성 요소 플래그 배열(flag) 각 프로세스의 임계 영역 진입 의사 표시 (flag, flag 초기값 False) 턴 변수(turn) 임계 영역 진입 순서 결정 (0 또는 1 값을 가짐) 동작 원리 진입 의사 표시:
프로세스 i가 임계 영역 진입 전 flag[i] = True 설정.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;436 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 피터슨 알고리즘 (Peterson's Algorithm)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/process-synchronization/petersons-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>라이브락 (Livelock)</h2></header><div class=entry-content><p>라이브락 (Livelock) 멀티스레딩 환경에서 발생할 수 있는 문제 상황으로, 프로세스나 스레드가 계속 실행 중이지만 실제로는 유용한 작업을 수행하지 못하는 상태
라이브락의 특징: 진행 중 상태: 프로세스나 스레드가 ‘실행 중’ 상태를 유지한다. 무의미한 작업: 실제로는 어떠한 유용한 작업도 수행하지 못한다. 반복적 상태 변경: 특정 조건을 만족시키기 위해 상태를 계속 변경하지만 원하는 결과를 달성하지 못한다. 라이브락과 데드락의 차이: 데드락: 프로세스들이 서로의 자원을 기다리며 완전히 멈춘 상태 라이브락: 프로세스들이 계속 실행되지만 실제로는 진전이 없는 상태 라이브락의 예시: 복도에서 마주친 두 사람: 서로 지나가려고 같은 방향으로 계속 이동하지만 결국 지나가지 못하는 상황 프로세스 간 자원 경쟁: 프로세스 A가 자원 Y를 보유하고 X를 필요로 함 프로세스 B가 자원 X를 보유하고 Y를 필요로 함 두 프로세스가 서로의 자원을 기다리며 계속 상태를 변경하지만 진전이 없음 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import threading import time class Philosopher: def __init__(self, name, left_fork, right_fork): self.name = name self.left_fork = left_fork self.right_fork = right_fork def try_eat(self): while True: # 계속해서 시도 if self.left_fork.acquire(timeout=1): # 왼쪽 포크 잡기 시도 print(f"{self.name}이(가) 왼쪽 포크를 집었습니다") if self.right_fork.acquire(timeout=1): # 오른쪽 포크 잡기 시도 print(f"{self.name}이(가) 식사를 시작합니다") time.sleep(1) # 식사하는 시간 self.right_fork.release() self.left_fork.release() print(f"{self.name}이(가) 포크를 내려놓고 다시 시도합니다") time.sleep(0.1) # 다른 철학자에게 기회를 주기 위한 대기 else: print(f"{self.name}이(가) 포크를 얻지 못해 다시 시도합니다") time.sleep(0.1) # 재시도 전 대기 # 테스트 코드 fork1 = threading.Lock() fork2 = threading.Lock() philosopher1 = Philosopher("철학자1", fork1, fork2) philosopher2 = Philosopher("철학자2", fork2, fork1) # 두 철학자가 동시에 식사하려 시도 t1 = threading.Thread(target=philosopher1.try_eat) t2 = threading.Thread(target=philosopher2.try_eat) t1.start() t2.start() 이 코드에서 두 철학자는 모두 활발히 행동하고 있지만(포크를 집었다 놨다 하면서), 실제로 식사는 하지 못하는 라이브락 상황이 발생할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-03 09:17:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;550 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 라이브락 (Livelock)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/livelock/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Starvation</h2></header><div class=entry-content><p>기아 상태 (Starvation) 운영 체제 및 동시성 프로그래밍에서 중요한 문제로, 특정 프로세스가 필요한 자원을 지속적으로 얻지 못해 실행되지 못하는 상황.
자원 관리 문제로, 낮은 우선순위 프로세스가 높은 우선순위 프로세스에 의해 자원이 계속 점유되어 무기한 대기하는 상황으로 주로 우선순위 기반 스케줄링에서 발생하며, 시스템 성능과 공정성에 부정적인 영향을 미친다.
Source: https://www.javatpoint.com/what-is-starvation-in-operating-system
발생 조건 기아 상태가 발생하기 위한 주요 조건은 다음과 같다:
우선순위 기반 스케줄링: 높은 우선순위 프로세스가 계속 실행되면서 낮은 우선순위 프로세스가 실행되지 못함. 자원 부족: 시스템 자원이 제한적일 때 특정 프로세스가 지속적으로 자원을 얻지 못함. 비공정한 스케줄링 알고리즘: 공정성을 고려하지 않는 알고리즘이 낮은 우선순위 프로세스를 무시함. 임계 구역 점유: 특정 프로세스가 임계 구역을 오래 점유하여 다른 프로세스의 접근을 차단. 해결책 및 방지책 기아 상태를 해결하거나 방지하기 위한 방법은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-03 07:52:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;818 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Starvation" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/critical-section/starvation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>상호 배제 (Mutual Exclusion)</h2></header><div class=entry-content><p>상호 배제 (Mutual Exclusion) 여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 방지하는 동기화 메커니즘.
한 번에 하나의 프로세스나 스레드만 임계 영역(critical section)에 진입할 수 있도록 보장하는 기법이다.
필요한 이유:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 상호 배제가 없는 경우의 문제점 class BankAccount: def __init__(self): self.balance = 1000 def withdraw(self, amount): # 다음 세 줄의 작업이 원자적이지 않음 current_balance = self.balance # 잔액 읽기 current_balance = current_balance - amount # 계산 self.balance = current_balance # 결과 저장 # 두 스레드가 동시에 실행되면 문제가 발생할 수 있음 account = BankAccount() # 스레드 1: withdraw(500) # 스레드 2: withdraw(500) # 예상 잔액: 0, 실제 잔액: 500 (잘못된 결과) 목적 데이터 무결성 유지: 여러 프로세스가 동시에 공유 데이터를 수정하는 것을 방지한다. 경쟁 조건(Race Condition) 예방: 프로세스 실행 순서에 따른 결과 불일치를 막는다. 교착 상태(Deadlock)와 기아 상태(Starvation) 방지: 자원 할당의 효율성을 높인다. 구현 방법 잠금(Lock)
가장 기본적인 동기화 메커니즘으로, 한 번에 하나의 스레드만 임계 영역에 접근할 수 있게 한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 07:50:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;373 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상호 배제 (Mutual Exclusion)" href=https://buenhyden.github.io/posts/computer-science/computer-system/operating-system/synchronization-and-concurrency-control/mutual-exclusion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>소켓(Socket)</h2></header><div class=entry-content><p>소켓(Socket) 소켓은 네트워크 상에서 수행되는 두 프로그램 간의 양방향 통신 링크의 한쪽 끝 단을 의미한다.
소켓은 프로세스가 네트워크를 통해 데이터를 송수신하기 위한 실제적인 창구 역할을 한다.
운영체제는 소켓을 통해 네트워크 통신을 위한 인터페이스를 제공한다.
소켓의 구성 요소 소켓은 다음 세 가지 요소로 구성된다:
프로토콜: 데이터 전송을 위한 표준 집합 규칙 (예: TCP/IP, UDP/IP) IP 주소: 서버 또는 클라이언트의 주소 포트 번호: 통신을 사용하는 애플리케이션을 식별하는 번호 소켓의 특징 프로토콜, IP 주소, 포트 번호로 정의된다. 서버 소켓과 클라이언트 소켓으로 구분된다. 실시간 데이터 전송에 적합하다. 소켓 통신의 장점 실시간 양방향 통신이 가능하다. 서버와 클라이언트 간 지속적인 연결을 유지할 수 있다. 소켓 통신의 단점 HTTP 통신에 비해 구현이 복잡할 수 있다. 지속적인 연결 유지로 인한 리소스 소비가 있을 수 있다. 소켓의 종류 소켓은 크게 두 가지 유형으로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-02 16:30:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;561 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 소켓(Socket)" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/processes/process-mgmt/ipc/socket/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queue</h2></header><div class=entry-content><p>메시지 큐(Message Queue) 프로세스 간 통신(IPC)의 메시지 큐(Message Queue)는 프로세스 간에 데이터를 교환하는 메커니즘이다.
메시지 큐는 커널 내에 저장된 메시지의 연결 리스트로, 고유한 식별자로 구분된다.
이는 프로세스들이 비동기적으로 통신할 수 있게 해주는 IPC 메커니즘이다.
메시지 크기 제한과 시스템 리소스 사용 등의 단점도 고려해야 한다.
적절한 사용 시나리오를 파악하고 효과적으로 활용하는 것이 중요하다.
Source: https://www.javatpoint.com/ipc-using-message-queues
메시지 큐의 특징 커널 관리: 메시지 큐는 커널에 의해 관리되어 안정성이 높고 동기화가 용이하다. FIFO 순서: 메시지는 일반적으로 선입선출(FIFO) 순서로 처리된다. 비동기 통신: 송신 프로세스와 수신 프로세스가 동시에 활성화될 필요가 없다. 메시지 구조: 각 메시지는 타입 필드, 길이, 실제 데이터로 구성된다. 프로세스 분리: 메시지 큐를 사용하면 프로세스들이 서로 직접 연결되지 않아도 된다. 메시지 큐의 주요 시스템 호출 ftok(): 고유한 키를 생성한다. msgget(): 메시지 큐를 생성하거나 기존 큐의 식별자를 반환한다. msgsnd(): 메시지를 큐에 추가한다. msgrcv(): 큐에서 메시지를 검색한다. msgctl(): 큐에 대한 다양한 작업을 수행한다. 메시지 큐 사용 방법 메시지 큐 생성:
...</p></div><footer class=entry-footer><span title='2024-10-02 12:03:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;246 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queue" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/processes/process-mgmt/ipc/message-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shared Memory</h2></header><div class=entry-content><p>공유 메모리(Shared Memory) 공유 메모리(Shared Memory)는 운영체제의 프로세스 간 통신(IPC) 기법 중 하나로, 여러 프로세스가 동시에 접근할 수 있는 메모리 영역이며, 커널에 의해 생성되고 관리되는 공통 메모리 공간이다.
이는 여러 프로세스가 동일한 물리적 메모리 영역에 접근할 수 있게 해주며, IPC 메커니즘 중에서 가장 빠른 통신 방법을 제공한다.
Source: https://www.geeksforgeeks.org/ipc-shared-memory/
작동 원리 프로세스가 커널에 공유 메모리 할당을 요청 커널이 해당 프로세스에 메모리 공간을 할당 이후 다른 프로세스들도 해당 메모리 영역에 접근 가능 공유 메모리의 생성과 관리 공유 메모리를 사용하는 일반적인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-10-02 12:03:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;354 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Memory" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/processes/process-mgmt/ipc/shared-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pipe</h2></header><div class=entry-content><p>파이프(Pipe) 파이프(Pipe)는 프로세스 간 통신(IPC)의 한 방법으로, 단방향 데이터 흐름을 제공하는 가장 오래된 IPC(프로세스 간 통신) 메커니즘 중 하나이다. 파이프는 한쪽 끝에서 데이터를 쓰고 다른 쪽 끝에서 데이터를 읽을 수 있게 해준다.
종류 익명 파이프 (Anonymous Pipe): 부모-자식 프로세스 간 통신에 사용
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os def create_anonymous_pipe(): """익명 파이프 생성 예제""" read_fd, write_fd = os.pipe() pid = os.fork() # 프로세스 생성 if pid > 0: # 부모 프로세스 os.close(read_fd) # 읽기 끝 닫기 os.write(write_fd, "Hello from parent".encode()) os.close(write_fd) else: # 자식 프로세스 os.close(write_fd) # 쓰기 끝 닫기 message = os.read(read_fd, 1024).decode() print(f"Child received: {message}") os.close(read_fd) 이름 있는 파이프 (Named Pipe 또는 FIFO): 관련 없는 프로세스 간 통신에 사용
...</p></div><footer class=entry-footer><span title='2024-10-02 12:02:00 +0000 UTC'>October 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;306 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe" href=https://buenhyden.github.io/posts/computer-science/processes-and-threads/processes/process-mgmt/ipc/pipe/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/64/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/66/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>