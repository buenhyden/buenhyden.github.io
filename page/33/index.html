<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.157.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json title=json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>체크리스트 기반 테스팅 (Checklist-based Testing)</h2></header><div class=entry-content><p>체크리스트 기반 테스팅 (Checklist-based Testing) Checklist-based Testing은 테스트 대상의 중요한 항목들을 체크리스트로 만들어 이를 기반으로 테스트를 수행하는 경험 기반 테스트 기법이다.
숙련된 테스터가 제품 검증을 위한 일련의 규칙이나 기준, 또는 참고/확인/기억해야 하는 상위수준 아이템 목록을 사용한다.
주요 특징 구조화된 접근 방식: 테스트 과정에 체계적인 구조를 제공한다. 일관성과 반복성: 모든 테스터가 동일한 단계를 따르고 동일한 항목을 확인하도록 보장한다. 중요 항목 누락 방지: 체크리스트를 통해 중요한 테스트 항목을 놓치지 않도록 한다. 경험 활용: 테스터의 경험과 지식을 체크리스트에 반영하여 활용한다. 적용 분야 Checklist-based Testing은 다양한 테스트 유형에 적용될 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-27 08:09:00 +0000 UTC'>October 27, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 체크리스트 기반 테스팅 (Checklist-based Testing)" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/test-design-techniques/experience-based-test/checklist-based-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>탐색적 테스팅(Exploratory Testing)</h2></header><div class=entry-content><p>탐색적 테스팅(Exploratory Testing) 탐색적 테스팅(Exploratory Testing)은 소프트웨어 테스팅의 한 접근 방식으로, 테스터의 창의성, 경험, 직관을 활용하여 소프트웨어를 자유롭게 탐색하며 결함을 발견하는 과정이다. 이 방법은 사전에 정의된 테스트 케이스에 의존하지 않고, 테스트 설계와 실행을 동시에 수행하는 특징이 있다.
주요 특징 테스터 중심: 테스터의 경험, 지식, 창의력을 최대한 활용한다. 유연성: 미리 정의된 테스트 케이스 없이도 즉시 테스트를 시작할 수 있다. 학습과 실행의 동시 진행: 소프트웨어를 사용하면서 동시에 새로운 테스트 시나리오를 생성한다. 발견 중심: 문서화보다는 결함 발견과 해결에 집중한다. 핵심 구성 요소 테스트 차터: 테스트의 목적과 범위를 정의하는 간단한 문서. 시간 제한(Time Boxing): 정해진 시간 동안 집중적으로 테스트를 수행한다. 테스트 노트: 테스트 중 발견한 사항과 아이디어를 기록한다. 요약 보고(Debriefing): 테스트 결과와 발견된 이슈를 팀과 공유한다. 장점 속도와 비용 효율성: 사전 준비가 적어 빠르게 테스트를 시작할 수 있다. 예상치 못한 버그 발견: 정형화된 테스트로는 찾기 어려운 버그를 발견할 수 있다. 사용성 개선: 사용자 관점에서 제품을 평가할 수 있다. 요구사항 변화에 대응: 애자일 개발 환경에 적합하다. 단점 주관성: 테스터의 개인 능력에 크게 의존한다. 테스트 범위 확인 어려움: 체계적인 계획이 없어 테스트 범위를 정확히 파악하기 어렵다. 관리와 통제의 어려움: 테스트의 양과 질을 관리하기 어려울 수 있다. 적용 사례 예를 들어, MP3 플레이어 앱을 테스트할 때 다음과 같은 탐색적 테스팅을 수행할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-27 07:23:00 +0000 UTC'>October 27, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 탐색적 테스팅(Exploratory Testing)" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/test-design-techniques/experience-based-test/exploratory-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오류 예측 검사(Error Guessing)</h2></header><div class=entry-content><p>오류 예측 검사(Error Guessing) 오류 예측 검사(Error Guessing)는 블랙박스 테스트 기법 중 하나로, 테스터의 경험, 지식, 직관을 활용하여 소프트웨어에서 발생할 가능성이 높은 오류를 예측하고 이를 기반으로 테스트 케이스를 설계하는 방법.
이 기법은 다른 테스트 기법으로는 발견하기 어려운 결함을 보완적으로 찾아내는 데 유용하다.
오류 예측 검사의 특징 경험 기반 접근:
과거의 경험, 유사한 시스템에서 발견된 오류 유형, 그리고 직관을 활용하여 잠재적 오류를 예측한다. 특정한 규칙이나 구조에 의존하지 않고 테스터의 전문성과 감각에 의존한다. 보충적 검사 기법:
...</p></div><footer class=entry-footer><span title='2024-10-27 00:13:00 +0000 UTC'>October 27, 2024</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 오류 예측 검사(Error Guessing)" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/testing--quality/test-design-techniques/experience-based-test/error-guessing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAML vs. JSON vs. XML</h2></header><div class=entry-content><p>YAML vs. JSON vs. XML 데이터 교환과 구성 파일 형식으로 YAML, JSON, XML은 현대 소프트웨어 개발에서 가장 널리 사용되는 세 가지 형식이다.
개요 및 역사 YAML (YAML Ain’t Markup Language) YAML은 2001년에 클라크 에반스(Clark Evans), 이니 넷(Ingy döt Net), 오렌 벤-코바(Oren Ben-Koki)에 의해 개발되었다. 원래는 “Yet Another Markup Language"의 약자였으나, 후에 “YAML Ain’t Markup Language"라는 재귀적 약자로 변경되었다. YAML은 인간 친화적인 구문과 읽기 쉬운 형식에 중점을 둔 데이터 직렬화 형식이다.
...</p></div><footer class=entry-footer><span title='2024-10-26 09:35:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to YAML vs. JSON vs. XML" href=https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-types--formats/exchange-formats/format-comparisons/yaml-vs-json-vs-xml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Serialization and Deserialization</h2></header><div class=entry-content><p>Serialization and Deserialization 직렬화(Serialization)와 역직렬화(Deserialization)는 객체 지향 프로그래밍, 데이터 저장, 네트워크 통신 등 다양한 분야에서 핵심적인 역할을 한다.
직렬화와 역직렬화의 개념 직렬화(Serialization)는 데이터 구조나 객체 상태를 저장하거나 전송할 수 있는 형식으로 변환하는 과정이다. 이 과정에서 객체의 상태는 바이트 스트림이나 텍스트 형식(예: JSON, XML)으로 변환된다. 직렬화는 복잡한 데이터 구조를 선형적인(linear) 형태로 “펼치는” 작업이라고 볼 수 있다.
역직렬화(Deserialization)는 직렬화의 반대 과정으로, 저장되거나 전송된 바이트 스트림이나 텍스트를 원래의 객체 구조로 다시 변환하는 작업이다. 이 과정을 통해 저장된 데이터를 애플리케이션에서 다시 사용할 수 있게 된다.
...</p></div><footer class=entry-footer><span title='2024-10-26 09:29:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;<span>7 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Serialization and Deserialization" href=https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-types--formats/serialization--processing/serialization-and-deserialization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>P2P and Hybrid VCS</h2></header><div class=entry-content><p>P2P And Hybrid VCS P2P VCS 는 Git 과 같은 분산형 버전 관리 시스템의 진화된 형태로 노드 간 직접 통신으로 센서리스 아키텍처를 구현하며, 하이브리드 VCS 는 메타데이터 관리를 중앙서버에서 처리한다. 주요 구성 요소로 DHT(분산 해시 테이블), 암호화 검증 계층, 자동 동기화 엔진이 포함된다. 도전 과제로 네트워크 지연 시간 최적화와 대규모 분산 트랜잭션 관리가 존재한다.
Radicle 과 같은 솔루션은 분산 네트워크에서 Git 기반 협업을, Perforce Helix 와 같은 시스템은 하이브리드 접근 방식을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-26 06:17:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;<span>24 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to P2P and Hybrid VCS" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/git-fundamentals/p2p-and-hybrid-vcs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터 불일치 (Data Inconsistency)</h2></header><div class=entry-content><p>데이터 불일치 (Data Inconsistency) 동일한 데이터가 데이터베이스 내의 여러 위치에서 서로 다른 형식이나 값으로 존재하는 상황
발생 조건 데이터 불일치가 발생하는 주요 조건:
동시성 작업 여러 프로세스나 스레드가 동시에 데이터를 수정할 때 트랜잭션이 적절히 관리되지 않을 때 분산 환경 네트워크 지연이나 실패가 발생할 때 데이터 복제 과정에서 시간 차이가 발생할 때 캐싱 문제 캐시 무효화가 제대로 이루어지지 않을 때 캐시와 원본 데이터 간의 동기화 실패 시스템 오류 하드웨어 오류, 네트워크 문제, 소프트웨어 버그 등으로 인해 발생할 수 있다. 데이터 통합 문제: 서로 다른 소스의 데이터를 통합할 때 발생할 수 있다 해결책 및 방지책 데이터 표준화: 데이터 형식, 값, 표현을 일관되게 만든다. 데이터 검증: 데이터 입력 시 유효성 검사를 수행한다. 데이터 정제: 오류를 식별하고 수정하는 과정을 거친다. 데이터 거버넌스: 데이터 관리에 대한 명확한 정책과 절차를 수립한다. 동기화 메커니즘: 분산 시스템에서 데이터 동기화를 위한 알고리즘을 사용한다. 실제 시스템에서의 예방책 데이터 감사: 정기적인 데이터 감사를 통해 불일치를 식별한다. 자동화 도구 사용: 데이터 품질 관리 도구를 활용하여 불일치를 자동으로 탐지한다. 데이터 프로파일링: 데이터의 특성을 이해하고 잠재적 문제를 파악한다. 버전 관리: 데이터 변경 이력을 추적하여 불일치 발생 시 원인을 파악한다. 고려사항 및 주의사항 성능 영향: 데이터 일관성 유지 메커니즘이 시스템 성능에 미치는 영향을 고려해야 한다. 확장성: 대규모 분산 시스템에서의 데이터 일관성 유지 방법을 고려해야 한다. 사용자 교육: 데이터 입력 및 수정 시 주의사항에 대해 사용자를 교육해야 한다. 비즈니스 규칙 반영: 데이터 일관성 규칙에 비즈니스 로직을 반영해야 한다. 주의 사항 및 모범 사례 버전 관리 모든 데이터 변경에 버전 번호 부여 낙관적 락킹 구현 충돌 감지 및 해결 메커니즘 구축 캐시 전략 Cache-Aside 패턴 사용 적절한 TTL(Time-To-Live) 설정 캐시 무효화 전략 수립 동기화 메커니즘 분산 락 사용 이벤트 기반 동기화 멱등성 보장 모니터링 및 감사 버전 이력 관리 변경 로그 기록 불일치 감지 알림 실제 구현시 고려사항 확장성 수평적 확장을 고려한 설계 샤딩 전략 수립 복제 지연 관리 성능 캐시 적중률 최적화 인덱스 전략 수립 배치 처리 활용 복구 전략 백업 및 복구 계획 롤백 메커니즘 데이터 정합성 검증 모범 사례 단일 진실 소스(Single Source of Truth) 유지 데이터 품질 메트릭 정의 및 모니터링 데이터 소유권 및 책임 명확화 지속적인 데이터 품질 개선 프로세스 구축 데이터 불일치 해결을 위한 명확한 워크플로우 수립 파이썬 예제로 보는 데이터 불일치 다음은 데이터 불일치가 발생할 수 있는 상황과 이를 해결하는 방법을 보여주는 예제
...</p></div><footer class=entry-footer><span title='2024-10-25 07:22:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 데이터 불일치 (Data Inconsistency)" href=https://buenhyden.github.io/posts/data--database-systems/data-fundamentals/data-quality/database-problems/data-inconsistency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GitOps and IaC</h2></header><div class=entry-content><p>GitOps and IaC GitOps 와 IaC(Infrastructure as Code) 는 현대 DevOps 환경에서 인프라스트럭처 관리를 자동화하고 코드화하는 핵심 방법론이다.
GitOps 는 Git 을 단일 진실의 소스 (Single Source of Truth) 로 활용하여 애플리케이션과 인프라의 배포를 자동화하는 접근 방식이다. IaC 는 인프라를 코드로 정의하여 자동화된 프로비저닝과 관리를 가능하게 한다. 이 두 가지 개념은 클라우드 네이티브 환경에서 자동화된 배포 파이프라인, 선언적 인프라 정의, 버전 관리 및 감사 기능을 통해 인프라와 애플리케이션 관리를 혁신하고 있다. 이 두 방법론을 결합하여 조직은 인프라스트럭처 프로비저닝, 애플리케이션 배포, 구성 관리를 자동화하고 일관성 있게 유지하며, 변경 사항을 추적하고 필요시 롤백할 수 있다.
ArgoCD 와 FluxCD 는 Kubernetes 환경에서 GitOps 를 구현하는 주요 도구이며, Terraform 은 다양한 클라우드 환경에서 IaC 를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-25 06:15:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;<span>20 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to GitOps and IaC" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/gitops-and-iac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로시저 (Procedure)</h2></header><div class=entry-content><p>프로시저 (Procedure) 데이터베이스 프로시저(Database Procedure)는 데이터베이스 내에 저장되고 실행되는 일련의 SQL 문들의 집합으로,
자주 사용하는 SQL 명령어들을 하나의 작은 프로그램으로 미리 작성해두고 필요할 때 호출하여 사용하는 것이다.
SQL Server에서의 프로시저 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 -- 주문 처리를 위한 저장 프로시저 생성 CREATE PROCEDURE ProcessOrder @OrderID int, @CustomerID int, @TotalAmount decimal(10,2) AS BEGIN -- 트랜잭션 시작 BEGIN TRANSACTION TRY -- 주문 정보 입력 INSERT INTO Orders (OrderID, CustomerID, OrderDate, TotalAmount) VALUES (@OrderID, @CustomerID, GETDATE(), @TotalAmount) -- 재고 수량 업데이트 UPDATE Inventory SET Quantity = Quantity - 1 WHERE ProductID IN ( SELECT ProductID FROM OrderDetails WHERE OrderID = @OrderID ) -- 고객 포인트 업데이트 UPDATE Customers SET Points = Points + (@TotalAmount * 0.01) WHERE CustomerID = @CustomerID -- 트랜잭션 완료 COMMIT TRANSACTION CATCH -- 오류 발생 시 롤백 ROLLBACK TRANSACTION -- 오류 정보 반환 SELECT ERROR_MESSAGE() AS ErrorMessage END END -- 프로시저 사용 예시 EXEC ProcessOrder @OrderID = 1001, @CustomerID = 500, @TotalAmount = 150000 프로시저의 주요 특징과 장점 성능 최적화
프로시저는 최초 실행 시 컴파일되어 캐시에 저장되므로, 반복 실행 시 더 빠른 성능을 제공한다:
...</p></div><footer class=entry-footer><span title='2024-10-24 09:05:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 프로시저 (Procedure)" href=https://buenhyden.github.io/posts/data--database-systems/database-technologies/relational-databases/advanced-sql/functions/procedure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>keyword</h2></header><div class=entry-content><p>Keyword SQL(Structured Query Language)는 데이터베이스를 관리하고 조작하기 위한 표준 언어로, 다양한 키워드를 통해 데이터 정의, 조작, 제어, 트랜잭션 관리 등을 수행한다.
데이터 조회 (Query) 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- SELECT: 데이터를 조회하는 기본 키워드 -- 지정된 컬럼의 데이터를 결과셋으로 반환 SELECT employee_id, first_name, salary FROM employees; -- FROM: 데이터를 가져올 테이블을 지정 -- 여러 테이블을 콤마로 구분하거나 JOIN을 사용할 수 있음 SELECT * FROM employees, departments; -- DISTINCT: 결과에서 중복된 행을 제거하는 데 사용 -- 기본 DISTINCT 사용 -- 부서별 unique한 직무 목록 조회 SELECT DISTINCT job_id FROM employees; -- 여러 컬럼에 DISTINCT 적용 -- 부서와 직무의 unique한 조합 조회 SELECT DISTINCT department_id, job_id FROM employees; -- COUNT와 함께 사용 -- 회사에 존재하는 직무 개수 조회 SELECT COUNT(DISTINCT job_id) as unique_jobs FROM employees; -- GROUP BY와 함께 사용 SELECT department_id, COUNT(DISTINCT job_id) as job_types FROM employees GROUP BY department_id; 결과 제한 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- LIMIT - 반환되는 결과의 최대 행 수를 제한합니다. SELECT * FROM employees LIMIT 10 -- 상위 10개 행만 반환 -- OFFSET - 결과의 시작 위치를 지정합니다. LIMIT와 함께 자주 사용됩니다. SELECT * FROM employees LIMIT 10 OFFSET 20 -- 21번째부터 30번째 행을 반환 -- FETCH - SQL 표준의 LIMIT와 유사한 기능을 합니다. SELECT * FROM employees FETCH FIRST 10 ROWS ONLY -- 페이지당 10개 항목, 3번째 페이지 조회 SELECT * FROM products ORDER BY name LIMIT 10 OFFSET 20; -- (페이지 번호 - 1) * 페이지 크기 = OFFSET 조건 연산자 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- WHERE: 조건절을 지정하여 특정 조건을 만족하는 데이터만 조회 -- AND, OR을 사용하여 여러 조건 조합 가능 SELECT * FROM employees WHERE salary > 50000 AND department_id = 10; -- IN: 값 목록 중 포함 여부 -- BETWEEN: 범위 조건 -- LIKE: 패턴 매칭 -- IS NULL: NULL 값 확인 SELECT * FROM employees WHERE department_id IN (10, 20, 30) AND salary BETWEEN 40000 AND 60000 AND first_name LIKE '김%' AND manager_id IS NOT NULL; -- CASE - 조건에 따라 다른 값을 반환합니다. -- WHEN - CASE 문에서 조건을 지정합니다. -- THEN - 조건이 참일 때 반환할 값을 지정합니다. -- ELSE - 모든 조건이 거짓일 때 반환할 값을 지정합니다. SELECT name, CASE WHEN age &lt; 20 THEN 'Young' WHEN age &lt; 60 THEN 'Adult' ELSE 'Senior' END as age_group FROM users; 정렬과 그룹화 키워드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 -- GROUP BY: 지정된 컬럼을 기준으로 데이터를 그룹화 -- 주로 집계 함수와 함께 사용 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id; -- ORDER BY: 결과를 정렬 -- ASC(오름차순), DESC(내림차순) 지정 가능 SELECT * FROM employees ORDER BY salary DESC, first_name ASC; -- HAVING: GROUP BY로 그룹화된 데이터에 대한 조건 지정 -- WHERE는 개별 행에 대한 조건, HAVING은 그룹에 대한 조건 SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 50000; 조인(Join) 관련 키워드 JOIN은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법이다. JOIN을 사용하면 여러 테이블의 데이터를 하나의 결과 집합으로 결합할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-24 07:56:00 +0000 UTC'>October 24, 2024</span>&nbsp;·&nbsp;<span>15 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to keyword" href=https://buenhyden.github.io/posts/data--database-systems/database-technologies/relational-databases/sql-fundamentals/keywords/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/32/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/34/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>