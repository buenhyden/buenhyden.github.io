<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WebSocket API</h2></header><div class=entry-content><p>WebSocket API WebSocket API는 WebSocket 프로토콜을 사용하여 클라이언트와 서버 간의 양방향, 실시간 통신을 가능하게 하는 웹 API로, HTTP 프로토콜의 단방향 통신과 폴링 방식의 한계를 극복하고, 클라이언트와 서버 간의 실시간 양방향 통신을 제공하는 기술이다.
WebSocket API는 이 프로토콜을 웹 애플리케이션에서 사용할 수 있게 해주는 인터페이스이다.
주요 기능 및 특징 양방향 통신: 클라이언트와 서버가 동시에 데이터를 주고받을 수 있다. 지속적 연결: 한 번 연결이 수립되면 지속적으로 유지된다. 실시간 데이터 교환: 폴링 없이 즉시 데이터를 주고받을 수 있다. 효율적인 리소스 사용: 연결이 유지되므로 반복적인 HTTP 요청의 오버헤드가 줄어든다. WebSocket 객체 생성 및 기본 사용법 WebSocket 객체를 생성하여 연결을 시작합니다:
...</p></div><footer class=entry-footer><span title='2024-10-19 05:37:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;577 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WebSocket API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/websocket-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>쓰로틀링 (Throttling)</h2></header><div class=entry-content><p>쓰로틀링 (Throttling) 쓰로틀링(Throttling)은 시스템이나 리소스의 과도한 사용을 제어하고 관리하는 기술이다.
특정 시간 동안 처리할 수 있는 요청의 수나 데이터의 양을 제한함으로써 시스템의 과부하를 방지하고 안정적인 서비스를 제공하는 것이 주요 목적이다.
작동 방식 지정된 시간 간격 내에 허용된 요청 수를 초과하면 추가 요청을 거부하거나 지연시킨다. 예를 들어, 초당 1000개의 요청만 허용한다면 그 이상의 요청은 throttle된다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ThrottlingController { private final int MAX_REQUESTS_PER_SECOND = 1000; private final Queue&lt;Long> requestTimestamps = new LinkedList&lt;>(); public boolean isRequestAllowed() { long currentTime = System.currentTimeMillis(); // 1초가 지난 타임스탬프 제거 while (!requestTimestamps.isEmpty() && requestTimestamps.peek() &lt; currentTime - 1000) { requestTimestamps.poll(); } // 현재 요청 수가 제한보다 적으면 허용 if (requestTimestamps.size() &lt; MAX_REQUESTS_PER_SECOND) { requestTimestamps.offer(currentTime); return true; } return false; } } 주요 용도 API 사용량 제한 서버 리소스 보호 DDoS 공격 방지 네트워크 트래픽 관리 쓰로틀링의 주요 유형 Rate Limiting (비율 제한)
...</p></div><footer class=entry-footer><span title='2024-10-19 04:14:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;590 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 쓰로틀링 (Throttling)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/throttling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GraphQL API</h2></header><div class=entry-content><p>GraphQL API GraphQL은 API를 위한 쿼리 언어이자 서버 측 런타임으로, 클라이언트가 필요한 데이터를 정확하게 요청하고 받을 수 있게 해주는 강력한 도구.
2012년 Facebook에서 개발되어 2015년 공개된 GraphQL은 REST API의 한계를 극복하고자 설계되었습니다.
GraphQL의 주요 특징 선언적 데이터 fetching: 클라이언트가 필요한 데이터의 구조를 정확히 명시할 수 있습니다. 단일 엔드포인트: 모든 요청이 하나의 엔드포인트로 전송됩니다. 강력한 타입 시스템: 스키마를 통해 데이터 구조를 명확히 정의합니다. 실시간 업데이트: Subscription을 통해 실시간 데이터 업데이트를 지원합니다. 효율적인 데이터 전송: Over-fetching과 Under-fetching 문제를 해결합니다. GraphQL의 주요 구성 요소 스키마 (Schema)
GraphQL API의 타입 시스템을 정의합니다.
사용 가능한 쿼리, 뮤테이션, 구독 및 사용자 정의 타입을 명시합니다.
...</p></div><footer class=entry-footer><span title='2024-10-19 03:22:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;449 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GraphQL API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/graphql-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>gRPC API</h2></header><div class=entry-content><p>gRPC API gRPC(gRPC Remote Procedure Call)는 Google에서 개발한 오픈소스 원격 프로시저 호출(RPC) 시스템.
이 시스템은 효율적이고 빠른 서비스 간 통신을 제공하며, 다양한 프로그래밍 언어와 플랫폼에서 사용할 수 있다.
gRPC는 특히 다음과 같은 상황에서 유용하다:
마이크로서비스 아키텍처 서비스 간 효율적인 통신 강력한 타입 안정성 뛰어난 성능 실시간 통신이 필요한 시스템 채팅 애플리케이션 실시간 모니터링 게임 서버 모바일 애플리케이션 효율적인 데이터 전송 배터리 사용량 최적화 네트워크 대역폭 절약 gRPC의 주요 특징 Protocol Buffers 사용: gRPC는 데이터 직렬화를 위해 Protocol Buffers를 사용합니다. 이는 JSON이나 XML보다 더 작고 빠른 데이터 포맷을 제공합니다. HTTP/2 기반: HTTP/2 프로토콜을 사용하여 높은 성능과 낮은 지연 시간을 제공합니다. 양방향 스트리밍: 클라이언트와 서버 간의 양방향 스트리밍을 지원하여 실시간 데이터 교환이 가능합니다. 다양한 언어 지원: Java, Python, Go, C++, Ruby 등 다양한 프로그래밍 언어를 지원합니다. 강력한 타입 시스템: Protocol Buffers를 통해 강력한 타입 시스템을 제공하여 타입 안정성을 보장합니다. gRPC 작동 방식 서비스 정의:.proto 파일에 서비스와 메시지 구조를 정의합니다. 코드 생성: Protocol Buffer 컴파일러를 사용하여 서버와 클라이언트 코드를 자동으로 생성합니다. 서버 구현: 생성된 코드를 기반으로 서버 비즈니스 로직을 구현합니다. 클라이언트 구현: 생성된 클라이언트 코드를 사용하여 서버와 통신합니다. gRPC의 통신 유형 Unary RPC: 클라이언트가 단일 요청을 보내고 서버가 단일 응답을 반환합니다.
...</p></div><footer class=entry-footer><span title='2024-10-19 03:22:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;344 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to gRPC API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/grpc-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RESTful API</h2></header><div class=entry-content><p>RESTful API(Representational State Transfer API) 웹 서비스를 설계하고 구현하기 위한 아키텍처 스타일
RESTful API는 HTTP 프로토콜을 기반으로 하며, 클라이언트와 서버 간의 통신을 위한 표준화된 방식을 제공한다.
RESTful API의 주요 특징 자원 중심 구조: URI를 통해 자원을 명확하게 표현합니다. HTTP 메서드 활용: GET, POST, PUT, DELETE 등의 HTTP 메서드를 사용하여 자원에 대한 CRUD 작업을 수행합니다. 무상태성(Stateless): 각 요청은 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 균일한 인터페이스: 일관된 방식으로 자원에 접근할 수 있습니다. 설계 원칙 자원 식별: URI를 통해 자원을 명확하게 식별합니다. HTTP 메서드 사용: 적절한 HTTP 메서드를 사용하여 자원에 대한 작업을 수행합니다. 자체 설명적 메시지: 요청과 응답은 자체적으로 이해할 수 있어야 합니다. HATEOAS(Hypermedia as the Engine of Application State): 응답에 관련 리소스의 링크를 포함합니다. 주요 제약 조건 클라이언트-서버 구조를 통해 관심사를 분리합니다. 이는 클라이언트와 서버가 독립적으로 발전할 수 있게 해줍니다. 예를 들어, 서버는 데이터 저장 방식을 변경할 수 있고, 클라이언트는 사용자 인터페이스를 개선할 수 있습니다. 무상태성(Stateless)을 유지합니다. 각 요청은 이전 요청과 독립적이며, 서버는 클라이언트의 상태를 저장하지 않습니다. 이는 시스템의 확장성을 높여주지만, 매 요청마다 필요한 모든 정보를 포함해야 한다는 의미이기도 합니다. 캐시 가능성을 제공합니다. HTTP의 캐싱 메커니즘을 활용하여 성능을 개선할 수 있습니다. 예를 들어, 자주 변경되지 않는 사용자 프로필 이미지는 클라이언트에서 캐시할 수 있습니다. RESTful API 구현 예시 다음은 Node.js와 Express.js를 사용한 간단한 RESTful API 예제입니다:
...</p></div><footer class=entry-footer><span title='2024-10-19 03:21:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;482 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to RESTful API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/restful-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOAP API</h2></header><div class=entry-content><p>SOAP API SOAP(Simple Object Access Protocol) API는 XML 기반의 메시지 교환 프로토콜.
분산 환경에서 데이터를 교환하기 위해 설계된 웹 서비스 통신 방식.
SOAP API의 주요 특징 XML 기반: 모든 SOAP 메시지는 XML 형식으로 구성됩니다. 프로토콜 독립성: HTTP, SMTP 등 다양한 프로토콜을 통해 전송될 수 있습니다. 표준화: 잘 정의된 표준을 따르며, 이는 다양한 플랫폼과 언어 간의 호환성을 보장합니다. 보안성: WS-Security와 같은 웹 서비스 보안 표준을 지원합니다. SOAP 메시지 구조 SOAP 메시지는 다음과 같은 요소로 구성됩니다:
...</p></div><footer class=entry-footer><span title='2024-10-19 03:21:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;164 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOAP API" href=https://buenhyden.github.io/posts/networking-and-communications/apis/soap-api/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>로드밸런싱 (LoadBalancing)</h2></header><div class=entry-content><p>로드밸런싱 (Load Balancing) 여러 서버나 네트워크 리소스에 작업량을 분산시켜주는 방법으로 이를 통해 특정 서버에 부하가 집중되는 것을 방지하고, 전체 시스템의 안정성과 가용성을 높일 수 있다.
개념 로드 밸런싱은 ‘부하 분산’이라고도 불리며, 다음과 같은 핵심 개념을 포함한다:
트래픽 분산: 클라이언트로부터 오는 네트워크 요청을 여러 서버에 균형있게 배분합니다. 서버 풀 관리: 여러 대의 서버를 하나의 그룹으로 관리하여 효율적으로 리소스를 활용합니다. 가용성 향상: 특정 서버에 장애가 발생해도 다른 서버로 트래픽을 리디렉션하여 서비스의 연속성을 보장합니다. 주요 특징 가용성(Availability) 보장 시스템의 일부가 실패하더라도 서비스를 계속 제공할 수 있습니다. 예를 들어, 3대의 서버 중 1대가 다운되어도 나머지 2대의 서버로 서비스를 계속할 수 있습니다. 확장성(Scalability) 제공 트래픽이 증가할 때 서버를 추가하기만 하면 됩니다. 마치 음식점에서 손님이 많아지면 웨이터를 추가로 투입하는 것과 같습니다. 유연성(Flexibility) 확보 서버 유지보수나 업데이트를 할 때, 특정 서버를 작업하는 동안 다른 서버로 트래픽을 우회시킬 수 있습니다. 장점 서비스 가용성 향상: 단일 서버 장애 시에도 서비스 중단을 방지합니다. 성능 최적화: 전체 시스템의 처리 능력과 응답 시간을 개선합니다. 확장성 제공: 트래픽 증가에 따라 유연하게 서버를 추가할 수 있습니다. 보안 강화: L7 로드 밸런서의 경우 애플리케이션 레벨에서의 보안 기능을 제공할 수 있습니다. 단점 초기 설정 복잡성: 로드 밸런서 구성과 관리에 전문 지식이 필요할 수 있습니다. 추가 비용: 하드웨어 로드 밸런서의 경우 구매 및 유지보수 비용이 발생합니다. 단일 실패 지점: 로드 밸런서 자체가 장애 지점이 될 수 있어 이중화 구성이 필요할 수 있습니다. 종류 L4 로드 밸런싱:
...</p></div><footer class=entry-footer><span title='2024-10-19 02:43:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;423 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 로드밸런싱 (LoadBalancing)" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/loadbalancing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>encapsulation and decapsulation</h2></header><div class=entry-content><p>Encapsulation (캡슐화) and Decapsulation (역캡슐화) 데이터에 헤더 (Header) 를 붙이고 아래 계층에 보내는 것을 캡슐화 (Encapsulation), 데이터에 헤더를 제거하고 위 계층에 보내는 것을 역캡슐화 (Decapsulation) 데이터 전송시 캡슐화가 이뤄지고 수신시 역캡슐화 (Decapsulation) 가 이뤄진다. 데이터에 헤더 (Header) 를 붙이고 아래 계층에 보내는 것을 캡슐화 (Encapsulation), 데이터에 헤더를 제거하고 위 계층에 보내는 것을 역캡슐화 (Decapsulation) 라고 한다. 중요성 모듈성: 각 계층의 기능을 논리적으로 분리하여 네트워크 프로토콜의 모듈식 설계를 가능하게 한다. 추상화: 다른 통신 계층에서 전달되는 정보의 구조를 추상화한다. 효율성: 대량의 데이터를 효율적으로 전송할 수 있게 한다. 보안: 데이터의 안전한 전송을 보장하며, 암호화된 통신 채널을 구축하는 데 도움을 준다. 유연성: 다양한 네트워크 환경과 프로토콜에 적응할 수 있는 유연성을 제공한다. 오류 검출 및 수정: 각 계층에서 데이터의 무결성을 확인하고 필요한 경우 오류를 수정할 수 있다. Encapsulation (캡슐화) 데이터가 송신자로부터 수신자에게 전송될 때 발생하는 과정
...</p></div><footer class=entry-footer><span title='2024-10-19 02:03:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1020 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to encapsulation and decapsulation" href=https://buenhyden.github.io/posts/networking-and-communications/concepts/encapsulation-and-decapsulation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>멱등성 (Idempotency)</h2></header><div class=entry-content><p>멱등성 (Idempotency) 동일한 요청을 여러 번 수행해도 시스템의 상태가 한 번 수행한 것과 동일한 결과를 보장하는 속성.
즉, 같은 작업을 반복해도 추가적인 부작용 없이 동일한 결과를 얻을 수 있다.
중요성 일관성 유지: 네트워크 문제나 중복 요청 상황에서도 시스템의 상태를 예측 가능하게 유지합니다. 오류 처리 단순화: 클라이언트가 안전하게 요청을 재시도할 수 있어 오류 처리가 간단해집니다. 장애 허용성: 네트워크 문제나 기타 중단에 더 잘 대처할 수 있어 신뢰성 있는 사용자 경험을 제공합니다. 데이터 무결성: 중복 작업이나 실패한 요청으로 인한 데이터 손상을 방지합니다. 구현 방법 고유 식별자 사용: 각 요청에 UUID 등의 고유 식별자를 할당하여 요청을 추적하고 식별합니다. 멱등성을 가진 HTTP 메서드 사용: GET, PUT, DELETE와 같은 멱등성을 가진 HTTP 메서드를 사용합니다. 멱등성 키 만료 시간 설정: 멱등성 키에 적절한 만료 시간을 설정하여 일정 기간 동안만 유효하도록 합니다. 응답 코드와 헤더 활용: 적절한 HTTP 상태 코드(예: 200, 201, 204)와 헤더(예: ETag, Last-Modified)를 사용하여 멱등성과 성공적인 처리를 나타냅니다. 이점 신뢰성 향상: 예기치 않은 다중 변경을 방지하여 시스템의 신뢰성을 높입니다. 오류 처리 개선: 네트워크 실패나 중단 시 안전한 재시도를 가능하게 하여 오류 처리와 복구를 단순화합니다. 사용자 경험 개선: 일관된 결과와 중복 작업 방지로 사용자 경험을 향상시킵니다. 시스템 무결성 유지: 반복된 작업으로 인한 데이터 손상을 방지하여 데이터 무결성을 유지합니다. 확장성 지원: 안전한 재시도와 여러 서버 간 부하 분산을 가능하게 하여 확장성을 지원합니다. HTTP 메서드별 멱등성 HTTP 메서드 멱등성 설명 GET O 리소스를 조회하는 용도로, 여러 번 요청해도 동일한 결과 반환 HEAD O GET과 유사하지만 헤더 정보만 반환 OPTIONS O 서버가 지원하는 메서드 정보를 반환 PUT O 리소스를 대체하거나 생성하며, 여러 번 요청해도 결과는 동일 DELETE O 리소스를 삭제하며, 여러 번 요청해도 서버 상태는 동일 POST X 새로운 리소스를 생성하거나 추가하므로 멱등성을 갖지 않음 PATCH △ 리소스의 부분 수정에 사용되며, 구현에 따라 멱등할 수도 있고 아닐 수도 있음 멱등성을 갖는 메서드는 네트워크 오류 시 안전하게 재시도할 수 있어 신뢰성 있는 통신에 유용하다.
그러나 멱등성이 있다고 해서 항상 서버의 상태를 변경하지 않는 것은 아니며, 안전한(safe) 메서드와는 구별해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-18 16:31:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;615 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 멱등성 (Idempotency)" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/http/idempotency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>안전한 메서드 (Safe Methods)</h2></header><div class=entry-content><p>안전한 메서드 (Safe Methods) 서버의 상태를 변경하지 않는 HTTP 메서드.
특징 리소스 변경 없음: 요청을 여러 번 보내도 서버의 상태가 동일하게 유지됩니다. 읽기 전용 작업: 주로 데이터를 조회하는 용도로 사용됩니다. 부작용 없음: 서버의 상태를 변경하지 않으므로 안전하게 여러 번 호출할 수 있습니다. 중요성 신뢰성: 클라이언트가 서버의 상태를 변경하지 않고 안전하게 정보를 요청할 수 있습니다. 캐싱 최적화: 안전한 메서드는 캐시하기에 적합하여 성능 향상에 도움이 됩니다. 사용자 경험: 브라우저가 안전한 메서드를 자유롭게 호출할 수 있어 프리페칭 등의 기능을 구현할 수 있습니다. 구현 방법 읽기 전용 로직: 안전한 메서드 구현 시 서버의 상태를 변경하지 않는 로직만 포함해야 합니다. 멱등성 보장: 안전한 메서드는 멱등성도 가져야 하므로, 여러 번 호출해도 동일한 결과를 반환하도록 구현합니다. 예외 처리: 안전한 메서드가 서버 상태를 변경하지 않도록 주의깊게 예외를 처리해야 합니다. 이점 성능 최적화: 안전한 메서드는 캐싱이 가능하여 네트워크 트래픽을 줄이고 응답 시간을 개선할 수 있습니다. 보안 강화: 데이터를 변경하지 않으므로 무단 수정이나 삭제의 위험이 없습니다. 확장성: 안전한 메서드는 프록시나 중간 계층에서 자유롭게 처리할 수 있어 시스템 확장성이 향상됩니다. HTTP 메서드별 안전성 GET: 안전한 메서드. 리소스를 조회하는 용도로 사용됩니다. HEAD: 안전한 메서드. GET과 유사하지만 헤더 정보만 반환합니다. OPTIONS: 안전한 메서드. 서버가 지원하는 메서드 정보를 반환합니다. POST: 안전하지 않은 메서드. 새로운 리소스를 생성하거나 데이터를 제출합니다. PUT: 안전하지 않은 메서드. 리소스를 생성하거나 대체합니다. DELETE: 안전하지 않은 메서드. 지정된 리소스를 삭제합니다. PATCH: 안전하지 않은 메서드. 리소스의 부분적인 수정에 사용됩니다.— 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-18 16:31:00 +0000 UTC'>October 18, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;219 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 안전한 메서드 (Safe Methods)" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/http/safe-methods/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/32/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/34/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>