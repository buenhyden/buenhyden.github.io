<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.143.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>디스조인트 셋 (Disjoint-Set)</h2></header><div class=entry-content><p>디스조인트 셋 (Disjoint-Set) 디스조인트 셋은 서로 겹치지 않는(disjoint) 부분 집합들로 나누어진 요소들의 집합을 표현하고 조작하는 데이터 구조이다.
각 부분 집합은 대표 요소(representative)를 가지며, 이를 통해 집합을 식별한다.
특징 동적 집합 관리: 요소들을 동적으로 그룹화하고 관리할 수 있다. 빠른 연산: Union과 Find 연산을 매우 효율적으로 수행한다. 경로 압축과 랭크 최적화: 트리 구조를 최적화하여 성능을 향상시킨다. 장점 효율성: 거의 상수 시간에 가까운 연산 복잡도를 제공한다. 간단한 구현: 기본 개념이 직관적이고 구현이 비교적 간단하다. 메모리 효율성: 추가적인 데이터 구조 없이 요소들의 관계를 표현한다. 단점 제한된 기능: 주로 Union과 Find 연산에 특화되어 있어 다른 복잡한 연산은 지원하지 않는다. 초기 설정 비용: 모든 요소에 대해 초기 집합을 생성해야 한다. 응용 Kruskal의 최소 신장 트리 알고리즘 사이클 검출 알고리즘 네트워크의 연결성 확인 이미지 세그멘테이션 동작 원리 디스조인트 셋은 트리 구조를 사용하여 집합을 표현한다.
각 트리의 루트 노드가 해당 집합의 대표 요소가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-11 07:07:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;371 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 디스조인트 셋 (Disjoint-Set)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/set/disjoint-set/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>B 트리 (B-tree)</h2></header><div class=entry-content><p>B 트리 (B-tree) 균형 잡힌 트리 구조로, 대용량 데이터를 효율적으로 관리하는 데 사용되는 자료구조
B-tree는 트리 자료구조의 일종으로, 이진 트리를 확장한 형태이다.
일반적인 이진 트리와 달리, 각 노드가 여러 개의 키를 가질 수 있고 여러 개의 자식을 가질 수 있는 것이 특징이다.
B-tree는 자체 균형 트리(Self-balanced Tree) 중 가장 유명한 자료구조이다.
이진 트리를 확장하여 하나의 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조이다.
B-tree는 Balanced-tree의 약자로, 항상 균형을 유지하는 특성을 가진다.
...</p></div><footer class=entry-footer><span title='2024-10-11 05:54:00 +0000 UTC'>October 11, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to B 트리 (B-tree)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/tree/balanced/b-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hash Map</h2></header><div class=entry-content><p>Hash Map HashMap은 키-값 쌍을 저장하고 관리하는 연관 배열의 구현체로, 효율적인 검색, 삽입, 삭제 연산을 제공한다.
HashMap은 해시 함수를 사용하여 키를 배열의 인덱스로 변환하고, 해당 인덱스에 값을 저장하는 데이터 구조이다.
이는 키를 통해 빠르게 값을 검색할 수 있게 해준다.
https://www.geeksforgeeks.org/load-factor-in-hashmap-in-java-with-examples/
특징 키-값 쌍 저장: 각 데이터는 고유한 키와 연관된 값으로 저장된다. 빠른 검색: 평균적으로 O(1) 시간 복잡도로 데이터를 검색할 수 있다. 동적 크기 조정: 데이터 양에 따라 자동으로 크기를 조정한다. 널(null) 허용: 대부분의 구현에서 널 키와 널 값을 허용한다. 장점 빠른 접근 및 수정: 키를 통한 빠른 데이터 접근과 수정이 가능하다. 유연성: 다양한 타입의 키와 값을 저장할 수 있다. 메모리 효율성: 데이터 양에 따라 동적으로 크기를 조절한다. 단점 충돌 가능성: 서로 다른 키가 같은 해시 값을 가질 수 있어 충돌이 발생할 수 있다. 순서 보장 없음: 데이터의 삽입 순서가 보장되지 않는다. 메모리 오버헤드: 해시 테이블 구조로 인한 추가적인 메모리 사용이 있을 수 있다. 응용 데이터베이스 인덱싱 캐시 구현 심볼 테이블 관리 빠른 데이터 검색이 필요한 다양한 애플리케이션 동작 원리 해시 함수: 키를 입력받아 배열의 인덱스로 변환한다. 충돌 해결: 서로 다른 키가 같은 인덱스를 가리킬 때 충돌을 해결하는 방법을 사용한다. 구성 요소 버킷: 실제 데이터를 저장하는 배열의 각 요소. 키(Key): 데이터를 식별하는 고유한 값. 값(Value): 키와 연관된 실제 데이터. 해시 함수: 키를 해시 코드로 변환하는 함수. 구현 방식 일반적으로 배열과 연결 리스트를 조합하여 구현한다.
배열은 버킷을 저장하고, 각 버킷은 연결 리스트로 충돌을 해결한다.
...</p></div><footer class=entry-footer><span title='2024-10-09 14:29:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;350 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hash Map" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-map/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock-free Stack</h2></header><div class=entry-content><p>Lock-free Stack Lock-free Stack은 락(lock)을 사용하지 않고 동시성을 제공하는 LIFO(Last-In-First-Out) 자료구조.
이 자료구조는 여러 스레드가 동시에 스택에 접근할 수 있으며, 시스템 전체의 진행을 보장한다.
특징 동시성 지원: 여러 스레드가 동시에 스택에 접근하고 수정할 수 있다. 락 사용 없음: 전통적인 동기화 기법인 락을 사용하지 않는다. 진행 보장: 시스템 전체의 진행을 보장하며, 개별 스레드의 기아 현상이 발생할 수 있다. 원자적 연산 사용: Compare-And-Swap(CAS)과 같은 원자적 연산을 사용한다. 구현 방식 Lock-free Stack은 주로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-09 13:22:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;333 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock-free Stack" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/stack/lock-free-stack/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrent Hash Map</h2></header><div class=entry-content><p>Concurrent Hash Map ConcurrentHashMap은 여러 스레드가 동시에 안전하게 접근할 수 있도록 설계된 HashMap의 동시성 버전이다.
이 자료구조는 멀티스레드 환경에서 높은 성능과 확장성을 제공하면서도 스레드 안전성을 보장한다.
Java의 동시성 컬렉션 중 하나로, 멀티스레드 환경에서 안전하게 사용할 수 있도록 설계된 Map 구현체이다.
Java를 제외한 프로그래밍 언어와 라이브러리에서도 동시성을 지원하기 위해 구현되어 있는 자료 구조이다.
특징 Thread-safe: 내부적으로 동기화 처리가 되어 있어 멀티스레드 환경에서 안전하다. 높은 동시성: 여러 스레드가 동시에 맵을 수정할 수 있으며, 읽기 작업은 락 없이 수행된다. 원자적 연산 지원: putIfAbsent(), replace(), remove() 등의 원자적 연산을 제공한다. 일관성 있는 반복자: 반복자가 생성된 시점의 맵 상태를 반영하며, ConcurrentModificationException을 발생시키지 않는다. 락 스트라이핑(Lock Striping): 맵을 여러 부분으로 나누어 각각 독립적으로 잠금을 걸어 동시성을 향상시킨다. Null 불허: 키와 값에 null을 허용하지 않는다. 이는 동시성 환경에서 null의 의미가 모호해질 수 있기 때문이다. 약한 일관성: 순간적으로 맵의 상태가 일관되지 않을 수 있지만, 최종적으로는 일관된 상태로 수렴한다. 구현 방식 ConcurrentHashMap은 다음과 같은 기술을 사용하여 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-09 13:21:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;517 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Hash Map" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/concurrent-hash-map/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cuckoo Hash Table</h2></header><div class=entry-content><p>Cuckoo Hash Table Cuckoo Hash Table은 해시 충돌 문제를 해결하기 위해 개발된 해시 테이블의 한 종류로, 두 개 이상의 해시 함수를 사용하여 각 키에 대해 여러 개의 가능한 위치를 제공한다.
특징 다중 해시 함수: 일반적으로 두 개 이상의 해시 함수를 사용한다. 결정적 성능: 최악의 경우에도 일정한 시간 복잡도를 보장한다. 동적 재배치: 충돌 발생 시 기존 항목을 다른 위치로 이동시킨다. 장점 빠른 검색 속도: O(1) 시간 복잡도로 검색 연산을 수행한다. 공간 효율성: 높은 로드 팩터를 유지할 수 있다. 삭제 연산 지원: Bloom Filter와 달리 효율적인 삭제가 가능하다. 단점 삽입 연산의 복잡성: 최악의 경우 무한 루프에 빠질 수 있어 재해싱이 필요할 수 있다. 구현의 복잡성: 일반 해시 테이블에 비해 구현이 더 복잡하다. 응용 데이터베이스 인덱싱 네트워크 라우팅 테이블 캐시 시스템 스팸 필터링 동작 원리 삽입:
...</p></div><footer class=entry-footer><span title='2024-10-09 12:57:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;487 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cuckoo Hash Table" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/cuckoo-hash-table/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bloom filter</h2></header><div class=entry-content><p>블룸 필터 (Bloom filter) 블룸 필터(Bloom Filter)는 공간 효율적인 확률적 데이터 구조로, 원소가 집합에 속하는지 여부를 빠르게 확인하는 데 사용된다.
1970년 Burton Howard Bloom이 고안한 이 구조는 **거짓 양성(false positive)**은 허용하지만 **거짓 음성(false negative)**은 절대 발생하지 않는다.
블룸 필터는 빠른 검색과 극도의 공간 효율이 필요한 시스템에서 필수적이다.
특히 대용량 데이터 처리, 실시간 애플리케이션, 메모리 제약 환경에서 강력한 성능을 발휘한다.
다만 정확성이 절대적이라면 전통적 해시 테이블이 더 적합하다.
핵심 구성 요소 비트 배열(Bit Array): 모든 비트가 0으로 초기화된 배열 (크기 m) 해시 함수(Hash Functions): 원소를 비트 배열의 인덱스로 매핑하는 k개의 독립적 해시 함수 동작 과정 삽입(Add)
원소를 k개의 해시 함수로 해싱 → 각 결과값을 비트 배열의 인덱스로 사용 → 해당 위치의 비트를 1로 설정.
예시: 원소 “apple"을 3개의 해시 함수로 해싱 → 인덱스 1, 4, 7 → 비트 배열 [0,1,0,1,0,0,1,0,0,0] 갱신.
...</p></div><footer class=entry-footer><span title='2024-10-09 12:37:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;703 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Bloom filter" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/bloom-filter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 테이블(Hash Table)</h2></header><div class=entry-content><p>해시 테이블(Hash Table) 해시 테이블은 키-값 쌍을 저장하는 데이터 구조로, 해시 함수를 사용하여 키를 인덱스로 변환.
효율적인 검색과 삽입 연산을 위해 설계되었다.
키(key)를 값(value)에 매핑하는 자료구조.
이 과정은 다음과 같이 작동한다.
해시 함수는 키를 받아서 숫자(해시값)로 변환한다. 이 해시값은 배열의 인덱스로 사용된다. 해당 인덱스에 값을 저장하거나 검색한다. ![](Introduction-to-Hashing.webp “https://www.geeksforgeeks.org/hashing-data-structure/?ref=outind _
특징: 시간 복잡도 삽입: 평균 O(1) 검색: 평균 O(1) 삭제: 평균 O(1) 해시 충돌 해결 방법 체이닝(Chaining): 같은 인덱스에 여러 값을 연결 리스트로 저장 개방 주소법(Open Addressing): 충돌 발생 시 다른 빈 공간을 찾아 저장 동적 크기 조정 로드 팩터(load factor)에 따라 크기를 조정 일반적으로 로드 팩터가 0.7~0.8을 넘으면 크기를 증가 체이닝 (Chaining)
구현이 비교적 간단하며, 해시 테이블이 가득 차더라도 새로운 항목을 계속 추가할 수 있다.
연결 리스트를 사용하기 때문에 캐시 성능이 떨어질 수 있으며 최악의 경우 검색 시간이 O(n)이 될 수 있다.
삽입과 삭제가 간단하며 해시 함수의 성능에 덜 민감하다.
추가적인 메모리가 필요하며 연결 리스트가 길어지면 검색 성능이 저하될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:54:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1339 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 테이블(Hash Table)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/non-linear/hash-based/hash-table/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Concurrent Skip List</h2></header><div class=entry-content><p>Concurrent Skip List Concurrent Skip List는 Skip List 자료구조를 기반으로 하여 멀티스레드 환경에서 동시에 삽입, 삭제, 검색 작업을 수행할 수 있도록 구현된 동시성 자료구조이다.
Skip List는 여러 계층의 연결 리스트로 구성된 정렬된 데이터 구조인데, ConcurrentSkipList는 이를 멀티스레드 환경에서 안전하게 사용할 수 있도록 구현한 것이다.
이 자료구조는 락-프리(lock-free) 또는 세밀한 동기화 메커니즘을 사용하여 높은 동시성을 제공한다.
특징 동시성 지원: 여러 스레드가 동시에 자료구조에 접근하고 수정할 수 있다. 락-프리 구현: 대부분의 연산에서 락을 사용하지 않고 Compare-and-Swap(CAS) 연산을 활용한다. 확장성: 멀티코어 시스템에서 높은 확장성을 제공한다. 로그 시간 복잡도: 평균적으로 O(log n) 시간 복잡도로 검색, 삽입, 삭제 연산을 수행한다. 확률적 균형: 재조정 작업 없이 확률적으로 균형을 유지한다. 구현 방식 레벨별 락-프리 리스트: 각 레벨의 리스트를 락-프리 연결 리스트로 취급한다. CAS 연산 사용: 노드 삽입 시 CAS 연산을 사용하여 동시성을 제어한다. 마킹 기법: 노드 삭제 시 다음 참조를 마킹하여 논리적 삭제를 수행한다. 도움 메커니즘: find() 메서드가 마킹된 노드를 정리하는 역할을 수행한다. 장점 높은 동시성: 여러 스레드가 동시에 작업을 수행할 수 있어 성능이 향상된다. 확장성: 스레드 수가 증가해도 성능 저하가 적다. 간단한 구현: 동시성 트리 구조에 비해 구현이 상대적으로 간단하다. 메모리 효율성: 일부 트리 구조보다 메모리 효율적일 수 있다. 응용 동시성 우선순위 큐: 멀티스레드 환경에서 효율적인 우선순위 큐 구현에 사용된다. 데이터베이스 시스템: 동시성 인덱싱 구조로 활용된다. 분산 시스템: 분산 환경에서의 정렬된 데이터 관리에 사용된다. 캐시 시스템: 동시성 캐시 구현에 활용될 수 있다. 동작 원리 Concurrent Skip List는 여러 레벨의 연결 리스트로 구성되며, 각 레벨은 이전 레벨의 “빠른 경로"로 작용한다.
검색, 삽입, 삭제 작업은 상위 레벨에서 시작하여 하위 레벨로 이동하면서 수행된다.
...</p></div><footer class=entry-footer><span title='2024-10-08 13:22:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;364 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Concurrent Skip List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/concurrent-skip-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Read-Copy-Update List</h2></header><div class=entry-content><p>Read-Copy-Update (RCU) List RCU List는 동시성을 지원하는 연결 리스트 구조로, 여러 스레드가 동시에 안전하게 접근하고 수정할 수 있도록 설계되었다.
RCU List는 Read-Copy-Update 메커니즘을 사용하여 구현된 동시성 연결 리스트로 읽기 작업에 대해 락을 사용하지 않으면서도 동시에 업데이트를 수행할 수 있게 해준다.
특징 락 없는 읽기: 읽기 작업은 동기화 없이 수행된다. 동시성 지원: 여러 스레드가 동시에 리스트에 접근할 수 있다. 읽기 성능 최적화: 읽기 작업의 성능이 매우 뛰어나다. 공간-시간 트레이드오프: 더 많은 공간을 사용하여 빠른 연산을 가능하게 한다. 구현 방식 삽입: 새 노드를 생성하고 원자적으로 리스트에 연결한다. 삭제: 노드를 리스트에서 제거한 후, 일정 시간이 지난 뒤 메모리를 해제한다. 읽기: 동기화 없이 리스트를 순회한다. 장점 높은 읽기 성능: 읽기 작업이 매우 빠르다. 확장성: 다중 코어 시스템에서 좋은 성능을 보인다. 데드락 방지: 읽기 작업에서 락을 사용하지 않아 데드락 위험이 줄어든다. 응용 운영체제 커널 데이터베이스 시스템 네트워크 스택 고성능 멀티스레드 애플리케이션 동작 원리 읽기 작업: 동기화 없이 리스트를 순회한다. 쓰기 작업: 새로운 버전의 데이터를 생성하고, 원자적으로 포인터를 업데이트한다. 삭제: 노드를 리스트에서 제거한 후, 모든 읽기 작업이 완료될 때까지 기다렸다가 메모리를 해제한다. 구성 요소 노드: 데이터와 다음 노드를 가리키는 포인터를 포함한다. 헤드 포인터: 리스트의 첫 번째 노드를 가리킨다. RCU 동기화 프리미티브: rcu_read_lock(), rcu_read_unlock(), synchronize_rcu() 등 예시 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.util.concurrent.atomic.AtomicReference; public class LockFreeStack&lt;T> { private static class Node&lt;T> { final T value; Node&lt;T> next; Node(T value) { this.value = value; } } private AtomicReference&lt;Node&lt;T>> head = new AtomicReference&lt;>(null); public void push(T value) { Node&lt;T> newNode = new Node&lt;T>(value); while (true) { Node&lt;T> currentHead = head.get(); newNode.next = currentHead; // CAS로 head를 새 노드로 업데이트 시도 if (head.compareAndSet(currentHead, newNode)) { return; } // 실패하면 다시 시도 } } public T pop() { while (true) { Node&lt;T> currentHead = head.get(); if (currentHead == null) { return null; } // CAS로 head를 다음 노드로 업데이트 시도 if (head.compareAndSet( currentHead, currentHead.next)) { return currentHead.value; } // 실패하면 다시 시도 } } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-08 13:22:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;348 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Read-Copy-Update List" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/data-structure/non-primitive/linear/linked-list/read-copy-update-list/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/40/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/42/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>