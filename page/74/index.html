<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Observer Pattern</h2></header><div class=entry-content><p>Observer Pattern 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
특징 객체 간 일대다 관계를 정의합니다. 주체(Subject)와 관찰자(Observer)로 구성됩니다. 느슨한 결합을 제공하여 유연성을 높입니다. 발행/구독 모델로도 알려져 있습니다. 두 가지 인터페이스로 이루어진다.
Subject
Observer들을 등록(attach)하고 제거(detach)할 수 있으며, 상태 변경 시 모든 Observer에게 알림을 보낸다. Observer
Subject로부터 받은 알림을 처리하는 update 메서드를 구현 사용사례 이벤트 처리 시스템: GUI 애플리케이션에서 버튼 클릭이나 키보드 입력 등의 이벤트 처리 뉴스 구독 서비스: 새로운 뉴스가 발행되면 구독자들에게 알림 소셜 미디어 피드: 새로운 게시물이 등록되면 팔로워들에게 알림 주식 시장 모니터링: 주식 가격 변동을 실시간으로 관심 있는 투자자들에게 알림 장점 느슨한 결합(Loose Coupling): Subject와 Observer는 서로의 구체적인 구현을 알 필요가 없음 유연한 객체 관계: 실행 시점에 동적으로 Observer를 추가하거나 제거 가능 개방-폐쇄 원칙(OCP) 준수: 기존 코드 수정 없이 새로운 Observer 추가 가능 단점 순서 보장의 어려움: 다수의 Observer에게 알림이 전달될 때 실행 순서 보장이 어려움 메모리 누수 가능성: Observer 해제를 제대로 하지 않으면 메모리 누수 발생 위험 복잡성 증가: Observer가 많아질수록 디버깅과 테스트가 어려워질 수 있음 주의사항 및 고려사항 순환 참조 방지: Observer가 Subject를 다시 업데이트하는 순환 참조 상황 주의 메모리 관리: Observer 등록 해제를 확실히 처리 상태 일관성 유지: 다수의 Observer가 있을 때 상태 일관성 보장 비동기 처리 고려: 많은 Observer가 있을 경우 비동기 처리 검토 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from abc import ABC, abstractmethod from typing import List # Observer 인터페이스 class NewsObserver(ABC): @abstractmethod def update(self, news: str) -> None: pass # Subject(Observable) 클래스 class NewsAgency: def __init__(self): self._observers: List[NewsObserver] = [] self._latest_news: str = "" def attach(self, observer: NewsObserver) -> None: if observer not in self._observers: self._observers.append(observer) def detach(self, observer: NewsObserver) -> None: self._observers.remove(observer) def notify_observers(self) -> None: for observer in self._observers: observer.update(self._latest_news) def publish_news(self, news: str) -> None: self._latest_news = news self.notify_observers() # Concrete Observer 클래스들 class NewsChannel(NewsObserver): def __init__(self, name: str): self.name = name def update(self, news: str) -> None: print(f"{self.name} received news: {news}") class NewsApp(NewsObserver): def __init__(self, app_name: str): self.app_name = app_name def update(self, news: str) -> None: print(f"{self.app_name} pushing notification: {news}") # 사용 예시 def main(): # Subject 생성 news_agency = NewsAgency() # Observer 생성 bbc = NewsChannel("BBC") cnn = NewsChannel("CNN") news_app = NewsApp("Breaking News App") # Observer 등록 news_agency.attach(bbc) news_agency.attach(cnn) news_agency.attach(news_app) # 뉴스 발행 news_agency.publish_news("Breaking: Major tech breakthrough announced!") # Observer 제거 news_agency.detach(cnn) # 새로운 뉴스 발행 news_agency.publish_news("Update: More details on tech breakthrough…") if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // Observer 인터페이스 (TypeScript 스타일) interface WeatherObserver { update(temperature: number, humidity: number): void; } // Subject(Observable) 클래스 class WeatherStation { private observers: WeatherObserver[] = []; private temperature: number = 0; private humidity: number = 0; public attach(observer: WeatherObserver): void { const isExist = this.observers.includes(observer); if (!isExist) { this.observers.push(observer); } } public detach(observer: WeatherObserver): void { const observerIndex = this.observers.indexOf(observer); if (observerIndex !== -1) { this.observers.splice(observerIndex, 1); } } public notify(): void { for (const observer of this.observers) { observer.update(this.temperature, this.humidity); } } public setMeasurements(temperature: number, humidity: number): void { this.temperature = temperature; this.humidity = humidity; this.notify(); } } // Concrete Observer 클래스들 class WeatherDisplay implements WeatherObserver { private name: string; constructor(name: string) { this.name = name; } public update(temperature: number, humidity: number): void { console.log( `${this.name} Display: Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } class WeatherLogger implements WeatherObserver { public update(temperature: number, humidity: number): void { console.log( `Logging - Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } // 사용 예시 function main() { // Subject 생성 const weatherStation = new WeatherStation(); // Observer 생성 const phoneDisplay = new WeatherDisplay("Phone"); const tabletDisplay = new WeatherDisplay("Tablet"); const logger = new WeatherLogger(); // Observer 등록 weatherStation.attach(phoneDisplay); weatherStation.attach(tabletDisplay); weatherStation.attach(logger); // 날씨 정보 업데이트 console.log("First weather update:"); weatherStation.setMeasurements(24, 65); // Observer 제거 weatherStation.detach(tabletDisplay); // 새로운 날씨 정보 업데이트 console.log("\nSecond weather update:"); weatherStation.setMeasurements(27, 70); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:16:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;779 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/observer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Access Modifiers</h2></header><div class=entry-content><p>Access Modifiers 객체지향 프로그래밍(OOP)에서 접근 제어자(Access Modifiers)는 클래스, 메서드, 변수 등의 접근 범위를 제어하는 중요한 개념이다. 이를 통해 캡슐화를 구현하고 코드의 안정성과 유지보수성을 향상시킬 수 있다.
접근 제어자를 적절히 사용하면 객체지향 프로그래밍의 핵심 원칙인 캡슐화를 효과적으로 구현할 수 있으며, 이는 코드의 품질과 유지보수성을 크게 향상시킨다.
접근 제어자의 종류 public
가장 넓은 접근 범위를 가진다. 어떤 클래스에서든 접근이 가능하다. 모든 패키지의 모든 클래스에서 이 요소에 접근할 수 있다. 1 2 3 4 5 6 class BankAccount: def __init__(self): self.account_number = "123-456-789" # public 변수 def get_balance(self): # public 메서드 return self.balance protected
...</p></div><footer class=entry-footer><span title='2024-09-23 04:49:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;906 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Access Modifiers" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/access-modifiers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KISS Principle</h2></header><div class=entry-content><p>KISS (Keep It Simple, Stupid) 원칙 시스템이나 코드의 복잡성을 최소화하라.
잘못된 예 1 2 3 4 5 6 def complex_calculation(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z): # 너무 많은 파라미터와 복잡한 로직이 포함되어 있음 result = a + b - c * d / e + f - g + h + i - j + k * l / m - n + o - p + q + r - s + t + u - v + w - x + y - z return result # 주석: 함수가 너무 복잡하고 많은 파라미터를 사용하여 KISS를 위반합니다. 잘된 예 1 2 3 4 5 def simple_calculation(a,b,c): result = a + b - c return result # 주석: 필요한 최소한의 파라미터와 간단한 로직으로 KISS를 준수합니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 01:00:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;123 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to KISS Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAGNI Principle</h2></header><div class=entry-content><p>YAGNI(You Ain’t Gonna Need It) Principle 당장 필요하지 않은 기능을 미리 구현하지 마라.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.loyalty_points = 0 # 아직 사용하지 않는 기능 def upgrade_to_premium(self): self.premium_member = True def add_loyalty_points(self, points): # 아직 사용하지 않는 기능 self.loyalty_points += points # 주석: 아직 사용하지 않는 loyalty_points 기능을 미리 구현하여 YAGNI 원칙을 위반합니다. # 이는 불필요한 복잡성을 추가하고, 실제로 필요하지 않을 수 있는 기능을 유지보수해야 하는 부담을 줍니다. class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.vip_status = False # 아직 필요 없는 기능 self.loyalty_points = 0 # 아직 필요 없는 기능 self.referred_users = [] # 아직 필요 없는 기능 self.last_login_history = [] # 아직 필요 없는 기능 def calculate_benefits(self): # 복잡한 혜택 계산 로직 (아직 필요 없음) pass def generate_referral_code(self): # 추천 코드 생성 로직 (아직 필요 없음) pass def track_login_history(self): # 로그인 이력 추적 로직 (아직 필요 없음) pass 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 주석: 현재 필요한 기능만 구현하여 YAGNI 원칙을 준수합니다. # 이를 통해 코드를 간결하게 유지하고, 실제로 필요한 기능이 확인될 때 추가할 수 있습니다. # YAGNI 준수 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 나중에 필요할 때 기능을 추가 class PremiumUser(User): def __init__(self, name, email): super().__init__(name, email) self.premium_member = True def get_premium_benefits(self): return ["무료 배송", "특별 할인"] 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:59:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAGNI Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle 코드 중복을 피하고 로직을 한 곳에서 관리하도록 권장하는 원칙.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = width * height perimeter = 2 * (width + height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 면적과 둘레 계산 로직이 중복되어 DRY 원칙을 위반합니다. # 계산 로직이 변경될 경우 여러 곳을 수정해야 하며, 실수의 가능성이 높아집니다. # 코드 중복 class Order: def calculate_total_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 total = total * 1.1 # 배송비 추가 if total &lt; 50: total += 10 return total class Cart: def calculate_preview_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 (중복된 로직) total = total * 1.1 # 배송비 추가 (중복된 로직) if total &lt; 50: total += 10 return total 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = calculate_rectangle_area(width, height) perimeter = calculate_rectangle_perimeter(width, height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 계산 로직을 함수로 분리하여 재사용하므로 DRY 원칙을 준수합니다. # 로직 변경 시 한 곳만 수정하면 되어 유지보수가 용이하고 일관성을 유지할 수 있습니다. # DRY 원칙 적용 class PriceCalculator: @staticmethod def calculate_price(items): total = sum(item.price for item in items) total = PriceCalculator.apply_tax(total) total = PriceCalculator.add_shipping_fee(total) return total @staticmethod def apply_tax(amount): return amount * 1.1 @staticmethod def add_shipping_fee(amount): return amount + 10 if amount &lt; 50 else amount class Order: def calculate_total_price(self, items): return PriceCalculator.calculate_price(items) class Cart: def calculate_preview_price(self, items): return PriceCalculator.calculate_price(items) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:58:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙.
단일 책임 원칙 (Single Responsibility Principle, SRP) 클래스는 단 하나의 책임만 가져야 한다.
여기서 ‘책임’이란 ‘변경의 이유’를 의미한다. 즉, 모듈은 오직 하나의 액터에 의해서만 변경되어야 한다.
이를 통해 코드의 모듈성과 유지보수성이 향상된다.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class User: def __init__(self, name): self.name = name def get_name(self): return self.name def save(self): # 데이터베이스에 사용자 정보를 저장하는 로직 pass def send_email(self, message): # 이메일을 보내는 로직 pass # 주석: 이 클래스는 사용자 정보 관리, 데이터베이스 저장, 이메일 발송 등 # 여러 책임을 가지고 있어 SRP를 위반합니다. 변경 사유가 여러 개 발생할 수 있습니다. 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class User: def __init__(self, name): self.name = name def get_name(self): return self.name class UserRepository: def save(self, user): # 데이터베이스에 사용자 정보를 저장하는 로직 pass class EmailService: def send_email(self, user, message): # 이메일을 보내는 로직 pass # 주석: 각 클래스가 단일 책임을 가지도록 분리되어 SRP를 준수합니다. # User 클래스는 사용자 정보만 관리하고, UserRepository는 저장을, # EmailService는 이메일 발송만 담당합니다. 각 기능의 변경이 다른 클래스에 영향을 주지 않습니다. 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다는 의미이다.
주로 상속이나 구성을 통해 달성되며, 안정적이고 오류가 적은 코드베이스를 만든다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;923 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-09-22 12:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;647 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Class and Object and Instance</h2></header><div class=entry-content><p>Class and Object and Instance 객체 지향 프로그래밍(Object-Oriented Programming, OOP)에서 클래스(Class)와 객체(Object), 그리고 인스턴스(Instance)는 핵심적인 개념이다.
클래스(Class) 클래스는 객체를 생성하기 위한 템플릿 또는 청사진이다.
정의: 객체를 정의해놓은 것 또는 객체의 설계도/틀 용도: 객체를 생성하는데 사용됨 구성: 연관된 데이터(속성)와 메서드(행동)의 집합 특징: 메모리를 차지하지 않음 한 번만 선언됨 예를 들어, ‘자동차’ 클래스는 모든 자동차의 공통적인 특성(브랜드, 모델, 색상 등)과 행동(시동 걸기, 가속하기 등)을 정의한다.
1 2 3 4 5 6 7 8 9 10 11 12 class Car: # 생성자: 객체가 생성될 때 초기화하는 메서드 def __init__(self, brand, color, year): self.brand = brand # 브랜드 속성 self.color = color # 색상 속성 self.year = year # 연식 속성 self.engine_on = False # 시동 상태 # 시동 걸기 메서드 def start_engine(self): self.engine_on = True return f"{self.brand} 차량의 시동을 겁니다." 객체(Object) 객체는 클래스를 기반으로 생성된 실체.
...</p></div><footer class=entry-footer><span title='2024-09-22 12:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;337 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Object and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-object-and-instance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다형성 (Polymorphism)</h2></header><div class=entry-content><p>다형성 (Polymorphism) 다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 특징 중 하나로, “여러 가지 형태를 가질 수 있는 능력"을 의미한다. 하나의 객체가 여러 가지 타입을 가질 수 있거나, 동일한 동작이 다양한 방식으로 실행될 수 있는 것을 말한다.
다형성의 본질은 “하나의 인터페이스, 다양한 구현"이다. 마치 리모컨이라는 하나의 인터페이스로 TV, 에어컨, 음향기기 등 다양한 기기를 제어할 수 있는 것과 같다.
실생활 예시 키보드의 Enter 키를 생각해보면 다형성을 쉽게 이해할 수 있다:
텍스트 편집기에서는 새로운 줄을 만든다 대화창에서는 메시지를 전송한다 웹 브라우저의 주소창에서는 페이지를 로드한다 같은 Enter 키지만, 상황에 따라 다른 동작을 수행하는 것이 바로 다형성의 예시이다.
...</p></div><footer class=entry-footer><span title='2024-09-22 10:25:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;784 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 다형성 (Polymorphism)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/polymorphism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>상속 (Inheritance)</h2></header><div class=entry-content><p>상속 (Inheritance) 상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 기존 클래스의 특성을 다른 클래스가 물려받아 재사용하고 확장할 수 있게 해주는 메커니즘이다.
이를 통해 코드의 재사용성을 높이고 계층적인 관계를 구현할 수 있다.
상속을 사용할 때 가장 중요한 세 가지 원칙이 있다:
IS-A 관계 확인: 자식 클래스는 반드시 부모 클래스의 한 종류여야 한다. “고양이는 동물이다"는 성립하지만, “자동차는 엔진이다"는 성립하지 않는다. 기능의 확장: 자식 클래스는 부모 클래스의 기능을 물려받아 확장하는 것이 목적이다. 기존 기능을 제한하거나 완전히 다른 의미로 변경하는 것은 좋지 않다. 적절한 캡슐화: protected 접근 제어자를 통해 상속 관계에서만 접근 가능한 멤버를 적절히 설계해야 한다. 상속의 의미 상속을 통해 우리는 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-22 10:10:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;818 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상속 (Inheritance)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/primary-principles/inheritance/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/73/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/75/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>