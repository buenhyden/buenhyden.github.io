<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.146.7"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)</h2></header><div class=entry-content><p>클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program) 클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)은 한국인터넷진흥원(KISA)에서 주관하는 클라우드 서비스의 보안성을 평가하고 인증하는 제도.
이 제도는 클라우드 서비스 이용자의 정보보호를 강화하고 클라우드 서비스의 안정성과 신뢰성을 검증하기 위해 도입되었다.
CSAP의 주요 특징 인증 유형: CSAP는 다음과 같은 유형으로 분류된다:
IaaS (Infrastructure as a Service) SaaS (Software as a Service) DaaS (Desktop as a Service) 인증 등급: 2022년 12월 29일, 과학기술정보통신부는 CSAP 인증 기준을 개선하여 3단계 등급 체계(상, 중, 하)를 도입함.
...</p></div><footer class=entry-footer><span title='2024-09-19 11:39:00 +0000 UTC'>September 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 클라우드 서비스 보안인증(CSAP, Cloud Security Assurance Program)" href=https://buenhyden.github.io/posts/security/governance-and-management/compliance-and-regulations/cloud-security-assurance-program/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server-Sent Events vs. Webhook</h2></header><div class=entry-content><p>Server-Sent Events vs. Webhook 실시간 애플리케이션을 개발할 때 서버와 클라이언트 간의 효율적인 통신 방식을 선택하는 것은 매우 중요하다. 서버 전송 이벤트(Server-Sent Events, SSE)와 웹훅(Webhook)은 모두 서버에서 클라이언트로 데이터를 전달하는 방법이지만, 그 작동 방식과 적합한 사용 사례가 크게 다르다.
서버 전송 이벤트(SSE) 기본 개념 서버 전송 이벤트(SSE)는 HTTP 연결을 통해 서버에서 클라이언트로 단방향 실시간 이벤트 스트림을 전송하는 기술이다. HTML5 표준의 일부로, 웹 브라우저에서 EventSource API를 통해 구현된다. SSE는 표준 HTTP 프로토콜 위에서 작동하며, 별도의 프로토콜 전환 없이 실시간 데이터 푸시가 가능하다.
...</p></div><footer class=entry-footer><span title='2025-03-08 06:04:00 +0000 UTC'>March 8, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-Sent Events vs. Webhook" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/event-based-style/server-sent-events/server-sent-events-vs-webhook/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>E-Commerce Service</h2></header><div class=entry-content><p>E-Commerce Service 여러 사용자가 동시에 하나의 물품을 구매하려고 할 때 발생할 수 있는 문제를 해결하기 위해 다음과 같은 요소들을 고려해야 한다.
고려해야 할 요소 동시성 제어: 여러 사용자가 동시에 같은 물품을 구매하려 할 때 발생할 수 있는 충돌을 관리해야 한다. 재고 관리: 실시간으로 정확한 재고 수량을 유지하고 업데이트해야 한다. 트랜잭션 일관성: 결제 과정과 재고 감소가 일관성 있게 처리되어야 한다. 사용자 경험: 구매 과정에서 사용자에게 명확한 피드백을 제공해야 한다. 핵심 영역 상품 관리 시스템 상품 정보 관리 (이름, 가격, 재고, 카테고리, 상품 상태 등) 재고 관리 시스템 (동시성 제어가 매우 중요) 상품 검색 및 필터링 기능 이미지 처리 및 저장 주문 처리 시스템 (매우 중요) 주문 상태 관리 (결제대기, 결제완료, 배송준비, 배송중, 배송완료 등) 장바구니 기능 동시 주문 처리를 위한 동시성 제어 재고 차감 로직 주문 취소/환불 처리 결제 시스템 결제 게이트웨이 연동 결제 상태 관리 결제 실패 처리 환불 처리 결제 보안 (매우 중요) 사용자 관리 회원가입/로그인 권한 관리 개인정보 보호 주소록 관리 구매 이력 관리 구현 방법 데이터베이스 수준의 잠금 (Database-Level Locking) 낙관적 잠금 (Optimistic Locking) 낙관적 잠금은 대부분의 트랜잭션이 충돌하지 않는다는 가정하에 작동한다.
...</p></div><footer class=entry-footer><span title='2024-12-03 12:54:00 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to E-Commerce Service" href=https://buenhyden.github.io/posts/system-design/case-studies/e-commerce-service/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>선사용 IT 솔루션</h2></header><div class=entry-content><p>선사용 IT 솔루션 선사용 IT 솔루션을 개발하기 위해 필요한 주요 기능과 서비스는 다음과 같다.
이는 해운업계의 디지털 전환 사례와 최신 기술 트렌드를 기반으로 정리되었다.
선박 운영 및 관리 선대 관리: 선박의 위치, 상태, 운항 스케줄을 실시간으로 모니터링하고 관리하는 기능. 연료 효율 관리: 연료 소비를 최적화하고 탄소 배출을 줄이기 위한 경로 최적화 및 연료 절감 시스템. 선박 유지보수: 선박 장비의 상태를 실시간으로 모니터링하고 예측 유지보수를 지원하는 시스템. 화물 및 물류 관리 화물 추적: RFID 및 IoT 기술을 활용하여 화물의 위치, 상태, 온도 등을 실시간으로 추적. 문서 디지털화: 블록체인을 활용한 전자 선하증권(e-BL) 및 기타 물류 문서의 디지털화로 투명성과 보안 강화. 물류 최적화: 화물 적재 및 하역 작업의 효율성을 높이고, 비용을 절감하는 시스템. 데이터 분석 및 의사결정 지원 빅데이터 분석: 선박 운항 데이터와 물류 데이터를 분석하여 운영 효율성과 비용 절감을 위한 인사이트 제공. AI 기반 분석: AI를 활용한 운항 경로 최적화, 사고 예방, 장비 고장 예측 등의 기능. 고객 서비스 향상 실시간 정보 제공: 고객에게 화물 상태와 예상 도착 시간 등의 정보를 실시간으로 제공하는 기능. 사용자 친화적인 인터페이스: 직관적인 UI/UX를 통해 고객과 운영자가 쉽게 시스템을 사용할 수 있게 설계. 통합 및 자동화 시스템 통합: ERP, WMS 등 기존 시스템과의 원활한 통합을 통해 데이터 공유와 프로세스 간소화. 자동화 프로세스: 문서 생성, 데이터 입력, 보고서 작성 등 반복 작업의 자동화를 통해 생산성 향상. 보안 및 규제 준수 보안 강화: 데이터 암호화, 접근 제어 등으로 민감한 정보를 보호하고 사이버 보안을 강화. 국제 규제 준수: IMO(국제해사기구) 탄소 배출 규제 및 CII 등급 관리 지원. 선원 복지 선상 인터넷 서비스: 저렴한 위성통신 비용으로 선원들에게 인터넷 접속 환경 제공. 안전 관리: AI 기반 CCTV 분석으로 선원의 이상 상태나 위험 상황을 사전에 감지하여 대응. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-03 01:43:00 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 선사용 IT 솔루션" href=https://buenhyden.github.io/posts/system-design/case-studies/%EC%84%A0%EC%82%AC%EC%9A%A9-it-%EC%86%94%EB%A3%A8%EC%85%98/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>물류 운송 관리 시스템 (Transportation Management System, TMS)</h2></header><div class=entry-content><p>물류 운송 관리 시스템 (Transportation Management System, TMS) TMS(Transportation Management System)는 물류 운송 관리 시스템으로, 기업의 물류 운송 프로세스를 효율적으로 관리하고 최적화하기 위한 솔루션이다.
TMS는 운송 계획 수립부터 실제 배송, 비용 정산까지 물류 운송과 관련된 모든 프로세스를 통합적으로 관리한다.
이는 마치 교통관제센터가 도시의 모든 교통 흐름을 모니터링하고 관리하는 것과 유사하다.
TMS가 제공하는 주요 기능 운송 계획 및 최적화
운송 경로를 최적화하여 배송 시간과 비용을 절감한다.
예를 들어, 여러 배송지를 방문해야 할 때 가장 효율적인 경로를 계산하고, 차량의 적재 용량을 고려하여 최적의 배차 계획을 수립한다.
실시간 교통 정보를 반영하여 더욱 정확한 계획이 가능하다.
...</p></div><footer class=entry-footer><span title='2024-12-03 06:56:00 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 물류 운송 관리 시스템 (Transportation Management System, TMS)" href=https://buenhyden.github.io/posts/system-design/case-studies/transportation-management-system/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Enterprise Resource Planning</h2></header><div class=entry-content><p>ERP (Enterprise Resource Planning) ERP(Enterprise Resource Planning)는 기업의 모든 자원을 통합적으로 관리하고 운영하기 위한 시스템.
ERP는 기업의 인력, 자본, 자재, 기계 등 모든 경영자원을 효율적으로 통합 관리하여 기업의 경쟁력을 높이는 통합정보시스템이다.
이는 재무, 인사, 생산, 물류, 영업 등 기업의 전반적인 업무 프로세스를 하나의 통합된 시스템으로 구축하여 정보를 공유하고 업무 효율을 높이는 것을 목표로 한다.
ERP의 주요 기능 및 서비스 재무/회계 관리
자금, 손익, 매출, 비용 등의 재무 정보 관리 회계 보고서 자동 생성 인사/급여 관리
...</p></div><footer class=entry-footer><span title='2024-12-03 00:01:00 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Enterprise Resource Planning" href=https://buenhyden.github.io/posts/system-design/case-studies/enterprise-resource-planning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Warehouse Management System</h2></header><div class=entry-content><p>창고 관리 시스템 (Warehouse Management System, WMS) WMS(Warehouse Management System)는 창고 관리 시스템으로, 창고 내의 물류 프로세스를 최적화하고 효율적으로 관리하기 위한 소프트웨어 애플리케이션을 말한다.
WMS는 재고 관리, 주문 처리, 입출고 관리 등 창고 운영의 전반적인 과정을 자동화하고 최적화하는 데 사용된다.
WMS의 주요 기능과 서비스 재고 관리 및 추적 실시간 재고 수준 모니터링 재고 위치 추적 및 최적화 바코드 및 RFID 기술을 활용한 재고 추적 주문 관리 및 처리 주문 접수 및 처리 자동화 피킹, 패킹, 배송 프로세스 최적화 주문 상태 실시간 추적 입고 및 출고 관리 입고 예약 및 처리 출고 계획 수립 및 실행 크로스도킹 관리 공간 최적화 창고 레이아웃 최적화 보관 위치 할당 및 관리 공간 활용도 분석 노동력 관리 작업 할당 및 스케줄링 직원 성과 추적 및 분석 생산성 향상을 위한 작업 최적화 보고 및 분석 재고 보고서 생성 성과 지표(KPI) 분석 예측 분석 및 의사결정 지원 운송 관리 배송업체 선택 및 비용 최적화 배송 추적 및 상태 업데이트 운송 문서 자동 생성 시스템 통합 ERP, TMS 등 다른 비즈니스 시스템과의 통합 EDI(전자데이터교환) 지원 API를 통한 맞춤형 통합 지원 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-03 00:01:00 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Warehouse Management System" href=https://buenhyden.github.io/posts/system-design/case-studies/warehouse-management-system/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>setup.cfg vs pyproject.toml</h2></header><div class=entry-content><p>setup.cfg vs. pyproject.toml setup.cfg와 pyproject.toml은 Python 프로젝트의 구성과 메타데이터를 정의하는 파일 형식이다.
이 두 파일은 프로젝트 설정, 의존성, 빌드 시스템 등을 관리하는 데 사용되며, 각각의 특징과 용도가 있다.
setup.cfg는 setuptools를 사용하는 전통적인 Python 패키징 시스템의 일부이다.
형식: INI 스타일의 설정 파일 주요 용도: 프로젝트 메타데이터 정의 (이름, 버전, 설명 등) 의존성 선언 패키지 데이터 및 스크립트 설정 특징: setup.py와 함께 사용되어 왔음 정적 메타데이터를 선언적으로 정의하는 데 적합 레거시 도구와의 호환성 유지 pyproject.toml은 PEP 518에서 도입된 새로운 표준 구성 파일이다.
...</p></div><footer class=entry-footer><span title='2024-11-27 14:29:00 +0000 UTC'>November 27, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to setup.cfg vs pyproject.toml" href=https://buenhyden.github.io/posts/programming-languages/python/fundamentals/configuration/setup.cfg-vs-pyproject.toml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloud vs. On-Premise</h2></header><div class=entry-content><p>Cloud vs. On-Premise Cloud와 On-Premise는 기업의 IT 인프라를 구축하고 관리하는 두 가지 주요 방식을 설명하는 개념이다.
이 두 방식은 데이터 저장, 애플리케이션 호스팅, 그리고 전반적인 IT 리소스 관리에 있어 근본적인 차이를 보인다.
비교 항목 On-Premise 클라우드 초기 구축 비용 - 서버, 네트워크 장비 등 높은 초기 투자 필요
- 데이터센터 구축 비용 발생
- 소프트웨어 라이선스 구매 필요 - 초기 투자 비용 최소화
- 필요한 만큼만 시작 가능
- 하드웨어 구매 불필요 운영 비용 - 예측 가능한 고정 비용
- 전담 IT 인력 필요
- 전기, 냉각 등 관리 비용 발생 - 사용량 기반 과금
- 탄력적인 비용 구조
- 운영 인력 최소화 가능 확장성 - 물리적 인프라 확장 필요
- 확장 시 많은 시간과 비용 소요
- 사전 용량 계획 중요 - 필요에 따라 즉시 확장 가능
- 자동 확장/축소 지원
- 글로벌 확장 용이 보안 - 물리적 보안 직접 통제
- 데이터 위치 완벽 통제
- 자체 보안 정책 수립 가능 - 서비스 제공자의 보안 정책 따름
- 공유 인프라 사용
- 데이터 위치 선택 제한적 유지보수 - 모든 유지보수 직접 담당
- 정기적인 하드웨어 교체 필요
- 패치/업그레이드 직접 관리 - 서비스 제공자가 유지보수 담당
- 자동 업데이트/패치 적용
- 최신 기술 자동 적용 커스터마이징 - 완전한 커스터마이징 자유
- 하드웨어/소프트웨어 직접 선택
- 특수 요구사항 수용 용이 - 제한된 커스터마이징
- 제공되는 서비스 내에서 선택
- 표준화된 서비스 위주 가용성 - 자체 인프라로 안정성 확보
- 인터넷 연결 없이도 운영 가능
- 장애 대응 직접 수행 - 서비스 제공자의 SLA 따름
- 인터넷 연결 필수
- 여러 지역 동시 운영 가능 데이터 주권 - 완벽한 데이터 통제권 보유
- 물리적 데이터 위치 확실
- 규제 준수 용이 - 데이터 주권 일부 제한
- 국가간 데이터 이동 가능
- 규제 준수 확인 필요 접근성 - 내부 네트워크 중심
- 원격 접속 별도 구성 필요
- 물리적 접근 통제 가능 - 언제 어디서나 접근 가능
- 다양한 디바이스 지원
- 글로벌 접근성 우수 재해 복구 - 별도의 재해복구 센터 필요
- 높은 구축/운영 비용
- 복구 절차 직접 수행 - 자동화된 백업/복구
- 여러 지역 복제 용이
- 신속한 재해 복구 적합한 상황 - 높은 보안이 필요한 경우
- 특수한 규제 준수 필요
- 레거시 시스템 운영 - 빠른 시작이 필요한 경우
- 유연한 확장성 필요
- 글로벌 서비스 제공 실제로는 많은 기업들이 두 방식의 장점을 모두 활용하는 하이브리드 형태를 채택하고 있다.
기업의 특성, 요구사항, 예산 등을 종합적으로 고려하여 적절한 방식을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-11-10 10:33:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cloud vs. On-Premise" href=https://buenhyden.github.io/posts/platform-engineering/infrastructure/cloud/cloud-vs-on-premise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Shared Database vs Shared Database Per Service</h2></header><div class=entry-content><p>Shared Database vs. Shared Database Per Service MSA(Microservices Architecture)에서 Shared Database와 Shared Database Per Service 패턴은 데이터 관리 전략의 일환으로 활용되며, 각각의 특징과 적용 시나리오가 뚜렷하게 구분된다.
두 패턴 모두 단일 데이터베이스 의존성으로 인한 리스크가 존재하므로, 장기적 관점에서는 Database Per Service로의 전환을 고려해야 한다. 특히 클라우드 환경(AWS RDS, Aurora)에서는 논리적 분리가 용이하나, 트랜잭션 격리와 확장성 측면에서 trade-off를 신중히 평가해야 한다.
Shared Database 패턴 정의 및 특징 여러 마이크로서비스가 단일 데이터베이스를 공유하며, 서비스 간 자유로운 테이블 접근 허용. 직접적인 ACID 트랜잭션을 통해 데이터 일관성 유지. 간단한 아키텍처로 시작 단계에서 빠른 개발 가능. 동작 방식 1 2 3 4 5 -- OrderService가 CustomerService의 테이블 직접 접근 예시 BEGIN TRANSACTION; SELECT CREDIT_LIMIT FROM CUSTOMERS WHERE CUSTOMER_ID = 123; INSERT INTO ORDERS (CUSTOMER_ID, AMOUNT) VALUES (123, 50000); COMMIT; 서비스 간 스키마 변경 시 협업 필요 (예: Customer 테이블 컬럼 추가 → OrderService 코드 수정). 장단점 장점 단점 - 복잡한 분산 트랜잭션 불필요 - 서비스 간 강한 결합성 발생 - 데이터 조인 및 통합 쿼리 용이 - 단일 데이터베이스 병목 현상 (SPOF) - 기존 모놀리식 시스템 전환 용이 - 스키마 변경 시 전체 서비스 영향도 검토 필요 적합한 시나리오 소규모 팀에서 신속한 프로토타이핑 필요 시. 레거시 시스템을 MSA로 점진적 전환하는 과정에서 임시 활용. 강한 ACID 트랜잭션 요구사항이 있는 금융/결제 시스템. Shared Database Per Service 패턴 정의 및 특징 단일 물리적 데이터베이스 인스턴스를 공유하지만, 서비스별 논리적 분리 (스키마/테이블 격리). 핫 테이블(Hot Table) 방지를 통해 성능 저하 최소화. 하위 호환성 유지가 필수적이며, 스키마 변경 시 모든 서비스 영향도 검토. 동작 방식 1 2 3 -- Sales 서비스: sales_db.sales_table -- Customer 서비스: sales_db.customer_table (논리적 분리) GRANT SELECT, INSERT ON sales_db.customer_table TO 'customer_service'@'%'; IAM 정책 또는 DB 권한 제어를 통해 서비스별 접근 범위 제한. 장단점 장점 단점 - 물리적 인프라 비용 절감 - 여전히 런타임 결합성 존재 - 부분적 스키마 독립성 보장 - 장기적 유지보수 복잡성 증가 - 데이터 중복 최소화 - 확장성 제약 (CPU/IO 리소스 경쟁) 적합한 시나리오 제한된 리소스 환경에서 다중 서비스 운영 필요 시. 기존 데이터 레이어 재설계 없이 MSA 도입 시. 규제 준수 요구사항으로 단일 데이터베이스 유지해야 하는 경우. 비교 분석표 항목 공유 데이터베이스 (Shared Database) 서비스별 전용 데이터베이스 (Database per Service) 데이터 격리 수준 테이블 수준 공유 스키마/테이블 논리적 분리 데이터 일관성 유지 ACID 트랜잭션을 통해 데이터 일관성을 쉽게 유지할 수 있습니다. 분산된 데이터로 인해 데이터 일관성 유지가 복잡해질 수 있으며, 이를 위해 사가(Saga) 패턴 등의 사용이 필요할 수 있습니다. 스키마 변경 영향도 모든 서비스 영향 관련 서비스만 영향 결합도 높음 (직접 테이블 접근) 중간 (권한 제어를 통한 제한적 접근) 서비스 독립성 데이터베이스 스키마 변경 시 여러 서비스 간 조율이 필요하여 서비스 간 결합도가 높아집니다. 각 서비스가 독립적인 데이터베이스를 소유하므로 서비스 간 결합도가 낮아 독립적인 개발, 배포, 확장이 가능합니다. 데이터베이스 선택 모든 서비스가 동일한 데이터베이스를 사용하므로 개별 서비스의 특수한 데이터 저장 요구 사항을 충족하기 어렵습니다. 각 서비스는 자신의 요구에 맞는 데이터베이스 유형을 선택할 수 있어 폴리글랏 퍼시스턴스(Polyglot Persistence)를 구현할 수 있습니다. 운영 복잡성 단일 데이터베이스를 관리하므로 운영이 단순합니다. 여러 개의 데이터베이스를 관리해야 하므로 운영 복잡성이 증가합니다. 트랜잭션 관리 로컬 ACID 트랜잭션 가능.
단일 데이터베이스 내에서 트랜잭션을 관리하므로 구현이 용이합니다. 로컬 ACID 트랜잭션 가능.
분산 트랜잭션 관리가 필요할 수 있으며, 이는 구현의 복잡성을 증가시킵니다. 확장성 단일 데이터베이스의 확장에 한계가 있을 수 있으며, 특정 서비스의 확장이 다른 서비스에 영향을 미칠 수 있습니다. 각 서비스가 독립적으로 확장 가능하므로 시스템 전체의 확장성이 향상됩니다. 보안 모든 서비스가 전체 데이터 접근 가능 권한 제어로 접근 범위 제한 패턴 선택 가이드 Shared Database 선택 시: 개발 초기 단계에서 빠른 출시를 목표로 할 때. 팀 규모가 작고 데이터 복잡도가 낮은 경우. Shared Database Per Service 선택 시: 기존 모놀리식 DB를 유지하며 MSA를 도입해야 할 때. 데이터 중복을 최소화해야 하지만 완전 분리가 어려운 경우. Database Per Service 권장 시: 대규모 시스템에서 완전한 독립성과 확장성이 필요할 때. 서비스별 폴리글랏 퍼시스턴스 적용이 필요한 경우. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-12 08:02:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Shared Database vs Shared Database Per Service" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/database/shared-database-vs-shared-database-per-service/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/10/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/12/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>