<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프로미스(Promise)</h2></header><div class=entry-content><p>프로미스(Promise) 프로미스(Promise)는 자바스크립트에서 비동기 처리를 위해 사용되는 객체이다.
프로미스(Promise)는 비동기 작업의 최종 완료 또는 실패를 나타내는 객체이다.
이는 비동기 처리를 동기적으로 처리할 수 있게 해주며, 콜백 함수의 단점을 보완한다.
프로미스(Promise)의 상태 프로미스(Promise)는 세 가지 상태를 가진다.
대기(Pending): 초기 상태, 비동기 처리 로직이 아직 완료되지 않은 상태 이행(Fulfilled): 비동기 처리가 성공적으로 완료되어 프로미스(Promise)가 결과 값을 반환한 상태 거부(Rejected): 비동기 처리가 실패하거나 오류가 발생한 상태 Promise 생성자와 Executor 함수의 기본 구조 프로미스(Promise)는 new Promise() 생성자를 통해 생성된다.
Promise를 생성할 때는 다음과 같은 구조를 사용한다:
...</p></div><footer class=entry-footer><span title='2024-11-21 14:54:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;979 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프로미스(Promise)" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/promise/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Loop</h2></header><div class=entry-content><p>Event Loop 이벤트 루프(Event Loop)는 자바스크립트의 비동기 작업을 관리하고 실행하는 핵심 메커니즘으로, 싱글 스레드 언어인 자바스크립트가 비동기적으로 동작할 수 있게 해주는 중요한 요소이다.
끊임없이 실행되는 프로세스로, 콜 스택이 비어있는지 확인하고 태스크 큐에서 콜백 함수를 가져와 실행하며, 자바스크립트 엔진이 아닌 호스팅 환경(브라우저 또는 Node.js)에서 제공되는 메커니즘이다. 또한, 비동기 작업의 완료 및 해당 콜백의 실행을 조정한다.
Event Loop의 구성 요소 콜 스택 (Call Stack): 현재 실행 중인 함수들이 쌓이는 곳. 후입선출(LIFO) 구조 웹 API (Web APIs): 브라우저에서 제공하는 비동기 작업을 처리하는 API. 콜백 큐 (Callback Queue): 비동기 작업이 완료된 후 실행될 콜백 함수들이 대기하는 곳. 선입선출(FIFO) 구조 이벤트 루프 (Event Loop): 콜 스택과 콜백 큐를 모니터링하며 작업을 조율. Event Loop의 동작 과정 JavaScript 코드가 실행되면 함수 호출은 콜 스택에 쌓인다. 비동기 함수(예: setTimeout, fetch)를 만나면 웹 API로 보내져 별도로 처리된다. 웹 API에서 작업이 완료되면 해당 콜백 함수를 콜백 큐로 보낸다. 이벤트 루프는 지속적으로 콜 스택이 비어있는지 확인한다. 콜 스택이 비어있다면, 이벤트 루프는 콜백 큐에서 가장 오래된 콜백을 콜 스택으로 이동시킨다. 이 과정을 반복한다. Event Loop의 기본 개념: 식당 시나리오 상황: 바쁜 식당에서 일하는 웨이터를 생각해보자.
...</p></div><footer class=entry-footer><span title='2024-11-21 12:44:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;662 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Loop" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/event-loop/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>pm2</h2></header><div class=entry-content><p>Pm2 PM2는 Node.js 애플리케이션을 위한 고급 프로덕션 프로세스 관리자.
이는 내장된 로드 밸런서를 포함하고 있으며, 애플리케이션을 항상 실행 상태로 유지하고, 시스템 재부팅 시에도 자동으로 재시작할 수 있게 해주는 도구.
프로세스 관리의 중요성:
서버 애플리케이션을 운영할 때는 단순히 애플리케이션을 실행하는 것 이상의 관리가 필요하다.
예기치 않은 충돌이 발생할 수 있고, 서버가 재시작될 수 있으며, 성능 모니터링이 필요할 수 있다.
PM2는 이러한 운영 관련 문제들을 효과적으로 해결해주는 도구. 주요 기능 프로세스 관리:
...</p></div><footer class=entry-footer><span title='2024-11-21 12:31:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;643 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to pm2" href=https://buenhyden.github.io/posts/programming-languages/javascript/package/pm2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jsdoc</h2></header><div class=entry-content><p>Jsdoc JSDoc은 JavaScript 소스 코드에 대한 API 문서를 생성하기 위한 마크업 언어.
정의와 개념 JavaScript 코드에 대한 설명을 위해 사용되는 주석 시스템. /** */ 형식의 주석 안에 @로 시작하는 특별한 태그를 사용하여 정보를 제공한다. 주요 특징 API 문서 자동 생성: 주석을 기반으로 HTML 형식의 문서를 생성한다. 타입 정보 제공: 함수의 매개변수, 반환값 등의 타입을 명시할 수 있다. 코드 에디터 지원: 많은 IDE에서 JSDoc을 인식하여 자동완성, 타입 체크 등을 제공한다. 주요 태그 @param: 함수 매개변수 설명 @returns: 함수 반환값 설명 @type: 변수의 타입 지정 @typedef: 사용자 정의 타입 생성 @example: 사용 예제 제공 사용 예시 1 2 3 4 5 6 7 8 9 /** * 두 수를 더하는 함수 * @param {number} a - 첫 번째 숫자 * @param {number} b - 두 번째 숫자 * @returns {number} 두 숫자의 합 */ function add(a, b) { return a + b; } 참고 및 출처 Use JSDoc: Index
...</p></div><footer class=entry-footer><span title='2024-11-21 11:41:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;147 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jsdoc" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/jsdoc/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Keywords</h2></header><div class=entry-content><p>Keywords 키워드들은 JavaScript 프로그래밍의 기본 구성 요소이며, ECMAScript 표준의 일부이다.
각 키워드는 특정한 프로그래밍 목적을 위해 설계되었으며, 이들을 올바르게 이해하고 사용하는 것이 효과적인 JavaScript 프로그래밍의 기초가 된다.
선언 관련 키워드 키워드 설명 예시 var 변수 선언 (함수 스코프) var name = "John"; let 변수 선언 (블록 스코프) let age = 25; const 상수 선언 (재할당 불가) const PI = 3.14; function 함수 선언 function add(a, b) { return a + b; } class 클래스 선언 class Person { constructor() {} } 조건문 및 반복문 키워드 키워드 설명 예시 if 조건문 if (age > 18) { console.log("Adult"); } else if문의 대안 조건 else { console.log("Minor"); } switch 다중 분기 조건문 switch (value) { case 1: break; } case switch문의 각 경우 case "A": return "Excellent"; default switch문의 기본 경우 default: return "Invalid"; for 반복문 for (let i = 0; i &lt; 5; i++) {} while 조건기반 반복문 while (count &lt; 10) {} do 최소 한번 실행되는 반복문 do { count++; } while (count &lt; 5); 제어 흐름 키워드 키워드 설명 예시 break 반복문/switch문 탈출 break; continue 현재 반복 건너뛰기 continue; return 함수에서 값 반환 return result; throw 예외 발생 throw new Error("Invalid input"); try 예외처리 시도 블록 try { riskyOperation(); } catch 예외처리 블록 catch (error) { handleError(error); } finally 예외 발생 여부와 관계없이 실행 finally { cleanup(); } 객체 지향 프로그래밍 키워드 키워드 설명 예시 this 현재 객체 참조 this.name = name; super 부모 클래스 참조 super(name); new 객체 생성 new Date(); extends 클래스 상속 class Student extends Person {} static 클래스 레벨 멤버 정의 static count = 0; get getter 메서드 정의 get name() { return this._name; } set setter 메서드 정의 set name(value) { this._name = value; } 모듈 및 패키지 키워드 키워드 설명 예시 import 모듈 가져오기 import { useState } from 'react'; export 모듈 내보내기 export default class MyComponent {} from 모듈 출처 지정 import React from 'react'; as 모듈 별칭 지정 import * as utils from './utils'; 기타 키워드 키워드 설명 예시 typeof 데이터 타입 확인 typeof value === "string" instanceof 객체 타입 확인 obj instanceof Array void undefined 값 반환 void function() {} delete 객체 프로퍼티 삭제 delete object.property in 프로퍼티 존재 확인 "name" in object debugger 디버깅 중단점 debugger; 예약된 리터럴 키워드 설명 예시 true 논리 참 값 let isActive = true; false 논리 거짓 값 let isDisabled = false; null 값이 없음을 나타내는 객체 let value = null; undefined 정의되지 않은 값 let value = undefined; 엄격 모드 키워드 키워드 설명 예시 “use strict” 엄격 모드 선언 "use strict"; // 코드의 시작 부분 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-21 03:18:00 +0000 UTC'>November 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;424 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Keywords" href=https://buenhyden.github.io/posts/programming-languages/javascript/concepts/keywords/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spring</h2></header><div class=entry-content><p>Spring Spring은 Java 기반의 현대적인 엔터프라이즈 애플리케이션 개발을 위한 포괄적인 프레임워크.
Spring은 웹 프레임워크가 아닌 일반 프레임워크.
그 이유는:
범위의 차이
웹 프레임워크: 웹 애플리케이션 개발에 특화 (예: Django, Flask) Spring: 웹 외에도 다양한 종류의 애플리케이션 개발 가능 기능의 포괄성
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Spring으로 웹이 아닌 일반 애플리케이션도 개발 가능 @SpringBootApplication public class BatchProcessingApplication { @Scheduled(fixedRate = 1000) public void processData() { // 배치 처리 로직 } } // 데스크톱 애플리케이션도 가능 @SpringBootApplication public class DesktopApplication extends Application { @Override public void start(Stage stage) { // JavaFX UI 로직 } } 모듈성
Spring은 필요한 기능만 선택적으로 사용할 수 있다:
...</p></div><footer class=entry-footer><span title='2024-11-20 09:52:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;947 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spring" href=https://buenhyden.github.io/posts/programming-languages/java/framework/spring/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spring Boot</h2></header><div class=entry-content><p>Spring Boot Spring Boot는 Spring 프레임워크를 기반으로 한 Java 애플리케이션 개발을 더욱 쉽고 빠르게 만들어주는 도구
주요 특징과 장점 자동 구성 (Auto Configuration) Spring Boot는 @SpringBootApplication 어노테이션을 통해 자동 구성 기능을 제공한다.
이는 클래스패스에 있는 라이브러리를 기반으로 애플리케이션을 자동으로 설정하여 개발자가 수동으로 빈(Bean)을 구성할 필요성을 줄여준다.
독립 실행형 (Standalone) Spring Boot 애플리케이션은 외부 서버에 의존하지 않고 독립적으로 실행될 수 있다.
내장된 서버(예: Tomcat, Jetty, Undertow)를 포함하고 있어 별도의 웹 애플리케이션 서버 설치 없이 애플리케이션을 실행할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-20 04:36:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;462 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spring Boot" href=https://buenhyden.github.io/posts/programming-languages/java/web-framework/spring-boot/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Junit</h2></header><div class=entry-content><p>Junit Java 프로그래밍 언어를 위한 가장 널리 사용되는 단위 테스트(Unit Testing) 프레임워크.
소프트웨어 개발 과정에서 코드의 품질을 보장하고 버그를 사전에 발견하는 데 중요한 역할을 한다.
JUnit은 Kent Beck과 Erich Gamma에 의해 1997년에 처음 개발되었.
당시 소프트웨어 개발에서 테스트의 중요성이 점점 커지면서, 개발자들이 쉽게 사용할 수 있는 테스트 프레임워크의 필요성이 대두되었.
현재는 JUnit 5 버전까지 발전했으며, 각 버전마다 더욱 강력하고 사용하기 쉬운 기능들이 추가되었다.
Spring Boot 2.2.0 버전부터는 기본적으로 JUnit 5를 지원한다.
...</p></div><footer class=entry-footer><span title='2024-11-20 00:23:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;564 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Junit" href=https://buenhyden.github.io/posts/programming-languages/java/testing/junit/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Polling publisher</h2></header><div class=entry-content><p>Polling Publisher Polling publisher는 마이크로서비스 아키텍처(MSA)에서 트랜잭셔널 메시징을 구현하는 방법 중 하나이다.
이 패턴은 Transactional Outbox 패턴과 함께 사용되어 데이터 일관성을 유지하면서 메시지를 안정적으로 발행하는 데 도움을 준다.
Polling publisher는 특히 소규모 시스템이나 간단한 구현이 필요한 경우에 적합한 방식이다. 그러나 대규모 시스템이나 실시간성이 중요한 경우에는 Transaction Log Tailing과 같은 다른 방식을 고려할 수 있다.
기본 개념 Outbox 테이블에 저장된 메시지를 주기적으로 조회(polling)하여 메시지 브로커로 발행한다.
데이터베이스 트랜잭션의 일부로 메시지를 Outbox 테이블에 저장한 후, 별도의 프로세스에서 이를 읽어 발행한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:46:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;383 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Polling publisher" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/polling-publisher/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Transaction log tailing</h2></header><div class=entry-content><p>Transaction Log Tailing Transaction log tailing은 마이크로서비스 아키텍처(MSA)에서 Transactional Messaging을 구현하는 방법 중 하나이다.
이 패턴은 데이터베이스의 트랜잭션 로그를 실시간으로 읽어 변경사항을 메시지 브로커에 발행하는 방식이다.
Transaction log tailing은 Polling publisher 방식과 비교될 수 있다. Polling은 주기적으로 데이터베이스를 조회하는 반면, log tailing은 실시간으로 변경사항을 감지한다. 이로 인해 log tailing이 더 빠르고 효율적이지만, 구현이 더 복잡할 수 있다.
이 패턴을 사용할 때는 메시지의 중복 발행 가능성을 고려해야 하며, 소비자 측에서 멱등성을 보장하는 방식으로 구현해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-19 11:45:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;288 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Transaction log tailing" href=https://buenhyden.github.io/posts/software-design-and-architecture/msa-patterns/transactional-messaging/transaction-log-tailing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/10/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/12/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>