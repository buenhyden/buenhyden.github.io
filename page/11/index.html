<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OAuth 2.0</h2></header><div class=entry-content><p>JWT vs. OAuth 2.0 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 컴팩트하고 자체 완결적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0
OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다. 주요 목적과 용도 JWT의 목적
...</p></div><footer class=entry-footer><span title='2025-04-03 07:30:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OAuth 2.0" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-formats/jwt/jwt-vs-oauth-20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. SAML</h2></header><div class=entry-content><p>Token Authentication vs. SAML 토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(보통 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후 요청에서 인증을 처리하는 방식이다.
기본 개념 및 작동 원리 인증 흐름: 사용자가 로그인 정보(ID/비밀번호)를 제출한다. 서버는 이를 검증하고 서명된 토큰을 생성한다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킨다. 서버는 토큰의 서명과 내용을 검증하여 사용자를 인증한다. 토큰 형식: 가장 일반적인 형식은 JWT(JSON Web Token)이다. JWT는 헤더, 페이로드, 서명의 세 부분으로 구성된다. 토큰은 Base64Url로 인코딩되어 HTTP 헤더로 전송된다. 주요 특징 무상태(Stateless): 서버는 세션 상태를 저장할 필요가 없다. 확장성: 서버 간에 세션 정보를 공유할 필요가 없어 수평적 확장이 용이한다. 클라이언트 중심: 토큰은 클라이언트에 저장되고 관리된다. 다양한 플랫폼 지원: 웹, 모바일, API 등 다양한 환경에서 사용 가능하다. 자체 포함적(Self-contained): 토큰 자체에 사용자 정보와 권한이 포함될 수 있다. SAML(Security Assertion Markup Language) SAML은 서로 다른 도메인 간에 인증 및 권한 부여 데이터를 교환하기 위한 XML 기반 표준이다. 주로 엔터프라이즈 환경에서 SSO(Single Sign-On)를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:23:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. SAML" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-based-authentication-vs-saml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. JWT</h2></header><div class=entry-content><p>Token Authentication vs. JWT 토큰 인증과 JWT는 모두 현대적인 웹 애플리케이션에서 사용자 인증을 관리하는 방법이지만, 이 둘 사이에는 중요한 차이점이 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다.
기본 개념 및 특징 일반적 작동 방식: 사용자가 자격 증명(username/password)을 제출한다. 서버는 이를 검증하고 고유한 토큰을 생성한다. 클라이언트는 이 토큰을 저장하고 향후 요청 시 제시한다. 서버는 토큰을 검증하여 사용자를 식별한다. 토큰 형태: 단순 무작위 문자열(UUID 등) 해시된 값 인코딩된 데이터 구조(JWT, SAML 등) 암호화된 페이로드 서버 측 저장: 대부분의 전통적인 토큰 시스템은 서버 측 저장소(데이터베이스, 캐시 등)에 토큰 정보를 보관한다. 토큰 자체는 단순한 식별자 역할을 하며, 관련 정보는 서버에서 조회한다. 토큰 관리: 서버가 발급한 토큰의 유효성을 관리한다. 만료, 폐기, 갱신 등의 작업이 서버 측에서 제어된다. JWT(JSON Web Token) JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다. JWT는 RFC 7519에 정의된 개방형 표준이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. JWT" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-based-authentication-vs-jwt/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. OAuth</h2></header><div class=entry-content><p>Token Authentication vs. OAuth 2.0 토큰 인증(Token Authentication)과 OAuth 2.0은 모두 사용자 인증 및 권한 부여를 처리하는 기술이지만, 목적과 구현 방식에 있어 중요한 차이점을 가지고 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자가 자격 증명(일반적으로 사용자 이름과 비밀번호)을 한 번 제공한 후, 서버가 생성한 토큰을 사용하여 이후의 요청에서 인증을 수행하는 방식이다.
기본 개념 토큰 인증의 핵심 아이디어는 사용자의 자격 증명을 한 번만 확인한 후, 서버가 서명된 토큰을 발급하여 클라이언트가 이 토큰을 사용해 자신을 인증하도록 하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. OAuth" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-based-authentication-vs-oauth-20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. OpenID Connect</h2></header><div class=entry-content><p>Token Authentication vs. OpenID Connect 현대 웹과 애플리케이션의 보안 생태계에서 인증과 권한 부여는 필수적인 요소이다. 토큰 인증(Token Authentication)과 OpenID Connect(OIDC)는 모두 이 영역에서 중요한 역할을 하지만, 목적과 기능 면에서 상당한 차이가 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(주로 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후의 요청에서 인증을 수행하는 방식이다.
기본 개념 및 작동 원리 토큰 인증의 핵심 아이디어는 사용자가 로그인하면 서버가 서명된 토큰을 발급하고, 이후 모든 요청에 이 토큰을 포함시켜 사용자를 식별하는 것이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. OpenID Connect" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-based-authentication-vs-openid-connect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Token Authentication vs. Cookie-Based Auth 토큰 인증(Token Authentication) 토큰 인증은 서버가 사용자의 인증 정보를 확인한 후 서명된 토큰을 발급하고, 클라이언트가 이 토큰을 이후의 요청에 포함시켜 자신을 인증하는 방식이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
작동 방식 사용자가 자격 증명(사용자 이름/비밀번호)을 서버에 제출한다. 서버는 자격 증명을 검증하고, 사용자 식별자와 권한 정보를 포함한 토큰을 생성한다. 서버는 비밀 키로 토큰에 서명하여 클라이언트에게 반환한다. 클라이언트는 이 토큰을 저장하고(주로 로컬 스토리지, 세션 스토리지 또는 메모리에 저장), 이후 요청의 Authorization 헤더에 포함시킨다. 서버는 토큰의 서명을 검증하고, 포함된 정보를 기반으로 사용자를 인증한다. 특징 무상태(Stateless): 서버는 클라이언트 상태 정보를 저장하지 않는다. 확장성: 여러 서버 간에 인증 정보를 공유할 필요가 없다. 플랫폼 독립적: 모바일 앱, SPA, API 등 다양한 클라이언트에서 사용 가능하다. 보안: 토큰에 서명을 통해 변조를 방지한다. 만료 시간 설정 가능: 토큰에 만료 시간을 포함할 수 있다. 쿠키 기반 인증(Cookie-Based Authentication) 쿠키 기반 인증은 서버가 사용자 인증 후 세션 ID를 포함한 쿠키를 클라이언트에 전송하고, 클라이언트가 이 쿠키를 모든 요청에 자동으로 포함시켜 인증하는 방식이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:21:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/backend-development/api-development/token-based-authentication/token-based-authentication-vs-cookie-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SAML vs. OpenID Connect</h2></header><div class=entry-content><p>SAML vs. OpenID Connect SAML(Security Assertion Markup Language)과 OpenID Connect는 모두 사용자 인증 및 권한 부여를 위한 핵심 프로토콜이지만, 역사, 구현 방식, 용도 면에서 중요한 차이점이 있다.
SAML (Security Assertion Markup Language) SAML은 2002년에 OASIS(Organization for the Advancement of Structured Information Standards)에 의해 개발된 XML 기반 프레임워크이다.
핵심 특징 XML 형식으로 인증 정보를 교환 주로 엔터프라이즈 환경과 대기업에서 사용 복잡한 구현이지만 높은 보안성 제공 웹 기반 SSO(Single Sign-On)에 최적화 메타데이터를 통한 신뢰 관계 구축 작동 방식 사용자가 서비스 제공자(SP)에게 접근 요청 SP는 사용자를 신원 제공자(IdP)로 리디렉션 IdP는 사용자를 인증하고 SAML 어설션(assertion) 생성 사용자는 SAML 어설션과 함께 SP로 리디렉션 SP는 SAML 어설션을 검증하고 사용자 접근 허용 OpenID Connect (OIDC) OpenID Connect는 2014년에 OpenID Foundation에 의해 개발된 OAuth 2.0 위에 구축된 인증 레이어이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 05:36:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SAML vs. OpenID Connect" href=https://buenhyden.github.io/posts/networking--protocols/core-protocols/application-layer/protocols/identity--directory--aaa/federation--authorization/saml-2.0/saml-vs-openid-connect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Load shifting vs. autoscaling</h2></header><div class=entry-content><p>Load Shifting vs. Autoscaling Load Shifting과 Autoscaling은 백엔드 시스템에서 리소스를 효율적으로 관리하기 위한 두 가지 중요한 전략이다. 이들은 서로 다른 목적과 작동 방식을 가지고 있으며, 특정 상황에 따라 적합하게 사용된다.
Load Shifting 개념: 워크로드를 피크 시간대에서 비피크 시간대로 이동하여 리소스를 더 균형 있게 활용하는 전략. 주요 목적: 리소스 사용 최적화. 비용 절감 (예: 전력 소비가 적은 시간대 활용). 시스템 안정성 유지. 작동 방식: 작업 스케줄링을 통해 특정 시간대에 작업을 재배치. 지리적 부하 이동을 통해 다른 데이터 센터나 지역으로 워크로드를 분산. 적용 사례: 배치 작업을 야간에 실행하여 낮 시간대 사용자 요청 처리에 집중. 전력 비용이 낮은 시간대에 대규모 작업 수행. Autoscaling 개념: 실시간 수요 변화에 따라 시스템의 리소스(예: 서버 인스턴스)를 자동으로 확장하거나 축소하는 기술. 주요 목적: 실시간 트래픽 변화 대응. 과도한 리소스 프로비저닝 방지로 비용 최적화. 성능 및 사용자 경험 개선. 작동 방식: CPU, 메모리, 네트워크 트래픽 등 실시간 메트릭을 기반으로 인스턴스 수를 조정. 수요 증가 시 서버를 추가하고, 수요 감소 시 서버를 비활성화. 적용 사례: 전자상거래 사이트에서 트래픽 급증 시 서버 자동 확장. 클라우드 환경에서 이벤트 기반 애플리케이션의 동적 확장. 차이점 비교 특성 Load Shifting Autoscaling 목적 워크로드를 시간 또는 지역적으로 이동하여 리소스 최적화 실시간 수요 변화에 따라 리소스를 자동 조정 작동 방식 작업 스케줄링 및 지리적 부하 이동 실시간 메트릭 기반 서버 확장 및 축소 주요 적용 사례 배치 작업 재조정, 전력 비용 최적화 웹 애플리케이션의 트래픽 급증 대응 자동화 수준 사전 계획된 스케줄 기반 실시간 동적 조정 비용 절감 방식 비피크 시간대 활용 필요 시 인스턴스 추가 및 제거로 비용 최적화 사용 환경 장기적인 워크로드 관리 단기적인 수요 변화 대응 용어 정리 용어 설명 참고 및 출처</p></div><footer class=entry-footer><span title='2025-04-02 15:29:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load shifting vs. autoscaling" href=https://buenhyden.github.io/posts/networking--protocols/advanced-networking/performance-optimization/traffic-management/load-shifting/load-shifting-vs-autoscaling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar vs. Kafka</h2></header><div class=entry-content><p>Apache Pulsar vs. Kafka 분산 메시징 시스템은 현대 데이터 중심 아키텍처의 중추 역할을 한다.
기본 개념 및 역사 Apache Kafka Apache Kafka는 2011년 LinkedIn에서 개발된 후 Apache 소프트웨어 재단으로 이관된 분산 스트리밍 플랫폼이다. 처음에는 LinkedIn 내부의 데이터 파이프라인 문제를 해결하기 위해 만들어졌지만, 이후 업계 표준 메시징 시스템으로 자리 잡았다. Kafka는 높은 처리량, 내구성, 확장성을 제공하는 로그 기반의 발행-구독(pub-sub) 메시징 시스템이다.
Apache Pulsar Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년에 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 다중 테넌트, 고성능 서비스로 설계되었으며, Kafka와 같은 발행-구독 메시징 시스템의 특성과 전통적인 메시지 큐의 장점을 결합했다. Pulsar는 처음부터 클라우드 네이티브 환경을 염두에 두고 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-02 06:04:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar vs. Kafka" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-kafka/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar vs. RabbitMQ</h2></header><div class=entry-content><p>Apache Pulsar vs. RabbitMQ Apache Pulsar와 RabbitMQ는 메시징 시스템으로서 각각 고유한 강점과 약점을 가지고 있으며, 사용 사례에 따라 적합한 선택이 달라질 수 있다.
기본 개념 및 역사 Apache Pulsar Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 처음부터 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다.
RabbitMQ RabbitMQ는 2007년 Rabbit Technologies Ltd.에서 개발되었으며, 현재는 VMware의 일부인 Pivotal Software에서 관리되고 있다. Erlang으로 작성된 RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다. 신뢰성, 유연성, 상호 운용성에 중점을 두고 설계되었다.
...</p></div><footer class=entry-footer><span title='2025-04-02 06:04:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar vs. RabbitMQ" href=https://buenhyden.github.io/posts/networking--protocols/communication-patterns/message-infrastructure/message-systems/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/10/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/12/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>