<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>용량 테스트 (Volume Test)</h2></header><div class=entry-content><p>용량 테스트 (Volume Test) 용량 테스트는 소프트웨어 시스템이 대량의 데이터를 처리할 때 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.
이는 시스템이 대규모 데이터를 효율적으로 처리할 수 있는지 검증하는 과정이다.
데이터베이스 시스템의 용량 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import time from database import DatabaseConnection from data_generator import DataGenerator class VolumeTest: def __init__(self): self.db = DatabaseConnection() self.data_generator = DataGenerator() self.metrics = [] def test_large_data_handling(self): """대용량 데이터 처리 테스트""" print("대용량 데이터 처리 테스트 시작…") # 테스트 데이터 생성 test_data = self.data_generator.generate_large_dataset( records=1000000, # 백만 건의 레코드 size_per_record="2KB" # 레코드당 2KB ) start_time = time.time() try: # 데이터 삽입 테스트 print("데이터 삽입 테스트 중…") self.test_bulk_insert(test_data) # 데이터 조회 테스트 print("데이터 조회 테스트 중…") self.test_data_retrieval() # 데이터 집계 테스트 print("데이터 집계 테스트 중…") self.test_data_aggregation() finally: execution_time = time.time() - start_time print(f"전체 테스트 소요 시간: {execution_time:f}초") def test_bulk_insert(self, data): """대량 데이터 삽입 성능 테스트""" batch_size = 10000 # 배치 크기 for i in range(0, len(data), batch_size): batch = data[i:i + batch_size] # 삽입 시간 측정 start_time = time.time() self.db.bulk_insert(batch) insert_time = time.time() - start_time # 성능 메트릭 기록 self.metrics.append({ 'operation': 'bulk_insert', 'batch_size': len(batch), 'execution_time': insert_time, 'records_per_second': len(batch) / insert_time }) 특징과 목적 용량 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-11 02:32:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;764 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 용량 테스트 (Volume Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/volume-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>확장성 테스트 (Scalability Test)</h2></header><div class=entry-content><p>확장성 테스트 (Scalability Test) 확장성 테스트는 소프트웨어 시스템이 증가하는 부하나 규모에 얼마나 잘 대응할 수 있는지를 평가하는 성능 테스트의 한 유형이다.
이는 시스템의 확장 능력을 측정하고 검증하는 과정이다.
웹 서비스의 확장성 테스트 예시 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 import time from concurrent.futures import ThreadPoolExecutor from monitoring import SystemMonitor class ScalabilityTest: def __init__(self): self.monitor = SystemMonitor() self.results = [] def test_vertical_scaling(self): """수직적 확장성 테스트 (단일 서버의 자원 증가에 따른 성능 변화 측정)""" # 서버 자원을 단계적으로 증가시키며 테스트 resource_configs = [ {"cpu_cores": 2, "memory": "2GB"}, {"cpu_cores": 4, "memory": "4GB"}, {"cpu_cores": 8, "memory": "8GB"} ] for config in resource_configs: # 서버 리소스 조정 self.adjust_server_resources(config) # 성능 측정 metrics = self.measure_performance() # 결과 기록 self.results.append({ "config": config, "metrics": metrics }) # 선형적 확장성 검증 self.verify_linear_scaling(config, metrics) def test_horizontal_scaling(self): """수평적 확장성 테스트 (서버 수 증가에 따른 성능 변화 측정)""" # 서버 인스턴스 수를 단계적으로 증가 for server_count in range(1, 6): # 서버 추가 self.add_server_instances(server_count) # 부하 테스트 실행 with ThreadPoolExecutor(max_workers=100) as executor: # 동시 요청 시뮬레이션 futures = [ executor.submit(self.simulate_request) for _ in range(1000) ] # 결과 수집 responses = [f.result() for f in futures] # 성능 메트릭 분석 self.analyze_scaling_metrics(server_count, responses) 특징과 목적 확장성 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-11 02:32:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;856 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 확장성 테스트 (Scalability Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/scalability-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>스파이크 테스트(Spike Test)</h2></header><div class=entry-content><p>스파이크 테스트(Spike Test) 스파이크 테스트는 시스템에 갑작스럽고 극단적인 부하를 주어 시스템의 반응을 측정하는 성능 테스트의 한 유형이다.
이는 마치 갑자기 많은 사람들이 한 번에 몰려드는 상황을 시뮬레이션하는 것과 비슷하다.
웹 서비스의 스파이크 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import time from concurrent.futures import ThreadPoolExecutor from monitoring import SystemMonitor class SpikeTest: def __init__(self): self.monitor = SystemMonitor() self.base_load = 100 # 기본 사용자 수 self.spike_load = 5000 # 스파이크 시 사용자 수 def run_spike_test(self): """스파이크 테스트 실행""" print("스파이크 테스트 시작…") # 1. 기본 부하 상태 측정 print("기본 부하 상태 측정 중…") base_metrics = self.measure_system_state(self.base_load) # 2. 스파이크 부하 생성 print(f"스파이크 발생: {self.spike_load}명의 동시 사용자 생성") spike_metrics = self.generate_spike_load() # 3. 복구 과정 모니터링 print("시스템 복구 과정 모니터링 중…") recovery_metrics = self.monitor_recovery() # 4. 결과 분석 self.analyze_results(base_metrics, spike_metrics, recovery_metrics) def measure_system_state(self, user_count): """시스템 상태 측정""" with ThreadPoolExecutor(max_workers=user_count) as executor: # 동시 요청 생성 futures = [ executor.submit(self.simulate_user_request) for _ in range(user_count) ] # 응답 수집 responses = [f.result() for f in futures] return { 'response_times': [r['response_time'] for r in responses], 'error_count': sum(1 for r in responses if r['error']), 'system_metrics': self.monitor.get_current_metrics() } 특징과 목적 스파이크 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-11 01:54:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;823 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 스파이크 테스트(Spike Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/spike-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>지속성 테스트(Endurance Test)</h2></header><div class=entry-content><p>지속성 테스트(Endurance Test) 지속성 테스트는 소프트웨어 시스템이 장기간 동안 지속적인 부하 상태에서 어떻게 동작하는지 확인하는 성능 테스트의 한 유형이다.
웹 서버의 지속성 테스트 예시 코드:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import time import psutil from datetime import datetime class EnduranceTest: def __init__(self, duration_hours=24): self.duration = duration_hours * 3600 # 시간을 초로 변환 self.metrics_history = [] def run_endurance_test(self): """24시간 지속성 테스트 실행""" print(f"테스트 시작: {datetime.now()}") start_time = time.time() while time.time() - start_time &lt; self.duration: # 시스템 메트릭 수집 metrics = self.collect_system_metrics() self.metrics_history.append(metrics) # 성능 저하 검사 if self.detect_performance_degradation(metrics): print("성능 저하 감지!") self.analyze_degradation() # 메모리 누수 검사 if self.detect_memory_leak(metrics): print("메모리 누수 감지!") self.analyze_memory_usage() time.sleep(60) # 1분마다 측정 def collect_system_metrics(self): """시스템 성능 지표 수집""" return { 'timestamp': datetime.now(), 'cpu_usage': psutil.cpu_percent(), 'memory_usage': psutil.virtual_memory().percent, 'disk_io': psutil.disk_io_counters(), 'response_time': self.measure_response_time() } def measure_response_time(self): """시스템 응답 시간 측정""" start_time = time.time() try: # 주요 API 엔드포인트 호출 response = requests.get('http://example.com/api/health') return time.time() - start_time except Exception as e: print(f"응답 시간 측정 실패: {str(e)}") return None 특징과 목적 지속성 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-11 01:53:00 +0000 UTC'>November 11, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;670 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 지속성 테스트(Endurance Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/performance-test/endurance-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Security Vulnerability Scanning</h2></header><div class=entry-content><p>보안 취약점 스캔 (Security Vulnerability Scanning) 시스템의 모든 진입점과 약점을 체계적으로 검사하는 과정이다.
주로 자동화된 도구를 사용하여 알려진 취약점 패턴을 검사하고, 잠재적인 보안 위험을 식별합니다.
주요 목적 잠재적인 보안 취약점 식별 데이터 유출 및 사이버 공격 위험 감소 규정 준수 요구사항 충족 전반적인 보안 태세 강화 작동 방식 대상 식별: 스캔할 시스템, 네트워크, 애플리케이션을 정의 스캔 실행: 자동화된 도구를 사용하여 취약점 검색 데이터 수집 및 분석: 발견된 취약점에 대한 정보 수집 및 분석 보고서 생성: 식별된 취약점과 심각도 수준을 포함한 상세 보고서 작성 결과 평가 및 조치: 우선순위에 따라 취약점 해결 방안 수립 주요 스캔 유형 네트워크 취약점 스캔: 방화벽, 라우터 등 네트워크 인프라의 취약점 검사 웹 애플리케이션 취약점 스캔: SQL 인젝션, XSS 등 웹 관련 취약점 탐지 데이터베이스 취약점 스캔: 데이터베이스 시스템의 보안 취약점 평가 호스트 취약점 스캔: 개별 서버나 워크스테이션의 OS 수준 취약점 검사 장점 조기 취약점 발견으로 비용 절감 자동화를 통한 효율적인 보안 관리 규정 준수 입증 용이 지속적인 보안 상태 모니터링 가능 주의사항 거짓 양성(false positive) 결과 발생 가능성 모든 취약점을 발견할 수 없음 스캔 자체가 시스템에 부하를 줄 수 있음 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-10 16:11:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Security Vulnerability Scanning" href=https://buenhyden.github.io/posts/qa/qc/technical-verification/security-vulnerability-scanning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>성능 프로파일링 (Performance Profiling)</h2></header><div class=entry-content><p>성능 프로파일링 (Performance Profiling) 성능 프로파일링(Performance Profiling)은 소프트웨어의 실행 동작을 분석하여 성능을 측정하고 개선하는 기술이다.
성능 프로파일링은 소프트웨어 개발 과정에서 중요한 품질 관리 활동으로, 초기 단계부터 지속적으로 수행하여 효율적이고 최적화된 소프트웨어를 개발하는 데 도움을 준다.
정의와 목적 성능 프로파일링은 소프트웨어의 실행 시 동작과 리소스 사용을 분석하는 과정이다.
주요 목적은 다음과 같다:
코드의 병목 지점 식별 리소스 사용량 분석 (CPU 시간, 메모리 사용 등) 실행 시간이 긴 함수나 코드 섹션 파악 성능 최적화를 위한 개선 지점 도출 프로파일링 단계 계획: 분석 대상과 목표 설정 데이터 수집: 실행 중 성능 데이터 수집 분석: 수집된 데이터 분석 및 병목 지점 식별 최적화: 분석 결과를 바탕으로 코드 개선 검증: 개선 효과 확인 주요 프로파일링 유형 CPU 프로파일링: 함수별 CPU 사용 시간 측정 메모리 프로파일링: 메모리 할당 및 해제 패턴 분석 I/O 프로파일링: 디스크, 네트워크 등 I/O 작업 분석 장점 코드 품질 향상 소프트웨어 효율성 증대 리소스 할당 최적화 사용자 경험 개선 확장성 향상 도구 다양한 성능 프로파일링 도구가 있으며, 대표적인 것들은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-10 16:10:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;171 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 성능 프로파일링 (Performance Profiling)" href=https://buenhyden.github.io/posts/qa/qc/technical-verification/performance-profiling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CCE(Common Configuration Enumeration)</h2></header><div class=entry-content><p>CCE(Common Configuration Enumeration) CCE(Common Configuration Enumeration)는 시스템의 보안 설정과 관련된 취약점을 식별하고 관리하기 위한 표준화된 명명 체계이다.
시스템 구성 문제에 고유 ID를 제공하여 여러 정보 소스와 도구 간에 구성 데이터를 빠르고 정확하게 상관시키는 것을 목적으로 한다.
이를 통해 시스템의 보안 설정을 일관되게 관리하고 평가할 수 있다.
주요 특징 표준화된 식별: 각 보안 설정에 고유한 CCE ID를 부여한다. 설정 중심: 시스템의 구성 설정에 초점을 맞춘다. 다양한 플랫폼 지원: 서버, 네트워크 장치, 방화벽 등 다양한 IT 인프라에 적용 가능하다. CCE의 중요성 일관성 유지: 여러 도구와 플랫폼에서 동일한 보안 설정을 일관되게 식별할 수 있다. 자동화 지원: 자동화된 보안 도구에서 CCE를 활용하여 효율적인 취약점 관리가 가능하다. 규정 준수: 다양한 보안 표준과 규정 준수를 위한 기준으로 활용된다. CCE의 구조와 형식 CCE 식별자는 ‘CCE-XXXX-X’ 형식을 따르며, 각 식별자는 특정 보안 구성 설정을 고유하게 식별한다.
예를 들어, ‘CCE-27277-8’은 Windows 시스템에서 최소 암호 길이 설정을 나타낸다.
...</p></div><footer class=entry-footer><span title='2024-11-10 07:58:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;452 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CCE(Common Configuration Enumeration)" href=https://buenhyden.github.io/posts/security/security-vulnerability/cce/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CVE</h2></header><div class=entry-content><p>CVE CVE는 공개적으로 알려진 사이버 보안 취약점들에 대한 표준화된 식별자를 제공하는 목록이다.
이는 보안 취약점에 대한 일관된 명명과 식별을 가능하게 하여, 서로 다른 보안 도구와 서비스 간의 데이터 공유와 취약점 관리를 용이하게 한다.
1999년 MITRE Corporation에 의해 만들어졌으며, 주요 목적은 다음과 같다:
보안 취약점에 대한 표준화된 식별자 제공 취약점 정보의 공유 및 협업 촉진 보안 도구 및 서비스 간의 데이터 공유 개선 CVE ID 구조 CVE ID는 다음과 같은 형식을 가진다:
CVE-[연도]-[일련번호]
...</p></div><footer class=entry-footer><span title='2024-11-10 07:58:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CVE" href=https://buenhyden.github.io/posts/security/security-vulnerability/cve/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CVSS(Common Vulnerability Scoring System)</h2></header><div class=entry-content><p>CVSS(Common Vulnerability Scoring System) CVSS는 “공통 취약점 등급 시스템"의 약자로, 소프트웨어 취약점의 특성과 심각도를 파악하는 데 도움이 되는 표준화된 시스템이다.
주요 목적 취약점의 심각도를 표준화된 방식으로 평가 취약점 대응의 우선순위 결정에 도움 조직 간 취약점 정보 공유 및 소통 촉진 CVSS 점수 체계 CVSS 점수는 0.0에서 10.0 사이의 값으로 표현되며, 다음과 같이 분류된다:
0.0-3.9: 낮음 4.0-6.9: 중간 7.0-8.9: 높음 9.0-10.0: 심각 CVSS 메트릭 그룹 CVSS 점수는 다음 세 가지 메트릭 그룹으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-10 07:58:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;276 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CVSS(Common Vulnerability Scoring System)" href=https://buenhyden.github.io/posts/security/security-vulnerability/cvss/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CWE(Common Weakness Enumeration)</h2></header><div class=entry-content><p>CWE(Common Weakness Enumeration) CWE는 소프트웨어와 하드웨어의 설계, 디자인, 코드 구현에서 발생할 수 있는 결함, 버그, 에러 등의 보안 약점을 카탈로그화한 것이다.
주요 목적 보안 약점에 대한 공통 언어 제공 소프트웨어 보안 도구 간의 호환성 향상 보안 약점 식별 및 완화를 위한 기준 제공 표기 방식 ID 체계
CWE는 'CWE-XXX' 형식으로 표기된다.
예:
CWE-119: 버퍼 오버플로우 CWE-89: SQL 인젝션 CWE-79: 크로스 사이트 스크립팅 상세 정보 구조
각 CWE 항목은 다음과 같은 정보를 포함한다:
...</p></div><footer class=entry-footer><span title='2024-11-10 07:58:00 +0000 UTC'>November 10, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;452 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CWE(Common Weakness Enumeration)" href=https://buenhyden.github.io/posts/security/security-vulnerability/cwe/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/10/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/12/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>