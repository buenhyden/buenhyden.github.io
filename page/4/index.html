<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PostCSS</h2></header><div class=entry-content><p>PostCSS PostCSS는 CSS를 JavaScript로 처리할 수 있게 해주는 도구이다.
일반적인 전처리기와 달리, PostCSS는 플러그인 시스템을 기반으로 작동한다.
이는 마치 레고 블록처럼 필요한 기능을 조합하여 자신만의 CSS 처리 도구를 만들 수 있게 해준다.
각 플러그인은 특정한 작업을 수행하며, 개발자는 프로젝트에 필요한 플러그인만 선택하여 사용할 수 있다.
기본적인 설정 예시:
1 2 3 4 5 6 7 8 // postcss.config.js module.exports = { plugins: [ require('autoprefixer'), require('postcss-preset-env'), require('cssnano') ] } 주요 플러그인과 기능 Autoprefixer
PostCSS의 가장 인기 있는 플러그인 중 하나.
이 플러그인이 어떻게 작동하는지 살펴보자:
...</p></div><footer class=entry-footer><span title='2024-11-18 06:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;478 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PostCSS" href=https://buenhyden.github.io/posts/frontend/stylesheet/postcss/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SASS</h2></header><div class=entry-content><p>SASS (Syntactically Awesome Style Sheets) Sass는 CSS를 더 강력하고 우아하게 작성할 수 있게 해주는 전처리기이다.
Sass는 기존 CSS의 한계를 극복하기 위해 만들어졌으며, 두 가지 문법을 제공한다:
SCSS(Sassy CSS) 들여쓰기 기반의 Sass
SCSS는 CSS와 완벽하게 호환되는 문법을 가지고 있어 더 널리 사용된다. 기본적인 SCSS 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 변수 정의 $primary-color: #3498db; $spacing: 20px; .container { max-width: 1200px; padding: $spacing; // 중첩된 규칙 .header { background-color: $primary-color; color: white; // 중첩된 선택자와 &(부모 선택자) 참조 &:hover { background-color: darken($primary-color, 10%); } } } 장점 코드 재사용성 향상: 변수와 믹스인을 통해 코드 중복을 줄일 수 있다. 유지보수 용이성: 구조화된 코드로 인해 스타일시트의 관리가 쉬워진다. 생산성 향상: 간결한 문법과 강력한 기능으로 개발 속도를 높일 수 있다. CSS 호환성: 기존 CSS와 완벽히 호환되어 점진적으로 도입할 수 있다. Sass의 핵심 기능들 변수 시스템
Sass는 강력한 변수 시스템을 제공하여 값을 재사용하기 쉽게 만든다:
...</p></div><footer class=entry-footer><span title='2024-11-18 06:58:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;581 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SASS" href=https://buenhyden.github.io/posts/frontend/stylesheet/sass/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CSS</h2></header><div class=entry-content><p>CSS (Cascading Style Sheets) CSS는 웹 페이지의 스타일과 레이아웃을 정의하는 스타일 시트 언어.
HTML이 웹 페이지의 구조와 내용을 담당한다면, CSS는 그 내용의 시각적 표현을 담당한다.
콘텐츠와 디자인을 분리하여 웹 개발의 효율성을 높인다.
주요 기능 색상, 폰트, 크기, 레이아웃, 애니메이션 등 다양한 스타일 속성 제어 반응형 웹 디자인을 위한 미디어 쿼리 지원 선택자를 통한 세밀한 요소 선택 및 스타일 적용 장점 일관된 디자인 유지 및 변경 용이 코드의 재사용성 향상 페이지 로딩 시간 단축 주의사항 브라우저 호환성 고려 필요 복잡한 선택자 사용 시 성능 저하 가능성 CSS 작성 방법 CSS를 HTML 문서에 적용하는 방법에는 세 가지가 있다:
...</p></div><footer class=entry-footer><span title='2024-11-18 06:41:00 +0000 UTC'>November 18, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;717 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CSS" href=https://buenhyden.github.io/posts/frontend/stylesheet/css/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>비대칭키 암호화 (Asymmetric Encryption)</h2></header><div class=entry-content><p>비대칭키 암호화 (Asymmetric Encryption) 비대칭키 암호화는 공개키 암호화라고도 불리며, 암호화와 복호화에 서로 다른 두 개의 키를 사용하는 암호화 방식.
장점:
키 분배가 용이하다 (공개키는 공개적으로 공유 가능) 높은 보안성을 제공한다. 디지털 서명 등 다양한 보안 기능 구현이 가능하다. 단점:
대칭키 암호화에 비해 처리 속도가 느리다. 더 많은 컴퓨팅 자원이 필요하다. 구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from cryptography.hazmat.primitives.asymmetric import rsa, padding from cryptography.hazmat.primitives import hashes class AsymmetricEncryption: def __init__(self): # 키 쌍 생성 self.private_key = rsa.generate_private_key( public_exponent=65537, # 일반적으로 사용되는 공개 지수 key_size=2048 # 보안을 위한 충분한 키 크기 ) # 개인키로부터 공개키 추출 self.public_key = self.private_key.public_key() def encrypt_message(self, message): """공개키로 메시지 암호화""" encrypted = self.public_key.encrypt( message.encode(), padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return encrypted def decrypt_message(self, encrypted_message): """개인키로 메시지 복호화""" decrypted = self.private_key.decrypt( encrypted_message, padding.OAEP( mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None ) ) return decrypted.decode() 주요 특징 키 분배 문제 해결: 안전하지 않은 채널에서도 키를 교환할 수 있다. 높은 보안성: 공개키가 노출되어도 개인키가 안전하면 전체 시스템이 안전하다. 디지털 서명 가능: 메시지의 무결성과 발신자 인증에 사용된다. 느린 처리 속도: 대칭키 암호화에 비해 연산 속도가 느리다. 작동 원리 공개키와 개인키라는 두 개의 키를 사용한다.
공개키로 암호화한 데이터는 개인키로만 복호화할 수 있다.
개인키로 암호화한 데이터는 공개키로만 복호화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-17 21:22:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;612 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 비대칭키 암호화 (Asymmetric Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/asymmetric-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 함수 (Hash Functions)</h2></header><div class=entry-content><p>해시 함수 (Hash Functions) 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
특징:
일방향성: 해시 값으로부터 원본 데이터를 복구하는 것이 계산상 불가능하다.
1 2 3 4 5 6 7 8 9 10 11 12 13 def demonstrate_one_way(): """해시 함수의 일방향성을 보여주는 함수""" class PasswordManager: def __init__(self): self.password_hash = None def set_password(self, password): # 비밀번호는 해시값으로만 저장 self.password_hash = create_hash(password) def verify_password(self, password): # 입력된 비밀번호의 해시값과 저장된 해시값 비교 return create_hash(password) == self.password_hash 결정성: 같은 입력에 대해 항상 같은 해시 값을 생성한다.
...</p></div><footer class=entry-footer><span title='2024-11-17 21:22:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1804 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 함수 (Hash Functions)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/hash-functions/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>대칭키 암호화 (Symmetric Encryption)</h2></header><div class=entry-content><p>대칭키 암호화 (Symmetric Encryption) 대칭키 암호화는 동일한 키를 사용하여 데이터를 암호화하고 복호화하는 방식.
구현 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from cryptography.fernet import Fernet class SymmetricEncryption: def __init__(self): # 대칭키 생성 self.key = Fernet.generate_key() self.cipher_suite = Fernet(self.key) def encrypt(self, data): """데이터 암호화""" if isinstance(data, str): data = data.encode() return self.cipher_suite.encrypt(data) def decrypt(self, encrypted_data): """데이터 복호화""" decrypted_data = self.cipher_suite.decrypt(encrypted_data) return decrypted_data.decode() # 사용 예시 encryptor = SymmetricEncryption() message = "Hello, World!" encrypted = encryptor.encrypt(message) decrypted = encryptor.decrypt(encrypted) 주요 특징 암호화와 복호화에 같은 키를 사용한다. 혼돈(confusion)과 확산(diffusion)의 원리를 이용하여 평문을 암호화한다. 주로 치환(substitution)과 순열(permutation) 연산을 포함한 라운드를 반복하는 구조로 설계된다. 데이터 변환 방식에 따라 블록 암호와 스트림 암호로 구분된다. 혼돈(confusion)과 확산(diffusion)의 원리 혼돈(confusion)
암호문과 키 사이의 관계를 숨기는 것.
키의 단일 비트 변화가 암호문의 많은 비트를 변화시킴.
주로 치환(substitution) 연산을 통해 달성. 확산(diffusion)
암호문과 평문 사이의 관계를 숨기는 것.
평문의 통계적 특성을 암호문 전체에 분산시킴.
주로 순열(permutation) 연산을 통해 달성. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def confusion_example(input_data, key): # 혼돈(Confusion) 예시: XOR 연산을 사용하여 입력 데이터와 키를 결합 # 각 문자를 키와 XOR 연산하여 암호화 return [chr(ord(char) ^ key) for char in input_data] def diffusion_example(input_data): # 확산(Diffusion) 예시: 간단한 순열 연산을 사용 # 입력 데이터를 뒤집어 확산 효과를 시뮬레이션 return input_data[::-1] # 예시 데이터와 키 input_data = "HELLO" key = 3 # 혼돈 적용 confused_data = confusion_example(input_data, key) # 확산 적용 diffused_data = diffusion_example(confused_data) # 결과 출력 print("원본 데이터:", input_data) print("혼돈 적용 후:", ''.join(confused_data)) print("확산 적용 후:", ''.join(diffused_data)) 라운드 반복 구조 치환과 순열 연산을 포함한 기본 구조(라운드)를 여러 번 반복하는 방식.
...</p></div><footer class=entry-footer><span title='2024-11-17 21:21:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;806 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 대칭키 암호화 (Symmetric Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/symmetric-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동형 암호화(Homomorphic Encryption)</h2></header><div class=entry-content><p>동형 암호화(Homomorphic Encryption) 동형 암호화는 암호화된 데이터를 복호화하지 않은 상태에서 연산을 수행할 수 있게 해주는 암호화 기술.
일반적인 암호화 방식에서는 데이터를 처리하기 위해서는 먼저 복호화를 해야 하지만, 동형 암호화에서는 암호화된 상태 그대로 데이터를 처리할 수 있다.
예를 들어, 두 개의 숫자 3과 4를 동형 암호화했다고 가정해보자.
이 암호화된 값들을 더하면, 그 결과를 복호화했을 때 7(즉, 3+4)이 나오게 된다.
동형 암호화의 종류 부분 동형 암호화(Partial Homomorphic Encryption, PHE):
하나의 연산만 지원(덧셈 또는 곱셈).
- 대표적인 예로 Paillier 암호화(덧셈 지원)와 RSA(곱셈 지원)가 있다.
- 구현이 비교적 간단하고 성능이 우수합니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 13:11:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;340 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동형 암호화(Homomorphic Encryption)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/homomorphic-encryption/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>양자 암호화(quantum cryptography)</h2></header><div class=entry-content><p>양자 암호화(quantum cryptography) 양자 암호화는 양자역학의 원리를 활용하여 완벽한 보안을 실현하는 암호화 기술.
전통적인 암호화가 수학적 복잡성에 기반한다면, 양자 암호화는 양자역학의 기본 법칙을 활용하여 이론적으로 해독이 불가능한 보안을 제공한다.
양자 암호화의 핵심 원리 양자 암호화의 가장 중요한 원리는 양자역학의 기본 특성들을 활용한다:
관측 효과: 양자 상태를 측정하면 그 상태가 변화한다. 이는 도청자가 통신을 엿들으려 할 때 필연적으로 흔적을 남기게 됨을 의미한다. 복제 불가능성: 양자 상태는 완벽하게 복제할 수 없다는 ‘양자 복제 불가 정리’를 기반으로 한다. 이는 도청자가 양자 정보를 완벽하게 복사할 수 없음을 보장한다. 중첩 상태: 양자는 동시에 여러 상태를 가질 수 있으며, 측정 전까지는 확률적인 상태로 존재한다. 이러한 특성은 암호키 생성에 활용된다. 양자 암호화의 구현 방식 양자키분배(Quantum Key Distribution, QKD)는 가장 대표적인 양자 암호화 구현 방식이다.
...</p></div><footer class=entry-footer><span title='2024-11-17 13:11:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;406 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 양자 암호화(quantum cryptography)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/quantum-cryptography/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>영지식 증명(Zero-Knowledge Proof, ZKP)</h2></header><div class=entry-content><p>영지식 증명(Zero-Knowledge Proof, ZKP) 영지식 증명은 어떤 명제가 참이라는 것을 증명하면서도, 그 명제에 대한 구체적인 정보는 전혀 공개하지 않는 암호학적 방법.
즉, 증명자(Prover)는 검증자(Verifier)에게 자신이 특정 정보를 알고 있다는 것을 증명하되, 그 정보의 내용은 전혀 노출하지 않는다.
쉬운 예시를 들어보자.
색맹이 아닌 사람(증명자)이 색맹인 사람(검증자)에게 두 개의 공이 서로 다른 색이라는 것을 증명하고 싶다고 가정해보자. 검증자는 두 공의 위치를 무작위로 바꾸고, 증명자는 어떤 공이 바뀌었는지 맞춘다.
이 과정을 여러 번 반복하면, 증명자가 실제로 색의 차이를 볼 수 있다는 것이 증명되지만, 각 공이 어떤 색인지는 검증자에게 전혀 알려지지 않는다.
...</p></div><footer class=entry-footer><span title='2024-11-17 13:10:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;404 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 영지식 증명(Zero-Knowledge Proof, ZKP)" href=https://buenhyden.github.io/posts/security/encryption-and-decryption/zero-knowledge-proof/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Session based Auth</h2></header><div class=entry-content><p>Session Based Auth Session based Authentication은 웹 애플리케이션에서 사용자의 인증 상태를 유지하는 전통적인 방법 서버 측에서 사용자의 인증 상태와 데이터를 관리하는 방식이다. 사용자가 로그인하면 서버는 고유한 세션 ID를 생성하고, 이와 관련된 사용자 정보를 서버의 메모리나 데이터베이스에 저장한다.
주요 장점 서버 제어
서버가 세션을 완전히 제어할 수 있어 필요할 때 즉시 세션을 무효화할 수 있습니다.
보안성
세션 데이터가 서버에 안전하게 보관되며, 클라이언트는 세션 ID만 가지고 있습니다.
사용 편의성
기존 웹 애플리케이션과의 호환성이 좋고, 구현이 상대적으로 단순합니다.
...</p></div><footer class=entry-footer><span title='2024-11-17 11:30:00 +0000 UTC'>November 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;574 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session based Auth" href=https://buenhyden.github.io/posts/security/authentication/session-based-auth/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>