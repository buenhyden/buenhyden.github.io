<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Framework vs. Library</h2></header><div class=entry-content><p>Framework vs. Library 프레임워크와 라이브러리는 소프트웨어 개발에서 필수적인 구성 요소로, 각각의 목적과 사용 방식이 다르다. 라이브러리는 특정 기능을 제공하는 코드 집합으로 개발자가 직접 호출해 사용한다. 반면, 프레임워크는 애플리케이션의 구조와 흐름을 정의하며, 개발자가 작성한 코드를 필요에 따라 호출하는 ’ 제어의 역전 ’ 원칙을 따른다. 이 차이는 시스템 설계의 핵심 원리와 실무 적용에 큰 영향을 미치며, 각 도구의 장단점, 적용 사례, 최적화 및 실무 적용 시 고려사항 등에서 뚜렷하게 드러난다.
핵심 개념 제어의 역전 (Inversion of Control, IoC): 프로그램의 제어 흐름이 전통적인 방식과 반대로 동작하는 설계 원칙 Hollywood Principle: “Don’t call us, we’ll call you” - 프레임워크가 개발자 코드를 호출 의존성 주입 (Dependency Injection): 객체의 의존성을 외부에서 주입하는 방식 애플리케이션 프레임워크 (Application Framework): 특정 도메인의 애플리케이션 개발을 위한 포괄적인 구조 코드 라이브러리 (Code Library): 재사용 가능한 함수와 클래스의 집합 Framework vs. Library 비교 구분 프레임워크 (Framework) 라이브러리 (Library) 정의 애플리케이션 개발을 위한 구조와 제어 흐름을 제공하는 소프트웨어 플랫폼 특정 기능을 수행하는 코드 집합으로, 필요 시 개발자가 직접 호출 제어 흐름 (Control Flow) 프레임워크가 전체 흐름을 제어하며, 개발자의 코드를 호출 (제어의 역전: IoC) 개발자가 라이브러리를 직접 호출하여 제어 흐름을 관리 사용 방식 프레임워크의 구조에 맞춰 코드를 작성하고, 확장 지점을 통해 기능 구현 필요한 기능만 선택적으로 가져와 호출 구조 제공 애플리케이션의 아키텍처 및 구성 방식을 정의 구조에 영향을 주지 않음 확장성 명확한 확장 포인트 제공 (예: Hook, 인터페이스 등) 함수 단위로 조합하여 사용 가능 유연성 프레임워크의 구조를 따르므로 상대적으로 유연성은 낮음 특정 기능 단위로 자유롭게 사용 가능 재사용성 특정 프레임워크에 종속적일 수 있음 다양한 프로젝트에서 재사용 가능함 예시 Spring, Angular, Django, React (의견 분분하지만 구조 제공 시 프레임워크로 분류되기도 함) Lodash, NumPy, jQuery, Requests 사용 시나리오 비교 구분 Framework Library 적합한 프로젝트 대규모, 복잡한 애플리케이션 특정 기능이 필요한 프로젝트 팀 규모 대규모 팀 (일관성 중요) 소규모 팀 (유연성 중요) 유지보수 프레임워크 업데이트에 의존 개별적으로 관리 가능 테스트 프레임워크 테스트 환경 사용 독립적인 단위 테스트 구조 및 아키텍처 Framework 아키텍처 graph TD A[Framework Core] --> B[Application Lifecycle] A --> C[Dependency Injection Container] A --> D[Configuration Management] A --> E[Plugin System] B --> F[Initialization] B --> G[Execution] B --> H[Cleanup] C --> I[Bean Factory] C --> J[Dependency Resolution] D --> K[XML/Annotation Config] D --> L[Environment Properties] E --> M[Extension Points] E --> N[Custom Components] F --> O[Developer Code] G --> O H --> O Framework 구성요소:
...</p></div><footer class=entry-footer><span title='2024-11-20 06:47:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Framework vs. Library" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/design-principles/inversion-of-control/framework-vs.-library/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Data Pipeline Pattern</h2></header><div class=entry-content><p>Data Pipeline Pattern 데이터 파이프라인 패턴은 데이터를 원천에서 목적지로 이동시키는 과정을 자동화하고 최적화하는 아키텍처 패턴이다.
이 패턴은 데이터의 수집, 처리, 저장, 분석에 이르는 전체 과정을 효율적으로 관리하는 데 사용된다.
데이터 파이프라인 패턴을 효과적으로 구현하면 데이터 기반 의사결정을 지원하고, 비즈니스 인텔리전스를 향상시킬 수 있다. 각 조직의 요구사항과 데이터 특성에 맞는 최적의 패턴을 선택하고 구현하는 것이 중요하다.
https://www.informatica.com/blogs/data-processing-pipeline-patterns.html
데이터 파이프라인의 주요 구성요소 데이터 수집 (Data Ingestion)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 데이터를 추출한다. 실시간 또는 배치 방식으로 데이터를 수집할 수 있다. 데이터 처리 및 변환 (Data Processing and Transformation)
...</p></div><footer class=entry-footer><span title='2024-11-19 03:56:00 +0000 UTC'>November 19, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Data Pipeline Pattern" href=https://buenhyden.github.io/posts/data-science-and-engineering/data-engineering/data-pipelines/data-pipeline-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>선택 정렬 (Selection Sort)</h2></header><div class=entry-content><p>선택 정렬 (Selection Sort) 선택 정렬은 가장 직관적이고 이해하기 쉬운 정렬 알고리즘 중 하나이다.
선택 정렬은 개념적으로 가장 단순한 정렬 알고리즘 중 하나로, 알고리즘을 처음 배우는 사람들에게 좋은 시작점이 된다. 비록 대규모 데이터에서는 효율적이지 않지만, 특정 상황에서는 실용적인 선택이 될 수 있다.
선택 정렬의 핵심 특징은 다음과 같다:
구현이 매우 간단합니다. 교환 연산의 수가 적습니다(최대 n-1번). 메모리 사용이 최소화된다. 입력 데이터의 상태와 관계없이 일정한 성능을 보인다. 더 효율적인 정렬 알고리즘이 많이 존재하지만, 선택 정렬은 그 단순함과 직관적인 접근 방식으로 알고리즘 학습에 중요한 역할을 한다. 또한 작은 데이터셋이나 특정 제약 조건이 있는 환경에서는 여전히 유용한 알고리즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 선택 정렬 (Selection Sort)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/sorting/comparison-sorts/selection-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>이진 검색 (Binary Search)</h2></header><div class=entry-content><p>이진 검색 (Binary Search) 이진 탐색은 정렬된 배열에서 특정 값을 찾기 위한 효율적인 알고리즘이다.
일반적인 선형 탐색보다 훨씬 빠르며, 특히 대규모 데이터셋에서 그 효율성이 두드러진다.
이진 탐색은 간단하면서도 강력한 알고리즘으로, 정렬된 데이터에서 매우 효율적인 검색을 가능하게 한다.
O(log n)의 시간 복잡도는 대규모 데이터셋에서 특히 중요하다.
이 알고리즘을 마스터하면 다양한 문제 해결과 시스템 최적화에 적용할 수 있다.
이진 검색은 정렬된 리스트에서 특정 값을 찾는 효율적인 알고리즘이다.
이 알고리즘은 리스트의 중간 값을 선택하고, 찾고자 하는 값과 비교하여 탐색 범위를 반으로 줄여가며 검색을 수행한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 05:40:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 이진 검색 (Binary Search)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/algorithms/searching/types/binary-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cross Compiler</h2></header><div class=entry-content><p>Cross Compiler 크로스 컴파일러는 현재 코드를 실행하는 환경(호스트)와는 다른 플랫폼(대상)에서 실행될 수 있는 실행 파일이나 바이너리를 생성하는 컴파일러이다. 이는 임베디드 시스템이나 운영체제 개발처럼 대상 시스템이 컴파일러를 직접 실행하기에 부적합한 경우에 자주 사용되며, 한 개발 환경에서 여러 플랫폼용 소프트웨어를 동시에 개발할 수 있게 해준다.
크로스 컴파일러는 소프트웨어 개발의 다양한 분야, 특히 임베디드 시스템, 모바일 애플리케이션, 게임 콘솔, IoT 기기 개발에서 필수적인 도구이다. 이 기술은 개발자가 한 시스템에서 개발하면서 다양한 타겟 플랫폼용 코드를 생성할 수 있게 해준다.
...</p></div><footer class=entry-footer><span title='2024-10-14 15:29:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cross Compiler" href=https://buenhyden.github.io/posts/programming-languages/programming-fundamentals/programming-language-theory/compilers--interpreters/language-processor/compiler/types/cross-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>문자 (Character)과 문자열 (String)</h2></header><div class=entry-content><p>문자 (Character) 단일 문자를 표현하는 데이터 타입이다. 각 프로그래밍 언어별로 character의 구현과 사용 방식이 다소 다르다.
Character는 단일 문자를 나타내는 데이터 타입으로, 일반적으로 문자, 숫자, 특수 문자, 공백 등을 포함할 수 있다.
특징 고정 크기: 대부분의 언어에서 character는 고정된 메모리 크기를 가진다. 유니코드 지원: 많은 현대 프로그래밍 언어에서 유니코드 문자를 지원한다. 정수형과의 호환성: 대부분의 언어에서 character는 정수형으로 변환 가능하다. 특성 불변성: 많은 언어에서 character는 불변(immutable) 타입이다. 순서성: ASCII 또는 유니코드 값을 기반으로 순서를 가진다. 단일 값: 하나의 문자만을 저장할 수 있다. 연산 종류 및 설명 비교 연산: 문자 간 대소 비교가 가능하다. 산술 연산: 정수형으로 변환하여 산술 연산이 가능하다. 형변환: 정수형이나 문자열로의 변환이 가능하다. 실제 활용 사례 및 설명 Java Java에서는 ‘char’ 키워드를 사용하여 character를 선언한다.
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 문자 (Character)과 문자열 (String)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/data-structures/primitive/character-and-string/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Recursion vs. Iteration</h2></header><div class=entry-content><p>Recursion vs. Iteration Iteration과 Recursion은 프로그래밍에서 반복적인 작업을 수행하는 두 가지 주요 방식이다.
Iteration은 루프를 사용하여 특정 조건이 만족될 때까지 코드 블록을 반복 실행하는 방식이다.
주로 for, while 등의 루프 구조를 사용한다.
Iteration은 명시적인 반복 구조를 가지며, 각 반복마다 변수의 상태가 변경된다.
Recursion은 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.
복잡한 문제를 더 작고 간단한 문제로 나누어 해결한다.
Recursion은 base case(종료 조건)와 recursive case(재귀 호출)로 구성된다.
Iteration vs. Recursion 특성 Iteration Recursion 정의 루프를 사용한 반복 실행 함수가 자기 자신을 호출 제어 구조 루프 (for, while 등) 함수 호출 스택 종료 조건 루프 조건이 거짓이 될 때 Base case에 도달할 때 메모리 사용 일반적으로 적음 함수 호출 스택으로 인해 많음 속도 대체로 빠름 대체로 느림 (오버헤드 존재) 코드 복잡성 간단한 문제에 적합 복잡한 문제 해결에 유용 무한 반복 위험 루프 조건 오류 시 발생 Base case 누락 시 발생 문제 해결 접근 순차적 실행 분할 정복 가독성 단순한 경우 높음 복잡한 경우 높음 디버깅 상대적으로 쉬움 상대적으로 어려움 두 방식 모두 장단점이 있으며, 문제의 특성과 요구사항에 따라 적절한 방식을 선택해야 한다.
Iteration은 단순하고 반복적인 작업에 적합하며, Recursion은 복잡한 문제를 분할하여 해결하는 데 유용하다.
...</p></div><footer class=entry-footer><span title='2024-10-06 11:03:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Recursion vs. Iteration" href=https://buenhyden.github.io/posts/computer-science-fundamentals/data-structures-and-algorithms/fundamentals/basic-concepts/recursion/recursion-vs-iteration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Syncronization Algorithms</h2></header><div class=entry-content><p>Syncronization Algorithms 동기화 알고리즘은 병행 시스템에서 **상호 배제(Mutual Exclusion)**를 보장하기 위한 핵심 메커니즘이다.
데커 알고리즘 (Dekker’s Algorithm) 목적: 2개 프로세스의 상호 배제
메커니즘:
flag 배열(진입 의사) + turn 변수(진입 순서) 교착 상태 방지를 위한 플래그 재설정과 턴 변경
예시: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class DekkerLock: def __init__(self): # 각 프로세스의 진입 시도를 나타내는 플래그 self.flag = [False, False] # 현재 임계 영역을 사용할 차례인 프로세스 번호 self.turn = 0 def lock(self, process_id): other = 1 - process_id # 다른 프로세스의 ID # 진입 시도 표시 self.flag[process_id] = True # 다른 프로세스가 진입 시도 중이면 대기 while self.flag[other]: if self.turn != process_id: # 자신의 차례가 아니면 진입 시도 포기 self.flag[process_id] = False # 자신의 차례가 될 때까지 대기 while self.turn != process_id: pass # 다시 진입 시도 self.flag[process_id] = True def unlock(self, process_id): # 차례를 다른 프로세스에게 넘김 self.turn = 1 - process_id # 진입 시도 표시 해제 self.flag[process_id] = False 피터슨 알고리즘 (Peterson’s Algorithm) 목적: 2개 프로세스의 간단한 상호 배제
메커니즘:
...</p></div><footer class=entry-footer><span title='2024-10-05 08:48:00 +0000 UTC'>October 5, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Syncronization Algorithms" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/concurrency-and-parallelism/synchronization/mutual-exclusion/methods/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GitHub Flow</h2></header><div class=entry-content><p>GitHub Flow GitHub Flow는 GitHub에서 제안한 브랜치 전략으로, 메인 브랜치(main)와 기능 브랜치(feature)만을 사용하여 개발과 배포를 진행한다. 각 기능은 별도의 브랜치에서 개발되며, Pull Request를 통해 코드 리뷰와 테스트를 거친 후 메인 브랜치에 병합된다. 이러한 방식은 빠른 피드백과 지속적인 배포를 가능하게 한다.
Git Flow의 복잡성을 제거하고 웹 기반 애플리케이션 개발에 최적화된 워크플로우로, main 브랜치를 중심으로 기능 브랜치를 활용하여 빠른 개발 주기와 안정적인 배포를 동시에 달성할 수 있다.
핵심 개념 메인 브랜치(main): 항상 배포 가능한 상태를 유지하는 브랜치이다. 기능 브랜치(feature): 새로운 기능이나 수정 사항을 개발하는 브랜치로, 작업 완료 후 Pull Request를 통해 메인 브랜치에 병합된다. 모든 작업은 설명적인 이름의 기능 브랜치에서 수행한다.
정기적인 커밋과 원격 저장소 푸시
승인 후 즉시 main 브랜치에 병합되며 즉시 배포된다.
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitHub Flow" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/git-workflow/branch-strategies/github-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Repo Templates and Setup</h2></header><div class=entry-content><p>Repo Templates and Setup Repo Templates and Setup(저장소 템플릿 및 세팅) 은 소프트웨어 개발에서 반복적인 프로젝트 구조, 설정 파일, 기본 문서 등을 표준화하여 여러 프로젝트에 빠르고 일관되게 적용할 수 있도록 지원하는 기능이다. GitHub 의 템플릿 저장소 기능을 활용하면 README,.gitignore, LICENSE 와 같은 기본 파일부터 프로젝트 구조, 이슈 템플릿, PR 템플릿까지 설정하여 신규 프로젝트의 생산성과 품질을 높일 수 있다. 퍼블릭/프라이빗 설정, 조직용 템플릿 관리 등 다양한 실무 요구를 반영하며, DevOps, CI/CD, 보안, 협업 등 현대 소프트웨어 개발의 핵심 기반으로 자리 잡고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-29 09:58:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Repo Templates and Setup" href=https://buenhyden.github.io/posts/devops-and-infrastructure/version-control-systems/repo-hosting-services/repo-templates-and-setup/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>