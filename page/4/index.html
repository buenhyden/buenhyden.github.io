<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)</h2></header><div class=entry-content><p>요구사항 수집 및 분석 (Requirements Gathering and Analysis) 이해관계자의 요구사항을 수집하고 분석하여 시스템 요구사항을 정의하는 단계
요구사항 도출 주요 목적 프로젝트의 모든 이해관계자로부터 필요한 요구사항을 수집한다. 개발될 시스템의 기능적, 비기능적 요구사항을 파악한다. 사용자의 실제 니즈와 기대사항을 정확히 이해한다. 프로젝트의 범위와 제약사항을 명확히 한다. 향후 개발 과정의 기초가 되는 정보를 수집한다. 잠재적인 문제점과 리스크를 조기에 식별한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 이해관계자 식별 및 분석 프로젝트와 관련된 모든 이해관계자 파악 및 분석 이해관계자 목록 및 분석 보고서 인터뷰 실시 주요 이해관계자와의 일대일 또는 그룹 인터뷰 진행 인터뷰 기록 및 요약 보고서 설문조사 수행 광범위한 사용자 그룹을 대상으로 설문조사 실시 설문조사 결과 분석 보고서 워크샵 및 브레인스토밍 그룹 토론을 통한 아이디어 및 요구사항 도출 워크샵 결과 문서 현행 시스템 분석 기존 시스템의 기능 및 문제점 분석 현행 시스템 분석 보고서 문서 검토 관련 비즈니스 문서, 정책, 절차 등 검토 문서 검토 요약 관찰 및 현장 조사 실제 업무 환경 관찰 및 사용자 행동 분석 관찰 보고서 프로토타이핑 초기 프로토타입 개발 및 사용자 피드백 수집 프로토타입 및 사용자 피드백 문서 주의해야할 요소 주의 요소 설명 이해관계자 다양성 고려 모든 관련 이해관계자의 의견을 균형있게 수집 숨겨진 요구사항 발견 명시적으로 표현되지 않은 잠재적 요구사항 파악 객관성 유지 개인적 편견 없이 중립적인 태도로 요구사항 수집 과도한 요구사항 관리 실현 가능성과 프로젝트 범위를 고려한 요구사항 관리 의사소통 명확성 모호한 표현을 피하고 명확한 언어로 요구사항 기술 일관성 유지 다양한 출처에서 수집된 요구사항 간의 일관성 확보 변화하는 요구사항 대응 프로젝트 진행 중 변경되는 요구사항에 유연하게 대응 우선순위 설정 요구사항의 중요도와 우선순위 적절히 설정 기술적 제약 고려 기술적 실현 가능성을 고려한 요구사항 수집 문서화의 정확성 수집된 요구사항을 정확하고 상세하게 문서화 요구사항 분석 주요 목적 수집된 요구사항을 체계적으로 정리하고 구조화한다. 요구사항 간의 관계와 의존성을 파악한다. 모호하거나 불완전한 요구사항을 명확히 한다. 요구사항의 우선순위를 설정한다. 요구사항의 실현 가능성과 일관성을 평가한다. 시스템의 범위와 경계를 명확히 정의한다. 향후 설계 및 개발 단계의 기초를 마련한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 분류 및 구조화 수집된 요구사항을 기능적/비기능적 등으로 분류 구조화된 요구사항 목록 요구사항 모델링 요구사항을 다이어그램 등으로 시각화 유스케이스 다이어그램, 데이터 흐름도 요구사항 명세화 각 요구사항을 상세히 기술 상세 요구사항 명세서 요구사항 검증 요구사항의 정확성, 일관성, 완전성 검토 요구사항 검증 보고서 요구사항 우선순위 지정 요구사항의 중요도와 구현 순서 결정 우선순위가 지정된 요구사항 목록 요구사항 협상 충돌하는 요구사항에 대한 이해관계자 간 협의 협상 결과 문서 요구사항 추적성 분석 요구사항 간의 연관관계 파악 요구사항 추적성 매트릭스 비즈니스 규칙 도출 시스템에 적용될 비즈니스 규칙 식별 비즈니스 규칙 문서 주의해야할 요소 주의 요소 설명 요구사항의 명확성 모호하거나 불명확한 요구사항을 명확히 정의 요구사항 간 일관성 서로 충돌하거나 모순되는 요구사항 해결 실현 가능성 검토 기술적, 시간적, 비용적 측면에서 실현 가능한지 평가 범위 관리 프로젝트 범위를 벗어나는 요구사항 식별 및 관리 이해관계자 참여 분석 과정에 주요 이해관계자의 지속적인 참여 보장 비즈니스 목표 연계 각 요구사항이 비즈니스 목표와 연계되는지 확인 변경 관리 요구사항 변경에 대한 체계적인 관리 프로세스 수립 추적성 확보 요구사항의 출처와 향후 설계/구현과의 연계성 유지 품질 속성 고려 성능, 보안, 사용성 등 비기능적 요구사항 충분히 고려 문서화의 적절성 분석 결과를 명확하고 이해하기 쉽게 문서화 요구사항 명세 주요 목적 수집 및 분석된 요구사항을 명확하고 구체적으로 문서화한다. 모든 이해관계자가 이해할 수 있는 형태로 요구사항을 표현한다. 개발 팀이 설계와 구현에 활용할 수 있는 상세한 기준을 제공한다. 테스트 및 검증의 기준이 되는 문서를 작성한다. 프로젝트의 범위와 기능을 명확히 정의한다. 향후 변경 관리와 추적성 확보를 위한 기준점을 마련한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 기능적 요구사항 작성 시스템이 수행해야 할 기능들을 상세히 기술 기능적 요구사항 문서 비기능적 요구사항 작성 성능, 보안, 사용성 등의 품질 요구사항 정의 비기능적 요구사항 문서 유스케이스 작성 사용자와 시스템 간의 상호작용을 시나리오 형태로 기술 유스케이스 문서 요구사항 모델링 요구사항을 다이어그램 등으로 시각화 UML 다이어그램 (유스케이스, 클래스, 시퀀스 등) 인터페이스 요구사항 정의 사용자 인터페이스, 외부 시스템 인터페이스 등 정의 인터페이스 요구사항 명세서 데이터 요구사항 정의 시스템에서 다룰 데이터의 구조와 특성 정의 데이터 사전, ER 다이어그램 제약사항 및 가정 문서화 프로젝트의 제약사항과 가정사항 명시 제약사항 및 가정 목록 요구사항 명세서 통합 모든 요구사항을 종합한 문서 작성 소프트웨어 요구사항 명세서(SRS) 주의해야할 요소 주의 요소 설명 명확성과 구체성 모호하지 않고 구체적으로 요구사항을 기술 일관성 유지 요구사항 간 충돌이나 모순이 없도록 유지 완전성 확보 모든 필요한 요구사항이 누락 없이 포함되도록 함 검증 가능성 각 요구사항이 테스트나 검증 가능하도록 작성 추적성 확보 요구사항의 출처와 향후 설계/구현과의 연계성 유지 우선순위 표시 각 요구사항의 중요도나 구현 우선순위를 명시 사용자 중심 기술 최종 사용자의 관점에서 이해하기 쉽게 기술 기술적 중립성 특정 기술이나 구현 방식에 치우치지 않도록 주의 변경 용이성 향후 변경이 용이하도록 모듈화하여 작성 표준 준수 조직이나 산업의 요구사항 명세 표준을 준수 요구사항 검증 주요 목적 수집 및 명세된 요구사항의 정확성, 완전성, 일관성을 확인한다. 요구사항이 이해관계자의 실제 니즈를 정확히 반영하는지 검증한다. 요구사항의 실현 가능성과 테스트 가능성을 평가한다. 요구사항 간의 충돌이나 모순을 식별하고 해결한다. 프로젝트의 목표와 범위에 부합하는지 확인한다. 잠재적인 리스크와 문제점을 조기에 발견하고 해결한다. 요구사항 문서의 품질을 향상시킨다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 검토 회의 이해관계자와 함께 요구사항을 검토하고 논의 검토 회의록, 수정 요구사항 목록 정형 인스펙션 체계적인 방법으로 요구사항 문서를 검사 인스펙션 보고서 워크스루 요구사항을 단계별로 검토하며 문제점 식별 워크스루 결과 문서 프로토타이핑 요구사항의 실현 가능성을 검증하기 위한 프로토타입 개발 프로토타입, 사용자 피드백 문서 요구사항 추적성 분석 요구사항 간의 연관관계와 일관성 검증 요구사항 추적성 매트릭스 모델 검증 요구사항 모델(예: UML 다이어그램)의 정확성 검증 모델 검증 보고서 체크리스트 기반 검증 미리 정의된 체크리스트를 사용한 요구사항 검증 체크리스트 결과 문서 자동화 도구를 이용한 검증 요구사항 관리 도구를 사용한 자동 검증 자동화 검증 결과 보고서 주의해야할 요소 주의 요소 설명 객관성 유지 개인적 편견 없이 객관적으로 요구사항을 검증 이해관계자 참여 다양한 이해관계자의 참여로 다각도 검증 일관성 확보 요구사항 간 일관성과 전체적인 조화 확인 실현 가능성 평가 기술적, 시간적, 비용적 측면에서의 실현 가능성 검토 명확성 검증 모호하거나 해석의 여지가 있는 요구사항 식별 완전성 확인 누락된 요구사항이나 정보가 없는지 확인 테스트 가능성 각 요구사항이 테스트 가능한 형태인지 검증 우선순위 재확인 요구사항의 우선순위가 적절히 설정되었는지 확인 변경 영향 분석 요구사항 변경이 미치는 영향 평가 문서화 품질 요구사항 문서의 가독성과 이해도 확인 요구사항 관리 계획 수립 주요 목적 요구사항의 체계적인 관리를 위한 프로세스와 절차를 정의한다. 요구사항의 변경을 효과적으로 통제하고 관리한다. 프로젝트 전 과정에 걸쳐 요구사항의 일관성과 추적성을 유지한다. 이해관계자 간의 요구사항 관련 의사소통을 원활히 한다. 요구사항 관련 리스크를 식별하고 관리한다. 요구사항 변경이 프로젝트에 미치는 영향을 평가하고 관리한다. 요구사항 관리에 필요한 자원과 도구를 계획한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 관리 프로세스 정의 요구사항 수집, 분석, 문서화, 검증 등의 프로세스 수립 요구사항 관리 프로세스 문서 변경 관리 절차 수립 요구사항 변경 요청, 평가, 승인, 구현 절차 정의 변경 관리 절차서 요구사항 추적성 계획 요구사항 간 및 다른 산출물과의 추적성 유지 방법 정의 요구사항 추적성 계획서 요구사항 우선순위 지정 방법 요구사항 우선순위 결정 기준 및 방법 정의 우선순위 지정 가이드라인 요구사항 속성 정의 각 요구사항에 대해 추적할 속성 정의 (예: 상태, 담당자 등) 요구사항 속성 정의서 도구 및 저장소 선정 요구사항 관리에 사용할 도구와 저장소 결정 도구 선정 보고서 역할 및 책임 정의 요구사항 관리 관련 역할과 책임 할당 RACI 매트릭스 의사소통 계획 수립 요구사항 관련 의사소통 방법 및 빈도 정의 의사소통 계획서 주의해야할 요소 주의 요소 설명 유연성 확보 프로젝트 특성에 맞는 유연한 관리 프로세스 설계 이해관계자 참여 모든 주요 이해관계자의 동의와 참여 보장 변경 영향 분석 요구사항 변경이 프로젝트에 미치는 영향 평가 방법 포함 버전 관리 요구사항 문서의 효과적인 버전 관리 방법 수립 보안 고려 민감한 요구사항 정보의 보안 유지 방안 마련 통합성 다른 프로젝트 관리 프로세스와의 통합성 확보 확장성 프로젝트 규모 변화에 대응할 수 있는 확장성 있는 계획 수립 측정 및 개선 요구사항 관리 프로세스의 효과성 측정 및 개선 방안 포함 도구 활용 적절한 요구사항 관리 도구 선정 및 활용 계획 수립 교육 및 훈련 팀원들의 요구사항 관리 역량 강화를 위한 교육 계획 포함 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-20 00:53:00 +0000 UTC'>September 20, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1235 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)" href=https://buenhyden.github.io/posts/qa/sdlc/2-requirements-gathering-and-analysis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Level Order Traversal</h2></header><div class=entry-content><p>레벨 순서 순회 (Level Order Traversal) 트리 자료구조에서 레벨 순서 순회(Level Order Traversal)는 트리의 각 레벨을 위에서 아래로, 각 레벨 내에서는 왼쪽에서 오른쪽으로 노드를 방문하는 방식이다.
이 순회 방식은 너비 우선 탐색(Breadth-First Search, BFS)의 일종으로 볼 수 있다.
레벨 순서 순회는 트리를 레벨별로 탐색하는 강력한 기법이다.
큐를 사용한 반복적 접근법이 가장 효율적인 구현 방식이며, 다양한 트리 문제를 해결하는 데 활용할 수 있다.
특히 트리의 구조적 특성을 분석하거나 레벨별 작업을 수행할 때 매우 유용하다.
...</p></div><footer class=entry-footer><span title='2024-12-06 09:59:00 +0000 UTC'>December 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;707 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Level Order Traversal" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/tree/binary-tree/traversal/level-order-traversal/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Compiler vs Interpreter vs Assembler</h2></header><div class=entry-content><p>Compiler Vs Interpreter Vs Assembler 컴파일러, 인터프리터, 어셈블러는 소스 코드를 기계가 이해할 수 있는 형태로 변환하는 서로 다른 언어 처리 도구이다.
각각의 도구는 입력 언어, 처리 방식, 실행 시간 및 사용 목적에 따라 차별화된 특징을 가지며, 개발 환경이나 애플리케이션의 요구사항에 맞춰 선택된다.
컴파일러 (Compiler) 컴파일러는 C, C++, Java와 같이 고수준 언어로 작성된 소스 코드를 한 번에 분석하고 번역하여 실행 가능한 기계어 또는 객체 코드를 생성한다.
작동 원리:
어휘 분석(Lexical Analysis): 소스 코드를 토큰(token)으로 분해한다. 구문 분석(Syntax Analysis): 토큰들을 구문 규칙에 따라 분석하여 파싱 트리를 생성한다. 의미 분석(Semantic Analysis): 코드의 의미를 검사하고 타입 체킹 등을 수행한다. 중간 코드 생성(Intermediate Code Generation): 최적화를 위한 중간 표현을 생성한다. 코드 최적화(Code Optimization): 중간 코드를 최적화하여 효율성을 높인다. 목적 코드 생성(Code Generation): 최종적으로 목표 기계어 또는 바이트코드를 생성한다. 특징:
...</p></div><footer class=entry-footer><span title='2024-12-05 03:57:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;840 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Compiler vs Interpreter vs Assembler" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler-vs-interpreter-vs-assembler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>의사코드(Pseudocode)</h2></header><div class=entry-content><p>의사코드(Pseudocode) 의사코드(Pseudocode)는 알고리즘을 설명하기 위한 비공식적이고 고수준의 표현 방식으로, 특정 프로그래밍 언어의 문법에 얽매이지 않고 간단한 텍스트 형태로 작성된다.
이는 개발자가 문제를 해결하기 위한 논리를 설계하고, 이를 기반으로 실제 코드를 작성하기 전에 구조를 검토할 수 있도록 돕는다.
의사코드는 알고리즘 설계와 문제 해결 과정에서 중요한 도구로, 논리를 명확히 하고 코드 작성을 체계적으로 준비할 수 있도록 돕는다.
이를 통해 프로그래머는 복잡한 문제를 단순화하고 효율적으로 해결할 수 있다.
의사코드는 알고리즘 설계와 문제 해결 과정에서 매우 유용한 도구이다.
프로그래밍 언어의 복잡한 문법에 얽매이지 않고 순수하게 알고리즘의 논리에 집중할 수 있게 해주며, 다양한 배경을 가진 사람들 간의 의사소통을 원활하게 한다.
...</p></div><footer class=entry-footer><span title='2024-12-05 01:09:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1439 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 의사코드(Pseudocode)" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/pseudo-code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TCP/IP 4계층 - 4. Application Layer</h2></header><div class=entry-content><p>Application Layer TCP/IP 프로토콜 스택에서 가장 상위 계층으로, 사용자와 가장 가까운 계층이다.
이메일, 웹 서핑, 파일 전송 등의 서비스를 위한 프로토콜들이 모여 있는 계층이다.
https://cheapsslsecurity.com/blog/what-is-the-tcp-model-an-exploration-of-tcp-ip-layers/
주요 기능 사용자가 네트워크 서비스를 이용할 수 있도록 인터페이스를 제공한다. 응용 프로그램 간의 데이터 통신을 위한 프로토콜을 정의한다. 하위 계층의 서비스에 접근할 수 있는 기능을 제공한다. 데이터 단위 단위: 메시지(Message) / 데이터(Data) 구조: 순수한 애플리케이션 데이터 특징 클라이언트-서버 모델이나 P2P 구조로 구현될 수 있다. 소켓을 통해 전송 계층과 통신한다. OSI 7계층 모델의 세션 계층, 표현 계층, 응용 계층을 포함한다. Application Layer에서 소켓(Socket)의 역할:
...</p></div><footer class=entry-footer><span title='2024-10-17 05:58:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;332 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCP/IP 4계층 - 4. Application Layer" href=https://buenhyden.github.io/posts/backend/api-design/basics/tcp-ip-4-layers/tcpip-4-layers-4-application-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TCP/IP 4계층 - 4. Application Layer</h2></header><div class=entry-content><p>Application Layer TCP/IP 프로토콜 스택에서 가장 상위 계층으로, 사용자와 가장 가까운 계층이다.
이메일, 웹 서핑, 파일 전송 등의 서비스를 위한 프로토콜들이 모여 있는 계층이다.
https://cheapsslsecurity.com/blog/what-is-the-tcp-model-an-exploration-of-tcp-ip-layers/
주요 기능 사용자가 네트워크 서비스를 이용할 수 있도록 인터페이스를 제공한다. 응용 프로그램 간의 데이터 통신을 위한 프로토콜을 정의한다. 하위 계층의 서비스에 접근할 수 있는 기능을 제공한다. 데이터 단위 단위: 메시지(Message) / 데이터(Data) 구조: 순수한 애플리케이션 데이터 특징 클라이언트-서버 모델이나 P2P 구조로 구현될 수 있다. 소켓을 통해 전송 계층과 통신한다. OSI 7계층 모델의 세션 계층, 표현 계층, 응용 계층을 포함한다. Application Layer에서 소켓(Socket)의 역할:
...</p></div><footer class=entry-footer><span title='2024-10-17 05:58:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;332 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCP/IP 4계층 - 4. Application Layer" href=https://buenhyden.github.io/posts/networking-knowledge/tcp-ip-4-layers/tcpip-4-layers-4-application-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OSI 7 Layers - 4. Transport Layer</h2></header><div class=entry-content><p>Transport Layer(전송 계층) 전송 계층은 OSI 모델의 4번째 계층으로, 종단 간(end-to-end) 통신을 담당한다.
이 계층은 상위 계층에서 받은 데이터를 세그먼트로 분할하고, 목적지에서 다시 조립하여 신뢰성 있는 데이터 전송을 보장한다.
전송 계층은 네트워크 통신의 신뢰성과 효율성을 보장하는 중요한 역할을 수행하며, 상위 계층의 애플리케이션에 투명한 데이터 전송 서비스를 제공한다.
Source: https://www.cloudflare.com/ko-kr/learning/ddos/glossary/open-systems-interconnection-model-osi/
역할과 기능 세그멘테이션과 재조립: 데이터를 세그먼트로 분할하고 목적지에서 재조립한다. 연결 제어: 연결 지향적(TCP) 또는 비연결형(UDP) 서비스를 제공한다. 흐름 제어: 송신자와 수신자 간의 데이터 전송 속도를 조절한다. 오류 제어: 데이터 전송 중 발생한 오류를 감지하고 수정한다. 다중화와 역다중화: 여러 애플리케이션의 데이터를 하나의 연결로 전송하고 수신 시 분리한다. 세그멘테이션 (Segmentation)
...</p></div><footer class=entry-footer><span title='2024-10-16 07:17:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;627 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OSI 7 Layers - 4. Transport Layer" href=https://buenhyden.github.io/posts/networking-knowledge/osi-7-layers/osi-7-layers-4-transport-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network Traffic</h2></header><div class=entry-content><p>네트워크 트래픽 (Network Traffic) 네트워크 트래픽은 컴퓨터 네트워크를 통해 이동하는 데이터의 양을 의미한다.
이는 마치 도로의 차량 통행량과 유사한 개념으로 이해할 수 있다.
도로에 차가 많이 몰리면 정체가 발생하듯이, 네트워크에 데이터가 많이 몰리면 속도 저하나 지연이 발생할 수 있다.
구체적으로는 서버와 스위치 등 네트워크 장치에서 일정 시간 내에 전송되는 데이터의 양을 말한다.
트래픽은 보통 바이트 단위(KB, MB, GB 등)로 측정되며, 웹사이트나 네트워크의 사용량을 나타내는 지표로 활용된다.
네트워크 트래픽은 다음과 같은 특성을 가진다:
...</p></div><footer class=entry-footer><span title='2024-10-16 02:43:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2216 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Traffic" href=https://buenhyden.github.io/posts/networking-knowledge/network-traffic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Just-In-Time (JIT) Compiler</h2></header><div class=entry-content><p>Just-In-Time (JIT) Compiler Just-In-Time (JIT) 컴파일러는 프로그램 실행 도중에 필요할 때마다 바이트코드나 중간 표현(IR)을 해당 플랫폼의 네이티브 기계어로 변환하는 동적 컴파일 기술이다.
JIT 컴파일러는 전통적인 정적 컴파일러와 달리 프로그램이 실행되는 동안 “핫스팟"이라고 부르는 자주 실행되는 코드 영역을 감지하여, 이 부분을 최적화된 기계어 코드로 변환한 후 캐시에 저장함으로써 이후부터는 빠른 실행 속도를 제공할 수 있다. 주로 자바(JVM), 자바스크립트(V8), 닷넷(CLR) 등에서 사용되며, 런타임 최적화를 통해 애플리케이션 성능을 크게 향상시킨다.
JIT 컴파일은 런타임 유연성과 성능 사이의 균형을 찾은 기술이다.
모던 프로그래밍 언어와 프레임워크에서 필수적인 요소로 자리잡았으며, 클라우드 네이티브 환경과 실시간 애플리케이션에서 더욱 중요해질 전망이다.
개발자는 대상 시스템의 요구사항에 따라 JIT과 AOT를 전략적으로 조합해 사용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 17:55:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3462 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Just-In-Time (JIT) Compiler" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/types/just-in-time-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Native Compiler vs Cross Compiler</h2></header><div class=entry-content><p>Native Compiler Vs Cross Compiler Native Compiler와 Cross Compiler는 모두 프로그래밍 언어로 작성된 소스 코드를 기계어 또는 실행 가능한 바이너리로 변환하는 컴파일 도구이지만, 그들이 생성하는 산출물이 실행되는 대상이 서로 다르다는 점에서 구분된다.
Native Compiler는 컴파일러가 실행되는 동일한 시스템의 하드웨어와 운영체제에 최적화된 코드를 생성한다. Cross Compiler는 호스트 시스템에서 실행되지만 다른 플랫폼(즉, 대상 시스템)에서 실행될 코드를 생성한다. 네이티브 컴파일러(Native Compiler)의 이해 네이티브 컴파일러는 컴파일러가 실행되는 환경(호스트 시스템)과 동일한 환경(타겟 시스템)에서 실행될 코드를 생성하는 컴파일러이다. 즉, 개발자가 사용하는 컴퓨터와 동일한 운영체제 및 CPU 아키텍처에서 실행될 프로그램을 컴파일한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 03:33:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1097 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Native Compiler vs Cross Compiler" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/native-compiler-vs-cross-compiler/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>