<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>라이브러리 (Library)와 프레임워크 (Framework)</h2></header><div class=entry-content><p>라이브러리 (Library)와 프레임워크 (Framework) 프로그래밍에서 라이브러리와 프레임워크는 소프트웨어 개발의 핵심 도구
비교 기준 라이브러리 (Library) 프레임워크 (Framework) 정의 특정 기능을 수행하는 코드의 재사용 가능한 모음 애플리케이션 개발을 위한 기본 구조와 규칙의 집합 제어 흐름 개발자가 직접 제어 (Caller가 Callee를 호출) 프레임워크가 제어 (IoC: Inversion of Control) 유연성 높음 (필요한 부분만 선택적으로 사용 가능) 상대적으로 낮음 (정해진 규칙과 구조를 따라야 함) 학습 곡선 상대적으로 낮음 (특정 기능만 학습) 높음 (전체 구조와 규칙을 이해해야 함) 코드 구조화 개발자가 직접 설계 프레임워크가 기본 구조 제공 대표적 예시 • React.js (UI 라이브러리)
• NumPy (수치 계산)
• jQuery (DOM 조작)
• Requests (HTTP 통신) • Django (Python 웹)
• Spring (Java 엔터프라이즈)
• Angular (웹 프론트엔드)
• Laravel (PHP 웹) 주요 장점 • 필요한 기능만 선택적 사용
• 가볍고 유연한 구조
• 빠른 학습과 적용 가능
• 다른 도구와 쉽게 통합 • 일관된 코드 구조
• 표준화된 개발 방식
• 보안, 성능 최적화 제공
• 큰 규모의 프로젝트에 적합 주요 단점 • 구조화된 가이드 부족
• 일관성 있는 코드 작성 어려움
• 큰 프로젝트에서 관리 어려움 • 학습에 많은 시간 필요
• 유연성 제한
• 불필요한 기능도 포함될 수 있음 사용 시기 • 특정 기능만 필요할 때
• 작은 규모의 프로젝트
• 최대한의 자유도가 필요할 때 • 큰 규모의 프로젝트
• 표준화된 개발이 필요할 때
• 팀 단위 개발 시 라이브러리(Library) 라이브러리는 특정 기능을 수행하는 함수, 클래스, 모듈 등의 모음이다.
개발자가 필요할 때 호출하여 사용할 수 있는 도구 모음이라고 볼 수 있다
...</p></div><footer class=entry-footer><span title='2024-11-20 06:47:00 +0000 UTC'>November 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;268 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 라이브러리 (Library)와 프레임워크 (Framework)" href=https://buenhyden.github.io/posts/programming-languages/library-and-framework/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>TCP/IP 4계층 - 3. Transport Layer</h2></header><div class=entry-content><p>Transport Layer 전송 계층은 서로 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신을 제공한다.
이 계층은 애플리케이션 계층과 인터넷 계층 사이에 위치하여 두 계층을 이어주는 역할을 수행하며, 데이터가 목적지 애플리케이션까지 안전하게 전달되도록 한다.
https://cheapsslsecurity.com/blog/what-is-the-tcp-model-an-exploration-of-tcp-ip-layers/
주요 기능 데이터 분할 및 재조립: 애플리케이션 계층에서 받은 데이터를 세그먼트로 분할하고, 수신 측에서 다시 조립한다. 포트 번호 관리: 애플리케이션을 구분하기 위해 포트 번호를 사용한다. 연결 제어: TCP의 경우 연결 지향적 통신을 제공한다. 신뢰성 있는 데이터 전송: TCP는 데이터의 정확한 전달과 순서를 보장한다. 특징 종단 간 통신: 전송 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다. 다중화와 역다중화: 여러 애플리케이션의 데이터를 하나의 연결로 전송하고, 수신 측에서 다시 분리한다. 흐름 제어와 혼잡 제어: TCP의 경우 이러한 기능을 제공하여 네트워크의 효율성을 높인다. 데이터 단위 단위: 세그먼트(TCP) / 데이터그램(UDP) 구조: TCP/UDP 헤더 + 응용 계층 메시지 1 2 3 4 5 [TCP 헤더(20바이트)] [응용 계층 데이터] ┌──────────┬──────────┬────────┬────────┬──────┐ │출발지 포트│목적지 포트│시퀀스 번호│확인 응답│윈도우│ … │ (16비트) │ (16비트) │(32비트) │(32비트)│(16비트)│ └──────────┴──────────┴────────┴────────┴──────┘ 전송 계층의 서비스 품질 전송 계층은 다양한 서비스 품질(QoS) 요구사항을 지원한다:
...</p></div><footer class=entry-footer><span title='2024-10-17 05:58:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;186 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to TCP/IP 4계층 - 3. Transport Layer" href=https://buenhyden.github.io/posts/networking-knowledge/fundamentals/tcp-ip-4layers/tcpip-4-layers-3-transport-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>삽입 정렬 (Insertion Sort)</h2></header><div class=entry-content><p>삽입 정렬 (Insertion Sort) 삽입 정렬은 간단하면서도 직관적인 정렬 알고리즘으로, 실생활에서 카드 게임을 할 때 손에 든 카드를 정렬하는 방식과 매우 유사하다.
삽입 정렬은 간단하고 직관적인 정렬 알고리즘으로, 작은 데이터셋이나 거의 정렬된 데이터에서 효율적으로 작동한다.
비록 큰 데이터셋에서는 O(n²)의 시간 복잡도로 인해 퀵 정렬, 합병 정렬, 힙 정렬 등에 비해 느리지만, 그 단순함과 특정 상황에서의 효율성으로 인해 여전히 중요한 알고리즘이다.
실제 응용에서는 종종 다른 정렬 알고리즘과 함께 하이브리드 접근 방식으로 사용되며, 이를 통해 더 나은 성능을 얻을 수 있다. 또한 이진 탐색을 활용한 최적화나 셸 정렬과 같은 변형을 통해 성능을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1449 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 삽입 정렬 (Insertion Sort)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/algorithms/sorting/insertion-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ahead-of-Time Compiler</h2></header><div class=entry-content><p>Ahead-of-Time (AOT) Compiler Ahead-of-Time(AOT) 컴파일러는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 네이티브 머신 코드로 미리 변환하는 기술이다. 이는 런타임 동안의 동적 컴파일 오버헤드를 제거하여, 프로그램이 시작될 때 바로 최적화된 실행 코드를 사용할 수 있도록 함으로써 빠른 시작 시간과 예측 가능한 성능을 제공한다.
AOT 컴파일러는 프로그램 실행 전에 소스 코드를 네이티브 코드로 변환하여 실행 성능을 최적화하는 중요한 도구이다. 특히 시작 시간, 예측 가능한 성능, 메모리 효율성이 중요한 환경에서 큰 이점을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1733 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Ahead-of-Time Compiler" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-processor/compiler/types/ahead-of-time-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Callback Hell</h2></header><div class=entry-content><p>Callback Hell 콜백 지옥은 여러 비동기 작업을 순차적으로 처리해야 할 때 발생하는 중첩된 콜백 구조를 말한다. 코드가 깊게 중첩되어 가독성이 떨어지고 유지보수가 어려워지는 문제가 있다.
이는 주로 여러 비동기 작업(API 호출, 파일 읽기, 타이머 등)이 순차적으로 실행되어야 할 때 발생하며, 코드가 피라미드 형태로 깊이 중첩되는 특징을 보인다.
콜백 지옥의 원인 비동기 작업의 연속성:
A 작업의 결과가 B 작업의 입력으로 필요할 때, 콜백 안에 콜백을 중첩해야 한다. JavaScript의 단일 스레드 특성:
비동기 작업 완료 시점을 콜백 함수로 처리해야 하므로 중첩이 불가피한다. 주요 문제점 문제점 설명 가독성 저하 코드의 들여쓰기 수준이 과도하게 증가하여 논리 흐름 파악이 어렵다. 에러 처리 복잡 각 콜백마다 별도의 에러 핸들링이 필요해 중복 코드가 발생한다. 유지보수 난이도 기능 수정 시 중첩 구조에서 의도치 않은 버그 발생 가능성이 높다. 해결 방법 1 2 3 4 5 6 7 8 9 10 11 getData(function(a) { getMoreData(a, function(b) { getEvenMoreData(b, function(c) { getYetEvenMoreData(c, function(d) { getFinalData(d, function(finalData) { console.log("최종 데이터:", finalData); }, errorCallback); }, errorCallback); }, errorCallback); }, errorCallback); }, errorCallback); 함수 분리 (모듈화) 각 콜백을 별도의 명명된 함수로 분리하여 중첩을 줄인다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:39:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;426 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Hell" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/callback-hell/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>정수(Integer)</h2></header><div class=entry-content><p>정수 (Integer) 정수(Integer)는 소수점이 없는 양수, 음수, 0을 표현하는 데이터 타입으로, 컴퓨터에서는 이진수로 표현되며, 일정 범위의 정수를 표현할 수 있다.
특징과 특성 고정된 크기의 메모리 사용 빠른 연산 속도 범위의 제한 (오버플로우 가능성) 직접적인 산술 연산 지원 종류 byte
범위: -128 ~ 127 8비트 비트 구성: 1비트 부호 + 7비트 값 특징: 가장 작은 정수 타입 메모리 효율적이지만 표현 범위가 제한적 주로 작은 범위의 데이터나 문자 표현에 사용 short
범위: -32,768 ~ 32,767 16비트 비트 구성: 1비트 부호 + 15비트 값 특징: 8비트보다 넓은 범위 표현 가능 메모리 사용량과 표현 범위의 균형이 좋음 작은 정수 값을 다룰 때 효율적 int
...</p></div><footer class=entry-footer><span title='2024-10-07 07:31:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;593 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 정수(Integer)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/primitive/integer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Programming Language Control Structures</h2></header><div class=entry-content><p>Programming Language Control Structures 프로그래밍에서 코드의 실행 흐름을 제어하는 핵심적인 구문이다.
Iteration Structures 특정 코드 블록을 반복적으로 실행하기 위한 구조
Language For Loop While Loop Do-While For-Each/Range Python for x in sequence while condition N/A for x in iterable Java for(init;condition;increment) while(condition) do {…} while(condition) for(Type x: collection) JavaScript for(let i=0;i&lt;n;i++) while(condition) do {…} while(condition) for(let x of iterable) TypeScript Same as JavaScript + type safety Same as JavaScript Same as JavaScript Same as JavaScript Golang for i:=0; i&lt;n; i++ for condition N/A for _, v:= range slice Kotlin for (i in range) while(condition) do {…} while(condition) for (item in collection) Rust for x in iter while condition loop {…} for x in collection Conditional Statements 특정 조건에 따라 다른 코드 블록을 실행하도록 하는 구조
...</p></div><footer class=entry-footer><span title='2024-10-06 11:12:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;278 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Programming Language Control Structures" href=https://buenhyden.github.io/posts/programming-languages/fundamentals/language-syntax/programming-language-control-structures/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)</h2></header><div class=entry-content><p>사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE) 사이트 신뢰성 엔지니어링(Site Reliability Engineering, SRE)은 IT 운영에 대한 소프트웨어 엔지니어링 접근 방식이다.
이 개념은 Google의 Ben Treynor Sloss가 2003년에 창안했으며, 소프트웨어 시스템의 안정성과 신뢰성을 유지하고 향상시키는 것을 목표로 한다.
예시를 들어, 설명해보면:
온라인 쇼핑몰을 운영하는 회사에서 SRE 팀이 다음과 같은 작업을 수행할 수 있다:
서비스 수준 목표 설정: 웹사이트 가용성 99.99%, 페이지 로드 시간 2초 이내 등의 목표를 정한다. 모니터링 시스템 구축: 실시간으로 웹사이트 트래픽, 서버 성능, 주문 처리 속도 등을 모니터링하는 대시보드를 만든다. 자동화: 서버 프로비저닝, 데이터베이스 백업, 보안 패치 적용 등의 작업을 자동화하는 스크립트를 개발한다. 장애 대응: 블랙프라이데이와 같은 대규모 세일 기간 동안 급증하는 트래픽에 대비한 대응 계획을 수립하고, 실제 장애 발생 시 신속하게 대응한다. 성능 최적화: 데이터베이스 쿼리 최적화, 캐싱 전략 수립, CDN 활용 등을 통해 웹사이트 성능을 지속적으로 개선한다. SRE는 개발팀과 운영팀 사이의 가교 역할을 하며, 소프트웨어의 안정성과 확장성을 보장하는 동시에 새로운 기능의 빠른 출시를 가능하게 한다.
이를 통해 기업은 고객에게 더 나은 서비스를 제공하고 비즈니스 목표를 달성할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-28 09:18:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;761 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 사이트 신뢰성 엔지니어링 (Site Reliability Engineering, SRE)" href=https://buenhyden.github.io/posts/devops/sre/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)</h2></header><div class=entry-content><p>요구사항 수집 및 분석 (Requirements Gathering and Analysis) 이해관계자의 요구사항을 수집하고 분석하여 시스템 요구사항을 정의하는 단계
요구사항 도출 주요 목적 프로젝트의 모든 이해관계자로부터 필요한 요구사항을 수집한다. 개발될 시스템의 기능적, 비기능적 요구사항을 파악한다. 사용자의 실제 니즈와 기대사항을 정확히 이해한다. 프로젝트의 범위와 제약사항을 명확히 한다. 향후 개발 과정의 기초가 되는 정보를 수집한다. 잠재적인 문제점과 리스크를 조기에 식별한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 이해관계자 식별 및 분석 프로젝트와 관련된 모든 이해관계자 파악 및 분석 이해관계자 목록 및 분석 보고서 인터뷰 실시 주요 이해관계자와의 일대일 또는 그룹 인터뷰 진행 인터뷰 기록 및 요약 보고서 설문조사 수행 광범위한 사용자 그룹을 대상으로 설문조사 실시 설문조사 결과 분석 보고서 워크샵 및 브레인스토밍 그룹 토론을 통한 아이디어 및 요구사항 도출 워크샵 결과 문서 현행 시스템 분석 기존 시스템의 기능 및 문제점 분석 현행 시스템 분석 보고서 문서 검토 관련 비즈니스 문서, 정책, 절차 등 검토 문서 검토 요약 관찰 및 현장 조사 실제 업무 환경 관찰 및 사용자 행동 분석 관찰 보고서 프로토타이핑 초기 프로토타입 개발 및 사용자 피드백 수집 프로토타입 및 사용자 피드백 문서 주의해야할 요소 주의 요소 설명 이해관계자 다양성 고려 모든 관련 이해관계자의 의견을 균형있게 수집 숨겨진 요구사항 발견 명시적으로 표현되지 않은 잠재적 요구사항 파악 객관성 유지 개인적 편견 없이 중립적인 태도로 요구사항 수집 과도한 요구사항 관리 실현 가능성과 프로젝트 범위를 고려한 요구사항 관리 의사소통 명확성 모호한 표현을 피하고 명확한 언어로 요구사항 기술 일관성 유지 다양한 출처에서 수집된 요구사항 간의 일관성 확보 변화하는 요구사항 대응 프로젝트 진행 중 변경되는 요구사항에 유연하게 대응 우선순위 설정 요구사항의 중요도와 우선순위 적절히 설정 기술적 제약 고려 기술적 실현 가능성을 고려한 요구사항 수집 문서화의 정확성 수집된 요구사항을 정확하고 상세하게 문서화 요구사항 분석 주요 목적 수집된 요구사항을 체계적으로 정리하고 구조화한다. 요구사항 간의 관계와 의존성을 파악한다. 모호하거나 불완전한 요구사항을 명확히 한다. 요구사항의 우선순위를 설정한다. 요구사항의 실현 가능성과 일관성을 평가한다. 시스템의 범위와 경계를 명확히 정의한다. 향후 설계 및 개발 단계의 기초를 마련한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 분류 및 구조화 수집된 요구사항을 기능적/비기능적 등으로 분류 구조화된 요구사항 목록 요구사항 모델링 요구사항을 다이어그램 등으로 시각화 유스케이스 다이어그램, 데이터 흐름도 요구사항 명세화 각 요구사항을 상세히 기술 상세 요구사항 명세서 요구사항 검증 요구사항의 정확성, 일관성, 완전성 검토 요구사항 검증 보고서 요구사항 우선순위 지정 요구사항의 중요도와 구현 순서 결정 우선순위가 지정된 요구사항 목록 요구사항 협상 충돌하는 요구사항에 대한 이해관계자 간 협의 협상 결과 문서 요구사항 추적성 분석 요구사항 간의 연관관계 파악 요구사항 추적성 매트릭스 비즈니스 규칙 도출 시스템에 적용될 비즈니스 규칙 식별 비즈니스 규칙 문서 주의해야할 요소 주의 요소 설명 요구사항의 명확성 모호하거나 불명확한 요구사항을 명확히 정의 요구사항 간 일관성 서로 충돌하거나 모순되는 요구사항 해결 실현 가능성 검토 기술적, 시간적, 비용적 측면에서 실현 가능한지 평가 범위 관리 프로젝트 범위를 벗어나는 요구사항 식별 및 관리 이해관계자 참여 분석 과정에 주요 이해관계자의 지속적인 참여 보장 비즈니스 목표 연계 각 요구사항이 비즈니스 목표와 연계되는지 확인 변경 관리 요구사항 변경에 대한 체계적인 관리 프로세스 수립 추적성 확보 요구사항의 출처와 향후 설계/구현과의 연계성 유지 품질 속성 고려 성능, 보안, 사용성 등 비기능적 요구사항 충분히 고려 문서화의 적절성 분석 결과를 명확하고 이해하기 쉽게 문서화 요구사항 명세 주요 목적 수집 및 분석된 요구사항을 명확하고 구체적으로 문서화한다. 모든 이해관계자가 이해할 수 있는 형태로 요구사항을 표현한다. 개발 팀이 설계와 구현에 활용할 수 있는 상세한 기준을 제공한다. 테스트 및 검증의 기준이 되는 문서를 작성한다. 프로젝트의 범위와 기능을 명확히 정의한다. 향후 변경 관리와 추적성 확보를 위한 기준점을 마련한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 기능적 요구사항 작성 시스템이 수행해야 할 기능들을 상세히 기술 기능적 요구사항 문서 비기능적 요구사항 작성 성능, 보안, 사용성 등의 품질 요구사항 정의 비기능적 요구사항 문서 유스케이스 작성 사용자와 시스템 간의 상호작용을 시나리오 형태로 기술 유스케이스 문서 요구사항 모델링 요구사항을 다이어그램 등으로 시각화 UML 다이어그램 (유스케이스, 클래스, 시퀀스 등) 인터페이스 요구사항 정의 사용자 인터페이스, 외부 시스템 인터페이스 등 정의 인터페이스 요구사항 명세서 데이터 요구사항 정의 시스템에서 다룰 데이터의 구조와 특성 정의 데이터 사전, ER 다이어그램 제약사항 및 가정 문서화 프로젝트의 제약사항과 가정사항 명시 제약사항 및 가정 목록 요구사항 명세서 통합 모든 요구사항을 종합한 문서 작성 소프트웨어 요구사항 명세서(SRS) 주의해야할 요소 주의 요소 설명 명확성과 구체성 모호하지 않고 구체적으로 요구사항을 기술 일관성 유지 요구사항 간 충돌이나 모순이 없도록 유지 완전성 확보 모든 필요한 요구사항이 누락 없이 포함되도록 함 검증 가능성 각 요구사항이 테스트나 검증 가능하도록 작성 추적성 확보 요구사항의 출처와 향후 설계/구현과의 연계성 유지 우선순위 표시 각 요구사항의 중요도나 구현 우선순위를 명시 사용자 중심 기술 최종 사용자의 관점에서 이해하기 쉽게 기술 기술적 중립성 특정 기술이나 구현 방식에 치우치지 않도록 주의 변경 용이성 향후 변경이 용이하도록 모듈화하여 작성 표준 준수 조직이나 산업의 요구사항 명세 표준을 준수 요구사항 검증 주요 목적 수집 및 명세된 요구사항의 정확성, 완전성, 일관성을 확인한다. 요구사항이 이해관계자의 실제 니즈를 정확히 반영하는지 검증한다. 요구사항의 실현 가능성과 테스트 가능성을 평가한다. 요구사항 간의 충돌이나 모순을 식별하고 해결한다. 프로젝트의 목표와 범위에 부합하는지 확인한다. 잠재적인 리스크와 문제점을 조기에 발견하고 해결한다. 요구사항 문서의 품질을 향상시킨다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 검토 회의 이해관계자와 함께 요구사항을 검토하고 논의 검토 회의록, 수정 요구사항 목록 정형 인스펙션 체계적인 방법으로 요구사항 문서를 검사 인스펙션 보고서 워크스루 요구사항을 단계별로 검토하며 문제점 식별 워크스루 결과 문서 프로토타이핑 요구사항의 실현 가능성을 검증하기 위한 프로토타입 개발 프로토타입, 사용자 피드백 문서 요구사항 추적성 분석 요구사항 간의 연관관계와 일관성 검증 요구사항 추적성 매트릭스 모델 검증 요구사항 모델(예: UML 다이어그램)의 정확성 검증 모델 검증 보고서 체크리스트 기반 검증 미리 정의된 체크리스트를 사용한 요구사항 검증 체크리스트 결과 문서 자동화 도구를 이용한 검증 요구사항 관리 도구를 사용한 자동 검증 자동화 검증 결과 보고서 주의해야할 요소 주의 요소 설명 객관성 유지 개인적 편견 없이 객관적으로 요구사항을 검증 이해관계자 참여 다양한 이해관계자의 참여로 다각도 검증 일관성 확보 요구사항 간 일관성과 전체적인 조화 확인 실현 가능성 평가 기술적, 시간적, 비용적 측면에서의 실현 가능성 검토 명확성 검증 모호하거나 해석의 여지가 있는 요구사항 식별 완전성 확인 누락된 요구사항이나 정보가 없는지 확인 테스트 가능성 각 요구사항이 테스트 가능한 형태인지 검증 우선순위 재확인 요구사항의 우선순위가 적절히 설정되었는지 확인 변경 영향 분석 요구사항 변경이 미치는 영향 평가 문서화 품질 요구사항 문서의 가독성과 이해도 확인 요구사항 관리 계획 수립 주요 목적 요구사항의 체계적인 관리를 위한 프로세스와 절차를 정의한다. 요구사항의 변경을 효과적으로 통제하고 관리한다. 프로젝트 전 과정에 걸쳐 요구사항의 일관성과 추적성을 유지한다. 이해관계자 간의 요구사항 관련 의사소통을 원활히 한다. 요구사항 관련 리스크를 식별하고 관리한다. 요구사항 변경이 프로젝트에 미치는 영향을 평가하고 관리한다. 요구사항 관리에 필요한 자원과 도구를 계획한다. 세부 활동과 산출물 세부 활동 설명 주요 산출물 요구사항 관리 프로세스 정의 요구사항 수집, 분석, 문서화, 검증 등의 프로세스 수립 요구사항 관리 프로세스 문서 변경 관리 절차 수립 요구사항 변경 요청, 평가, 승인, 구현 절차 정의 변경 관리 절차서 요구사항 추적성 계획 요구사항 간 및 다른 산출물과의 추적성 유지 방법 정의 요구사항 추적성 계획서 요구사항 우선순위 지정 방법 요구사항 우선순위 결정 기준 및 방법 정의 우선순위 지정 가이드라인 요구사항 속성 정의 각 요구사항에 대해 추적할 속성 정의 (예: 상태, 담당자 등) 요구사항 속성 정의서 도구 및 저장소 선정 요구사항 관리에 사용할 도구와 저장소 결정 도구 선정 보고서 역할 및 책임 정의 요구사항 관리 관련 역할과 책임 할당 RACI 매트릭스 의사소통 계획 수립 요구사항 관련 의사소통 방법 및 빈도 정의 의사소통 계획서 주의해야할 요소 주의 요소 설명 유연성 확보 프로젝트 특성에 맞는 유연한 관리 프로세스 설계 이해관계자 참여 모든 주요 이해관계자의 동의와 참여 보장 변경 영향 분석 요구사항 변경이 프로젝트에 미치는 영향 평가 방법 포함 버전 관리 요구사항 문서의 효과적인 버전 관리 방법 수립 보안 고려 민감한 요구사항 정보의 보안 유지 방안 마련 통합성 다른 프로젝트 관리 프로세스와의 통합성 확보 확장성 프로젝트 규모 변화에 대응할 수 있는 확장성 있는 계획 수립 측정 및 개선 요구사항 관리 프로세스의 효과성 측정 및 개선 방안 포함 도구 활용 적절한 요구사항 관리 도구 선정 및 활용 계획 수립 교육 및 훈련 팀원들의 요구사항 관리 역량 강화를 위한 교육 계획 포함 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-20 00:53:00 +0000 UTC'>September 20, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1235 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 2. 요구사항 수집 및 분석 (Requirements Gathering and Analysis)" href=https://buenhyden.github.io/posts/qa/sdlc/2-requirements-gathering-and-analysis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Edge List</h2></header><div class=entry-content><p>Edge List 참고 및 출처</p></div><footer class=entry-footer><span title='2024-12-07 14:01:00 +0000 UTC'>December 7, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Edge List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/graph/representation/edge-list/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>