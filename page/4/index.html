<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.154.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.5311427199677f919b17469b4ca383951185b54edbae0ec7a5b4378f78d8f4f4.css integrity="sha256-UxFCcZlnf5GbF0abTKODlRGFtU7brg7HpbQ3j3jY9PQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>LLVM vs 기존 컴파일러 비교</h2></header><div class=entry-content><p>LLVM vs. 기존 컴파일러 비교 LLVM(Low Level Virtual Machine)은 모듈식 컴파일러 인프라스트럭처로, 다양한 프로그래밍 언어와 하드웨어 플랫폼을 지원하도록 설계되었다.
LLVM은 현대 컴파일러 인프라스트럭처의 중요한 혁신으로, 모듈화된 설계, 강력한 최적화 기능, 다양한 언어와 타겟 지원을 통해 소프트웨어 개발 환경을 크게 발전시켰다.
전통적인 컴파일러와 비교할 때, LLVM은 재사용성, 확장성, 개발자 친화적 도구 측면에서 큰 강점을 가지고 있다.
그러나 복잡성, 특수 타겟 지원, 리소스 요구사항 등의 측면에서는 여전히 개선의 여지가 있다. 또한 GCC와 같은 전통적인 컴파일러도 계속 발전하면서 LLVM의 장점을 일부 수용하고 있다.
...</p></div><footer class=entry-footer><span title='2024-12-05 07:28:00 +0000 UTC'>December 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to LLVM vs 기존 컴파일러 비교" href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/interpreter-vs-compiler-vs-assembler/compiler/llvm-vs-%EA%B8%B0%EC%A1%B4-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EB%B9%84%EA%B5%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CSR vs SSR</h2></header><div class=entry-content><p>CSR (Client Side Rendering) vs. SSR (Server Side Rendering) 비교 항목 Client Side Rendering (CSR) Server Side Rendering (SSR) 렌더링 방식 브라우저에서 JavaScript를 실행하여 콘텐츠를 렌더링 서버에서 HTML을 생성하여 클라이언트에 전달 초기 로딩 시간 상대적으로 긺 (JavaScript 번들을 모두 다운로드하고 실행해야 함) 상대적으로 빠름 (이미 렌더링된 HTML을 받음) 초기 컨텐츠 표시 빈 페이지 후 로딩 즉시 컨텐츠 표시 서버 부하 낮음 (정적 파일만 제공) 높음 (매 요청마다 HTML 생성) SEO 친화성 낮음 (JavaScript 실행 전까지 빈 HTML) 높음 (완성된 HTML이 검색 엔진에 제공) 상호작용성 높음 상대적으로 낮음 후속 페이지 로딩 빠름 각 요청마다 서버 처리 필요 Time to First Paint (TFP) 느림 빠름 Time to Interactive (TTI) JavaScript 로드 후 빠름 JavaScript 로드 필요시 추가 시간 소요 메모리 사용량 클라이언트 측 높음 서버 측 높음 사용자 경험 초기 로딩 후 빠른 페이지 전환 페이지 전환마다 서버 요청 필요 캐싱 전략 JavaScript 파일과 정적 자원 캐싱 용이 동적 HTML 캐싱이 복잡할 수 있음 개발 복잡도 상대적으로 단순 (단일 JavaScript 애플리케이션) 상대적으로 복잡 (서버와 클라이언트 로직 모두 관리) 보안 중요 로직이 클라이언트에 노출될 수 있음 중요 로직을 서버에서 처리하여 안전 오프라인 기능 구현 용이 제한적 데이터 업데이트 실시간 업데이트 용이 페이지 새로고침 필요 대역폭 사용 초기에 높음, 이후 낮음 지속적으로 중간 수준 서버 인프라 요구사항 낮음 (정적 호스팅 가능) 높음 (동적 서버 필요) 리소스 사용 클라이언트 리소스 많이 사용 서버 리소스 많이 사용 데이터 업데이트 실시간 업데이트 용이 페이지 새로고침 필요할 수 있음 적합한 사용 사례 대시보드, SPA, 관리자 패널 블로그, 뉴스 사이트, 전자상거래 프레임워크 예시 React, Vue, Angular Next.js, Nuxt.js, Angular Universal 유지보수성 프론트엔드 중심 유지보수 프론트엔드와 백엔드 모두 유지보수 필요 이 두 방식은 각각의 장단점이 있으며, 최근에는 이들의 장점을 결합한 하이브리드 렌더링 방식(예: Next.js의 정적 생성과 서버 사이드 렌더링 조합)이 많이 사용되고 있다.
프로젝트의 요구사항과 특성에 따라 적절한 렌더링 방식을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-02 12:28:00 +0000 UTC'>December 2, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CSR vs SSR" href=https://buenhyden.github.io/posts/software-development--engineering/platform-development/frontend-development/advanced-topics/rendering/csr-vs-ssr/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OSI vs.TCP/IP Model</h2></header><div class=entry-content><p>OSI vs.TCP/IP Model TCP/IP(Internet Protocol Suite) 와 OSI 참조 모델은 계층화 철학이 다르다.
OSI 는 ISO 표준의 개념적 7 계층으로 기능을 세분해 교육·표준화·원인분석에 적합하고, TCP/IP 는 RFC 기반의 실무적 4 계층 (또는 5 계층 변형) 으로 운영체제·네트워크 장비의 실제 프로토콜과 직접 매핑된다.
실무에서는 TCP/IP 를 기준으로 시스템 설계·모니터링·보안 배치를 하고, OSI 모델은 문제 구간 식별과 교육용 틀로 병행 활용하는 것이 현실적이다.
기초 개념 및 배경 비교 개념 정의 및 본질 차이 TCP/IP 와 OSI 는 둘 다 네트워크를 이해하기 위한 ’ 계층화 ’ 도구다.
다만 TCP/IP 는 실제 인터넷에서 사용하는 **프로토콜들의 집합 (실무 기준)**이고, OSI 는 통신 기능을 세밀하게 나눈 교육·설계용 참조 모델이다.
...</p></div><footer class=entry-footer><span title='2024-10-19 02:11:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;47 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OSI vs.TCP/IP Model" href=https://buenhyden.github.io/posts/networking--protocols/network-fundamentals/basic-concepts/network-models/osi-vs-tcp-ip-model/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>삽입 정렬 (Insertion Sort)</h2></header><div class=entry-content><p>삽입 정렬 (Insertion Sort) 삽입 정렬은 간단하면서도 직관적인 정렬 알고리즘으로, 실생활에서 카드 게임을 할 때 손에 든 카드를 정렬하는 방식과 매우 유사하다.
삽입 정렬은 간단하고 직관적인 정렬 알고리즘으로, 작은 데이터셋이나 거의 정렬된 데이터에서 효율적으로 작동한다.
비록 큰 데이터셋에서는 O(n²)의 시간 복잡도로 인해 퀵 정렬, 합병 정렬, 힙 정렬 등에 비해 느리지만, 그 단순함과 특정 상황에서의 효율성으로 인해 여전히 중요한 알고리즘이다.
실제 응용에서는 종종 다른 정렬 알고리즘과 함께 하이브리드 접근 방식으로 사용되며, 이를 통해 더 나은 성능을 얻을 수 있다. 또한 이진 탐색을 활용한 최적화나 셸 정렬과 같은 변형을 통해 성능을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 삽입 정렬 (Insertion Sort)" href=https://buenhyden.github.io/posts/data-structures--algorithms/core-concepts/linear-structures--algorithms/arrays--lists/array--list-algorithms/sorting-algorithms/insertion-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Ahead-of-Time Compiler</h2></header><div class=entry-content><p>Ahead-of-Time (AOT) Compiler Ahead-of-Time(AOT) 컴파일러는 프로그램 실행 전에 소스 코드나 중간 언어(예: 바이트코드)를 네이티브 머신 코드로 미리 변환하는 기술이다. 이는 런타임 동안의 동적 컴파일 오버헤드를 제거하여, 프로그램이 시작될 때 바로 최적화된 실행 코드를 사용할 수 있도록 함으로써 빠른 시작 시간과 예측 가능한 성능을 제공한다.
AOT 컴파일러는 프로그램 실행 전에 소스 코드를 네이티브 코드로 변환하여 실행 성능을 최적화하는 중요한 도구이다. 특히 시작 시간, 예측 가능한 성능, 메모리 효율성이 중요한 환경에서 큰 이점을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-10-14 18:02:00 +0000 UTC'>October 14, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Ahead-of-Time Compiler" href=https://buenhyden.github.io/posts/programming-languages/foundations/language-theory/compilation-and-interpretation/compiler-types/ahead-of-time-compiler/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Callback Hell</h2></header><div class=entry-content><p>Callback Hell 콜백 지옥은 여러 비동기 작업을 순차적으로 처리해야 할 때 발생하는 중첩된 콜백 구조를 말한다. 코드가 깊게 중첩되어 가독성이 떨어지고 유지보수가 어려워지는 문제가 있다.
이는 주로 여러 비동기 작업(API 호출, 파일 읽기, 타이머 등)이 순차적으로 실행되어야 할 때 발생하며, 코드가 피라미드 형태로 깊이 중첩되는 특징을 보인다.
콜백 지옥의 원인 비동기 작업의 연속성:
A 작업의 결과가 B 작업의 입력으로 필요할 때, 콜백 안에 콜백을 중첩해야 한다. JavaScript의 단일 스레드 특성:
비동기 작업 완료 시점을 콜백 함수로 처리해야 하므로 중첩이 불가피한다. 주요 문제점 문제점 설명 가독성 저하 코드의 들여쓰기 수준이 과도하게 증가하여 논리 흐름 파악이 어렵다. 에러 처리 복잡 각 콜백마다 별도의 에러 핸들링이 필요해 중복 코드가 발생한다. 유지보수 난이도 기능 수정 시 중첩 구조에서 의도치 않은 버그 발생 가능성이 높다. 해결 방법 1 2 3 4 5 6 7 8 9 10 11 getData(function(a) { getMoreData(a, function(b) { getEvenMoreData(b, function(c) { getYetEvenMoreData(c, function(d) { getFinalData(d, function(finalData) { console.log("최종 데이터:", finalData); }, errorCallback); }, errorCallback); }, errorCallback); }, errorCallback); }, errorCallback); 함수 분리 (모듈화) 각 콜백을 별도의 명명된 함수로 분리하여 중첩을 줄인다.
...</p></div><footer class=entry-footer><span title='2024-10-09 05:39:00 +0000 UTC'>October 9, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Hell" href=https://buenhyden.github.io/posts/programming-languages/javascript-family/javascript/core-features/asynchronous-programming/callback/callback-hell/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GitLab Flow</h2></header><div class=entry-content><p>GitLab Flow GitLab Flow는 GitLab에서 제안한 브랜치 전략으로, 기능 중심 개발과 이슈 추적을 통합하여 소프트웨어 개발을 간소화한다. 이는 GitFlow의 복잡성을 줄이고, GitHub Flow의 단순함을 유지하면서도 다양한 배포 환경을 지원하는 유연성을 제공한다.
핵심 개념 GitLab Flow의 핵심 개념은 다음과 같다:
업스트림 퍼스트(Upstream First): 항상 상위 환경으로 먼저 병합하는 원칙 이슈 추적 통합: GitLab 이슈와 머지 리퀘스트(MR)의 긴밀한 연계 상황별 워크플로우: 프로젝트 특성에 따라 선택 가능한 세 가지 모델 메인 브랜치: main: 배포 가능한 코드 보유. 환경 브랜치: 개발, 스테이징, 프로덕션 등 각 배포 환경에 대응하는 장수 브랜치 staging, pre-prod, production: 단계별 테스트 및 배포. 기능 브랜치: 새로운 기능 개발을 위한 단기 브랜치 feature/*: 기능 개발 후 main에 병합. 풀 리퀘스트: 코드 리뷰 및 병합 프로세스. graph TD main[main 브랜치] -->|분기| feature[feature/기능] feature -->|풀 리퀘스트| main main -->|병합| staging[staging] staging -->|병합| pre-prod[pre-prod] pre-prod -->|병합| production[production] ▲ GitLab Flow 환경 브랜치 워크플로우[3][6]
https://www.linkedin.com/pulse/gitlab-flow-jadson-santos
...</p></div><footer class=entry-footer><span title='2024-09-29 13:47:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GitLab Flow" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/branch-strategies/gitlab-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Branching and Merging</h2></header><div class=entry-content><p>Branching and Merging Branching and Merging은 Git 과 같은 분산 버전 관리 시스템에서 핵심적인 기능이다. 브랜칭은 독립적인 작업 공간을 생성하여 여러 개발자가 동시에 작업할 수 있게 하며, 머징은 이러한 작업 결과를 하나의 코드베이스로 통합한다. 이를 통해 병렬 개발, 기능 분리, 코드 안정성 유지 등이 가능해진다. Git, SVN, Mercurial 등 다양한 버전 관리 시스템에서 지원되며, 현대 소프트웨어 개발의 필수 요소이다.
핵심 개념 Branching (브랜칭): 코드베이스의 복사본 생성으로 기능 개발/버그 수정을 격리한다. Merging (머징): 분리된 변경 사항을 메인 코드베이스에 통합하는 과정이다. HEAD: 현재 작업 중인 브랜치의 최신 커밋을 가리키는 포인터이다. graph TD main[main] -->|분기| feature[feature/login] feature -->|머지| main main -->|배포| Production 목적 병렬 개발 환경 제공 코드 충돌 최소화 기능별/작업별 독립적 개발 지원 안정적인 배포 프로세스 구축 필요성 다수의 개발자가 동시에 작업하는 환경에서 협업 효율성 증대 프로덕션 코드의 안정성 보장 실험적 기능 개발과 버그 수정의 분리 코드 리뷰와 품질 관리 용이성 주요 기능 브랜치 생성/삭제 브랜치 전환 (Checkout) 코드 병합 (Merge) 리베이스 (Rebase) 충돌 해결 (Conflict Resolution) 특징 분산형 개발 지원 비선형적 개발 이력 관리 원격 저장소와의 동기화 다양한 병합 전략 제공 장점과 단점 구분 항목 설명 ✅ 장점 병렬 개발 여러 기능을 동시에 개발 가능 안정성 메인 브랜치의 안정성 유지 실험 용이성 실험적 기능을 안전하게 테스트 롤백 용이성 문제 발생 시 쉽게 이전 상태로 복구 ⚠ 단점 복잡성 브랜치가 많아지면 관리가 복잡 충돌 발생 병합 시 코드 충돌 가능성 학습 곡선 초보자에게 어려운 개념 리소스 사용 브랜치별 리소스 사용량 증가 주요 원리 구성 요소 기능 역할 HEAD 현재 브랜치 참조 현재 작업 중인 브랜치를 가리킴 Branch Pointer 커밋 참조 특정 커밋을 가리키는 포인터 Commit Object 변경사항 저장 코드 변경 내용과 메타데이터 저장 Tree Object 디렉토리 구조 파일과 디렉토리 구조 표현 Merge Base 공통 조상 커밋 브랜치 분기점 식별 Branching 브랜칭의 주요 원리는 포인터 기반의 참조 시스템이다:
...</p></div><footer class=entry-footer><span title='2024-09-28 09:56:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Branching and Merging" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/git-fundamentals/branching-and-merging/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SVN Mercurial Overview</h2></header><div class=entry-content><p>SVN Mercurial Overview SVN(Subversion)과 Mercurial은 소프트웨어 개발에서 코드의 변경 이력을 관리하고 협업을 지원하는 버전 관리 시스템이다. SVN은 중앙 집중형(Centralized) 시스템으로, 모든 버전 이력이 중앙 서버에 저장된다. 반면, Mercurial은 분산형(Distributed) 시스템으로, 각 개발자가 전체 저장소를 로컬에 복제하여 작업한다. 각 시스템은 저장 방식, 협업 모델, 성능 등에서 차이가 있으며, 프로젝트의 특성과 요구사항에 따라 적절한 시스템을 선택해야 한다.
핵심 개념 SVN (Subversion) SVN은 Apache Software Foundation에서 개발한 중앙 집중식 버전 관리 시스템이다.
핵심 개념은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-28 04:19:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SVN Mercurial Overview" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/git-fundamentals/svn-mercurial-overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CI/CD</h2></header><div class=entry-content><p>CI/CD (Continuous Integration/Continuous Delivery) CI/CD(지속적 통합/지속적 배포) 는 소프트웨어 개발 라이프사이클을 자동화하는 현대적인 방법론으로, 개발자들이 코드 변경사항을 자주 통합하고 테스트하며 배포할 수 있게 해준다. 지속적 통합 (CI) 은 개발자들이 코드를 중앙 저장소에 자주 병합하고 자동화된 빌드 및 테스트를 실행하는 과정을 의미하며, 지속적 배포 (CD) 는 검증된 코드 변경사항을 자동으로 프로덕션 환경에 배포하는 프로세스를 말한다.
CI/CD 는 소프트웨어 품질 향상, 개발 주기 단축, 배포 위험 감소, 팀 협업 강화 등의 이점을 제공하여 현대 소프트웨어 개발 환경에서 필수적인 관행으로 자리 잡았다.
...</p></div><footer class=entry-footer><span title='2024-09-23 18:14:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;24 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CI/CD" href=https://buenhyden.github.io/posts/software-development--engineering/engineering-operations/devops--ci-cd/overview/ci-cd/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/3/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/5/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>