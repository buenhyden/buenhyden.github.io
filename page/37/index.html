<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.150.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>페이징 (Paging)</h2></header><div class=entry-content><p>페이징 (Paging) 먼저 페이징이 필요한 배경을 이해해보자.
초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.
이는 두 가지 큰 문제를 발생시켰다:
큰 프로그램은 메모리에 적재하기 어려웠다. 메모리 단편화(fragmentation)가 심각했다.
이러한 문제를 해결하기 위해 페이징이 도입되었다. 페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 ‘페이지(page)‘라 하고, 물리적 메모리의 단위를 ‘프레임(frame)‘이라고 한다.
Source: https://www.geeksforgeeks.org/paging-in-operating-system/
페이징 시스템의 주요 구성 요소 페이지 테이블(Page Table):
...</p></div><footer class=entry-footer><span title='2024-10-01 13:37:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 페이징 (Paging)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/system-software/operating-systems/memory-management/virtual-memory/paging-systems/paging/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Code Review Best Practices</h2></header><div class=entry-content><p>Code Review Best Practices **Version Control Systems (VCS)**에서 Code Review Best Practices는 코드 품질 향상과 팀 협업 강화를 위한 핵심 프로세스입니다. 소프트웨어 개발 과정에서 동료 개발자가 작성한 코드를 검토하여 품질을 향상시키고, 버그를 사전에 방지하며, 지식 공유를 촉진하는 역할을 한다. 2025 년 현재 AI 통합, 자동화된 검토 도구, 지표 기반 평가가 주요 트렌드로 부상하며, Git 을 중심으로 한 워크플로우 최적화가 중요시된다.
핵심 개념 및 목적 코드 리뷰는 한 개발자가 작성한 코드를 다른 개발자가 검토하는 체계적인 프로세스이다. 주로 풀 리퀘스트 (Pull Request) 또는 머지 리퀘스트 (Merge Request) 를 통해 이루어지며, 코드의 품질, 가독성, 기능성 및 표준 준수 여부를 평가한다.
...</p></div><footer class=entry-footer><span title='2024-10-01 09:48:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Code Review Best Practices" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/code-review-best-practices/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Release Management</h2></header><div class=entry-content><p>Release Management 릴리스 관리 (Release Management) 는 소프트웨어 개발 프로세스에서 코드 변경사항을 개발 환경에서 프로덕션 환경으로 안전하고 체계적으로 배포하는 전체 과정을 관리하는 방법론이다. 이는 버전 관리 시스템과 긴밀하게 연계되어 코드 변경사항의 추적, 버전 관리, 배포 프로세스 자동화 등을 포함한다. 효과적인 릴리스 관리는 소프트웨어의 품질 보장, 배포 위험 최소화, 사용자 경험 향상, 개발 팀의 생산성 증대에 기여한다.
2025 년 현재 DevOps 및 CI/CD 도구와의 통합을 통해 지속적 배포 자동화가 강화되고 있으며, AI 기반 위험 관리 및 클라우드 네이티브 아키텍처 지원이 주목받고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-01 09:48:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Release Management" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/release-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Open Source Contribution</h2></header><div class=entry-content><p>Open Source Contribution 오픈소스 기여 (Open Source Contribution) 는 공개된 소프트웨어 프로젝트에 개인이나 조직이 코드, 문서, 테스트, 버그 리포트 등을 통해 참여하는 활동이다. 이는 버전 관리 시스템 (특히 Git) 을 중심으로 이루어지며, Fork-Clone- 수정 -Pull Request 로 이어지는 표준화된 워크플로우를 통해 진행된다. 오픈소스 기여는 소프트웨어 개발 생태계의 지속 가능성을 유지하고, 개발자 간 지식 공유와 협업을 촉진하며, 개인 개발자에게는 실무 경험과 평판을 쌓을 기회를 제공한다.
핵심 개념 오픈소스 기여는 공개된 소프트웨어 프로젝트에 개발자가 자발적으로 참여하여 코드, 문서, 디자인, 테스트 등을 통해 가치를 더하는 활동이다.
...</p></div><footer class=entry-footer><span title='2024-10-01 06:07:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Open Source Contribution" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/open-source-contribution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pull Request Flow</h2></header><div class=entry-content><p>Pull Request Flow Pull Request(PR) 는 현대 소프트웨어 개발에서 코드 협업과 품질 관리의 중심이 되는 기능이다.
GitHub, GitLab, Bitbucket 과 같은 Git 호스팅 서비스들이 제공하는 이 기능은 코드 변경 사항을 메인 코드베이스에 통합하기 전에 검토하고 논의할 수 있는 구조화된 방법을 제공한다.
Pull Request 는 현대 소프트웨어 개발의 핵심 협업 메커니즘으로, 코드 품질 향상과 팀 지식 공유에 중요한 역할을 한다. GitHub, GitLab, Bitbucket 과 같은 플랫폼들은 각자의 방식으로 이 기능을 구현하고 있으며, 지속적으로 개선하고 있다.
...</p></div><footer class=entry-footer><span title='2024-10-01 02:11:00 +0000 UTC'>October 1, 2024</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pull Request Flow" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/collaboration-workflows/pull-request-flow/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Byte Addressable Memory vs Word Addressable Memory</h2></header><div class=entry-content><p>Byte Addressable Memory vs. Word Addressable Memory Byte Addressable Memory와 Word Addressable Memory는 컴퓨터 메모리의 주소 지정 방식을 설명하는 개념이다.
이 두 가지 방식은 메모리의 구조와 데이터 접근 방법에 중요한 차이를 나타낸다.
Sourece: https://examradar.com/memory-organisation/
Byte Addressable Memory Byte Addressable Memory는 각 바이트(8비트)마다 고유한 주소가 할당되어 개별적으로 접근할 수 있는 메모리 구조이다.
가장 작은 주소 지정 단위(smallest addressable unit)는 1바이트(8비트)이며, 이를 통해 메모리의 각 바이트에 직접 접근할 수 있다.
CPU는 개별 바이트 단위로 메모리에 접근할 수 있으며, 워드(일반적으로 4바이트 또는 8바이트) 단위의 접근도 가능하다.
32비트 시스템에서는 2^32개의 주소를 가질 수 있어 최대 4GB의 메모리를 지원하며, 64비트 시스템에서는 훨씬 더 큰 주소 공간을 제공한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 11:38:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Byte Addressable Memory vs Word Addressable Memory" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/memory-systems/memory-management/address-translation/memory-address-modes/byte-addressable-memory-vs-word-addressable-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Large-scale Management</h2></header><div class=entry-content><p>Large-scale Management 대규모 버전 관리 시스템 (Version Control Systems) 의 엔터프라이즈 활용은 수백 명의 개발자와 수십 기가바이트 이상의 코드베이스를 효율적으로 관리하기 위한 전략과 기술을 포함한다. Git 과 같은 분산 버전 관리 시스템 (DVCS) 은 유연성과 확장성을 제공하지만, 대규모 환경에서는 성능 최적화, 브랜칭 전략, 접근 제어, 코드 소유권 관리 등 추가적인 고려사항이 필요하다. 이를 위해 Partial Clone, Shallow Clone, Submodule, CODEOWNERS 파일 등의 기능이 활용되며, 팀 규모에 따른 브랜칭 전략도 중요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 06:20:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;23 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Large-scale Management" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/large-scale-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MonoRepo vs. MultiRepo</h2></header><div class=entry-content><p>MonoRepo vs. MultiRepo 모노레포 (Monorepo) 와 멀티레포 (Multirepo) 는 소프트웨어 개발에서 코드베이스를 관리하는 대표적인 두 가지 전략이다. MonoRepo는 여러 프로젝트를 하나의 저장소에서 관리하는 방식으로, 코드 공유와 일관된 개발 환경을 제공한다. 반면, MultiRepo는 각 프로젝트를 별도의 저장소에서 관리하여 독립성과 유연성을 강조한다.
이 두 접근 방식은 코드 공유, 종속성 관리, 빌드 시스템, 팀 협업, 확장성 등의 측면에서 서로 다른 장단점을 가지고 있다. 프로젝트의 규모, 팀 구조, 회사 문화, 기술 스택 등 다양한 요소에 따라 적합한 방식이 달라질 수 있으며, 최근에는 두 방식의 장점을 결합한 하이브리드 접근법이나 각 방식의 단점을 보완하는 도구들도 등장하고 있다.
...</p></div><footer class=entry-footer><span title='2024-09-30 06:18:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MonoRepo vs. MultiRepo" href=https://buenhyden.github.io/posts/software-development--engineering/development-practices/version-control/advanced-topics/enterprise-usage/monorepo-vs-multirepo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Caching Techniques</h2></header><div class=entry-content><p>Caching Techniques 캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.
브라우저 캐싱 (Browser Caching)
브라우저 캐싱은 웹 페이지 리소스(이미지, CSS 파일, JavaScript 파일 등)를 사용자의 기기에 로컬로 저장하는 기술이다.
사용자가 같은 웹사이트를 다시 방문할 때, 이 리소스들을 서버에서 다시 다운로드하지 않고 캐시에서 불러올 수 있어 페이지 로드 시간을 크게 줄일 수 있다.
이는 반복 방문자의 경험을 개선하고 전반적인 사용자 만족도를 높이는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 02:37:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caching Techniques" href=https://buenhyden.github.io/posts/system-architecture--design/system-components/data--state-management/cache/cache-types/caching-techniques/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CPU</h2></header><div class=entry-content><p>CPU CPU(중앙처리장치)는 컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.
CPU의 주요 구성요소 CPU는 크게 세 가지 주요 구성요소로 이루어져 있다
제어장치 (Control Unit, CU) 산술논리장치 (Arithmetic Logic Unit, ALU) 레지스터 (Registers) 제어장치 (Control Unit) 제어장치는 CPU의 ‘교통 경찰’ 역할을 한다.
주요 기능:
명령어를 순서대로 실행할 수 있도록 제어 주기억장치로부터 프로그램 명령을 순차적으로 가져와 해독 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치 등으로 전송 산술논리장치 (ALU) ALU는 CPU 내에서 실제 연산을 수행하는 부분
...</p></div><footer class=entry-footer><span title='2024-09-29 16:44:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CPU" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-systems/computer-architecture/processor-architecture/cpu/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/36/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/38/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>