<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Filter</h2></header><div class=entry-content><p>Message Filter Message Filter는 특정 기준에 따라 원하지 않는 메시지를 제거하고 원하는 메시지만 통과시키는 패턴이다.
이 패턴은 컴포넌트가 관심 없는 메시지를 받지 않도록 하여 시스템의 효율성을 높이는 데 사용된다.
Message Filter 패턴을 적절히 활용하면 MSA 환경에서 메시지 처리의 효율성을 크게 높일 수 있다. 하지만 필터링 로직의 복잡성과 유지보수성을 고려하여 설계해야 한다.
주요 특징 단일 입력 채널과 단일 출력 채널을 가진다. 정의된 기준에 따라 메시지를 평가한다. 기준을 충족하는 메시지만 출력 채널로 전달한다. 기준을 충족하지 않는 메시지는 폐기된다. 구현 방법 필터 조건 정의: 메시지를 평가할 기준을 설정한다. 메시지 평가: 입력된 메시지가 정의된 조건을 충족하는지 확인한다. 메시지 라우팅: 조건을 충족하는 메시지는 다음 단계로 전달하고, 그렇지 않은 메시지는 폐기한다. 구현 방식 메시지 필터는 주로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Filter" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/messaging-systems/message-routing/message-filter/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Router</h2></header><div class=entry-content><p>Message Router Message Router는 메시지의 내용이나 메타데이터를 기반으로 메시지를 적절한 목적지로 전달하는 컴포넌트이다. 이는 메시지의 흐름을 제어하고 시스템의 유연성을 높이는 데 중요한 역할을 한다.
Message Router는 MSA 환경에서 메시지 흐름을 효과적으로 관리하고 시스템의 유연성을 높이는 중요한 패턴이다. 적절히 구현하면 시스템의 확장성과 유지보수성을 크게 향상시킬 수 있다.
Message Router의 주요 특징 메시지 내용 기반 라우팅: 메시지의 페이로드나 헤더를 분석하여 라우팅 결정을 내린다. 동적 라우팅: 런타임에 라우팅 규칙을 변경할 수 있어 시스템의 유연성을 높인다. 다중 목적지 지원: 하나의 메시지를 여러 목적지로 라우팅할 수 있다. 메시지 변환: 필요에 따라 메시지 형식을 변환할 수 있다. Message Router의 종류 콘텐츠 기반 라우터: 메시지 내용을 분석하여 라우팅한다. 헤더 값 라우터: 메시지 헤더의 특정 값을 기준으로 라우팅한다. 수신자 목록 라우터: 미리 정의된 수신자 목록에 따라 메시지를 분배한다. 동적 라우터: 외부 조건이나 설정에 따라 라우팅 로직을 동적으로 변경한다. Message Router의 장점 유연성: 시스템 구성 요소 간의 결합도를 낮추어 유연성을 높인다. 확장성: 새로운 처리 로직이나 목적지를 쉽게 추가할 수 있다. 트래픽 관리: 메시지 흐름을 제어하여 시스템 부하를 관리할 수 있다. 비즈니스 로직 분리: 라우팅 로직을 중앙화하여 비즈니스 로직과 분리할 수 있다. 주의사항 복잡성 관리: 라우팅 규칙이 복잡해질수록 관리가 어려워질 수 있다. 성능 고려: 복잡한 라우팅 로직은 시스템 성능에 영향을 줄 수 있다. 오류 처리: 라우팅 실패 시의 오류 처리 전략이 필요하다. Message Router 구현 예시 Node.js를 사용한 Message Filter
...</p></div><footer class=entry-footer><span title='2024-11-15 12:09:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Router" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/messaging-systems/message-routing/message-router/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Idempotent Consumer</h2></header><div class=entry-content><p>Idempotent Consumer Idempotent Consumer는 마이크로서비스 아키텍처(MSA)의 메시징 패턴 중 하나로, 메시지의 중복 처리를 방지하고 시스템의 일관성을 유지하는 데 중요한 역할을 한다.
Idempotent Consumer는 동일한 메시지를 여러 번 처리하더라도 시스템의 상태가 변하지 않도록 설계된 소비자를 의미한다. 즉, 메시지의 중복 처리가 발생해도 최종 결과는 항상 동일하다.
Idempotent Consumer 패턴은 MSA 환경에서 메시지의 안정적인 처리를 보장하고, 시스템의 일관성을 유지하는 데 중요한 역할을 한다. 이 패턴을 적절히 구현함으로써 분산 시스템의 신뢰성과 견고성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-15 11:43:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Idempotent Consumer" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/messaging-systems/message-endpoints/idempotent-consumer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Domain event</h2></header><div class=entry-content><p>Domain Event 도메인 이벤트(Domain Event)는 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하고 시스템 간 의존성을 줄이며 확장성을 높이는 데 중요한 개념이다.
도메인 이벤트는 주로 도메인 주도 설계(DDD) 의 개념에서 비롯되었으며, 비즈니스 로직과 시스템 상태 변화의 핵심을 나타낸다.
이를 통해 분산 시스템에서 데이터 일관성과 비즈니스 흐름을 효과적으로 관리할 수 있다.
도메인 이벤트는 도메인 내에서 발생한 중요한 상태 변화를 나타내는 객체이다.
이는 과거에 발생한 사건을 기술하며, 다른 모듈이나 시스템이 해당 이벤트를 구독하고 적절히 반응할 수 있도록 설계된다. 예를 들어, 전자상거래 시스템에서 “주문이 생성됨(Order Created)“이나 “결제가 완료됨(Payment Completed)” 같은 사건이 도메인 이벤트로 표현될 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-15 11:08:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain event" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-design/tradeoffs-and-theorems/maintaining-data-consistency/domain-event/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Saga Pattern</h2></header><div class=entry-content><p>Saga Pattern Saga Pattern은 마이크로서비스 아키텍처에서 분산 트랜잭션을 관리하기 위한 디자인 패턴이다.
Saga Pattern은 여러 서비스에 걸친 데이터 일관성을 유지하기 위해 사용된다.
각 서비스의 로컬 트랜잭션을 순차적으로 실행하며, 실패 시 보상 트랜잭션을 통해 일관성을 유지한다.
주요 특징:
분산 환경에서의 트랜잭션 관리 순차적인 로컬 트랜잭션 실행 실패 시 보상 트랜잭션 실행 Saga Pattern의 구현 방식 Saga Pattern은 크게 두 가지 방식으로 구현할 수 있다:
Choreography-based Saga 각 서비스가 이벤트를 발행하고 구독하여 트랜잭션을 진행 중앙 조정자 없이 서비스 간 직접 통신
장점: 구현이 간단하고 이해하기 쉬움 서비스 간 결합도가 낮음
단점: 복잡한 워크플로우에서는 추적이 어려울 수 있음 순환 종속성 발생 가능성 https://microservices.io/patterns/data/saga.html
...</p></div><footer class=entry-footer><span title='2024-11-15 10:06:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Saga Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/system-design/reliability/saga/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Aggregate Pattern</h2></header><div class=entry-content><p>Aggregate Pattern Aggregate 패턴은 마이크로서비스 아키텍처(MSA)에서 데이터 일관성을 유지하기 위한 중요한 패턴 중 하나이다.
이 패턴은 도메인 주도 설계(DDD)에서 유래했으며, 복잡한 도메인 모델을 관리하고 트랜잭션 경계를 정의하는 데 도움을 줍니다.
Aggregate는 하나의 루트 엔티티(Aggregate Root)와 관련된 객체들의 집합이다.
이 집합은 하나의 단위로 취급되며, 데이터 일관성을 유지하는 경계 역할을 한다.
Aggregate 패턴을 효과적으로 사용하려면 도메인에 대한 깊은 이해와 지속적인 리팩토링이 필요하다.
이 패턴을 통해 마이크로서비스 아키텍처에서 데이터 일관성을 유지하면서도 확장 가능하고 유지보수가 용이한 시스템을 구축할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-15 02:00:00 +0000 UTC'>November 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Aggregate Pattern" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/data-management/aggregate/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>3rd party registration</h2></header><div class=entry-content><p>3rd Party Registration 3rd Party Registration은 마이크로서비스 아키텍처에서 서비스 디스커버리를 위한 패턴 중 하나이다.
이 패턴에서는 서비스 인스턴스가 직접 자신을 서비스 레지스트리에 등록하지 않고, 별도의 외부 컴포넌트가 서비스의 등록과 해제를 담당한다.
주요 특징:
서비스 인스턴스와 레지스트리 간의 결합도 감소 중앙 집중식 서비스 관리 다양한 언어와 프레임워크에 대한 일관된 등록 메커니즘 제공 3rd Party Registration 패턴은 마이크로서비스 아키텍처에서 서비스 디스커버리를 효과적으로 관리할 수 있는 방법이지만, 추가적인 복잡성을 감수해야 하므로, 시스템의 규모와 요구사항을 고려하여 적절히 적용해야 한다.
...</p></div><footer class=entry-footer><span title='2024-11-14 11:47:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 3rd party registration" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/service-discovery/3rd-party-registration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Self registration</h2></header><div class=entry-content><p>Self Registration Self Registration은 각 마이크로서비스 인스턴스가 자신의 정보를 서비스 레지스트리에 직접 등록하고 관리하는 패턴이다. 서비스가 시작될 때 자동으로 등록되고, 종료될 때 해제되는 방식으로 동작한다.
Self Registration 패턴은 마이크로서비스 환경에서 동적으로 변화하는 서비스 인스턴스를 효과적으로 관리할 수 있게 해주는 중요한 패턴이다. 하지만 구현의 복잡성과 유지보수 측면에서 주의가 필요하며, 프로젝트의 규모와 요구사항에 따라 적절히 선택해야 한다.
주요 특징 자동 등록: 서비스 인스턴스가 시작될 때 자신의 정보(호스트, IP 주소, 포트 등)를 레지스트리에 등록한다. 자동 해제: 서비스가 종료될 때 레지스트리에서 자신의 정보를 제거한다. 헬스체크: 주기적으로 레지스트리에 헬스체크 신호를 보내 자신이 살아있음을 알린다. 상태 관리: 서비스 인스턴스가 자신의 상태를 가장 잘 알기 때문에, UP/DOWN 외에도 STARTING, AVAILABLE 등 더 복잡한 상태 모델을 구현할 수 있다. 구현 방법 서비스 레지스트리 설정: Eureka, Consul, ZooKeeper 등의 도구를 사용하여 중앙 레지스트리를 구축한다. 서비스 등록 코드 구현: 각 마이크로서비스에 자신을 레지스트리에 등록하는 코드를 추가한다. 헬스체크 메커니즘 구현: 주기적으로 레지스트리에 헬스체크 신호를 보내는 로직을 구현한다. 서비스 디스커버리 클라이언트 구현: 다른 서비스들이 등록된 서비스를 찾고 통신할 수 있도록 한다. 장점 구현이 비교적 간단하다. 추가적인 시스템 컴포넌트가 필요하지 않다. 서비스가 자신의 상태를 가장 잘 알기 때문에 정확한 정보를 제공할 수 있다. 단점 서비스와 레지스트리 간의 결합도가 높아진다. 각 프로그래밍 언어와 프레임워크마다 등록 로직을 구현해야 한다. 서비스가 비정상적으로 종료될 경우 레지스트리에서 자동으로 제거되지 않을 수 있다. 구현 예시 Netflix Eureka는 셀프 등록 패턴의 대표적인 예시이다.
Eureka 클라이언트는 다음과 같은 방식으로 동작한다:
...</p></div><footer class=entry-footer><span title='2024-11-14 11:47:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Self registration" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/service-discovery/self-registration/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Server-side discovery</h2></header><div class=entry-content><p>Server-side Discovery Server-side Discovery는 클라이언트가 서비스의 위치를 직접 찾지 않고, 중간에 위치한 로드 밸런서나 프록시 서버가 서비스 위치를 찾아 요청을 라우팅하는 방식이다.
Server-side Discovery는 클라이언트를 단순화하고 중앙 집중식 관리를 가능하게 하는 장점이 있지만, 추가 인프라와 관리가 필요한 단점도 있다. 프로젝트의 요구사항과 팀의 역량을 고려하여 적절히 선택해야 한다.
작동 원리 서비스 등록: 각 서비스 인스턴스는 시작 시 자신의 정보를 서비스 레지스트리에 등록한다. 클라이언트 요청: 클라이언트는 서비스의 실제 위치를 모르고, 로드 밸런서에 요청을 보낸다. 서비스 조회: 로드 밸런서는 서비스 레지스트리에서 해당 서비스의 가용한 인스턴스 정보를 조회한다. 요청 라우팅: 로드 밸런서는 적절한 서비스 인스턴스를 선택하여 요청을 전달한다. 응답 반환: 서비스의 응답은 로드 밸런서를 통해 클라이언트에게 전달된다. 장점 클라이언트 단순화: 클라이언트는 서비스 디스커버리 로직을 구현할 필요가 없어 단순해진다. 언어 중립성: 클라이언트 측 구현이 필요 없어 다양한 프로그래밍 언어로 개발된 서비스들을 쉽게 통합할 수 있다. 보안 강화: 로드 밸런서 수준에서 추가적인 보안 계층을 구현할 수 있다. 중앙 집중식 관리: 서비스 디스커버리와 로드 밸런싱을 중앙에서 관리할 수 있다. 단점 추가 인프라 필요: 로드 밸런서나 프록시 서버와 같은 추가 인프라가 필요하다. 단일 실패 지점: 로드 밸런서가 단일 실패 지점이 될 수 있어 고가용성 설계가 중요하다. 복잡성 증가: 전체 시스템의 복잡성이 증가할 수 있다. 구현 예시 AWS Elastic Load Balancer (ELB): 클라이언트는 ELB의 DNS 이름을 통해 요청을 보내며, ELB는 등록된 EC2 인스턴스나 ECS 컨테이너 사이에서 부하를 분산한다. Kubernetes의 kube-proxy: Kubernetes에서는 각 노드에서 실행되는 kube-proxy가 서비스 디스커버리와 로드 밸런싱을 담당하며, 클러스터 내의 서비스 요청을 적절한 파드(Pod)로 전달한다. Node.js를 사용한 Server-side Discovery 구현 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 // 서버 사이드 디스커버리 라우터 구현 class ServiceRouter { constructor(options = {}) { this.registryUrl = options.registryUrl || 'http://service-registry:8500'; this.serviceCache = new Map(); this.cacheTimeout = options.cacheTimeout || 30000; // 30초 this.loadBalancer = new LoadBalancer(); } async handleRequest(req, res) { const serviceName = this.extractServiceName(req); try { // 서비스 인스턴스 찾기 const serviceInstance = await this.findServiceInstance(serviceName); // 요청 전달 const response = await this.forwardRequest(req, serviceInstance); // 응답 전달 this.sendResponse(res, response); } catch (error) { this.handleError(res, error); } } async findServiceInstance(serviceName) { // 캐시된 서비스 확인 const cachedInstances = this.getCachedInstances(serviceName); if (cachedInstances && cachedInstances.length > 0) { return this.loadBalancer.selectInstance(cachedInstances); } // 서비스 레지스트리 조회 const instances = await this.queryRegistry(serviceName); this.updateCache(serviceName, instances); return this.loadBalancer.selectInstance(instances); } async forwardRequest(req, serviceInstance) { const targetUrl = this.buildTargetUrl(serviceInstance, req.path); return await fetch(targetUrl, { method: req.method, headers: req.headers, body: req.body, timeout: 5000 }); } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-14 11:47:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Server-side discovery" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/service-discovery/server-side-discovery/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Service registry</h2></header><div class=entry-content><p>Service Registry Service Registry는 마이크로서비스 환경에서 각 서비스 인스턴스의 네트워크 위치(IP 주소와 포트)를 저장하고 관리하는 중앙화된 데이터베이스이다.
이는 동적으로 변화하는 마이크로서비스 환경에서 서비스 디스커버리를 가능하게 하는 핵심 요소이다.
Service Registry는 MSA 환경에서 서비스 디스커버리를 가능하게 하는 핵심 컴포넌트이다. 이를 통해 동적이고 확장 가능한 마이크로서비스 아키텍처를 구현할 수 있다.
서비스 레지스트리의 중요성 MSA 환경에서는 서비스 인스턴스가 자동 확장, 장애 복구, 배포 등의 이유로 동적으로 생성되고 소멸되며, 이에 따라 네트워크 위치가 변경된다.
이러한 동적인 특성으로 인해, 서비스 레지스트리는 다음과 같은 역할을 수행한다:
...</p></div><footer class=entry-footer><span title='2024-11-14 11:47:00 +0000 UTC'>November 14, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Service registry" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/integration/service-discovery/service-registry/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/36/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/38/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>