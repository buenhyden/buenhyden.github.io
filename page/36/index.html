<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Authentication Code</h2></header><div class=entry-content><p>Message Authentication Code Message Authentication Code는 메시지의 무결성(integrity)과 출처 인증(authentication)을 동시에 보장하기 위한 암호학적 도구로, 메시지와 비밀키를 입력으로 받아 고정된 길이의 값을 생성하며, 이 값은 메시지에 대한 일종의 디지털 지문 역할을 한다.
예를 들어, Alice가 Bob에게 메시지를 보낼 때를 생각해보자.
Alice는 메시지와 함께 MAC 값을 전송하고, Bob은 수신한 메시지로부터 동일한 비밀키를 사용하여 MAC 값을 계산한다. 두 MAC 값이 일치한다면, Bob은 메시지가 변조되지 않았으며 실제로 Alice가 보낸 것임을 확신할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-08 13:10:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;395 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Authentication Code" href=https://buenhyden.github.io/posts/computer-science/security/cryptography/message-authentication-code/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>방화벽 (Firewall)</h2></header><div class=entry-content><p>방화벽 (Firewall) 네트워크 보안의 핵심 요소로, 내부 네트워크를 외부의 위협으로부터 보호하는 시스템.
방화벽은 미리 정의된 보안 규칙에 기반하여 들어오고 나가는 네트워크 트래픽을 모니터링하고 제어하는 네트워크 보안 시스템으로 신뢰할 수 있는 내부 네트워크와 신뢰할 수 없는 외부 네트워크(예: 인터넷) 사이의 장벽 역할을 한다.
방화벽의 기본 동작 원리
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Firewall: def __init__(self): # 기본 규칙 설정 self.rules = [] self.default_policy = "DENY" # 기본적으로 모든 트래픽 차단 def add_rule(self, rule): """새로운 방화벽 규칙 추가""" self.rules.append(rule) def check_packet(self, packet): """패킷 검사 수행""" for rule in self.rules: if rule.matches(packet): return rule.action return self.default_policy class FirewallRule: def __init__(self, protocol, src_ip, dst_ip, src_port, dst_port, action): self.protocol = protocol self.src_ip = src_ip self.dst_ip = dst_ip self.src_port = src_port self.dst_port = dst_port self.action = action # "ALLOW" or "DENY" def matches(self, packet): """패킷이 규칙과 일치하는지 확인""" return ( self.protocol == packet.protocol and self.src_ip.matches(packet.src_ip) and self.dst_ip.matches(packet.dst_ip) and self.src_port.matches(packet.src_port) and self.dst_port.matches(packet.dst_port) ) 주요 기능 접근 통제(Access Control):
...</p></div><footer class=entry-footer><span title='2024-11-08 06:18:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;727 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 방화벽 (Firewall)" href=https://buenhyden.github.io/posts/security/firewall/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IDS and IPS</h2></header><div class=entry-content><p>IDS and IPS IDS(Intrusion Detection System)와 IPS(Intrusion Prevention System)는 네트워크 보안을 위한 중요한 도구이다.
IPS와 IDS는 다계층 분석을 통해 네트워크 전반의 보안을 강화하며, 각 계층의 특성에 맞는 보안 기능을 제공한다.
IPS와 IDS는 OSI 7계층에서 주로 다음 계층들에서 동작한다:
네트워크 계층(3계층):
패킷 레벨에서의 분석과 필터링을 수행한다 IP 주소, 프로토콜 정보를 기반으로 한 검사가 이루어진다. 예를 들어, IP 스푸핑이나 DDoS 공격과 같은 네트워크 계층의 공격을 탐지하고 차단한다. 전송 계층(4계층):
TCP/UDP 포트 정보를 분석하여 비정상적인 연결 시도를 탐지한다. 포트 스캔이나 TCP SYN 플러딩과 같은 공격을 모니터링한다. 세션 하이재킹 시도를 감지할 수 있다. 응용 계층(7계층):
...</p></div><footer class=entry-footer><span title='2024-11-08 02:11:00 +0000 UTC'>November 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;691 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to IDS and IPS" href=https://buenhyden.github.io/posts/security/security-tools/ids-and-ips/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CCE(Common Configuration Enumeration)</h2></header><div class=entry-content><p>CCE(Common Configuration Enumeration) CCE(Common Configuration Enumeration)는 시스템의 보안 설정과 관련된 취약점을 식별하고 관리하기 위한 표준화된 명명 체계이다.
시스템 구성 문제에 고유 ID를 제공하여 여러 정보 소스와 도구 간에 구성 데이터를 빠르고 정확하게 상관시키는 것을 목적으로 한다.
이를 통해 시스템의 보안 설정을 일관되게 관리하고 평가할 수 있다.
주요 특징 표준화된 식별: 각 보안 설정에 고유한 CCE ID를 부여한다. 설정 중심: 시스템의 구성 설정에 초점을 맞춘다. 다양한 플랫폼 지원: 서버, 네트워크 장치, 방화벽 등 다양한 IT 인프라에 적용 가능하다. CCE의 중요성 일관성 유지: 여러 도구와 플랫폼에서 동일한 보안 설정을 일관되게 식별할 수 있다. 자동화 지원: 자동화된 보안 도구에서 CCE를 활용하여 효율적인 취약점 관리가 가능하다. 규정 준수: 다양한 보안 표준과 규정 준수를 위한 기준으로 활용된다. CCE의 구조와 형식 CCE 식별자는 ‘CCE-XXXX-X’ 형식을 따르며, 각 식별자는 특정 보안 구성 설정을 고유하게 식별한다.
예를 들어, ‘CCE-27277-8’은 Windows 시스템에서 최소 암호 길이 설정을 나타낸다.
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;452 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CCE(Common Configuration Enumeration)" href=https://buenhyden.github.io/posts/security/security-vulnerability/cce/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CVE</h2></header><div class=entry-content><p>CVE CVE는 공개적으로 알려진 사이버 보안 취약점들에 대한 표준화된 식별자를 제공하는 목록이다.
이는 보안 취약점에 대한 일관된 명명과 식별을 가능하게 하여, 서로 다른 보안 도구와 서비스 간의 데이터 공유와 취약점 관리를 용이하게 한다.
1999년 MITRE Corporation에 의해 만들어졌으며, 주요 목적은 다음과 같다:
보안 취약점에 대한 표준화된 식별자 제공 취약점 정보의 공유 및 협업 촉진 보안 도구 및 서비스 간의 데이터 공유 개선 CVE ID 구조 CVE ID는 다음과 같은 형식을 가진다:
CVE-[연도]-[일련번호]
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CVE" href=https://buenhyden.github.io/posts/security/security-vulnerability/cve/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CVSS(Common Vulnerability Scoring System)</h2></header><div class=entry-content><p>CVSS(Common Vulnerability Scoring System) CVSS는 “공통 취약점 등급 시스템"의 약자로, 소프트웨어 취약점의 특성과 심각도를 파악하는 데 도움이 되는 표준화된 시스템이다.
주요 목적 취약점의 심각도를 표준화된 방식으로 평가 취약점 대응의 우선순위 결정에 도움 조직 간 취약점 정보 공유 및 소통 촉진 CVSS 점수 체계 CVSS 점수는 0.0에서 10.0 사이의 값으로 표현되며, 다음과 같이 분류된다:
0.0-3.9: 낮음 4.0-6.9: 중간 7.0-8.9: 높음 9.0-10.0: 심각 CVSS 메트릭 그룹 CVSS 점수는 다음 세 가지 메트릭 그룹으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;276 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CVSS(Common Vulnerability Scoring System)" href=https://buenhyden.github.io/posts/security/security-vulnerability/cvss/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CWE(Common Weakness Enumeration)</h2></header><div class=entry-content><p>CWE(Common Weakness Enumeration) CWE는 소프트웨어와 하드웨어의 설계, 디자인, 코드 구현에서 발생할 수 있는 결함, 버그, 에러 등의 보안 약점을 카탈로그화한 것이다.
주요 목적 보안 약점에 대한 공통 언어 제공 소프트웨어 보안 도구 간의 호환성 향상 보안 약점 식별 및 완화를 위한 기준 제공 표기 방식 ID 체계
CWE는 'CWE-XXX' 형식으로 표기된다.
예:
CWE-119: 버퍼 오버플로우 CWE-89: SQL 인젝션 CWE-79: 크로스 사이트 스크립팅 상세 정보 구조
각 CWE 항목은 다음과 같은 정보를 포함한다:
...</p></div><footer class=entry-footer><span title='2024-11-07 07:58:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;452 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CWE(Common Weakness Enumeration)" href=https://buenhyden.github.io/posts/security/security-vulnerability/cwe/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DAC</h2></header><div class=entry-content><p>재량적 접근 제어(Discretionary Access Control, DAC) 재량적 접근 제어는 리소스의 소유자가 해당 리소스에 대한다른 사용자들의 접근 권한을 직접 제어할 수 있는 접근 제어 방식.
이는 우리가 일상적으로 사용하는 컴퓨터의 파일 시스템과 매우 유사한 방식으로 작동한다.
예를 들어, 여러분이 문서를 만들면 해당 문서의 소유자가 되어 다른 사람들에게 읽기, 쓰기, 또는 실행 권한을 부여할 수 있다.
개인용 컴퓨터나 작은 규모의 조직에서 사용되며, 높은 수준의 보안이 요구되는 환경에서는 다른 접근 제어 방식과 함께 사용되는 것이 일반적이다.
예를 들어, 기업 환경에서는 DAC와 함께 역할 기반 접근 제어(RBAC)나 강제적 접근 제어(MAC)를 함께 사용하여 보안을 강화하는 경우가 많다.
...</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;575 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/dac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MAC</h2></header><div class=entry-content><p>강제적 접근 제어(Mandatory Access Control, MAC) 시스템 전체에 걸쳐 중앙에서 정의된 보안 정책에 따라 접근 권한을 강제로 적용하는 접근 제어 방식.
이는 개별 사용자나 소유자가 임의로 접근 권한을 변경할 수 없다는 점에서 DAC와 큰 차이가 있다.
군사, 정부 기관, 금융 기관 등 높은 수준의 보안이 요구되는 환경에서 사용된다.
일반적인 기업이나 개인용 시스템에서는 구현의 복잡성과 관리 부담 때문에 다른 접근 제어 방식을 선호하는 경우가 많다.
작동원리:
두 가지 중요한 보안 원칙을 적용한다:
...</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;633 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/mac/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PBAC</h2></header><div class=entry-content><p>정책 기반 접근 제어(Policy-Based Access Control, PBAC) 중앙에서 정의된 정책들을 기반으로 접근 권한을 결정하는 접근 제어 방식.
각 정책은 “누가”, “무엇을”, “어떤 조건에서” 할 수 있는지를 정의하며, 이러한 정책들은 프로그래밍 방식으로 표현되고 평가된다.
현대적인 클라우드 환경이나 마이크로서비스 아키텍처에서 특히 유용하다.
AWS IAM, Azure RBAC 등의 클라우드 서비스들이 PBAC를 구현한 대표적인 예시.
작동 방식:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 class Policy { constructor(name, conditions, effect) { this.name = name; this.conditions = conditions; this.effect = effect; // 'allow' 또는 'deny' } evaluate(context) { try { // 모든 조건을 평가 return this.conditions.every(condition => condition(context)); } catch (error) { console.error(`Policy evaluation error: ${error.message}`); return false; } } } class PolicyEngine { constructor() { this.policies = new Map(); } addPolicy(policy) { this.policies.set(policy.name, policy); } evaluateAccess(context) { let finalDecision = false; for (const policy of this.policies.values()) { const matches = policy.evaluate(context); if (matches) { finalDecision = policy.effect === 'allow'; // 명시적인 거부 정책이 있으면 즉시 거부 if (policy.effect === 'deny') { return false; } } } return finalDecision; } } // 정책 조건 예시들 const conditions = { isWorkingHours: (context) => { const hour = context.time.getHours(); return hour >= 9 && hour &lt; 18; }, isInternalNetwork: (context) => { return context.ipAddress.startsWith('192.168.'); }, hasRole: (role) => (context) => { return context.user.roles.includes(role); }, hasPermission: (permission) => (context) => { return context.user.permissions.includes(permission); } }; // 정책 엔진 사용 예시 const policyEngine = new PolicyEngine(); // HR 문서 접근 정책 const hrDocumentPolicy = new Policy( 'HR_Document_Access', [ conditions.isWorkingHours, conditions.isInternalNetwork, conditions.hasRole('HR'), conditions.hasPermission('read_hr_documents') ], 'allow' ); // 주말 접근 제한 정책 const weekendRestrictionPolicy = new Policy( 'Weekend_Restriction', [ (context) => { const day = context.time.getDay(); return day === 0 || day === 6; } ], 'deny' ); policyEngine.addPolicy(hrDocumentPolicy); policyEngine.addPolicy(weekendRestrictionPolicy); // 접근 시도 예시 const accessContext = { user: { name: 'Alice', roles: ['HR'], permissions: ['read_hr_documents'] }, time: new Date('2024-12-17T14:00:00'), // 평일 오후 2시 ipAddress: '192.168.1.100', resource: 'employee_records' }; const hasAccess = policyEngine.evaluateAccess(accessContext); console.log(`Access granted: ${hasAccess}`); 주요 특징 유연성: 다양한 조건과 규칙을 조합하여 세밀한 접근 제어가 가능하다. 중앙 집중식 관리: 정책을 중앙에서 관리하여 일관성을 유지하고 관리를 용이하게 한다. 컨텍스트 인식: 사용자 신원, 리소스 특성, 시간, 위치 등 다양한 컨텍스트 정보를 고려한다. 동적 평가: 접근 요청 시 실시간으로 정책을 평가하여 결정을 내린다. 장점 세밀한 접근 제어: 복잡한 비즈니스 규칙과 요구사항을 정책에 반영할 수 있다. 변화에 대한 빠른 대응: 정책 변경만으로 접근 제어 로직을 신속하게 수정할 수 있다. 일관성 유지: 중앙에서 관리되는 정책으로 전체 시스템의 일관성을 보장한다. 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 class AdvancedPolicyEngine { constructor() { this.policies = new Map(); this.auditLog = []; } addPolicy(policy) { this.policies.set(policy.name, policy); } async evaluateAccess(context) { const decisions = []; const startTime = Date.now(); try { for (const policy of this.policies.values()) { const decision = { policyName: policy.name, effect: policy.effect, matches: await policy.evaluate(context), timestamp: new Date() }; decisions.push(decision); if (decision.matches && policy.effect === 'deny') { this.logDecision(context, decisions, 'denied'); return false; } } const finalDecision = decisions.some(d => d.matches && d.effect === 'allow'); this.logDecision(context, decisions, finalDecision ? 'allowed' : 'denied'); return finalDecision; } catch (error) { this.logError(context, error); throw error; } } logDecision(context, decisions, result) { const logEntry = { timestamp: new Date(), user: context.user.name, resource: context.resource, action: context.action, decisions: decisions, finalResult: result, contextSnapshot: { …context } }; this.auditLog.push(logEntry); } logError(context, error) { const errorEntry = { timestamp: new Date(), type: 'error', user: context.user.name, error: error.message, stack: error.stack, context: { …context } }; this.auditLog.push(errorEntry); } getAuditLog(filters = {}) { return this.auditLog.filter(entry => { return Object.entries(filters).every(([key, value]) => entry[key] === value ); }); } } 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-06 23:49:00 +0000 UTC'>November 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;746 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to PBAC" href=https://buenhyden.github.io/posts/backend/api-design/authorization-methods/pbac/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/35/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/37/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>