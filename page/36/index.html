<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.143.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Domain</h2></header><div class=entry-content><p>Domain 도메인(Domain)은 인터넷 상의 계층적 주소 체계로, 사용자가 이해하기 쉬운 형태의 웹사이트 주소를 제공한다.
도메인은 인터넷에서 컴퓨터 네트워크의 호스트를 식별하는 고유한 이름이다.
IP 주소를 사람이 기억하기 쉬운 문자열로 변환한 것으로 볼 수 있다.
도메인은 인터넷의 핵심 구성 요소로, 사용자 친화적인 웹 주소 체계를 제공하며 인터넷의 효율적인 관리와 사용을 가능하게 한다.
역할과 기능 웹사이트 식별: 사용자가 웹사이트를 쉽게 찾고 접근할 수 있게 한다. IP 주소 매핑: 도메인 이름을 해당하는 IP 주소로 변환한다. 네트워크 구조화: 인터넷을 계층적으로 구조화하여 관리를 용이하게 한다. 특징 계층적 구조: 최상위 도메인부터 하위 도메인까지 계층적으로 구성된다. 고유성: 각 도메인 이름은 인터넷 상에서 유일하다. 확장성: 새로운 도메인을 쉽게 추가할 수 있다. 구성과 구조 도메인은 점(.)으로 구분된 여러 부분으로 구성된다:
서브도메인.2차도메인.최상위도메인
예: www.example.com
...</p></div><footer class=entry-footer><span title='2024-10-17 02:03:00 +0000 UTC'>October 17, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;549 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain" href=https://buenhyden.github.io/posts/networking-and-communications/protocol/dns/domain/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Media Access Control Address (MAC Address)</h2></header><div class=entry-content><p>Media Access Control Address(MAC Address) 네트워크 장비를 식별하기 위한 고유한 하드웨어 주소.
구조 48비트(6바이트) 길이의 주소로, 16진수 형식으로 표현된다.
주로 6개의 2자리 16진수 그룹으로 표시되며, 콜론(:), 하이픈(-), 또는 점(.)으로 구분된다.
1 2 3 4 5 class MACAddress: def __init__(self, address): # MAC 주소 예시: "00:1A:2B:3C:4D:5E" self.oui = address[:8] # 조직 고유 식별자 (앞 3바이트) self.nic = address[9:] # 네트워크 인터페이스 식별자 (뒤 3바이트) MAC 주소의 첫 24비트(3바이트)는 OUI(Organizationally Unique Identifier)로, IEEE에서 제조업체에 할당하는 고유 번호 나머지 24비트는 제조업체가 각 장치에 할당하는 고유 번호. 용도 로컬 네트워크 내에서 장치를 고유하게 식별한다. 데이터 링크 계층(OSI 모델의 2계층)에서 사용된다. 네트워크 통신에서 데이터 패킷의 송신자와 수신자를 식별한다. 특징 제조업체에 의해 할당되며, 전 세계적으로 고유하다. 하드웨어에 고정되어 있어 일반적으로 변경할 수 없다. LAN 환경에서 장치 간 통신에 사용된다. IP 주소와의 차이 MAC 주소는 물리적 주소로, 로컬 네트워크 내에서만 사용된다. IP 주소는 논리적 주소로, 인터넷 상에서 전역적으로 사용된다. 기능 네트워크 진단 및 문제 해결에 사용된다. 네트워크 보안(MAC 주소 필터링 등)에 활용될 수 있다. MAC 주소의 종류 유니캐스트 주소 특정 단일 장치를 위한 주소.
...</p></div><footer class=entry-footer><span title='2024-10-16 12:19:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;635 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Media Access Control Address (MAC Address)" href=https://buenhyden.github.io/posts/networking-and-communications/media-access-control-address/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Packet</h2></header><div class=entry-content><p>Packet (패킷, 네트워크 패킷) 패킷은 네트워크에서 데이터를 주고받을 때 사용되는 형식화된 데이터 블록이다.
주요 목적은 다음과 같다:
효율적인 데이터 전송 네트워크 대역폭의 효율적 사용 오류 검출 및 복구 용이성 네트워크 혼잡 방지 패킷을 사용하는 이유는? 패킷이 모두 대상에 도착하는 한 동일한 대상에 대해 서로 다른 네트워크 경로를 사용할 수 있음을 의미한다. 특정 프로토콜에서 패킷은 각 패킷이 다른 경로를 사용하여 도착하더라도 올바른 순서로 최종 목적지에 도착해야 한다. 여러 컴퓨터의 패킷이 기본적으로 임의의 순서로 동일한 선로를 통해 이동할 수 있다. 동일한 네트워킹 장비를 통해 동시에 여러 연결을 수행할 수 있다. 그 결과로 수십억 개의 장치가 인터넷에서 동시에 데이터를 교환할 수 있다. 패킷의 구조 패킷은 일반적으로 세 부분으로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;303 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Packet" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/packet/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Routing</h2></header><div class=entry-content><p>Routing 데이터 패킷이 출발지에서 목적지까지 가장 효율적인 경로로 전달되도록 하는 과정.
네트워크 계층(3계층)에서 이루어지는 핵심 기능으로, 라우터가 패킷의 목적지 IP 주소를 확인하고 최적의 경로를 결정한다.
주요 특징 경로 결정: 라우팅 테이블을 참조하여 최적의 경로를 선택한다. 네트워크 연결: 서로 다른 네트워크를 연결하여 통신을 가능하게 한다. 패킷 전달: 선택된 경로를 통해 패킷을 다음 홉으로 전달한다. 중요성 효율적인 데이터 전송을 가능하게 한다. 네트워크의 안정성과 확장성을 향상시킨다. 트래픽 관리와 로드 밸런싱에 기여한다. 라우팅 방식 정적 라우팅: 관리자가 수동으로 라우팅 테이블을 구성한다.
...</p></div><footer class=entry-footer><span title='2024-10-16 10:18:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;620 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Routing" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/routing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network Hop</h2></header><div class=entry-content><p>Network Hop 네트워크 홉(Network Hop)은 데이터 패킷이 출발지에서 목적지로 이동하는 과정에서 거치는 네트워크 장비(주로 라우터)의 횟수를 의미한다.
홉은 데이터 패킷이 한 네트워크 지점에서 다음 지점으로 이동할 때마다 발생합니다.
각 홉은 패킷이 목적지에 도달하기 위해 거치는 중간 단계를 나타낸다. 주요 역할은 다음과 같다:
경로 결정: 각 홉에서 라우터는 패킷의 다음 목적지를 결정한다. 네트워크 성능 측정: 홉 수는 네트워크의 복잡성과 데이터 전송 경로의 길이를 나타낸다. 패킷 전달: 각 홉은 패킷을 다음 네트워크 장비로 전달하는 역할을 한다. 홉 카운트(Hop Count) 홉 카운트는 패킷이 출발지에서 목적지까지 거치는 홉의 총 개수를 의미한다. 이는 네트워크 경로의 길이를 측정하는 중요한 지표이다.
...</p></div><footer class=entry-footer><span title='2024-10-16 09:19:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;225 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network Hop" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/network-hop/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>프래그먼테이션 (Fragmentation)</h2></header><div class=entry-content><p>프래그먼테이션 (Fragmentation) Fragmentation은 큰 데이터 패킷을 네트워크의 최대 전송 단위(Maximum Transmission Unit, MTU)보다 작은 조각으로 나누는 과정이다.
이는 다음과 같은 목적을 가진다:
다양한 MTU를 가진 네트워크 간의 통신 가능 네트워크 성능 향상 대역폭 활용도 개선 프래그먼테이션이 필요한 이유 네트워크마다 처리할 수 있는 최대 패킷 크기가 다르다.
이를 MTU(Maximum Transmission Unit)라고 한다.
예를 들어:
이더넷의 MTU: 1500 바이트 PPP의 MTU: 576 바이트 Wi-Fi의 MTU: 2304 바이트
만약 4000 바이트 크기의 데이터를 MTU가 1500 바이트인 이더넷 네트워크로 전송하려면, 이 데이터는 반드시 더 작은 조각들로 나뉘어야 한다. Fragmentation의 작동 방식 프래그먼트 생성 원본 패킷은 여러 개의 작은 프래그먼트로 나뉜다.
각 프래그먼트는:
...</p></div><footer class=entry-footer><span title='2024-10-16 02:40:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;372 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 프래그먼테이션 (Fragmentation)" href=https://buenhyden.github.io/posts/networking-and-communications/osi-7-layers/network-layer/fragmentation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Network and Communication Devices</h2></header><div class=entry-content><p>Network and Communication Devices Source: https://www.geeksforgeeks.org/network-devices-hub-repeater-bridge-switch-router-gateways/
네트워크 및 통신 장치들은 각각 고유한 기능과 특성을 가지고 있으며, 네트워크의 다양한 요구사항을 충족시키기 위해 사용된다. 물리적 연결과 신호 전송: 리피터, 허브, NIC 등은 물리적 연결과 신호 전송을 담당. 데이터 전송 최적화: 스위치와 브리지는 네트워크 세그먼트 간의 효율적인 데이터 전송을 지원. 네트워크 간 연결: 라우터와 게이트웨이는 서로 다른 네트워크를 연결하고 데이터를 라우팅. 보안: 방화벽은 네트워크 보안을 담당. 무선 연결: 액세스 포인트는 무선 네트워크 연결을 제공. 신호 변환: 모뎀은 디지털 신호와 아날로그 신호 간의 변환을 수행. 장치들은 네트워크의 규모, 복잡성, 요구사항에 따라 적절히 선택되어 사용된다. 장치들의 특성을 이해하고, 네트워크의 요구사항에 맞게 적절히 선택, 구성, 관리해야 한다. 중요성 네트워크의 효율성과 성능 향상 데이터의 안전한 전송 보장 다양한 네트워크 토폴로지 구현 가능 네트워크 확장성 제공 Devices 모듈레이터 (Modulator) / 디모듈레이터 (Demodulator) 모듈레이터 (Modulator): 디지털 신호를 아날로그 신호로 변환 디모듈레이터 디모듈레이터: 아날로그 신호를 디지털 신호로 변환 네트워크 및 통신 장비 장비 동작 계층 주요 기능 작동 방식 장점 단점 주요 사용 사례 Bridge (브릿지) 데이터 링크 계층 (L2) • 두 개의 네트워크 세그먼트 연결 • MAC 주소 기반 필터링 • 충돌 도메인 분리 • MAC 주소 테이블 유지 • 프레임 포워딩/필터링 • Store-and-forward 방식 • 네트워크 세그먼트 확장 • 트래픽 필터링 • 간단한 구성 • 확장성 제한 • 대규모 네트워크에 부적합 • 라우팅 불가 • 소규모 네트워크 연결 • 부서별 네트워크 분리 • 네트워크 확장 Gateway (게이트웨이) 응용 계층 (L7) • 서로 다른 네트워크 프로토콜 변환 • 데이터 형식 변환 • 보안 기능 • 프로토콜 변환 • 데이터 재포장 • 양방향 변환 • 이기종 네트워크 연결 • 높은 보안성 • 프로토콜 유연성 • 높은 복잡도 • 성능 오버헤드 • 고비용 • 기업 네트워크 연동 • 클라우드 연결 • 보안 게이트웨이 Router (라우터) 네트워크 계층 (L3) • 네트워크 간 패킷 라우팅 • 최적 경로 선택 • 트래픽 제어 • 라우팅 테이블 관리 • 패킷 검사 및 전달 • 동적 라우팅 • 확장성 우수 • 지능적 라우팅 • 네트워크 분리 • 높은 비용 • 구성 복잡성 • 관리 필요성 • 인터넷 연결 • WAN 구축 • 네트워크 분할 Switch (스위치) 데이터 링크 계층 (L2) • 장치 간 데이터 전송 • 포트 기반 필터링 • VLAN 지원 • MAC 주소 학습 • 프레임 스위칭 • 포트 기반 전송 • 고성능 • 낮은 지연 • 포트별 제어 • L3 기능 제한 • 관리 복잡성 • 초기 비용 • LAN 구축 • 데이터센터 • 기업 네트워크 Wireless Access Point 데이터 링크 계층 (L2) • 무선 네트워크 접속점 제공 • 무선-유선 변환 • 보안 관리 • 무선 신호 송수신 • 인증 및 암호화 • 채널 관리 • 이동성 지원 • 설치 용이 • 유연한 확장 • 신호 간섭 • 보안 취약성 • 거리 제한 • 무선 네트워크 구축 • 사무실 Wi-Fi • 공공 핫스팟 Amplifier (증폭기) 물리 계층 (L1) • 신호 강화 • 거리 확장 • 노이즈 제거 • 신호 증폭 • 임피던스 매칭 • 필터링 • 신호 품질 향상 • 거리 확장 • 간단한 구성 • 노이즈 증폭 • 전력 소비 • 비용 증가 • 장거리 통신 • 케이블 TV • 광통신 Hub (허브) 물리 계층 (L1) • 물리적 연결 제공 • 신호 재생성 • 포트 확장 • 브로드캐스트 방식 • 단순 신호 전달 • 포트별 복제 • 저비용 • 간단한 구성 • 쉬운 설치 • 낮은 효율성 • 대역폭 공유 • 보안 취약 • 소규모 네트워크 • 임시 연결 • 테스트 환경 Load Balancer 다양한 계층 • 트래픽 분산 • 서버 부하 분산 • 가용성 보장 • 부하 모니터링 • 트래픽 분배 • 헬스 체크 • 고가용성 • 확장성 • 성능 최적화 • 구성 복잡성 • 고비용 • 단일 실패점 • 웹 서버 부하분산 • 클라우드 서비스 • 대규모 애플리케이션 Modem (모뎀) 물리 계층 (L1) • 디지털-아날로그 변환 • 신호 변조/복조 • 프로토콜 변환 • 신호 변환 • 에러 검출/정정 • 속도 조절 • 다양한 매체 지원 • 호환성 • 설치 용이 • 속도 제한 • 지연 발생 • 신호 감쇠 • 인터넷 연결 • 원격 통신 • 데이터 전송 Repeater (리피터) 물리 계층 (L1) • 신호 재생성 • 거리 확장 • 노이즈 제거 • 신호 증폭 • 타이밍 복원 • 파형 정형 • 거리 확장 • 신호 품질 향상 • 간단한 구성 • 지연 발생 • 제한된 기능 • 캐스케이드 제한 • 장거리 네트워크 • 신호 강화 • 케이블 확장 각 장비의 특징적인 활용 시나리오:
...</p></div><footer class=entry-footer><span title='2024-10-16 02:03:00 +0000 UTC'>October 16, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;868 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Network and Communication Devices" href=https://buenhyden.github.io/posts/networking-and-communications/network-and-communication-devices/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>보간 검색 (Interpolation Search)</h2></header><div class=entry-content><p>보간 검색 (Interpolation Search) 보간 검색(Interpolation Search)은 정렬된 배열에서 특정 값을 효율적으로 찾기 위한 탐색 알고리즘이다.
이진 탐색(Binary Search)과 유사하지만, 데이터 분포를 고려해 탐색 위치를 예측함으로써 평균적으로 더 빠른 성능을 보인다. 특히 균등한 데이터 분포에서 효과적이다.
보간 검색은 데이터 특성에 민감하므로, 균등 분포가 보장되지 않으면 이진 탐색을 권장한다.
알고리즘 선택 시 데이터의 분포와 크기를 고려하는 것이 중요하다.
핵심 개념 데이터 균등성 가정: 배열의 값이 선형적으로 분포되어 있다고 가정한다.
예측 위치 계산: 탐색 위치를 다음 공식으로 계산한다.
...</p></div><footer class=entry-footer><span title='2024-10-15 12:33:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;592 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 보간 검색 (Interpolation Search)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/searching-algorithms/interpolation-search/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>버블 정렬 (Bubble Sort)</h2></header><div class=entry-content><p>버블 정렬 (Bubble Sort) 버블 정렬(Bubble Sort)은 인접한 요소를 반복적으로 비교하고 교환하여 정렬하는 간단한 알고리즘이다.
정렬 과정에서 큰 값이 물속 거품처럼 위로 올라오는 모습을 닮아 이름이 붙었다. 작은 데이터 세트나 교육용으로 주로 활용되며, 구현이 쉽지만 성능이 낮은 특징을 가진다.
https://www.wscubetech.com/resources/dsa/bubble-sort
알고리즘 작동 원리 비교: 배열의 첫 번째 요소부터 시작해 인접한 두 요소(arr[i]와 arr[i+1])를 비교한다. 교환: 순서가 잘못된 경우(arr[i] > arr[i+1]) 두 요소의 위치를 교환한다. 반복: 배열의 끝까지 이 과정을 반복하면 가장 큰 요소가 마지막 위치로 이동한다. 패스 완료: 한 번의 전체 순회(패스)를 마치면 정렬 범위를 하나 줄이고 과정을 반복한다. 예시: [5, 3, 8, 4, 2]
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;420 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 버블 정렬 (Bubble Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/bubble-sort/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>병합 정렬 (Merge Sort)</h2></header><div class=entry-content><p>병합 정렬 (Merge Sort) 병합 정렬(Merge Sort)은 분할 정복(divide and conquer) 방식을 사용하는 비교 기반 정렬 알고리즘이다.
존 폰 노이만이 1945년 개발한 이 알고리즘은 대규모 데이터셋 처리에 적합하며, **안정 정렬(Stable Sort)**의 특성을 가진다. 모든 경우(최선, 평균, 최악)에서 **O(n log n)**의 시간 복잡도를 보장한다.
병합 정렬은 데이터 무결성과 안정성이 중요한 시스템(예: 금융 거래 로그)에서 선호된다.
현대 프로그래밍 언어의 표준 라이브러리(예: Python sorted(), Java Collections.sort())에서도 하이브리드 방식으로 병합 정렬을 활용한다.
https://www.programiz.com/dsa/merge-sort
...</p></div><footer class=entry-footer><span title='2024-10-15 08:38:00 +0000 UTC'>October 15, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;528 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 병합 정렬 (Merge Sort)" href=https://buenhyden.github.io/posts/data-structure-and-algorithm/algorithm/sorting-algorithms/merge-sort/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/35/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/37/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>