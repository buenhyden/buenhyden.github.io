<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.157.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.d522c866f0cc9c20ae4fa73a0a8c07f0af4c36af75bcbcd3e90558446f681077.css integrity="sha256-1SLIZvDMnCCuT6c6CowH8K9MNq91vLzT6QVYRG9oEHc=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json title=json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>명령형 (Imperative) vs. 선언적 (Declarative) 프로그래밍</h2></header><div class=entry-content><p>명령형 프로그래밍(Imperative Programming) vs. 선언적 프로그래밍(Declarative Programming) 명령형 프로그래밍과 선언적 프로그래밍은 소프트웨어 개발에서 가장 기본적인 두 가지 프로그래밍 패러다임이다.
이들은 문제를 해결하는 접근 방식과 코드 작성 철학에서 근본적인 차이를 보인다.
명령형 프로그래밍과 선언적 프로그래밍은 서로 배타적이지 않으며, 각각 고유한 장점과 적합한 사용 사례가 있다.
현대 소프트웨어 개발에서는 두 패러다임을 상황에 맞게 적절히 조합하여 사용하는 것이 일반적이다.
명령형 프로그래밍은 세밀한 제어와 최적화가 필요한 영역에서 강점을 발휘하며, 선언적 프로그래밍은 높은 수준의 추상화와 간결함이 중요한 영역에서 유리하다. 개발자로서 두 패러다임 모두를 이해하고 적절히 활용할 수 있다면, 다양한 문제 영역에서 효과적인 솔루션을 구축할 수 있을 것이다.
...</p></div><footer class=entry-footer><span title='2025-02-09 12:38:00 +0000 UTC'>February 9, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to 명령형 (Imperative) vs. 선언적 (Declarative) 프로그래밍" href=https://buenhyden.github.io/posts/software-development/foundations/programming-paradigms/imperative-vs-declarative-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>select_related</h2></header><div class=entry-content><p>select_related select_related는 SQL의 JOIN 연산을 활용하여 외래 키(Foreign Key) 관계가 있는 객체를 단일 쿼리로 함께 가져오는 메서드이다.
이는 “many-to-one” 관계(ForeignKey)나 “one-to-one” 관계(OneToOneField)에서 특히 유용하다.
1 2 3 4 5 # 기본 사용법 book = Book.objects.select_related('publisher').get(id=1) # 이제 book.publisher에 접근할 때 추가 쿼리 없이 바로 접근 가능 publisher_name = book.publisher.name # 추가 데이터베이스 호출 없음 Django의 select_related는 관계형 데이터를 효율적으로 가져오기 위한 필수적인 도구이다.
올바르게 사용하면 애플리케이션의 성능을 크게 향상시킬 수 있다. 특히 ForeignKey와 OneToOneField 관계에서 N+1 쿼리 문제를 해결하는 데 탁월하다.
...</p></div><footer class=entry-footer><span title='2025-02-08 02:39:00 +0000 UTC'>February 8, 2025</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to select_related" href=https://buenhyden.github.io/posts/software-development/python/ecosystem--practice/web-frameworks/django/orm/queryset/optimization/select_related/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>RFC 7519</h2></header><div class=entry-content><p>RFC 7519 RFC 7519는 JSON Web Token(JWT)에 대한 공식 인터넷 표준 문서이다.
2015년 5월에 Internet Engineering Task Force(IETF)에 의해 발행된 이 문서는 JWT의 구조, 형식, 서명 방법, 암호화 방법 등을 상세히 정의하고 있다. JWT는 당사자 간에 안전하게 정보를 전송하기 위한 간결하고 자체 포함적인 방법을 제공하는 개방형 표준이다.
JWT는 현대 웹 애플리케이션과 마이크로서비스 아키텍처에서 인증 및 정보 교환을 위한 핵심 기술로 자리 잡았다. 특히 Single Sign-On(SSO), API 인증, 정보의 안전한 전송 등 다양한 사용 사례에서 널리 활용되고 있다.
...</p></div><footer class=entry-footer><span title='2025-02-06 03:33:00 +0000 UTC'>February 6, 2025</span>&nbsp;·&nbsp;<span>14 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to RFC 7519" href=https://buenhyden.github.io/posts/software-development/platform-development/backend-development/api-development/token-based-authentication/token-formats/jwt/rfc-7519/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hollywood Principle</h2></header><div class=entry-content><p>Hollywood Principle Hollywood Principle 은 객체지향 설계 및 프레임워크 설계에서 널리 쓰이는 원칙으로, “Don’t call us, we’ll call you” 라는 문구로 대표된다. 이 원칙은 저수준 (구현) 모듈이 고수준 (프레임워크, 추상화) 모듈을 직접 호출하는 것이 아니라, 고수준 모듈이 저수준 모듈을 필요할 때 호출하도록 구조를 설계한다. 이를 통해 의존성 부패 (Dependency Rot) 를 방지하고, 시스템의 유연성, 확장성, 테스트 용이성을 높인다. 대표적으로 Inversion of Control, Dependency Injection, Observer, Template Method, Strategy 패턴 등에서 적용된다.
...</p></div><footer class=entry-footer><span title='2025-02-04 14:27:00 +0000 UTC'>February 4, 2025</span>&nbsp;·&nbsp;<span>24 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Hollywood Principle" href=https://buenhyden.github.io/posts/software-development/design-fundamentals/architecture-principles/inversion-of-control/hollywood-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Short Polling</h2></header><div class=entry-content><p>Short Polling Short polling은 클라이언트와 서버 간의 실시간에 가까운 통신을 구현하기 위한 기본적인 기술이다.
Short polling은 실시간 업데이트가 필요하지만 진정한 실시간성이 중요하지 않은 애플리케이션에서 구현이 간단하고 호환성이 좋은 솔루션이다. 그러나 사용자가 많아지거나 지연 시간이 중요한 애플리케이션에서는 Long Polling, SSE, WebSockets 같은 더 효율적인 기술의 사용을 고려해야 한다.
Short Polling의 개념 Short polling은 클라이언트가 주기적으로 서버에 HTTP 요청을 보내 새로운 데이터가 있는지 확인하는 방식이다. 클라이언트는 정해진 시간 간격으로 서버에 요청을 보내고, 서버는 그 순간 가지고 있는, 클라이언트가 아직 받지 않은 데이터를 응답한다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:45:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;<span>3 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Short Polling" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/hybrid/polling/types/short-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Long Polling</h2></header><div class=entry-content><p>Long Polling Long polling은 전통적인 short polling의 한계를 극복하기 위해 발전된 웹 통신 기법으로, 실시간에 가까운 데이터 전송을 가능하게 한다. 이 기술은 특히 웹소켓(WebSocket)이 등장하기 전에 실시간 웹 애플리케이션 구현에 널리 사용되었다.
Long polling은 WebSockets의 대중화 이전에 실시간 웹 애플리케이션의 핵심 기술이었으며, 오늘날에도 특정 상황에서 유용한 접근 방식이다. 특히 WebSockets 지원이 제한된 환경이나, 단순한 실시간 요구사항을 가진 애플리케이션에서 여전히 가치 있는 솔루션이다.
최신 웹 애플리케이션에서는 WebSockets가 선호되는 경향이 있지만, Long polling은 폴백(fallback) 메커니즘으로 구현되어 WebSockets를 지원하지 않는 환경에서도 실시간에 가까운 경험을 제공할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-02-01 03:44:00 +0000 UTC'>February 1, 2025</span>&nbsp;·&nbsp;<span>6 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Long Polling" href=https://buenhyden.github.io/posts/computer-science/communication-patterns/asynchronous-communication/hybrid/polling/types/long-polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Priority Queue</h2></header><div class=entry-content><p>우선순위 큐 (Priority Queue) 우선순위 큐는 일반적인 큐(FIFO)와 달리, 데이터의 우선순위에 따라 처리 순서가 결정되는 추상 자료형입니다.
핵심 개념 우선순위 기반: 먼저 들어온 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나갑니다. 최대 우선순위 큐 / 최소 우선순위 큐: 상황에 따라 큰 값이 우선인 경우와 작은 값이 우선인 경우로 나뉩니다. 기초 이해 구현 방식: 배열, 연결 리스트 등으로 구현할 수 있으나, 일반적으로 힙(Heap) 자료구조를 사용하여 삽입과 삭제 모두 $O(\log n)$의 시간 복잡도를 가지도록 구현합니다. 정리 및 학습 가이드 내용 정리 활용 사례: 다익스트라 최단 경로 알고리즘, CPU 스케줄링, 데이터 압축(허프만 코딩) 등에서 핵심적으로 사용됩니다. 힙(Heap)과의 관계: 우선순위 큐는 인터페이스(무엇을 하는가)이고, 힙은 이를 구현하는 가장 효율적인 실제 방법(무게 중심) 중 하나입니다. 용어 정리 용어 설명 Heap 우선순위 큐를 구현하기 위해 주로 사용되는 이진 트리 기반 자료구조입니다. Dijkstra 우선순위 큐를 사용하여 최단 경로를 찾는 대표적인 알고리즘입니다. 참고 및 출처 Wikipedia: Priority Queue GeeksforGeeks: Priority Queue Set 1 (Introduction)</p></div><footer class=entry-footer><span title='2025-01-29 03:54:00 +0000 UTC'>January 29, 2025</span>&nbsp;·&nbsp;<span>1 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Priority Queue" href=https://buenhyden.github.io/posts/computer-science/linear-structures--algorithms/stack--queue/queue-implementation/priority-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Brute Force</h2></header><div class=entry-content><p>Divide and Conquer vs. Brute Force 알고리즘은 프로그래밍의 핵심이며, 문제 해결 방식에 따라 효율성과 성능이 크게 달라진다.
두 알고리즘 모두 장단점이 있으며, 상황에 따라 적절한 선택이 필요하다.
먼저 브루트 포스로 문제를 해결한 다음, 필요에 따라 분할 정복과 같은 더 효율적인 알고리즘으로 발전시키는 것이 좋다. 알고리즘의 선택은 문제의 성격, 데이터의 크기, 요구되는 효율성, 그리고 개발자의 친숙도에 따라 달라질 수 있다.
Divide and Conquer(분할 정복) 알고리즘 기본 개념 분할 정복은 복잡한 문제를 더 작고 관리하기 쉬운 하위 문제들로 나누어 해결하는 방법이다.
이 알고리즘은 세 가지 주요 단계로 구성된다:
...</p></div><footer class=entry-footer><span title='2025-01-24 07:17:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Brute Force" href=https://buenhyden.github.io/posts/computer-science/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/divide-and-conquer-vs-brute-force/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Divide and Conquer vs. Branch and Bound</h2></header><div class=entry-content><p>Divide and Conquer vs. Branch and Bound “Divide and Conquer(분할 정복)“과 “Branch and Bound(분기 한정)“은 복잡한 문제를 해결하는 다른 접근법을 제공하며, 각각의 장단점과 적합한 활용 사례가 있다.
“Divide and Conquer"와 “Branch and Bound"는 복잡한 문제를 해결하기 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 작은 하위 문제로 나누어 해결하는 일반적인 방법인 반면, 분기 한정은 최적화 문제에서 효율적으로 최적해를 찾기 위한 전문화된 방법이다.
분할 정복은 정렬, 검색 등의 기본 알고리즘에 널리 사용되며, 분기 한정은 TSP, 배낭 문제 등의 복잡한 최적화 문제에 효과적이다.
두 알고리즘 모두 컴퓨터 과학에서 중요한 도구이므로, 문제의 특성에 따라 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2025-01-24 02:16:00 +0000 UTC'>January 24, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Divide and Conquer vs. Branch and Bound" href=https://buenhyden.github.io/posts/computer-science/basic-algorithmic-paradigms/recursion--divide-and-conquer/divide-and-conquer/divide-and-conquer-vs-branch-and-bound/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Typescript vs. Javascript</h2></header><div class=entry-content><p>Typescript vs. Javascript JavaScript와 TypeScript는 둘 다 웹 및 기타 환경에서 널리 사용되는 프로그래밍 언어이지만, 설계와 사용 목적에 있어 몇 가지 중요한 차이가 있다.
JavaScript는 인터프리터(또는 JIT 컴파일러)에 의해 실행되는 동적 타입의 스크립트 언어로, 유연성과 간편함을 제공하며 브라우저와 Node.js 등에서 기본 언어로 사용된다. TypeScript는 Microsoft에서 개발한 JavaScript의 상위 집합(superset)으로, 정적 타입 시스템과 클래스, 인터페이스, 제네릭 등 강력한 객체지향 프로그래밍(OOP) 기능을 추가하여 대규모 애플리케이션이나 엔터프라이즈 환경에서 코드의 안정성과 유지보수성을 높이는 데 목적이 있다. JavaScript JavaScript는 1995년 Brendan Eich에 의해 만들어진 웹 브라우저용 스크립트 언어이다. 원래는 웹 페이지에 상호작용을 추가하기 위해 설계되었지만, 현재는 브라우저 환경 외에도 서버 사이드(Node.js), 모바일 앱 개발(React Native), 데스크톱 애플리케이션(Electron) 등 다양한 환경에서 사용된다.
...</p></div><footer class=entry-footer><span title='2025-01-19 00:43:00 +0000 UTC'>January 19, 2025</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>Me</span></footer><a class=entry-link aria-label="post link to Typescript vs. Javascript" href=https://buenhyden.github.io/posts/software-development/javascript-family/typescript-vs-javascript/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/15/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/17/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>