<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cookie-Based Auth vs. Basic Authentication</h2></header><div class=entry-content><p>Cookie-Based Auth vs. Basic Authentication 쿠키 기반 인증(Cookie-Based Authentication) 작동 원리 쿠키 기반 인증은 HTTP 쿠키를 사용하여 사용자의 인증 상태를 유지하는 방식이다.
일반적인 흐름은 다음과 같다:
사용자가 로그인 폼에 자격 증명(사용자 이름과 비밀번호)을 입력한다. 서버는 자격 증명을 검증하고, 인증에 성공하면 세션 ID를 생성한다. 서버는 이 세션 ID를 쿠키로 클라이언트에게 전송한다 (Set-Cookie 헤더 사용). 브라우저는 해당 도메인에 대한 후속 요청에 이 쿠키를 자동으로 포함시킨다. 서버는 쿠키에 포함된 세션 ID를 검증하여 사용자를 식별한다. 장점 사용자 경험: 사용자가 자격 증명을 한 번만 입력하면 되므로 편리하다. 상태 관리: 서버 측에서 세션 상태를 유지할 수 있어 세밀한 제어가 가능하다. 보안 옵션: HttpOnly, Secure, SameSite 등의 플래그를 통해 보안을 강화할 수 있다. 만료 및 갱신: 세션 타임아웃과 자동 갱신 메커니즘을 구현할 수 있다. 로그아웃: 서버에서 세션을 무효화하여 즉시 로그아웃이 가능하다. 단점 CSRF 취약점: 적절한 보호 조치 없이는 사이트 간 요청 위조(CSRF) 공격에 취약할 수 있다. 확장성 문제: 세션 데이터를 서버에 저장하면 분산 시스템에서 확장성 문제가 발생할 수 있다. 도메인 제한: 쿠키는 기본적으로 단일 도메인에 제한되어 있어 크로스 도메인 요청에 제약이 있다. 모바일 앱 호환성: 일부 모바일 앱 환경에서는 쿠키 관리가 복잡할 수 있다. 기본 인증(Basic Authentication) 작동 원리 기본 인증은 HTTP 프로토콜에 내장된 간단한 인증 메커니즘이다:
...</p></div><footer class=entry-footer><span title='2025-04-02 02:48:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cookie-Based Auth vs. Basic Authentication" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/cookie-based-authentication/cookie-based-auth-vs-basic-authentication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Jwt vs. Cookie-Based Auth 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간 정보를 안전하게 JSON 객체로 전송하기 위한 컴팩트하고 독립적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 HMAC 알고리즘이나 RSA/ECDSA와 같은 공개/개인 키 쌍을 사용하여 서명할 수 있다.
쿠키 기반 인증
쿠키 기반 인증은 사용자가 로그인할 때 서버가 세션 ID를 생성하고, 이 세션 ID를 쿠키에 저장하여 클라이언트에게 전송하는 방식이다. 모든 후속 요청에서 클라이언트는 이 쿠키를 서버에 보내고, 서버는 세션 ID를 확인하여 사용자를 인증한다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:47:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-cookie-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Session-based Auth</h2></header><div class=entry-content><p>Jwt vs. Session-based Auth 기본 개념 JWT(JSON Web Token)
JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있으며, 토큰 자체에 필요한 모든 정보를 포함하고 있다. JWT는 주로 상태 비저장(Stateless) 인증 메커니즘으로 사용된다.
세션 기반 인증
세션 기반 인증은 서버가 사용자의 인증 상태를 유지하는 전통적인 인증 방식이다. 사용자가 로그인하면 서버는 세션 ID를 생성하고 이를 서버 메모리나 데이터베이스에 저장한다. 이 세션 ID는 쿠키를 통해 클라이언트에게 전달되며, 후속 요청에서 클라이언트는 이 쿠키를 전송하여 인증 상태를 유지한다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:46:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Session-based Auth" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-session-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. Session-based Auth</h2></header><div class=entry-content><p>Token Authentication vs. Session-based Auth 세션 기반 인증(Session-based Authentication) 세션 기반 인증은 전통적인 인증 방식으로, 서버가 사용자의 로그인 상태를 세션으로 유지하는 방식이다.
작동 원리 인증 과정: 사용자가 자격 증명(사용자 이름/비밀번호)을 제출한다. 서버는 자격 증명을 검증하고, 유효한 경우 고유한 세션 ID를 생성한다. 서버는 세션 ID와 관련 사용자 정보를 서버 측 저장소(메모리, 데이터베이스, 캐시 등)에 저장한다. 서버는 세션 ID를 클라이언트에게 쿠키로 전송한다. 클라이언트는 이후 요청 시 이 쿠키를 자동으로 포함시킨다. 서버는 쿠키의 세션 ID를 확인하여 사용자를 식별한다. 세션 수명 주기: 세션은 사용자가 로그인할 때 생성된다. 세션은 일정 시간이 지나면 만료된다(서버 설정에 따라 다름). 사용자가 로그아웃하면 세션이 명시적으로 파기된다. 서버는 세션의 유효성과 만료를 관리한다. 주요 특징 상태 유지(Stateful): 서버가 세션 정보를 저장하고 관리한다. 쿠키 기반: 주로 HTTP 쿠키를 통해 세션 ID를 전달한다. 서버 측 저장소: 세션 데이터가 서버에 저장된다. 간단한 구현: 대부분의 웹 프레임워크에서 기본적으로 지원한다. 명시적인 세션 관리: 서버가 세션 생성, 검증, 만료, 파기를 제어한다. 토큰 인증(Token Authentication) 토큰 인증은 클라이언트에게 서명된 토큰을 발급하여 인증하는 방식이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:45:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. Session-based Auth" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-session-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backpressure</h2></header><div class=entry-content><p>Backpressure Backpressure는 데이터 처리 시스템에서 수신 측이 송신 측에게 자신의 처리 용량을 알려 데이터 흐름을 제어하는 메커니즘이다. 이는 시스템이 과부하 없이 안정적으로 작동하도록 하며, 특히 분산 시스템이나 대규모 데이터 스트리밍 환경에서 필수적이다.
백프레셔의 기본 개념과 원리 백프레셔는 수신 구성 요소가 송신 구성 요소에게 데이터 처리 능력을 신호로 알려주는 흐름 제어 메커니즘이다. 이름의 유래는 파이프나 유체 시스템에서 역압력(back pressure)이 발생하는 물리적 현상에서 왔다.
핵심 원리 수신측 제어: 데이터를 수신하는 시스템이 처리 가능한 양을 송신 시스템에 알림 피드백 루프: 송신측과 수신측 사이의 지속적인 커뮤니케이션 자기 조절: 시스템이 자체적으로 처리 속도를 조절하는 메커니즘 물리적 아날로그 물리적 시스템에서의 백프레셔 개념을 이해하면 소프트웨어에서의 적용이 더 명확해진다.
...</p></div><footer class=entry-footer><span title='2025-04-01 15:16:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backpressure" href=https://buenhyden.github.io/posts/system-design/migration-strategies/backpressure/backpressure/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OpenID Connect</h2></header><div class=entry-content><p>JWT vs. OpenID Connect JWT(JSON Web Token)와 OpenID Connect(OIDC)는 모두 현대적인 인증 및 권한 부여 시스템에서 중요한 역할을 하는 기술이다. 이 두 기술은 서로 밀접한 관계가 있지만, 목적과 기능 면에서 중요한 차이점을 가지고 있다.
JWT(JSON Web Token) JWT는 당사자 간에 안전하게 정보를 전송하기 위한 개방형 표준(RFC 7519)으로, 컴팩트하고 자체 포함적인 방식으로 정보를 안전하게 전달한다.
기본 구조 JWT는 점(.)으로 구분된 세 부분으로 구성된다:
헤더(Header): 토큰 유형과 사용된 암호화 알고리즘 정보 페이로드(Payload): 클레임(사용자 ID, 만료 시간 등) 정보 서명(Signature): 토큰의 무결성을 보장하는 디지털 서명 예시:
...</p></div><footer class=entry-footer><span title='2025-04-01 14:53:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OpenID Connect" href=https://buenhyden.github.io/posts/security-engineering/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-openid-connect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOAP API vs. SOAP</h2></header><div class=entry-content><p>SOAP API vs. SOAP SOAP(Simple Object Access Protocol)는 웹 서비스 통신을 위한 중요한 프로토콜이지만, ‘SOAP API’와 ‘SOAP’라는 용어는 종종 혼용되어 사용된다.
SOAP와 SOAP API는 관련되어 있지만 다른 개념이다. SOAP는 메시지 교환 프로토콜이고, SOAP API는 이 프로토콜을 사용하여 구현된 웹 서비스이다. 이 둘의 관계를 이해하는 것은 웹 서비스 아키텍처를 설계하고 구현하는 데 중요한 기초가 된다.
현대 API 설계에서는 REST, GraphQL 등의 가벼운 대안이 더 많이 사용되고 있지만, 특정 엔터프라이즈 환경에서는 SOAP의 강력한 기능과 표준화된 접근 방식이 여전히 가치를 지니고 있다.
...</p></div><footer class=entry-footer><span title='2025-04-01 03:18:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOAP API vs. SOAP" href=https://buenhyden.github.io/posts/backend-development/api-design-and-implementation/api-styles/tunnel-style/soap/soap-api-vs-soap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DNS</h2></header><div class=entry-content><p>DNS DNS(Domain Name System)는 인터넷의 전화번호부와 같은 역할을 한다. 사람이 읽고 이해할 수 있는 도메인 이름(예: www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소(예: 192.0.2.1)로 변환해주는 시스템이다. 이 변환 과정은 사용자가 인터넷에서 웹사이트나 API에 접근할 때 필수적인 단계이다.
DNS의 작동 방식 DNS 변환 과정은 여러 단계로 이루어지는 분산 시스템이다.
이 과정을 “DNS 조회” 또는 “DNS 해석"이라고 부른다.
DNS 조회 과정 사용자 입력: 사용자가 브라우저에 도메인 이름(api.example.com)을 입력한다. 로컬 DNS 캐시 확인: 브라우저와 운영체제는 먼저 자체 캐시를 확인하여 최근에 방문한 도메인의 IP 주소를 찾는다. 리커시브 DNS 서버 질의: 캐시에서 찾지 못하면, 요청은 일반적으로 ISP(인터넷 서비스 제공업체)가 제공하는 리커시브 DNS 서버로 전달된다. 루트 DNS 서버 질의: 리커시브 서버는 전 세계에 분산된 루트 DNS 서버에 질의한다. 루트 서버는 최상위 도메인(TLD) 서버의 위치를 알려준다. TLD DNS 서버 질의: 리커시브 서버는 TLD 서버(예:.com,.org,.net)에 질의하여 해당 도메인의 권한 있는 네임서버의 위치를 알아낸다. 권한 있는 네임서버 질의: 리커시브 서버는 권한 있는 네임서버에 도메인 이름에 대한 IP 주소를 요청한다. 응답 반환: IP 주소는 리커시브 서버를 통해 사용자의 컴퓨터로 반환된다. 이 정보는 일정 기간 동안 캐시된다. 연결 설정: 브라우저는 이제 해당 IP 주소를 사용하여 웹 서버 또는 API 서버에 연결한다. DNS 데이터 구조 DNS는 계층적 분산 데이터베이스로 구성되어 있다.
...</p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DNS" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/dns/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Domain Name</h2></header><div class=entry-content><p>Domain Name 도메인 이름은 인터넷의 기본 구성 요소로, 특히 API 디자인과 웹 서비스 개발에서 중요한 역할을 한다.
도메인 이름의 기본 개념 도메인 이름이란? 도메인 이름은 인터넷에서 특정 위치를 식별하는 사람이 읽을 수 있는 주소이다. 컴퓨터가 서로 통신할 때 사용하는 숫자로 된 IP 주소(예: 192.168.1.1) 대신, 사람이 기억하고 입력하기 쉬운 텍스트 형식(예: example.com)을 제공한다.
도메인 이름의 주요 목적은 다음과 같다:
기억하기 쉬운 웹 주소 제공 브랜드 아이덴티티 확립 웹사이트와 서비스에 대한 접근성 향상 IP 주소가 변경되더라도 일관된 접근점 유지 도메인 이름 시스템(DNS)과의 관계 도메인 이름 시스템(DNS)은 도메인 이름을 IP 주소로 변환하는 인터넷의 전화번호부와 같은 역할을 한다. 사용자가 브라우저에 도메인 이름을 입력하면, DNS는 해당 도메인 이름과 연결된 IP 주소를 찾아 사용자를 올바른 서버로 연결한다.
...</p></div><footer class=entry-footer><span title='2025-04-01 02:20:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain Name" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/domain-name/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Hosting</h2></header><div class=entry-content><p>Hosting 호스팅은 API 설계와 배포에 있어 핵심적인 요소이다. 잘 설계된 API도 적절한 호스팅 환경이 없다면 사용자에게 안정적으로 서비스를 제공할 수 없다.
호스팅의 기본 개념 호스팅이란 무엇인가? 호스팅은 API, 웹사이트, 애플리케이션과 같은 디지털 자산을 인터넷을 통해 사용자에게 제공하기 위해 서버 공간과 자원을 제공하는 서비스이다. API 호스팅은 API가 24시간 내내 접근 가능하고, 안정적으로 요청을 처리하며, 적절한 보안과 성능을 유지할 수 있도록 한다.
호스팅 서비스는 다음과 같은 기본 요소를 제공한다:
서버 인프라(물리적 또는 가상 서버) 네트워크 연결 저장 공간 처리 능력(CPU, 메모리) 보안 장치 관리 도구 웹 서버의 역할 호스팅의 핵심에는 웹 서버가 있다.
...</p></div><footer class=entry-footer><span title='2025-03-31 23:50:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Hosting" href=https://buenhyden.github.io/posts/computer-science-fundamentals/networking-knowledge/fundamentals/internet/hosting/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/15/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/17/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>