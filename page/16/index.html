<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar vs. Kafka</h2></header><div class=entry-content><p>Apache Pulsar vs. Kafka 분산 메시징 시스템은 현대 데이터 중심 아키텍처의 중추 역할을 한다.
기본 개념 및 역사 Apache Kafka Apache Kafka는 2011년 LinkedIn에서 개발된 후 Apache 소프트웨어 재단으로 이관된 분산 스트리밍 플랫폼이다. 처음에는 LinkedIn 내부의 데이터 파이프라인 문제를 해결하기 위해 만들어졌지만, 이후 업계 표준 메시징 시스템으로 자리 잡았다. Kafka는 높은 처리량, 내구성, 확장성을 제공하는 로그 기반의 발행-구독(pub-sub) 메시징 시스템이다.
Apache Pulsar Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년에 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 다중 테넌트, 고성능 서비스로 설계되었으며, Kafka와 같은 발행-구독 메시징 시스템의 특성과 전통적인 메시지 큐의 장점을 결합했다. Pulsar는 처음부터 클라우드 네이티브 환경을 염두에 두고 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-02 06:04:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar vs. Kafka" href=https://buenhyden.github.io/posts/system-design/system-components/application-and-execution-core/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-kafka/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Apache Pulsar vs. RabbitMQ</h2></header><div class=entry-content><p>Apache Pulsar vs. RabbitMQ Apache Pulsar와 RabbitMQ는 메시징 시스템으로서 각각 고유한 강점과 약점을 가지고 있으며, 사용 사례에 따라 적합한 선택이 달라질 수 있다.
기본 개념 및 역사 Apache Pulsar Apache Pulsar는 2016년 Yahoo에서 개발되어 2018년 Apache 소프트웨어 재단의 최상위 프로젝트가 되었다. Pulsar는 처음부터 클라우드 네이티브 환경과 대규모 분산 시스템을 위해 설계되었으며, 높은 처리량과 낮은 지연 시간을 모두 달성하는 메시징 및 스트리밍 플랫폼이다.
RabbitMQ RabbitMQ는 2007년 Rabbit Technologies Ltd.에서 개발되었으며, 현재는 VMware의 일부인 Pivotal Software에서 관리되고 있다. Erlang으로 작성된 RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 구현한 가장 널리 사용되는 오픈 소스 메시지 브로커 중 하나이다. 신뢰성, 유연성, 상호 운용성에 중점을 두고 설계되었다.
...</p></div><footer class=entry-footer><span title='2025-04-02 06:04:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Apache Pulsar vs. RabbitMQ" href=https://buenhyden.github.io/posts/system-design/system-components/application-and-execution-core/event-streaming-platforms/apache-pulsar/apache-pulsar-vs-rabbitmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Basic Authentication</h2></header><div class=entry-content><p>Jwt vs. Basic Authentication JWT(JSON Web Token) 개요 JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 개방형 표준(RFC 7519)이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 HMAC 알고리즘이나 RSA/ECDSA를 사용한 공개/개인 키 쌍으로 서명될 수 있다.
구조 JWT는 세 부분으로 구성되며, 각 부분은 점(.)으로 구분된다:
헤더(Header): 토큰 유형과 사용된 서명 알고리즘을 지정한다. 페이로드(Payload): 클레임(claim)이라고 불리는 엔티티와 추가 데이터를 포함한다. 서명(Signature): 헤더와 페이로드를 인코딩한 값과 비밀 키를 사용하여 생성된 서명이다. 결과적으로 JWT는 다음과 같은 형태를 가진다:
...</p></div><footer class=entry-footer><span title='2025-04-02 02:49:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Basic Authentication" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-basic-authentication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Session-Based Auth vs. Basic Authentication</h2></header><div class=entry-content><p>Session-Based Auth vs. Basic Authentication 기본 인증(Basic Authentication) 기본 인증은 HTTP 프로토콜에 내장된 가장 단순한 인증 방식 중 하나이다. 1996년 RFC 2068에서 처음 소개되었으며, 현재는 RFC 7617에서 정의되고 있다.
작동 방식 클라이언트가 서버에 리소스를 요청한다. 인증이 필요한 리소스인 경우, 서버는 “401 Unauthorized” 응답과 함께 “WWW-Authenticate” 헤더를 전송한다. 클라이언트는 사용자 이름과 비밀번호를 콜론으로 결합한 후 Base64로 인코딩한다. 이 인코딩된 값을 “Authorization: Basic [인코딩된 값]” 형태로 헤더에 포함시켜 요청을 재전송한다. 서버는 이 헤더를 디코딩하여 사용자 이름과 비밀번호를 확인하고, 유효한 경우 리소스에 접근을 허용한다. 특징 구현이 매우 간단하다. 모든 HTTP 요청마다 인증 정보가 전송된다. Base64 인코딩은 암호화가 아니므로 HTTPS 없이는 보안에 취약하다. 사용자 세션 상태를 유지하지 않는다(Stateless) 로그아웃 메커니즘이 없다 세션 기반 인증(Session-Based Authentication) 세션 기반 인증은 서버 측에서 사용자의 상태를 유지하는 인증 방식이다. 1990년대 후반부터 웹 애플리케이션에서 널리 사용되기 시작했다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:49:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Session-Based Auth vs. Basic Authentication" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/session-based-authentication/session-based-auth-vs-basic-authentication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cookie-Based Auth vs. Basic Authentication</h2></header><div class=entry-content><p>Cookie-Based Auth vs. Basic Authentication 쿠키 기반 인증(Cookie-Based Authentication) 작동 원리 쿠키 기반 인증은 HTTP 쿠키를 사용하여 사용자의 인증 상태를 유지하는 방식이다.
일반적인 흐름은 다음과 같다:
사용자가 로그인 폼에 자격 증명(사용자 이름과 비밀번호)을 입력한다. 서버는 자격 증명을 검증하고, 인증에 성공하면 세션 ID를 생성한다. 서버는 이 세션 ID를 쿠키로 클라이언트에게 전송한다 (Set-Cookie 헤더 사용). 브라우저는 해당 도메인에 대한 후속 요청에 이 쿠키를 자동으로 포함시킨다. 서버는 쿠키에 포함된 세션 ID를 검증하여 사용자를 식별한다. 장점 사용자 경험: 사용자가 자격 증명을 한 번만 입력하면 되므로 편리하다. 상태 관리: 서버 측에서 세션 상태를 유지할 수 있어 세밀한 제어가 가능하다. 보안 옵션: HttpOnly, Secure, SameSite 등의 플래그를 통해 보안을 강화할 수 있다. 만료 및 갱신: 세션 타임아웃과 자동 갱신 메커니즘을 구현할 수 있다. 로그아웃: 서버에서 세션을 무효화하여 즉시 로그아웃이 가능하다. 단점 CSRF 취약점: 적절한 보호 조치 없이는 사이트 간 요청 위조(CSRF) 공격에 취약할 수 있다. 확장성 문제: 세션 데이터를 서버에 저장하면 분산 시스템에서 확장성 문제가 발생할 수 있다. 도메인 제한: 쿠키는 기본적으로 단일 도메인에 제한되어 있어 크로스 도메인 요청에 제약이 있다. 모바일 앱 호환성: 일부 모바일 앱 환경에서는 쿠키 관리가 복잡할 수 있다. 기본 인증(Basic Authentication) 작동 원리 기본 인증은 HTTP 프로토콜에 내장된 간단한 인증 메커니즘이다:
...</p></div><footer class=entry-footer><span title='2025-04-02 02:48:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cookie-Based Auth vs. Basic Authentication" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/cookie-based-authentication/cookie-based-auth-vs-basic-authentication/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Cookie-Based Auth</h2></header><div class=entry-content><p>Jwt vs. Cookie-Based Auth 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간 정보를 안전하게 JSON 객체로 전송하기 위한 컴팩트하고 독립적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 HMAC 알고리즘이나 RSA/ECDSA와 같은 공개/개인 키 쌍을 사용하여 서명할 수 있다.
쿠키 기반 인증
쿠키 기반 인증은 사용자가 로그인할 때 서버가 세션 ID를 생성하고, 이 세션 ID를 쿠키에 저장하여 클라이언트에게 전송하는 방식이다. 모든 후속 요청에서 클라이언트는 이 쿠키를 서버에 보내고, 서버는 세션 ID를 확인하여 사용자를 인증한다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:47:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Cookie-Based Auth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-cookie-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>jwt vs. Session-based Auth</h2></header><div class=entry-content><p>Jwt vs. Session-based Auth 기본 개념 JWT(JSON Web Token)
JWT는 당사자 간에 정보를 JSON 객체로 안전하게 전송하기 위한 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있으며, 토큰 자체에 필요한 모든 정보를 포함하고 있다. JWT는 주로 상태 비저장(Stateless) 인증 메커니즘으로 사용된다.
세션 기반 인증
세션 기반 인증은 서버가 사용자의 인증 상태를 유지하는 전통적인 인증 방식이다. 사용자가 로그인하면 서버는 세션 ID를 생성하고 이를 서버 메모리나 데이터베이스에 저장한다. 이 세션 ID는 쿠키를 통해 클라이언트에게 전달되며, 후속 요청에서 클라이언트는 이 쿠키를 전송하여 인증 상태를 유지한다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:46:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to jwt vs. Session-based Auth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-session-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. Session-based Auth</h2></header><div class=entry-content><p>Token Authentication vs. Session-based Auth 세션 기반 인증(Session-based Authentication) 세션 기반 인증은 전통적인 인증 방식으로, 서버가 사용자의 로그인 상태를 세션으로 유지하는 방식이다.
작동 원리 인증 과정: 사용자가 자격 증명(사용자 이름/비밀번호)을 제출한다. 서버는 자격 증명을 검증하고, 유효한 경우 고유한 세션 ID를 생성한다. 서버는 세션 ID와 관련 사용자 정보를 서버 측 저장소(메모리, 데이터베이스, 캐시 등)에 저장한다. 서버는 세션 ID를 클라이언트에게 쿠키로 전송한다. 클라이언트는 이후 요청 시 이 쿠키를 자동으로 포함시킨다. 서버는 쿠키의 세션 ID를 확인하여 사용자를 식별한다. 세션 수명 주기: 세션은 사용자가 로그인할 때 생성된다. 세션은 일정 시간이 지나면 만료된다(서버 설정에 따라 다름). 사용자가 로그아웃하면 세션이 명시적으로 파기된다. 서버는 세션의 유효성과 만료를 관리한다. 주요 특징 상태 유지(Stateful): 서버가 세션 정보를 저장하고 관리한다. 쿠키 기반: 주로 HTTP 쿠키를 통해 세션 ID를 전달한다. 서버 측 저장소: 세션 데이터가 서버에 저장된다. 간단한 구현: 대부분의 웹 프레임워크에서 기본적으로 지원한다. 명시적인 세션 관리: 서버가 세션 생성, 검증, 만료, 파기를 제어한다. 토큰 인증(Token Authentication) 토큰 인증은 클라이언트에게 서명된 토큰을 발급하여 인증하는 방식이다. 가장 널리 사용되는 토큰 형식은 JWT(JSON Web Token)이다.
...</p></div><footer class=entry-footer><span title='2025-04-02 02:45:00 +0000 UTC'>April 2, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. Session-based Auth" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-session-based-auth/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circuit Breaker</h2></header><div class=entry-content><p>Circuit Breaker Circuit Breaker는 분산 시스템에서 장애가 발생하거나 과부하 상태일 때 서비스의 안정성을 유지하기 위한 디자인 패턴이다. 이는 전기 회로의 차단기에서 영감을 받아, 연속적인 실패 시 추가적인 장애 전파를 방지하고 시스템을 보호한다. 특히 마이그레이션 과정에서 서비스 간 의존성이 높은 환경에서 필수적으로 적용된다.
서킷 브레이커 패턴의 기본 개념 서킷 브레이커 패턴은 전기 회로의 차단기에서 영감을 받은 소프트웨어 디자인 패턴으로, 가정용 전기 차단기가 과부하 시 전기를 차단하여 화재를 방지하는 것처럼, 소프트웨어 서킷 브레이커는 장애가 발생한 서비스에 대한 호출을 일시적으로 중단하여 시스템 전체의 안정성을 보호한다.
...</p></div><footer class=entry-footer><span title='2025-04-01 15:17:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;21 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circuit Breaker" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/architecture-styles-and-patterns/architecture-patterns/resilience-patterns/isolation-and-protection/circuit-breaker/circuit-breaker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Backpressure</h2></header><div class=entry-content><p>Backpressure Backpressure는 데이터 처리 시스템에서 수신 측이 송신 측에게 자신의 처리 용량을 알려 데이터 흐름을 제어하는 메커니즘이다. 이는 시스템이 과부하 없이 안정적으로 작동하도록 하며, 특히 분산 시스템이나 대규모 데이터 스트리밍 환경에서 필수적이다.
백프레셔의 기본 개념과 원리 백프레셔는 수신 구성 요소가 송신 구성 요소에게 데이터 처리 능력을 신호로 알려주는 흐름 제어 메커니즘이다. 이름의 유래는 파이프나 유체 시스템에서 역압력(back pressure)이 발생하는 물리적 현상에서 왔다.
핵심 원리 수신측 제어: 데이터를 수신하는 시스템이 처리 가능한 양을 송신 시스템에 알림 피드백 루프: 송신측과 수신측 사이의 지속적인 커뮤니케이션 자기 조절: 시스템이 자체적으로 처리 속도를 조절하는 메커니즘 물리적 아날로그 물리적 시스템에서의 백프레셔 개념을 이해하면 소프트웨어에서의 적용이 더 명확해진다.
...</p></div><footer class=entry-footer><span title='2025-04-01 15:16:00 +0000 UTC'>April 1, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Backpressure" href=https://buenhyden.github.io/posts/system-design/asynchronous-processing/asynchronism/backpressure/backpressure/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/15/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/17/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>