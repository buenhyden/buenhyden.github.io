<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Thread</h2></header><div class=entry-content><p>스레드의 기본 개념과 프로세스와의 차이점 설명. 멀티스레딩의 장점과 주요 구현 방식(POSIX Threads, Windows Threads). 유사 기술: 멀티프로세싱, 비동기 처리. Thread Thread는 프로그램 실행의 기본 단위로, 프로세스 내에서 실행되는 독립적인 작업 흐름을 의미한다.
하나의 프로세스는 여러 개의 Thread를 가질 수 있으며, 이들은 프로세스의 자원을 공유한다.
Source: https://blog.devgenius.io/program-process-and-thread-explained-in-one-minute-6016e4fdf4de
Thread의 구성 요소 Thread는 다음과 같은 구성 요소를 가진다:
프로그램 카운터 레지스터 집합 스택 공간 Thread ID
이러한 요소들은 각 Thread의 독립적인 실행을 가능하게 한다. Thread의 특징 경량성: Thread는 프로세스에 비해 생성과 관리가 더 빠르고 효율적이다. 자원 공유: 같은 프로세스 내의 Thread들은 코드, 데이터, 파일 등의 자원을 공유한다. 병렬 실행: 멀티코어 시스템에서는 여러 Thread가 실제로 동시에 실행될 수 있다. 기능과 역할 기능 역할 장점 병렬 처리 - 동시에 여러 작업 수행
CPU 활용도 증가 - 성능 향상
- 응답성 개선 자원 공유 - 프로세스 자원 공유
- 효율적인 메모리 사용 - 메모리 절약
- 통신 비용 감소 비동기 처리 - 독립적인 작업 수행
- 이벤트 처리 - 응답성 향상
UI 처리 효율화 Thread의 종류 Thread는 크게 두 가지로 나눌 수 있다:
...</p></div><footer class=entry-footer><span title='2024-10-04 23:32:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Thread" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/threads/threads/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multithreading</h2></header><div class=entry-content><p>멀티 쓰레딩 (Multithreading) Multithreading은 운영 체제에서 프로그램이 여러 작업을 동시에 수행할 수 있게 해주는 기능이다. 즉, 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 의미하며, 각 스레드는 프로세스의 자원을 공유하면서도 독립적인 실행 경로를 가진다.
이는 단일 프로세스 내에서 여러 실행 흐름(스레드)을 생성하고 관리하며, 현대 컴퓨터 시스템의 성능과 효율성을 크게 향상시킨다.
Source: https://www.geeksforgeeks.org/multithreading-in-operating-system/
각 스레드는 자신만의 프로그램 카운터, 레지스터 집합, 스택을 가지고 있다. 하지만 같은 프로세스 내의 스레드들은 코드, 데이터 섹션, 파일과 같은 자원을 공유한다. 이는 프로세스보다 스레드의 생성과 컨텍스트 스위칭이 더 가벼운 이유가 된다.
...</p></div><footer class=entry-footer><span title='2024-10-04 14:33:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multithreading" href=https://buenhyden.github.io/posts/computer-science-fundamentals/operating-systems/process-management/thread-management/multithreading/__index/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mutex</h2></header><div class=entry-content><p>Mutex Mutex(Mutual Exclusion) 는 공유 자원에 대한 접근을 동기화하는 객체.
한 번에 하나의 스레드만이 Mutex 를 소유할 수 있으며, 소유권 개념이 있어 Mutex 를 획득한 스레드만이 이를 해제할 수 있다.
Source: https://www.geeksforgeeks.org/std-mutex-in-cpp/
주요 특징 두 가지 상태 (잠김/열림) 를 가집니다. 한 번에 하나의 스레드만 소유할 수 있습니다. 소유한 스레드만이 잠금을 해제할 수 있습니다. Mutex 의 종류 일반 Mutex (Normal Mutex) 가장 기본적인 형태의 Mutex.
단순한 상호 배제 기능을 제공하며, 재진입이 불가능하다.
가장 빠른 성능을 제공하지만 우선순위 상속과 같은 고급 기능은 지원하지 않는다.
...</p></div><footer class=entry-footer><span title='2024-10-04 11:00:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;51 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mutex" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/mutex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>조건 변수 (Condition Variable)</h2></header><div class=entry-content><p>조건 변수 (Condition Variable) 조건 변수 (Condition Variables) 는 프로세스 동기화에서 중요한 역할을 하는 동기화 기본 요소로, 스레드가 특정 조건이 충족될 때까지 대기하도록 하는 메커니즘을 제공한다.
스레드가 특정 조건이 만족될 때까지 대기하고, 조건이 충족되면 다른 스레드가 대기 중인 스레드를 깨우는 데 사용된다.
뮤텍스와의 연관 조건 변수는 일반적으로 뮤텍스와 함께 사용된다.
뮤텍스는 조건을 원자적으로 검사하고 변경할 수 있도록 보장한다.
주요 연산 wait(): 스레드가 조건이 충족될 때까지 대기하도록 한다. signal()/notify_one(): 대기 중인 단일 스레드를 깨운다. broadcast()/notify_all(): 해당 조건 변수에서 대기 중인 모든 스레드를 깨운다. 사용 패턴 조건을 보호하는 뮤텍스를 획득한다. 조건을 테스트한다. 조건이 거짓이면 wait() 를 호출하여 대기한다. 조건이 참이면 작업을 수행하고 뮤텍스를 해제한다. 가짜 깨우기 (Spurious Wakeup) 가짜 깨우기는 조건 변수 (Condition Variable) 를 사용할 때 발생할 수 있는 현상이다.
스레드가 실제로 signal 이나 broadcast 를 받지 않았는데도 wait 상태에서 깨어나는 현상을 말한다.
...</p></div><footer class=entry-footer><span title='2024-10-04 10:54:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조건 변수 (Condition Variable)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/condition-synchronization/condition-variable/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>원자적 연산 (Atomic Operation)</h2></header><div class=entry-content><p>원자적 연산 (Atomic Operation) 원자적 연산(Atomic Operation)은 멀티스레딩 환경에서 데이터의 일관성과 안전성을 보장하기 위한 중요한 개념으로, 상호 배제(Mutual Exclusion)를 구현하는 데 중요한 역할을 한다.
원자적 연산이란, 더 이상 쪼개질 수 없는 최소 단위의 연산을 의미하는데 중단되거나 간섭받지 않고 완전히 실행되는 연산을 말한다.
이는 마치 물리학에서 원자가 더 이상 쪼개질 수 없는 가장 작은 단위인 것처럼, 컴퓨터 과학에서도 더 이상 분할할 수 없는 가장 작은 실행 단위를 의미한다.
주요 특징 불가분성: 원자적 연산은 중간에 중단되거나 다른 프로세스에 의해 간섭받지 않는다. 일관성: 연산이 성공적으로 완료되거나 아예 실행되지 않는다. 가시성: 다른 스레드에서 원자적 연산의 결과를 즉시 확인할 수 있다. 원자적 연산의 중요성 데이터 무결성 보장: 여러 스레드가 동시에 같은 데이터에 접근할 때 발생할 수 있는 경쟁 조건(Race Condition)을 방지한다. 동기화 구현: 원자적 연산은 복잡한 동기화 메커니즘의 기본 구성 요소이다. 성능 향상: 락(Lock)과 같은 고수준의 동기화 메커니즘보다 더 가볍고 빠르다. 원자적 연산의 예시 읽기-수정-쓰기(Read-Modify-Write) 연산:
...</p></div><footer class=entry-footer><span title='2024-10-04 10:48:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;33 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 원자적 연산 (Atomic Operation)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/atomic-operation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동시성 (Concurrency)</h2></header><div class=entry-content><p>동시성 (Concurrency) 동시성 (Concurrency)은 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 매우 빠르게 작업 간 전환을 하면서 처리하는 방식이다. 예를 들어, 하나의 CPU 코어에서 여러 작업을 빠르게 번갈아가며 실행하여 마치 동시에 여러 작업이 처리되는 것처럼 보이게 만든다.
Source: https://dynamogeeks.com/blog/concurrency-vs-parallelism-a-simplified-explanation
동시성의 특징 논리적 개념: 동시성은 물리적으로 동시에 실행되는 것이 아닌, 논리적으로 동시에 실행되는 것처럼 보이게 하는 개념이다. 자원 효율성: CPU가 유휴 상태로 있지 않고 계속해서 작업을 처리하므로 시스템 자원을 효율적으로 사용할 수 있다. 응답성 향상: 여러 작업을 번갈아가며 처리하므로 전체적인 시스템의 응답성이 향상된다. 동시성의 구현 방법 멀티스레딩: 하나의 프로세스 내에서 여러 스레드를 사용하여 작업을 동시에 처리한다. 비동기 프로그래밍: 작업을 비동기적으로 처리하여 한 작업이 완료되기를 기다리지 않고 다른 작업을 수행할 수 있게 한다. 동시성의 장점 성능 향상: 여러 작업을 동시에 처리함으로써 전체적인 처리 속도를 높일 수 있다. 자원 활용 최적화: CPU와 같은 시스템 자원을 최대한 활용할 수 있다. 사용자 경험 개선: 특히 UI 애플리케이션에서 동시성을 활용하면 사용자 반응성을 크게 향상시킬 수 있다. 동시성의 주의점 복잡성 증가: 동시성 프로그래밍은 일반적인 순차적 프로그래밍보다 복잡할 수 있다. 동기화 문제: 여러 작업이 공유 자원에 동시에 접근할 때 발생할 수 있는 문제를 주의해야 한다. 디버깅의 어려움: 동시에 실행되는 작업들 간의 상호작용으로 인해 버그를 찾고 수정하기가 어려울 수 있다. 동시성의 실제 예시 웹 브라우저: 여러 탭을 동시에 열어 각각 다른 웹페이지를 로드하면서 사용자 입력을 받는 것은 동시성의 좋은 예이다. 데이터베이스 시스템: 여러 사용자의 쿼리를 동시에 처리하는 데이터베이스 시스템도 동시성을 활용한다. 동시성은 현대 프로그래밍에서 매우 중요한 개념으로, 시스템의 성능을 향상시키고 사용자 경험을 개선하는 데 크게 기여한다.
...</p></div><footer class=entry-footer><span title='2024-10-04 06:51:00 +0000 UTC'>October 4, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 (Concurrency)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/concurrency-control/concurrency/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Monitor</h2></header><div class=entry-content><p>Monitor 프로세스 동기화에서 **모니터(Monitor)**는 공유 자원에 대한 안전한 접근을 보장하기 위한 상위 수준의 동기화 도구이다.
모니터는 공유 데이터와 해당 데이터를 조작하는 연산을 하나의 모듈로 캡슐화하여, 다중 스레드 환경에서의 경쟁 조건(Race Condition)을 방지한다.
모니터는 고수준의 동기화 추상화로, 복잡한 뮤텍스/세마포어 관리 없이 안전한 병행 프로그래밍을 가능하게 한다.
현대 언어에서는 모니터 패턴이 내장되어 있어(synchronized, lock), 데드락과 경쟁 조건을 효과적으로 방지한다.
다만 저수준 시스템 프로그래밍에서는 뮤텍스나 세마포어가 더 유연할 수 있다.
정의 모니터는 **뮤텍스(Mutex)**와 **조건 변수(Condition Variable)**를 결합한 추상화된 동기화 메커니즘이다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:54:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Monitor" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/monitor/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Semaphore</h2></header><div class=entry-content><p>Semaphore 멀티스레딩 환경에서 공유 자원에 대한 접근을 제어하는 동기화 도구.
세마포어는 네덜란드의 컴퓨터 과학자 Edsger Dijkstra 가 1965 년에 소개한 개념으로, 여러 프로세스나 스레드가 공유 자원에 동시에 접근하는 것을 제어하는 변수 또는 추상 데이터 타입.
세마포어는 간단한 정수 값을 사용하여 자원의 가용성을 나타낸다.
주요 특징 동기화 메커니즘: 세마포어는 여러 프로세스나 스레드 간의 실행 순서와 타이밍을 제어한다. 자원 관리: 한정된 수의 자원 (예: 프린터, 데이터베이스 연결) 에 대한 접근을 제어한다. 원자적 연산: 세마포어 조작은 중단되지 않는 단일 연산으로 수행된다. 대기 큐: 자원을 기다리는 프로세스들을 대기 큐에 저장한다. 세마포어의 종류 이진 세마포어 (Binary Semaphore):
...</p></div><footer class=entry-footer><span title='2024-10-03 10:54:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;50 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Semaphore" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/semaphore/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데커 알고리즘 (Dekker's Algorithm)</h2></header><div class=entry-content><p>데커 알고리즘 (Dekker’s Algorithm) 데커 알고리즘(Dekker’s Algorithm)은 두 프로세스 간 **상호 배제(Mutual Exclusion)**를 보장하기 위해 1965년 네덜란드의 수학자 Theodorus Dekker가 개발한 최초의 소프트웨어 상호 배제(mutual exclusion) 알고리즘이다.
이 알고리즘은 두 개의 프로세스가 공유 자원에 동시에 접근하는 것을 방지하여 경쟁 상태(race condition)를 해결하는 방법을 제시한다.
공유 자원에 대한 안전한 접근을 위해 **플래그(flag)**와 턴(turn) 변수를 활용하며, 하드웨어적 명령어 없이 소프트웨어만으로 구현 가능하다.
데커 알고리즘은 상호 배제 문제 해결의 역사적 중요성을 가지지만, 현대 시스템에서는 **세마포어(Semaphore)**나 **뮤텍스(Mutex)**와 같은 더 효율적인 동기화 기법이 주로 사용된다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데커 알고리즘 (Dekker's Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/dekkers-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)</h2></header><div class=entry-content><p>램포트의 빵집 알고리즘 (Lamport’s Bakery Algorithm) 램포트의 빵집 알고리즘(Lamport’s Bakery Algorithm)은 N개 프로세스의 상호 배제(Mutual Exclusion) 문제를 해결하기 위한 소프트웨어 기반 알고리즘이다. 1974년 레슬리 램포트(Leslie Lamport)가 제안했으며, 빵집에서 번호표를 받아 순서대로 서비스받는 방식에서 아이디어를 얻었다.
램포트의 빵집 알고리즘은 병행 프로그래밍의 이론적 토대를 제공했지만, 현대 시스템에서는 주로 하드웨어 지원 동기화 기법이 사용된다. 단, 분산 시스템이나 임베디드 환경에서는 여전히 연구 및 적용 사례가 존재한다.
핵심 원리 번호표 시스템 각 프로세스는 임계 영역 진입 전 고유한 번호표를 받는다. 번호표는 단조 증가(monotonically increasing) 방식으로 발급되며, 동시 접근 시 프로세스 ID로 우선순위 결정한다. 단조 증가(monotonically increasing)란 함수나 수열이 항상 증가하거나 일정한 값을 유지하는 성질을 의미한다. 즉, 감소하는 구간 없이 유지되거나 증가하는 경우를 말한다.
...</p></div><footer class=entry-footer><span title='2024-10-03 10:47:00 +0000 UTC'>October 3, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 램포트의 빵집 알고리즘 (Lamport's Bakery Algorithm)" href=https://buenhyden.github.io/posts/computer-science-fundamentals/concurrency-and-parallelism/synchronization/mutual-exclusion/lamports-bakery-algorithm/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/52/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/54/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>