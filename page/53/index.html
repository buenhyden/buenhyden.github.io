<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Pipe-Filter Pattern</h2></header><div class=entry-content><p>Pipe-Filter Pattern 파이프-필터 패턴(Pipe-Filter Pattern)은 데이터 스트림을 처리하는 시스템에서 사용되는 소프트웨어 아키텍처 패턴.
이 패턴은 복잡한 처리 과정을 독립적인 단계로 나누어 모듈화하고, 이들을 순차적으로 연결하여 데이터를 처리한다.
주요 구성 요소 필터(Filter):
단일 작업을 수행하는 처리 컴포넌트입니다 입력을 받아 처리하고 출력을 생성합니다 독립적으로 동작하며 다른 필터에 대해 알지 못합니다 재사용이 가능하고 조합할 수 있어야 합니다 파이프(Pipe):
필터 간의 데이터 전달을 담당합니다 데이터 버퍼링과 동기화를 처리합니다 필터들을 느슨하게 결합시킵니다 대개 큐나 스트림으로 구현됩니다 파이프라인(Pipeline):
...</p></div><footer class=entry-footer><span title='2024-09-26 08:28:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;829 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Pipe-Filter Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/pipe-filter-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Producer-Consumer Pattern</h2></header><div class=entry-content><p>Producer-Consumer Pattern Producer-Consumer Pattern은 소프트웨어 아키텍처에서 중요한 디자인 패턴 중 하나로, 주로 동시성 프로그래밍과 분산 시스템에서 사용된다.
이 패턴은 데이터를 생성하는 프로듀서(Producer)와 데이터를 소비하는 컨슈머(Consumer) 사이의 작업을 분리하여 효율적인 데이터 처리를 가능하게 한다.
https://jenkov.com/tutorials/java-concurrency/producer-consumer.html
주요 구성 요소 프로듀서 (Producer): 데이터나 작업을 생성하는 엔티티. 컨슈머 (Consumer): 프로듀서가 생성한 데이터나 작업을 처리하는 엔티티. 버퍼 (Buffer): 프로듀서와 컨슈머 사이에서 데이터를 임시 저장하는 공유 자원. 주로 큐(Queue)의 형태로 구현된다. 작동 방식 프로듀서는 데이터나 작업을 생성하여 버퍼에 추가한다. 컨슈머는 버퍼에서 데이터나 작업을 가져와 처리한다. 버퍼는 프로듀서와 컨슈머 사이의 중간 저장소 역할을 하며, 동기화를 관리한다. 주요 특징 비동기 처리: 프로듀서와 컨슈머가 독립적으로 작동하여 비동기 처리가 가능하다. 버퍼링: 버퍼를 통해 생산과 소비 속도의 차이를 조절할 수 있다. 병렬 처리: 여러 프로듀서와 컨슈머가 동시에 작업할 수 있어 병렬 처리가 가능하다. 느슨한 결합: 프로듀서와 컨슈머는 서로에 대해 직접적인 의존성이 없다. 장점 처리량 향상: 생산과 소비를 병렬로 수행하여 전체 시스템의 처리량을 높일 수 있다. 유연성: 프로듀서와 컨슈머를 독립적으로 확장할 수 있다. 부하 분산: 버퍼를 통해 작업 부하를 균등하게 분산시킬 수 있다. 피크 부하 관리: 일시적인 부하 증가를 버퍼를 통해 완화할 수 있다. 단점 복잡성: 동기화와 버퍼 관리로 인해 시스템 복잡도가 증가할 수 있다. 메모리 사용: 버퍼가 큰 경우 메모리 사용량이 증가할 수 있다. 지연 가능성: 버퍼가 가득 차거나 비어있을 때 지연이 발생할 수 있다. 적용 사례 작업 큐 시스템: 백그라운드 작업 처리, 이메일 발송 등의 비동기 작업 관리 로그 처리 시스템: 대량의 로그 데이터를 효율적으로 수집하고 분석 스트리밍 데이터 처리: 실시간 데이터 스트림의 처리 및 분석 멀티스레드 애플리케이션: 스레드 간 작업 분배 및 동기화 구현 시 고려사항 동기화 메커니즘: 버퍼 접근 시 적절한 동기화 방법(예: 세마포어, 뮤텍스) 사용 버퍼 크기 조정: 시스템 요구사항에 맞는 적절한 버퍼 크기 설정 예외 처리: 버퍼 오버플로우, 언더플로우 등의 예외 상황 관리 종료 조건: 프로듀서와 컨슈머의 적절한 종료 시점 및 방법 정의 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-26 01:12:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;290 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Producer-Consumer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/producer-consumer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Component-Based Architecture</h2></header><div class=entry-content><p>Component-Based Architecture 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 11:48:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Component-Based Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/component-based-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-Driven Architecture</h2></header><div class=entry-content><p>Event-Driven Architecture Event-Driven Architecture (EDA)는 현대 소프트웨어 아키텍처 패턴 중 하나로, 시스템 내에서 발생하는 이벤트를 중심으로 동작하는 설계 방식이다.
이 아키텍처는 분산 시스템, 마이크로서비스, 실시간 애플리케이션 등에서 널리 사용되며, 시스템의 유연성, 확장성, 그리고 반응성을 향상시키는 데 중요한 역할을 한다.
https://medium.com/@seetharamugn/the-complete-guide-to-event-driven-architecture-b25226594227
주요 구성 요소 이벤트 생성자 (Event Producer)
이벤트를 감지하고 생성하는 컴포넌트 예: 사용자 액션, 센서 데이터, 시스템 상태 변화 등 이벤트 채널 (Event Channel)
이벤트를 전달하는 메시징 인프라 예: Apache Kafka, RabbitMQ, AWS SNS 등 이벤트 처리자 (Event Consumer)
...</p></div><footer class=entry-footer><span title='2024-09-25 11:38:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;542 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-Driven Architecture" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-driven-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Model-View-ViewModel-Pattern</h2></header><div class=entry-content><p>Model-View-ViewModel-Pattern 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 11:26:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;4 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Model-View-ViewModel-Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/model-view-viewmodel-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Sourcing Pattern</h2></header><div class=entry-content><p>Event Sourcing Pattern Event Sourcing Pattern은 데이터 처리와 저장에 대한 접근 방식을 정의하는 아키텍처 패턴으로, 시스템의 상태 변화를 일련의 이벤트로 기록하고 저장하는 방식을 채택한다.
https://www.geeksforgeeks.org/event-sourcing-pattern/
주요 개념 이벤트 기반 데이터 저장
Event Sourcing은 데이터의 최종 상태만을 저장하는 대신, 모든 변경 사항을 이벤트로 기록한다.
예를 들어, 주문 시스템에서 “주문 생성”, “아이템 추가”, “주문 완료” 등의 이벤트가 순차적으로 저장된다.
이벤트 스토어
모든 이벤트는 추가 전용(append-only) 로그인 이벤트 스토어에 순차적으로 저장된다.
이 스토어는 시스템의 권위 있는 데이터 소스 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-09-25 11:17:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;697 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Sourcing Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/event-sourcing-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Monolithic Pattern</h2></header><div class=entry-content><p>Monolithic Pattern 모놀리식 패턴(Monolithic Pattern)은 소프트웨어 아키텍처에서 가장 전통적이고 널리 사용되는 패턴 중 하나.
이 패턴은 애플리케이션의 모든 구성 요소가 단일 코드베이스와 단일 실행 단위로 통합된 형태를 취한다.
주요 특징 단일 코드베이스: 모든 기능과 모듈이 하나의 코드베이스에 통합되어 있습니다. 단일 배포 단위: 전체 애플리케이션이 하나의 단위로 빌드되고 배포됩니다. 공유 데이터베이스: 일반적으로 하나의 중앙 집중식 데이터베이스를 사용합니다. 통합된 구성 요소: UI, 비즈니스 로직, 데이터 접근 계층 등이 모두 하나의 애플리케이션 내에 포함됩니다. 주요 구성 요소 ![Monolithic Architecture](1_HuM5OTnmQNUC2oIwiOn22A.webp “https://medium.com/design-microservices-architecture-with-patterns/monolithic-to-microservices-architecture-with-patterns-best-practices-a768272797b2_
...</p></div><footer class=entry-footer><span title='2024-09-25 11:14:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1254 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Monolithic Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/monolithic-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Queues and Streams</h2></header><div class=entry-content><p>Message Queues and Streams 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 09:01:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;7 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Queues and Streams" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/message-queues-and-streams/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CQRS 패턴 (Command Query Responsibility Segregation)</h2></header><div class=entry-content><p>CQRS 패턴 (Command Query Responsibility Segregation) 애플리케이션의 명령(Command)과 쿼리(Query)의 책임을 분리하는 소프트웨어 아키텍처 패턴
이 패턴은 데이터를 변경하는 작업과 데이터를 읽는 작업을 별도의 모델로 분리하여 처리한다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 from dataclasses import dataclass from datetime import datetime from typing import List, Optional # 도메인 모델 @dataclass class Product: id: str name: str price: float stock: int created_at: datetime updated_at: datetime # Command 모델 (쓰기 작업) @dataclass class CreateProductCommand: name: str price: float stock: int @dataclass class UpdateProductStockCommand: product_id: str stock: int # Query 모델 (읽기 작업) @dataclass class ProductDetailsQuery: product_id: str @dataclass class ProductListQuery: page: int page_size: int # Command 핸들러 (쓰기 작업 처리) class ProductCommandHandler: def __init__(self, command_db): self.command_db = command_db def handle_create_product(self, command: CreateProductCommand) -> str: product = Product( id=generate_id(), name=command.name, price=command.price, stock=command.stock, created_at=datetime.now(), updated_at=datetime.now() ) self.command_db.save(product) # 이벤트 발행 (읽기 데이터베이스 동기화를 위함) publish_event("ProductCreated", product) return product.id def handle_update_stock(self, command: UpdateProductStockCommand): product = self.command_db.get_by_id(command.product_id) if not product: raise ValueError("Product not found") product.stock = command.stock product.updated_at = datetime.now() self.command_db.update(product) publish_event("ProductStockUpdated", product) # Query 핸들러 (읽기 작업 처리) class ProductQueryHandler: def __init__(self, query_db): self.query_db = query_db def handle_product_details(self, query: ProductDetailsQuery) -> Optional[Product]: return self.query_db.get_by_id(query.product_id) def handle_product_list(self, query: ProductListQuery) -> List[Product]: return self.query_db.get_page(query.page, query.page_size) # API 레이어 class ProductAPI: def __init__(self, command_handler: ProductCommandHandler, query_handler: ProductQueryHandler): self.command_handler = command_handler self.query_handler = query_handler def create_product(self, name: str, price: float, stock: int) -> str: command = CreateProductCommand(name=name, price=price, stock=stock) return self.command_handler.handle_create_product(command) def update_stock(self, product_id: str, stock: int): command = UpdateProductStockCommand(product_id=product_id, stock=stock) self.command_handler.handle_update_stock(command) def get_product(self, product_id: str) -> Optional[Product]: query = ProductDetailsQuery(product_id=product_id) return self.query_handler.handle_product_details(query) def list_products(self, page: int, page_size: int) -> List[Product]: query = ProductListQuery(page=page, page_size=page_size) return self.query_handler.handle_product_list(query) 주요 구성 요소 https://junuuu.tistory.com/891
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;677 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CQRS 패턴 (Command Query Responsibility Segregation)" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/cqrs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Domain-Driven Design</h2></header><div class=entry-content><p>Domain-Driven Design 복잡한 소프트웨어 시스템을 개발하기 위한 접근 방식으로, 비즈니스 도메인을 중심으로 소프트웨어를 설계하고 개발하는 방법론.
이 패턴은 Eric Evans가 2003년에 출간한 책 “Domain-Driven Design: Tackling Complexity in the Heart of Software"에서 처음 소개되었다.
DDD의 핵심 개념 유비쿼터스 언어 (Ubiquitous Language)
DDD에서는 개발자와 도메인 전문가 사이의 의사소통을 위해 공통의 언어를 사용하는 것을 강조한다.
이 언어는 코드, 문서, 대화 등 모든 곳에서 일관되게 사용되어야 한다.
이를 통해 도메인 지식을 정확히 소프트웨어에 반영할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;718 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Domain-Driven Design" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-architecture-patterns/domain-driven-design/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/52/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/54/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>