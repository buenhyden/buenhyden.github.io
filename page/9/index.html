<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>단위 테스트 (Unit Test)</h2></header><div class=entry-content><p>단위 테스트 (Unit Test) 단위 테스트는 소프트웨어의 가장 작은 단위인 개별 모듈이나 컴포넌트를 독립적으로 테스트하는 과정이다.
이는 마치 자동차를 조립하기 전에 각 부품이 제대로 작동하는지 확인하는 것과 비슷하다.
특징과 목적 단위 테스트의 주요 특징과 목적은 다음과 같다:
독립성: 각 테스트는 다른 테스트와 독립적으로 실행된다. 자동화: 테스트를 자동으로 실행할 수 있어 빠르고 반복적인 테스트가 가능하다. 빠른 피드백: 개발자가 코드를 변경할 때마다 즉시 테스트를 실행하여 문제를 빠르게 발견할 수 있다. 버그 조기 발견: 개발 초기 단계에서 버그를 찾아 수정 비용을 줄일 수 있다. 테스트 범위 단위 테스트는 주로 다음과 같은 요소를 검증한다다:
...</p></div><footer class=entry-footer><span title='2024-11-13 02:13:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;862 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 단위 테스트 (Unit Test)" href=https://buenhyden.github.io/posts/qa/qc/test/fundamental-testing/unit-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오류 예측 검사(Error Guessing)</h2></header><div class=entry-content><p>오류 예측 검사(Error Guessing) 오류 예측 검사(Error Guessing)는 블랙박스 테스트 기법 중 하나로, 테스터의 경험, 지식, 직관을 활용하여 소프트웨어에서 발생할 가능성이 높은 오류를 예측하고 이를 기반으로 테스트 케이스를 설계하는 방법.
이 기법은 다른 테스트 기법으로는 발견하기 어려운 결함을 보완적으로 찾아내는 데 유용하다.
오류 예측 검사의 특징 경험 기반 접근:
과거의 경험, 유사한 시스템에서 발견된 오류 유형, 그리고 직관을 활용하여 잠재적 오류를 예측한다. 특정한 규칙이나 구조에 의존하지 않고 테스터의 전문성과 감각에 의존한다. 보충적 검사 기법:
...</p></div><footer class=entry-footer><span title='2024-11-13 00:13:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;448 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오류 예측 검사(Error Guessing)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-testing/experience-based-test/error-guessing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Path Coverage</h2></header><div class=entry-content><p>경로 커버리지(Path Coverage) 경로 커버리지는 프로그램의 제어 흐름 그래프(Control Flow Graph, CFG)에서 모든 가능한 실행 경로를 테스트하는 구조적 테스팅 기법이다.
이는 프로그램의 입력과 출력 값보다는 내부 제어 흐름에 초점을 맞춘다.
먼저 경로 커버리지의 기본 개념을 간단한 예제를 통해 이해해보자:
1 2 3 4 5 6 7 8 9 10 11 def calculate_discount(price, is_member, is_sale_period): if is_member: if is_sale_period: return price * 0.8 # 20% 할인 else: return price * 0.9 # 10% 할인 else: if is_sale_period: return price * 0.95 # 5% 할인 else: return price # 할인 없음 이 함수에는 다음과 같은 가능한 실행 경로들이 있다:
...</p></div><footer class=entry-footer><span title='2024-11-12 15:01:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;825 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Path Coverage" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/path-coverage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>조건 커버리지 (Condition Coverage)</h2></header><div class=entry-content><p>조건 커버리지 (Condition Coverage) 조건 커버리지는 결정 포인트 내의 각 개별 조건식이 참(true)과 거짓(false)의 결과를 최소한 한 번씩 갖도록 테스트하는 기법이다.
이는 전체 조건식의 결과와는 독립적으로 각 개별 조건의 결과에 초점을 맞춘다.
주요 특징 개별 조건 중심: 전체 조건식이 아닌 각 개별 조건식의 결과를 검증한다. 최소 요구사항: 각 조건이 최소한 한 번씩 참과 거짓의 결과를 가져야 한다. 세분화된 테스트: 복잡한 조건문의 각 부분을 개별적으로 테스트할 수 있다. 장점 조건의 독립적 평가: 각 조건을 독립적으로 평가하여 더 세밀한 테스트가 가능하다. 제어 흐름에 대한 높은 민감도: 프로그램의 제어 흐름을 더 정확하게 테스트할 수 있다. 결정 커버리지보다 강력: 더 많은 테스트 케이스를 요구하므로 더 철저한 테스트가 가능하다. 단점 전체 조건식 결과 보장 부족: 개별 조건의 참/거짓만을 테스트하므로 전체 조건식의 모든 결과를 보장하지 않을 수 있다. 테스트 케이스 증가: 조건의 수가 많아질수록 필요한 테스트 케이스의 수가 증가한다.
따라서 조건 커버리지는 다른 테스트 커버리지 지표들(구문 커버리지, 분기 커버리지 등)과 함께 사용되어야 하며, 이를 통해 더 완성도 높은 테스트를 수행할 수 있다. 조건 커버리지를 계산하는 방법 1 2 3 4 5 6 public boolean isEligibleForDiscount(int age, boolean isMember, int purchaseAmount) { if (age >= 60 && isMember || purchaseAmount > 1000) { return true; } return false; } 이 코드에는 세 가지 개별 조건이 있다:
...</p></div><footer class=entry-footer><span title='2024-11-12 15:01:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;766 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 조건 커버리지 (Condition Coverage)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/condition-coverage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decision Coverage</h2></header><div class=entry-content><p>결정 커버리지 (Decision Coverage) 결정 커버리지는 프로그램의 모든 결정 포인트(조건문)에서 전체 조건식이 최소한 한 번씩 참(True)과 거짓(False)의 결과를 가지도록 테스트하는 방법이다.
이는 브랜치 커버리지(Branch Coverage)라고도 불린다.
간단한 예제:
1 2 3 4 5 6 7 8 9 10 11 public class LoanApproval { public boolean approveLoan(double income, double creditScore) { if (income >= 50000) { if (creditScore >= 700) { return true; } return false; } return false; } } 이 코드의 결정 커버리지를 100% 달성하기 위해서는 다음과 같은 테스트 케이스가 필요하다:
...</p></div><footer class=entry-footer><span title='2024-11-12 15:00:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;546 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decision Coverage" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/decision-coverage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Statement Coverage</h2></header><div class=entry-content><p>구문 커버리지 (Statement Coverage) 구문 커버리지는 프로그램을 구성하는 모든 문장들이 최소한 한 번은 실행될 수 있는 입력 데이터를 테스트 데이터로 선정하는 기준이다.
또한 라인 커버리지(Line Coverage)라고도 불린다.
먼저 간단한 예제를 통해 구문 커버리지의 이해:
1 2 3 4 5 6 7 8 9 10 11 12 13 def calculate_grade(score): # 구문 1 if score >= 90: # 구문 2 grade = 'A' elif score >= 80: # 구문 3 grade = 'B' else: # 구문 4 grade = 'C' # 구문 5 return grade 이 함수의 모든 구문을 실행하기 위해서는 다음과 같은 테스트 케이스가 필요하다:
...</p></div><footer class=entry-footer><span title='2024-11-12 15:00:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;682 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Statement Coverage" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/statement-coverage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>회귀 테스트 (Regression Test)</h2></header><div class=entry-content><p>회귀 테스트 (Regression Test) 회귀 테스트는 소프트웨어의 변경이나 수정 후에 기존 기능이 여전히 올바르게 작동하는지 확인하는 테스트이다.
온라인 쇼핑몰의 회귀 테스트 예시:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import unittest from shopping_mall import ShoppingCart, Product, User class ShoppingMallRegressionTest(unittest.TestCase): def setUp(self): """테스트 준비: 필요한 객체들을 초기화합니다.""" self.cart = ShoppingCart() self.user = User("test_user") self.product = Product("노트북", 1000000) def test_existing_cart_functionality(self): """장바구니 기능 회귀 테스트 장바구니 할인 기능이 추가된 후에도 기존 장바구니 기능들이 정상적으로 작동하는지 확인합니다. """ # 상품 추가 테스트 self.cart.add_item(self.product) self.assertEqual(len(self.cart.items), 1) # 상품 제거 테스트 self.cart.remove_item(self.product) self.assertEqual(len(self.cart.items), 0) # 금액 계산 테스트 self.cart.add_item(self.product, quantity=2) self.assertEqual(self.cart.total_price, 2000000) def test_new_discount_feature(self): """새로운 할인 기능 테스트 새로 추가된 할인 기능이 기존 가격 계산 로직을 망가뜨리지 않는지 확인합니다. """ # 기본 가격 계산 self.cart.add_item(self.product) base_price = self.cart.total_price # 할인 적용 self.cart.apply_discount(10) # 10% 할인 # 할인된 가격 확인 expected_price = base_price * 0.9 self.assertEqual(self.cart.total_price, expected_price) # 할인 제거 후 원래 가격으로 복원되는지 확인 self.cart.remove_discount() self.assertEqual(self.cart.total_price, base_price) 특징과 목적 회귀 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-12 14:28:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;565 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 회귀 테스트 (Regression Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/regression-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>사용성 테스트 (Usability Test)</h2></header><div class=entry-content><p>사용성 테스트 (Usability Test) 사용성 테스트는 제품이나 서비스를 실제 사용자가 사용해보면서 그 과정을 관찰하고 분석하는 테스트 방법이다.
이는 사용자가 제품을 얼마나 쉽고 효율적으로 사용할 수 있는지를 평가한다.
모바일 앱의 사용성 테스트 시나리오:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def run_shopping_app_test(): """쇼핑앱 사용성 테스트 시나리오""" test = UsabilityTest() # 테스트 작업 정의 test.add_task( "상품검색", "원하는 상품을 검색하고 찾기", "3번 이내의 클릭으로 원하는 상품 도달" ) test.add_task( "장바구니추가", "상품을 장바구니에 추가하기", "오류 없이 상품을 장바구니에 추가" ) test.add_task( "결제진행", "장바구니에서 결제 완료까지", "5분 이내 결제 완료" ) # 테스트 참가자의 수행 결과 기록 test.record_task_result("user1", "상품검색", { "time": 45, # 초 단위 "errors": 1, "satisfaction": 4 # 5점 만점 }) # 결과 분석 test.analyze_results() 특징과 목적 사용성 테스트의 주요 특징과 목적은 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-11-12 14:25:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;746 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 사용성 테스트 (Usability Test)" href=https://buenhyden.github.io/posts/qa/qc/test/specialized-testing/usability-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Function Coverage</h2></header><div class=entry-content><p>함수 커버리지 (Function Coverage) 함수 커버리지는 프로그램 내의 모든 함수가 테스트 중에 최소한 한 번 이상 호출되었는지를 측정하는 지표이다.
간단한 예제:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Calculator: def add(self, a, b): return a + b def subtract(self, a, b): return a - b def multiply(self, a, b): return a * b def divide(self, a, b): if b == 0: raise ValueError("Cannot divide by zero") return a / b 이 계산기 클래스의 모든 함수를 테스트하기 위해서는 다음과 같은 테스트 코드가 필요하다:
...</p></div><footer class=entry-footer><span title='2024-11-12 10:30:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;651 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Function Coverage" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/function-coverage/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다중 조건 테스팅 (Branch Condition Combination Testing)</h2></header><div class=entry-content><p>다중 조건 테스팅 (Branch Condition Combination Testing) 다중 조건 테스팅은 각 결정문에서 가능한 모든 조건 조합을 테스트하는 기법이다.
이는 조건 커버리지의 확장된 형태로, 가능한 모든 부울 조건 조합을 테스트하는 것을 목표로 한다.
주요 특징 완전한 조건 조합: 결정문 내의 모든 개별 조건식에 대해 가능한 모든 true/false 조합을 테스트한다. 높은 커버리지: 100% 다중 조건 커버리지를 달성하면 결정 커버리지와 조건 커버리지도 100% 달성된다. 복잡한 로직 테스트: 여러 조건이 복합적으로 사용되는 복잡한 의사결정 구조를 철저히 테스트할 수 있다. 장점 철저한 테스트: 모든 가능한 조건 조합을 테스트하므로 누락된 경우의 수 없이 철저한 테스트가 가능하다. 숨겨진 버그 발견: 특정 조건 조합에서만 발생하는 오류를 찾아낼 수 있다. 로직 오류 검출: 복잡한 조건문의 로직 오류를 효과적으로 발견할 수 있다. 단점 테스트 케이스 증가: 조건의 수가 증가할수록 테스트 케이스의 수가 기하급수적으로 늘어난다. 시간과 비용: 많은 테스트 케이스로 인해 테스트 수행 시간과 비용이 증가한다. 복잡성: 조건이 많은 경우 모든 조합을 고려하는 것이 매우 복잡해질 수 있다. 사용 사례 다중 조건 테스팅은 다음과 같은 상황에서 특히 유용하다:
...</p></div><footer class=entry-footer><span title='2024-11-12 10:08:00 +0000 UTC'>November 12, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;326 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 다중 조건 테스팅 (Branch Condition Combination Testing)" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/white-box-testing/branch-condition-combination-testing/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/8/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/10/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>