<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.141.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Black-box Test and White-box Test</h2></header><div class=entry-content><p>Black-box Test and White-box Test Black-box Testing(블랙박스 테스팅)은 소프트웨어의 내부 구조나 동작 원리를 모르는 상태에서 진행하는 테스트 방식이다.
마치 불투명한 상자 안을 들여다볼 수 없는 것처럼, 테스터는 입력값을 넣고 그에 따른 출력값만을 확인한다.
예를 들어, 계산기 애플리케이션을 테스트할 때 “2+2"를 입력했을 때 “4"가 출력되는지만 확인하고, 그 계산 과정이 어떤 알고리즘으로 이루어지는지는 고려하지 않는다.
Black-box Testing의 주요 특징은 다음과 같다:
사용자 관점에서의 테스트가 가능하다. 실제 사용자들이 소프트웨어를 사용하는 방식과 유사하게 테스트할 수 있다. 테스터가 코드에 대한 지식이 없어도 테스트를 수행할 수 있다. 경계값 분석, 동등 분할, 결정 테이블 등의 기법을 활용할 수 있다. 반면 White-box Testing(화이트박스 테스팅)은 소프트웨어의 내부 로직을 알고 있는 상태에서 진행하는 테스트이다.
투명한 상자처럼 내부 구조를 모두 볼 수 있어, 코드의 특정 부분이 어떻게 작동하는지 세세하게 테스트할 수 있다.
예를 들어, 로그인 기능을 테스트할 때 비밀번호 암호화 과정, 데이터베이스 접근 방식, 예외 처리 등의 내부 로직을 모두 확인한다.
...</p></div><footer class=entry-footer><span title='2024-12-21 02:29:00 +0000 UTC'>December 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;714 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Black-box Test and White-box Test" href=https://buenhyden.github.io/posts/qa/qc/test/test-design/black-box-test-and-white-box-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Python Super</h2></header><div class=entry-content><p>Python Super super()는 상속 관계에서 부모 클래스의 메서드를 호출하는 데 사용되는 중요한 도구.
부모 클래스(슈퍼클래스)의 메서드를 호출할 때 사용된다. 주로 자식 클래스에서 부모 클래스의 메서드를 확장하거나 재정의할 때 활용된다.
사용 예제:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Animal: def __init__(self, name): self.name = name def speak(self): return f"{self.name} makes a sound" class Dog(Animal): def __init__(self, name, breed): # 부모 클래스의 __init__ 메서드 호출 super().__init__(name) self.breed = breed def speak(self): # 부모 클래스의 speak 메서드를 확장 base_sound = super().speak() return f"{base_sound} - specifically, a woof!" # 사용 예시 my_dog = Dog("Rex", "Golden Retriever") print(my_dog.speak()) # 출력: "Rex makes a sound - specifically, a woof!" 특징 부모 클래스 참조: super()는 현재 클래스의 부모 클래스를 참조한다. 메서드 연결: 부모 클래스의 메서드에 접근하여 호출할 수 있게 한다. 동적 결정: 런타임에 메서드 호출을 결정한다. MRO(Method Resolution Order) 활용: 다중 상속 시 메서드 해석 순서를 따른다. 장점 코드 재사용: 부모 클래스의 코드를 재사용하여 중복을 줄인다. 유연성: 부모 클래스의 구현을 변경해도 자식 클래스에서 수정할 필요가 없다. 다중 상속 지원: 복잡한 상속 구조에서도 적절한 부모 메서드를 호출할 수 있다. 단점 복잡성: 다중 상속 시 상속 구조가 복잡해질 수 있다. 예상치 못한 동작: 상속 계층에 따라 의도하지 않은 메서드가 호출될 수 있다. 주요 사용 방법 super().init(): 부모 클래스의 생성자를 호출한다. super().method_name(): 부모 클래스의 특정 메서드를 호출한다. super()의 고급 기능과 특징 다중 상속에서의 활용 super()는 다중 상속 상황에서 메서드 해결 순서(MRO)를 따라 적절한 메서드를 찾아준다:
...</p></div><footer class=entry-footer><span title='2024-12-21 02:00:00 +0000 UTC'>December 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;663 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Python Super" href=https://buenhyden.github.io/posts/programming-languages/python/concepts/class/super/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>가상 메모리 (Virtual Memory)</h2></header><div class=entry-content><p>가상 메모리 (Virtual Memory) 가상 메모리(Virtual Memory)는 운영체제의 메모리 관리 기법 중 하나로, 물리적 메모리의 한계를 극복하고 더 큰 메모리 공간을 제공하는 기술이다.
실제 물리적 메모리(RAM)의 크기에 관계없이 프로그램이 사용할 수 있는 메모리 공간을 확장하며, 프로그램의 주소 공간을 실제 메모리에서 분리하여 가상 주소 공간을 제공한다.
가상 메모리가 필요한 이유:
메모리 제약 극복
프로그램의 크기가 실제 물리적 메모리보다 클 수 있다.
예를 들어 16GB RAM을 가진 컴퓨터에서 20GB가 필요한 프로그램을 실행할 수 있게 된다. 메모리 보호
각 프로세스는 자신만의 가상 주소 공간을 가지므로, 다른 프로세스의 메모리에 접근할 수 없다. 메모리 효율성
실제로 사용되는 부분만 물리적 메모리에 적재함으로써 메모리를 효율적으로 사용할 수 있다. Source: https://cse.poriyaan.in/topic/virtual-memory-50746/#google_vignette
...</p></div><footer class=entry-footer><span title='2024-12-20 13:37:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1121 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 가상 메모리 (Virtual Memory)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/virtual-memory/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>세그먼테이션 (Segmentation)</h2></header><div class=entry-content><p>세그먼테이션 (Segmentation) 세그먼테이션(Segmentation)은 운영체제의 메모리 관리 기법 중 하나로, 프로세스를 논리적 단위인 세그먼트로 나누어 관리하는 방식이다.
세그먼테이션의 기본 개념을 이해하기 위해, 먼저 프로그램의 구조를 생각해보자.
일반적인 프로그램은 코드 영역, 데이터 영역, 스택 영역 등 서로 다른 목적을 가진 영역들로 구성된다.
세그먼테이션은 이러한 논리적 단위들을 각각의 세그먼트로 관리한다.
Source: https://www.geeksforgeeks.org/segmentation-in-operating-system/
세그먼테이션의 주요 구성 요소와 작동 방식 세그먼트 테이블(Segment Table):
1 2 3 4 5 6 7 8 9 10 struct SegmentTableEntry { uint32_t base; // 세그먼트의 시작 주소 uint32_t limit; // 세그먼트의 크기 bool present; // 메모리 존재 여부 struct { bool read; // 읽기 권한 bool write; // 쓰기 권한 bool execute; // 실행 권한 } protection; }; 주소 변환 과정:
논리적 주소는 다음과 같이 구성된다:
...</p></div><footer class=entry-footer><span title='2024-12-20 13:37:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;314 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 세그먼테이션 (Segmentation)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/segmentation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>페이징 (Paging)</h2></header><div class=entry-content><p>페이징 (Paging) 먼저 페이징이 필요한 배경을 이해해보자.
초기 컴퓨터 시스템에서는 프로그램 전체가 물리 메모리에 연속적으로 적재되어야 했다.
이는 두 가지 큰 문제를 발생시켰다:
큰 프로그램은 메모리에 적재하기 어려웠다. 메모리 단편화(fragmentation)가 심각했다.
이러한 문제를 해결하기 위해 페이징이 도입되었다. 페이징의 기본 개념은 프로그램의 논리적 주소 공간과 물리적 메모리를 동일한 크기의 작은 단위로 나누어 관리하는 것이다. 이때 논리적 주소 공간의 단위를 ‘페이지(page)‘라 하고, 물리적 메모리의 단위를 ‘프레임(frame)‘이라고 한다.
Source: https://www.geeksforgeeks.org/paging-in-operating-system/
페이징 시스템의 주요 구성 요소 페이지 테이블(Page Table):
...</p></div><footer class=entry-footer><span title='2024-12-20 13:37:00 +0000 UTC'>December 20, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;509 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 페이징 (Paging)" href=https://buenhyden.github.io/posts/computer-system/operating-system/memory-mgmt/memory-mgmt-techniques/paging/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/38/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/40/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>