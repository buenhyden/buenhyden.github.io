<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Greenlet and Gevent</h2></header><div class=entry-content><p>Greenlet and Gevent Greenlet과 Gevent는 Python에서 동시성 프로그래밍을 위한 라이브러리이다.
Greenlet Greenlet은 Python에서 경량 코루틴을 구현한 라이브러리이다.
추가적으로 이야기 하면, Greenlet은 Python의 경량 협력적 멀티태스킹(cooperative multitasking)을 위한 기본 단위이다. 이는 마치 매우 가벼운 스레드처럼 작동하지만, 운영체제 수준의 스레드가 아닌 사용자 공간에서 실행되는 마이크로스레드이다.
주요 특징:
경량성: 일반 스레드보다 생성 비용이 매우 적다. 협력적 멀티태스킹: 명시적으로 제어권을 양보할 때만 컨텍스트 스위칭이 일어난다. 단일 OS 스레드 내 실행: 모든 greenlet은 동일한 물리적 스레드에서 실행된다. 사용 예:
...</p></div><footer class=entry-footer><span title='2025-01-15 05:33:00 +0000 UTC'>January 15, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;658 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Greenlet and Gevent" href=https://buenhyden.github.io/posts/programming-languages/python/library/concurrency/greenlet-and-gevent/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Rye</h2></header><div class=entry-content><p>Rye Rye는 파이썬 프로젝트와 패키지 관리를 위한 통합 솔루션으로, 2022년 11월에 Pynecone이라는 이름으로 처음 공개되었으나, 2023년 6월에 Rye로 이름이 변경되었다.
Rye는 파이썬 개발자들이 겪는 다양한 환경 설정 및 관리 문제를 해결하기 위해 설계되었다.
주요 특징 통합 환경 관리: Rye는 파이썬 설치, 프로젝트 초기화, 의존성 관리, 가상 환경 설정 등을 단일 도구로 통합한다. pyproject.toml 기반: 프로젝트 구성을 위해 현대적인 pyproject.toml 파일을 사용한다. 빠른 성능: Rust로 작성되어 기존 도구들보다 훨씬 빠른 성능을 제공한다. 다목적성: 복잡한 프로젝트, 모노레포, 글로벌 도구 설치 등 다양한 시나리오를 지원한다. 자동화된 가상 환경: 프로젝트별로 독립적인 가상 환경을 자동으로 생성하고 관리한다. 설치 및 사용 Rye는 다양한 운영 체제에서 쉽게 설치할 수 있다:
...</p></div><footer class=entry-footer><span title='2025-01-15 04:19:00 +0000 UTC'>January 15, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;232 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Rye" href=https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/rye/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>uv</h2></header><div class=entry-content><p>Uv UV(Ultraviolet)는 최신 패키지 관리 도구이다.
Rust로 작성된 UV는 기존의 pip, pip-tools, virtualenv 등을 대체할 수 있는 초고속 파이썬 패키지 설치 및 의존성 해결 도구이다.
주요 특징 속도: UV는 기존 도구들보다 10-100배 빠른 성능을 자랑한다. 캐시를 사용하지 않을 때도 pip나 pip-tools보다 8-10배 빠르며, 캐시 사용 시 80-115배의 속도 향상을 보인다. 다목적성: UV는 pip, pip-tools, virtualenv, pyenv 등 여러 도구의 기능을 단일 바이너리로 통합했다. Python 버전 관리: UV를 사용하면 여러 Python 버전을 쉽게 설치하고 관리할 수 있다. 프로젝트 관리: pyproject.toml 파일을 사용하여 프로젝트 의존성을 관리한다. 스크립트 지원: 단일 파일 스크립트에 대한 의존성 관리와 실행을 지원한다. 설치 및 사용 UV는 다음과 같이 설치할 수 있다:
...</p></div><footer class=entry-footer><span title='2025-01-15 04:18:00 +0000 UTC'>January 15, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;215 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to uv" href=https://buenhyden.github.io/posts/programming-languages/python/package-and-project-management/uv/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Context Switching</h2></header><div class=entry-content><p>Context Switching Context Switching은 운영 체제에서 매우 중요한 개념으로, 여러 프로세스나 스레드가 단일 CPU 자원을 공유하여 효율적으로 실행될 수 있게 하는 메커니즘이다.
Context Switching은 CPU가 현재 실행 중인 프로세스나 스레드의 상태를 저장하고, 다른 프로세스나 스레드의 상태를 불러와 실행을 재개하는 과정을 말한다.
이를 통해 여러 작업이 동시에 실행되는 것처럼 보이게 된다.
Source: https://www.geeksforgeeks.org/context-switch-in-operating-system/
Context Switching의 필요성 멀티태스킹: 여러 프로세스가 동시에 실행되는 것처럼 보이게 하여 시스템 효율성을 높인다. 인터럽트 처리: 하드웨어 인터럽트나 시스템 호출 등에 신속하게 대응할 수 있다. 자원 공유: 단일 CPU로 여러 프로세스를 실행할 수 있게 한다. Context Switching의 과정 현재 실행 중인 프로세스의 상태 저장: CPU 레지스터, 프로그램 카운터 등의 정보를 PCB(Process Control Block)에 저장한다. 새로운 프로세스 선택: 스케줄러가 다음에 실행할 프로세스를 선택한다. 새 프로세스의 상태 복원: 선택된 프로세스의 PCB에서 상태 정보를 불러와 CPU 레지스터에 복원한다. 실행 재개: 새 프로세스의 실행을 시작한다. Context Switching의 트리거 인터럽트: 하드웨어나 소프트웨어에서 발생하는 인터럽트. 시간 할당 종료: 프로세스에 할당된 CPU 시간이 끝났을 때. I/O 요청: 프로세스가 I/O 작업을 요청하여 대기 상태로 전환될 때. 우선순위: 더 높은 우선순위의 프로세스가 실행 준비될 때. Context Switching의 구현 방식 하드웨어 스위칭: 프로세서 코어에 내장된 태스크 상태 세그먼트(TSS)를 사용한다. 소프트웨어 스위칭: 운영 체제의 커널 루틴과 데이터 구조를 사용하여 구현한다. 더 빠르고 일관성 있는 방식이다. Context Switching의 장단점 장점:
...</p></div><footer class=entry-footer><span title='2025-01-15 01:00:00 +0000 UTC'>January 15, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;290 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Context Switching" href=https://buenhyden.github.io/posts/computer-system/operating-system/process-mgmt/context-switching/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Multithreading</h2></header><div class=entry-content><p>멀티 쓰레딩 (Multithreading) Multithreading은 운영 체제에서 프로그램이 여러 작업을 동시에 수행할 수 있게 해주는 기능이다. 즉, 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 것을 의미하며, 각 스레드는 프로세스의 자원을 공유하면서도 독립적인 실행 경로를 가진다.
이는 단일 프로세스 내에서 여러 실행 흐름(스레드)을 생성하고 관리하며, 현대 컴퓨터 시스템의 성능과 효율성을 크게 향상시킨다.
Source: https://www.geeksforgeeks.org/multithreading-in-operating-system/
각 스레드는 자신만의 프로그램 카운터, 레지스터 집합, 스택을 가지고 있다. 하지만 같은 프로세스 내의 스레드들은 코드, 데이터 섹션, 파일과 같은 자원을 공유한다. 이는 프로세스보다 스레드의 생성과 컨텍스트 스위칭이 더 가벼운 이유가 된다.
...</p></div><footer class=entry-footer><span title='2025-01-14 14:33:00 +0000 UTC'>January 14, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;219 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Multithreading" href=https://buenhyden.github.io/posts/computer-system/system-execution-models/threads-and-multithreading/multithreading/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/16/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/18/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>