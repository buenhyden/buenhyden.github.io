<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>논리 프로그래밍 (Logic Programming)</h2></header><div class=entry-content><p>논리 프로그래밍 (Logic Programming) 수학적 논리에 기반한 프로그래밍 패러다임
전통적인 프로그래밍이 “어떻게(how)” 문제를 해결할지에 중점을 둔다면, 논리 프로그래밍은 “무엇을(what)” 해결해야 하는지에 초점을 맞춘다.
프로그램은 사실(facts)과 규칙(rules)의 집합으로 구성되며, 시스템은 이러한 논리적 관계를 사용하여 쿼리(queries)에 대한 답을 찾아낸다.
특징 선언적 스타일: 프로그램의 목표를 명시하고, 실행 방법은 시스템이 결정합니다. 논리 규칙: 프로그램은 술어(predicates)와 사실로 표현된 논리 규칙으로 구성됩니다. 패턴 매칭: 입력을 논리 규칙과 대조하여 적용 가능성을 판단합니다. 지식 표현: 복잡한 관계와 개념을 명확하고 간결하게 표현할 수 있습니다. 추론 메커니즘: 기존 사실과 규칙으로부터 새로운 사실과 규칙을 도출합니다. 장점 표현력: 복잡하고 추상적인 개념을 간결하게 표현할 수 있습니다. 모듈성: 독립적인 모듈로 프로그램을 분리할 수 있어 재사용성과 유지보수성이 향상됩니다. 유연성: 다양한 실행 모드(전방 연쇄, 후방 연쇄, 대화형 쿼리)를 지원합니다. 효율적인 메모리 관리: 데이터 저장과 메모리 관리가 효율적입니다. 지식 표현에 적합: 논리적 관계를 쉽게 사실과 규칙으로 변환할 수 있습니다. 단점 계산 효율성: 복잡한 문제나 대규모 지식 기반에서는 계산 비용이 높을 수 있습니다. 비결정성: 여러 해결책이 존재하거나 예측 불가능한 동작을 할 수 있습니다. 디버깅의 어려움: 오류나 예상치 못한 결과의 원인을 추적하기 어려울 수 있습니다. 제한된 문제 범위: 모든 유형의 문제에 적합하지 않을 수 있습니다. 주의사항 및 고려사항 적절한 문제 선택: 논리 프로그래밍이 적합한 문제 영역을 선택해야 합니다. 성능 최적화: 복잡한 쿼리나 대규모 데이터셋에서의 성능을 고려해야 합니다. 지식 표현의 정확성: 사실과 규칙이 정확하게 도메인 지식을 반영해야 합니다. 비결정성 관리: 여러 해결책이 존재할 때의 처리 방법을 고려해야 합니다. 다른 패러다임과의 통합: 필요에 따라 명령형 또는 함수형 프로그래밍과 결합할 수 있습니다. 예시 Python 사실(Facts) 표현: 사실들은 단순한 관계 튜플로 표현됩니다 예: (“부모”, “철수”, “영희”)는 “철수는 영희의 부모이다"를 의미합니다 규칙(Rules) 정의: 규칙은 head(결론)와 body(조건)로 구성됩니다 조부모 관계는 두 개의 부모 관계를 통해 추론됩니다 추론 엔진: 재귀적으로 사실과 규칙을 탐색합니다 백트래킹을 사용하여 모든 가능한 해답을 찾습니다 순환 참조를 방지하기 위한 방문 집합을 사용합니다 패턴 매칭: 간단한 패턴 매칭을 통해 관계를 확인합니다 실제 논리 프로그래밍 언어에서는 더 복잡한 단일화(unification) 알고리즘을 사용합니다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class LogicEngine: def __init__(self): self.facts = [] self.rules = [] def add_fact(self, fact): """사실을 데이터베이스에 추가합니다""" self.facts.append(fact) def add_rule(self, rule): """규칙을 데이터베이스에 추가합니다""" self.rules.append(rule) def query(self, goal): """목표에 대한 해답을 찾습니다""" return self._solve(goal, set()) def _solve(self, goal, visited): """재귀적으로 해답을 찾습니다""" # 순환 참조 방지 if str(goal) in visited: return set() results = set() visited.add(str(goal)) # 사실에서 직접 매칭 확인 for fact in self.facts: if self._match(goal, fact): results.add(fact) # 규칙을 통한 추론 for rule in self.rules: if self._match(goal, rule.head): for body_fact in self._solve(rule.body, visited.copy()): results.add(rule.head) return results def _match(self, pattern1, pattern2): """두 패턴이 매칭되는지 확인합니다""" return pattern1 == pattern2 class Rule: def __init__(self, head, body): self.head = head self.body = body # 가족 관계 예제 def main(): engine = LogicEngine() # 사실 추가 (부모-자식 관계) engine.add_fact(("부모", "철수", "영희")) engine.add_fact(("부모", "영희", "민수")) engine.add_fact(("부모", "영희", "수진")) # 규칙 추가 (조부모 관계) engine.add_rule(Rule( ("조부모", "X", "Z"), ("부모", "X", "Y", "부모", "Y", "Z") )) # 쿼리 실행 print("=== 직접적인 부모 관계 ===") results = engine.query(("부모", "영희", "민수")) print(f"영희는 민수의 부모인가? {len(results) > 0}") print("\n=== 조부모 관계 추론 ===") results = engine.query(("조부모", "철수", "민수")) print(f"철수는 민수의 조부모인가? {len(results) > 0}") if __name__ == "__main__": main() Javascript 사실(Facts) 표현: 사실들은 단순한 관계 튜플로 표현됩니다 예: (“부모”, “철수”, “영희”)는 “철수는 영희의 부모이다"를 의미합니다 규칙(Rules) 정의: 규칙은 head(결론)와 body(조건)로 구성됩니다 조부모 관계는 두 개의 부모 관계를 통해 추론됩니다 추론 엔진: 재귀적으로 사실과 규칙을 탐색합니다 백트래킹을 사용하여 모든 가능한 해답을 찾습니다 순환 참조를 방지하기 위한 방문 집합을 사용합니다 패턴 매칭: 간단한 패턴 매칭을 통해 관계를 확인합니다 실제 논리 프로그래밍 언어에서는 더 복잡한 단일화(unification) 알고리즘을 사용합니다 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class LogicEngine { constructor() { this.facts = new Set(); this.rules = []; } addFact(fact) { this.facts.add(JSON.stringify(fact)); } addRule(rule) { this.rules.push(rule); } query(goal) { return this._solve(goal, new Set()); } _solve(goal, visited) { const goalStr = JSON.stringify(goal); if (visited.has(goalStr)) { return new Set(); } const results = new Set(); visited.add(goalStr); // 사실에서 직접 매칭 확인 for (const factStr of this.facts) { const fact = JSON.parse(factStr); if (this._match(goal, fact)) { results.add(factStr); } } // 규칙을 통한 추론 for (const rule of this.rules) { if (this._match(goal, rule.head)) { const bodyResults = this._solve(rule.body, new Set(visited)); if (bodyResults.size > 0) { results.add(JSON.stringify(rule.head)); } } } return results; } _match(pattern1, pattern2) { return JSON.stringify(pattern1) === JSON.stringify(pattern2); } } class Rule { constructor(head, body) { this.head = head; this.body = body; } } // 가족 관계 예제 async function main() { const engine = new LogicEngine(); // 사실 추가 (부모-자식 관계) engine.addFact(["부모", "철수", "영희"]); engine.addFact(["부모", "영희", "민수"]); engine.addFact(["부모", "영희", "수진"]); // 규칙 추가 (조부모 관계) engine.addRule(new Rule( ["조부모", "X", "Z"], ["부모", "X", "Y", "부모", "Y", "Z"] )); // 쿼리 실행 console.log("=== 직접적인 부모 관계 ==="); const parentResults = engine.query(["부모", "영희", "민수"]); console.log(`영희는 민수의 부모인가? ${parentResults.size > 0}`); console.log("\n=== 조부모 관계 추론 ==="); const grandparentResults = engine.query(["조부모", "철수", "민수"]); console.log(`철수는 민수의 조부모인가? ${grandparentResults.size > 0}`); } main().catch(console.error); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-21 09:05:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;924 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 논리 프로그래밍 (Logic Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/logic-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>함수형 프로그래밍 (Functional Programming)</h2></header><div class=entry-content><p>함수형 프로그래밍 (Functional Programming) 수학적 함수의 개념을 바탕으로 한 프로그래밍 패러다임.
이 방식은 상태 변경과 데이터 변경을 최소화하고 함수의 응용을 강조.
특징 순수 함수: 동일한 입력에 대해 항상 같은 출력을 반환하며, 부수 효과가 없습니다. 불변성: 데이터는 생성된 후 변경되지 않습니다. 고차 함수: 함수를 인자로 받거나 함수를 반환할 수 있습니다. 재귀: 반복문 대신 재귀를 사용하여 문제를 해결합니다. 지연 평가: 필요한 시점까지 계산을 미룹니다. 장점 코드의 간결성과 가독성: 함수 중심의 코드로 더 읽기 쉽고 이해하기 쉽습니다. 테스트와 디버깅 용이성: 순수 함수는 예측 가능하므로 테스트하기 쉽습니다. 병렬 처리 용이성: 불변성과 부수 효과 없음으로 인해 동시성 처리가 쉽습니다. 모듈성과 재사용성: 작은 순수 함수들의 조합으로 큰 프로그램을 만들 수 있습니다. 단점 학습 곡선: 전통적인 명령형 프로그래밍과 다른 사고방식이 필요합니다. 성능 이슈: 불변성으로 인해 메모리 사용량이 증가할 수 있습니다. 복잡성: 일부 문제에서는 함수형 접근이 더 복잡할 수 있습니다. 주의사항 및 고려사항 적절한 사용: 모든 문제에 함수형 접근이 최선은 아닙니다. 문제의 특성을 고려해야 합니다. 성능 최적화: 불변성과 순수 함수로 인한 성능 저하를 주의해야 합니다. 팀의 이해도: 팀 전체가 함수형 프로그래밍 개념을 이해하고 있어야 합니다. 예시 Python Python 예제는 금융 거래 분석 시스템을 구현.
다음과 같은 함수형 프로그래밍 개념들을 보여준다:
...</p></div><footer class=entry-footer><span title='2024-09-21 09:05:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;974 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 함수형 프로그래밍 (Functional Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/functional-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>추상화 (Abstraction)</h2></header><div class=entry-content><p>추상화 (Abstraction) 프로그래밍에서 핵심적인 개념으로, 복잡한 시스템이나 데이터를 단순화하여 필수적인 특징만을 강조하는 과정이다.
필요한 세부사항을 숨기고 중요한 정보만을 표현함으로써 코드의 복잡성을 줄이고 이해도를 높이는 데 도움을 준다.
주요 특징 복잡성 감소: 추상화는 시스템의 복잡한 내부 로직을 감추고 사용자에게 필요한 기능만을 제공한다. 코드 재사용성 향상: 공통 로직을 추상화하여 여러 곳에서 재사용할 수 있게 한다. 유연성 증가: 구체적인 구현을 숨기고 인터페이스만 제공함으로써, 나중에 구현 방법을 변경해도 외부에 영향을 주지 않는다. 모듈성 향상: 시스템을 독립적인 모듈로 나눌 수 있어 개발과 유지보수가 용이해진다. 추상화의 종류 데이터 추상화: 복잡한 데이터 구조를 단순화하여 표현한다.
...</p></div><footer class=entry-footer><span title='2024-09-21 06:46:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;418 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 추상화 (Abstraction)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/abstraction/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Abstract class</h2></header><div class=entry-content><p>Abstract Class 추상 클래스는 하나 이상의 추상 메서드를 포함하는 클래스이다.
추상 메서드는 선언만 되고 구현되지 않은 메서드를 말한다.
이는 기본적인 구조는 정의하지만 세부적인 구현은 하위 클래스에 맡긴다.
기본 구조:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from abc import ABC, abstractmethod class Shape(ABC): @abstractmethod def calculate_area(self): """도형의 넓이를 계산하는 추상 메서드""" pass @abstractmethod def calculate_perimeter(self): """도형의 둘레를 계산하는 추상 메서드""" pass def get_description(self): """일반 메서드 - 모든 하위 클래스가 공유""" return "이것은 2차원 도형입니다." 주요 특징 인스턴스화 불가: 추상 클래스는 직접 객체를 생성할 수 없다. 상속 목적: 다른 클래스들의 기본 클래스 역할을 한다. 추상 및 구체 메서드 포함: 추상 메서드와 구현된 메서드를 모두 가질 수 있다. 공통 인터페이스 제공: 관련된 클래스들에 대한 공통 인터페이스나 동작을 정의한다. 추상 클래스의 구현과 활용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Circle(Shape): def __init__(self, radius): self.radius = radius def calculate_area(self): """원의 넓이 계산 구현""" return 3.14 * self.radius * self.radius def calculate_perimeter(self): """원의 둘레 계산 구현""" return 2 * 3.14 * self.radius class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def calculate_area(self): """직사각형의 넓이 계산 구현""" return self.width * self.height def calculate_perimeter(self): """직사각형의 둘레 계산 구현""" return 2 * (self.width + self.height) 사용 목적 계층 구조 생성: 관련 클래스들의 공통 속성과 메서드를 정의한다. 템플릿 메서드 패턴: 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스에서 구현하도록 한다. 프레임워크 개발: API나 프레임워크에서 기본 구조를 정의하는 데 사용된다. 예시 Java에서 추상 클래스 선언 예:
이 예시에서 Shape는 추상 클래스로, draw() 메서드는 추상 메서드이며 setColor() 메서드는 구체적인 구현을 가진다.
...</p></div><footer class=entry-footer><span title='2024-09-21 05:39:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;301 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Abstract class" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/abstract-class/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>오버라이딩(Overriding)과 오버로딩(Overloading)</h2></header><div class=entry-content><p>오버라이딩(Overriding)과 오버로딩(Overloading) 기본 개념 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 정의 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것 같은 클래스 내에서 동일한 이름의 메서드를 매개변수를 다르게 하여 여러 개 정의하는 것 목적 상속 관계에서 메서드의 구현을 변경하기 위해 사용 비슷한 기능을 하는 메서드를 하나의 이름으로 여러 가지 방식으로 사용하기 위해 사용 다형성 유형 런타임 다형성 (동적 바인딩) 컴파일 타임 다형성 (정적 바인딩) 핵심 특징 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 이름 반드시 동일해야 함 반드시 동일해야 함 매개변수 부모 메서드와 동일해야 함 타입이나 개수가 달라야 함 반환 타입 부모 메서드와 동일하거나 공변 반환 타입이어야 함 다를 수 있음 접근 제어자 부모 메서드보다 더 제한적일 수 없음 자유롭게 지정 가능 예외 처리 부모 메서드보다 더 큰 범위의 예외를 던질 수 없음 자유롭게 지정 가능 코드 예시 비교 오버라이딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 부모 클래스 class Animal { public void makeSound() { System.out.println("동물이 소리를 냅니다"); } } // 자식 클래스 class Dog extends Animal { @Override // 오버라이딩 명시 public void makeSound() { System.out.println("멍멍!"); } } class Cat extends Animal { @Override public void makeSound() { System.out.println("야옹!"); } } 오버로딩 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Calculator { // 정수 덧셈 public int add(int a, int b) { return a + b; } // 실수 덧셈 public double add(double a, double b) { return a + b; } // 세 정수의 덧셈 public int add(int a, int b, int c) { return a + b + c; } // 배열의 덧셈 public int add(int[] numbers) { int sum = 0; for (int num : numbers) { sum += num; } return sum; } } 실행 시점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 결정 시점 런타임에 결정 컴파일 타임에 결정 바인딩 동적 바인딩 정적 바인딩 성능 영향 약간의 오버헤드 발생 가능 오버헤드 없음 사용 목적 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 주요 용도 • 부모 클래스 메서드의 동작 변경
• 다형성 구현
• 특화된 기능 구현 • 메서드 이름의 재사용
• 다양한 매개변수 처리
• 코드의 간결성 향상 활용 상황 • 추상 메서드 구현
• 인터페이스 구현
• 상속받은 메서드 수정 • 생성자 다중 정의
• 유틸리티 메서드 구현
• API 설계 제약사항 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 메서드 제약 • final 메서드는 오버라이드 불가
• private 메서드는 오버라이드 불가
• static 메서드는 오버라이드 불가 • 매개변수만 다르면 됨
• 반환 타입만 다른 것은 불가
• 접근 제어자 제약 없음 상속 관계 반드시 상속 관계가 있어야 함 상속 관계 불필요 기타 제약 • 부모의 메서드보다 접근성을 좁힐 수 없음
• 부모보다 더 큰 예외 선언 불가 • 매개변수 순서만 다른 경우 주의 필요
• 모호한 호출 가능성 주의 장단점 비교 구분 오버라이딩 (Overriding) 오버로딩 (Overloading) 장점 • 다형성 구현 가능
• 코드 재사용성 향상
• 유연한 설계 가능 • 직관적인 메서드명 사용
• 코드 가독성 향상
• API 사용 편의성 증가 단점 • 런타임 오버헤드
• 복잡한 상속 관계시 추적 어려움
• 잘못 사용시 부모 클래스 동작 훼손 • 과도한 사용시 복잡도 증가
• 타입 변환 오류 가능성
• 모호한 메서드 호출 가능성 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-21 04:56:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;535 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 오버라이딩(Overriding)과 오버로딩(Overloading)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/overriding-and-overloading/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/116/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/118/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>