<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Lock-free Queue</h2></header><div class=entry-content><p>Lock-free Queue Lock-free Queue는 락(lock)을 사용하지 않고 동시성을 제공하는 FIFO(First-In-First-Out) 자료구조이다.
이 자료구조는 여러 생산자(producer)와 소비자(consumer)가 동시에 큐에 접근할 수 있으며, 시스템 전체의 진행을 보장한다.
특징 동시성 지원: 여러 스레드가 동시에 큐에 접근하고 수정할 수 있다. 락 사용 없음: 전통적인 동기화 기법인 락을 사용하지 않는다. 진행 보장: 시스템 전체의 진행을 보장하며, 개별 스레드의 기아 현상이 발생할 수 있다. 원자적 연산 사용: Compare-And-Swap(CAS)과 같은 원자적 연산을 사용한다. 구현 방식 Lock-free Queue는 주로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-08 13:21:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;474 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Lock-free Queue" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/concurrent-data-structures/lock-free-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Suffix Array</h2></header><div class=entry-content><p>Suffix Array Suffix Array는 주어진 문자열의 모든 접미사(suffix)를 사전순으로 정렬한 배열로, 각 요소는 접미사의 시작 위치를 나타내는 정수이다.
https://www.geeksforgeeks.org/suffix-arrays-for-competitive-programming/
https://www.geeksforgeeks.org/suffix-arrays-for-competitive-programming/
특징 모든 접미사를 사전순으로 정렬하여 저장한다. 공간 효율적인 구조를 가진다. 빠른 문자열 검색을 가능하게 한다. 장점 효율적인 문자열 검색과 패턴 매칭이 가능하다. 공간 복잡도가 O(n)으로 효율적이다. 다양한 문자열 관련 문제 해결에 활용될 수 있다. 단점 구축 과정이 복잡할 수 있다. 기본 구현의 시간 복잡도가 O(n^2 log n)으로 높다. 응용 문자열 검색 및 패턴 매칭 생물정보학에서의 DNA 시퀀싱 분석 데이터 압축 알고리즘 텍스트 인덱싱 및 전체 텍스트 검색 동작 원리 문자열의 모든 접미사를 생성한다. 생성된 접미사들을 사전순으로 정렬한다. 정렬된 접미사의 시작 위치를 배열에 저장한다. 구성 요소 원본 문자열 정수 배열 (접미사의 시작 위치를 저장) (선택적으로) LCP(Longest Common Prefix) 배열 구현 방식 일반적으로 다음과 같은 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-08 13:01:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;273 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Suffix Array" href=https://buenhyden.github.io/posts/computer-science/string-search-and-manipulations/data-structures/suffix-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circular Linked List</h2></header><div class=entry-content><p>Circular Linked List 이는 Linked List의 한 변형으로, 데이터를 저장하고 조직하는 특정한 방식을 제공한다.
Circular Linked List(원형 연결 리스트)는 마지막 노드가 첫 번째 노드를 가리키는 연결 리스트의 변형이다.
이 구조에서는 리스트의 끝이 존재하지 않으며, 모든 노드가 연결되어 원을 형성한다.
https://www.geeksforgeeks.org/circular-linked-list/
특징 마지막 노드의 next 포인터가 NULL이 아닌 첫 번째 노드를 가리킨다. 리스트의 어느 노드에서 시작하더라도 모든 노드를 순회할 수 있다. 리스트의 끝과 시작이 연결되어 있어 순환 구조를 가진다. 장점 리스트의 처음이나 마지막에 노드를 삽입하는 연산이 편리하다. 하나의 노드에서 다른 모든 노드로의 접근이 가능하다. 순환적인 데이터 구조를 표현하기에 적합하다. 메모리를 효율적으로 사용할 수 있다. 단점 구현이 단순 연결 리스트보다 복잡하다. 무한 루프에 빠질 가능성이 있어 순회 중단이 어려울 수 있다. 노드 삭제 시 이전 노드를 찾기 위해 전체 리스트를 순회해야 할 수 있다. 응용 Circular Linked List는 다음과 같은 상황에서 유용하게 사용된다:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;371 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circular Linked List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/types/circular-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Circular Queue</h2></header><div class=entry-content><p>Circular Queue (Circular Buffer) 이는 선형 큐의 확장된 버전으로, 데이터를 효율적으로 저장하고 관리하는 특정한 방식을 제공한다.
Circular Queue는 마지막 요소가 첫 번째 요소와 연결되어 원형 구조를 형성하는 큐 데이터 구조이다.
이는 ‘Ring Buffer’라고도 불리며, 고정 크기의 배열을 사용하여 데이터를 연속적인 루프로 저장한다.
https://www.geeksforgeeks.org/what-is-circular-queue-circular-queue-meaning/
특징 원형 구조: 마지막 위치가 첫 번째 위치와 연결되어 있다. FIFO (First In First Out) 원칙을 따른다. 두 개의 포인터: 큐의 front와 rear를 추적하는 두 개의 포인터를 사용한다. 고정 크기: 초기화 시 크기가 설정되며, 이후 변경이 어렵다. 장점 메모리 효율성: 선형 큐의 주요 한계인 메모리 낭비 문제를 해결한다. 빠른 연산: 삽입과 삭제 연산의 시간 복잡도가 O(1)이다. 공간 재사용: 큐의 앞부분이 비어있을 때 재사용이 가능하다. 캐시 지역성: 연속된 메모리 사용으로 CPU 캐시 성능이 향상된다. 단점 크기 제한: 고정 크기로 인해 오버플로우와 데이터 손실 가능성이 있다. 구현 복잡성: 선형 큐보다 구현이 복잡하다. 디버깅 어려움: 원형 구조로 인해 디버깅이 어려울 수 있다. 동적 크기 조정의 어려움: 크기를 동적으로 조정하기 어렵다. 응용 CPU 스케줄링: 운영 체제에서 프로세스 관리에 사용된다. 트래픽 관리 시스템: 교차로에서의 효율적인 흐름 제어에 활용된다. 메모리 관리: 운영 체제의 메모리 관리에 사용된다. 스트리밍 서비스: 오디오 및 비디오 스트리밍에 활용된다. 네트워크 패킷 관리: 라우터와 스위치에서 패킷 데이터 처리에 사용된다. 동작 원리 초기화: front와 rear 포인터를 -1로 설정한다. 삽입(Enqueue): 큐가 가득 찼는지 확인한다. rear 포인터를 원형으로 증가시킨 ((rear + 1) % size). 새 요소를 rear 위치에 삽입한다[11]. 삭제(Dequeue): 큐가 비어있는지 확인한다. front 위치의 요소를 반환한다. front 포인터를 원형으로 증가시킨다 ((front + 1) % size). 구성 요소 배열: 데이터를 저장하는 고정 크기의 배열. front 포인터: 큐의 첫 번째 요소를 가리킨다. rear 포인터: 큐의 마지막 요소를 가리킨다. size: 큐의 최대 크기를 나타낸다. 구현 방식 JavaScript를 사용한 Circular Queue 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;527 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Circular Queue" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/queue/types/circular-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Doubly Linked List</h2></header><div class=entry-content><p>Doubly Linked List Doubly Linked List는 노드들이 양방향으로 연결된 선형 데이터 구조로, 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터를 포함하고 있다.
Doubly Linked List는 각 노드가 데이터와 두 개의 링크 필드를 가지고 있는 있으며, 이 두 개의 링크는 이전 노드(previous node)와 다음 노드(next node)를 가리킨다.
이러한 구조로 인해 리스트의 양방향 순회가 가능해진다.
![Doubly Linked List](Insertion-at-the-End-in-Doubly-Linked-List-copy.webp “https://www.geeksforgeeks.org/doubly-linked-list/ _
특징 양방향 연결: 각 노드는 이전 노드와 다음 노드를 모두 가리킨다. 헤드와 테일: 리스트의 시작(헤드)과 끝(테일)을 모두 가리키는 포인터를 유지한다. 순환 구조: 마지막 노드의 다음 노드는 첫 번째 노드를, 첫 번째 노드의 이전 노드는 마지막 노드를 가리킬 수 있다. 장점 양방향 탐색: 리스트를 앞뒤로 탐색할 수 있어 효율적인 검색이 가능하다. 삽입과 삭제의 효율성: 노드의 삽입과 삭제가 O(1) 시간 복잡도로 수행된다. 리스트 끝에서의 연산: 테일 포인터를 통해 리스트의 마지막 요소에 즉시 접근할 수 있다. 단점 메모리 사용량 증가: 각 노드가 두 개의 포인터를 저장해야 하므로 메모리 사용량이 증가한다. 구현의 복잡성: 단일 연결 리스트에 비해 구현이 더 복잡하다. 삽입과 삭제 시 포인터 조작: 노드 삽입과 삭제 시 여러 포인터를 조작해야 한다. 응용 웹 브라우저의 앞으로/뒤로 탐색 기능 음악 플레이어의 재생 목록 운영 체제의 작업 스케줄링 캐시 구현 복잡한 데이터 구조(예: 그래프)의 기본 구성 요소 동작 원리 삽입: 새 노드를 생성하고 이전 노드와 다음 노드의 포인터를 적절히 조정한다. 삭제: 삭제할 노드의 이전 노드와 다음 노드를 서로 연결하고 해당 노드를 메모리에서 해제한다. 탐색: 헤드나 테일에서 시작하여 원하는 노드를 찾을 때까지 포인터를 따라 이동한다. 구성 요소 노드: 데이터와 이전/다음 노드를 가리키는 두 개의 포인터로 구성된다. 헤드 포인터: 리스트의 첫 번째 노드를 가리킨다. 테일 포인터: 리스트의 마지막 노드를 가리킨다. 구현 방식 JavaScript를 사용한 Doubly Linked List 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;573 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Doubly Linked List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/types/doubly-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Skip List</h2></header><div class=entry-content><p>Skip List Skip List는 정렬된 연결 리스트를 기반으로 하여 빠른 검색, 삽입, 삭제 연산을 지원하는 확률적 데이터 구조이다.
Skip List는 여러 레벨의 연결 리스트로 구성된 데이터 구조로, 각 레벨은 그 아래 레벨의 일부 요소를 포함하며, 최하위 레벨은 모든 요소를 포함한다.
https://en.wikipedia.org/wiki/Skip_list#/media/File:Skip_list.svg
특징 다중 레벨 구조: 여러 층의 연결 리스트로 구성된다. 확률적 균형: 랜덤화를 통해 구조의 균형을 유지한다. 정렬 상태 유지: 요소들은 정렬된 순서로 유지된다. 장점 빠른 검색: 평균 O(log n) 시간 복잡도로 검색이 가능하다. 효율적인 삽입/삭제: 평균 O(log n) 시간에 삽입과 삭제가 가능하다. 구현의 단순성: 균형 이진 탐색 트리에 비해 구현이 간단하다. 단점 추가 메모리 사용: 여러 레벨의 포인터로 인해 추가 메모리가 필요하다. 확률적 성능: 최악의 경우 O(n) 시간 복잡도가 발생할 수 있다. 응용 데이터베이스 인덱싱: RocksDB와 같은 키-값 저장소에서 사용된다. 메모리 관리: 비휘발성 메모리 최적화에 활용된다. 캐시 구현: 효율적인 캐시 시스템 구축에 사용된다. 동작 원리 검색: 최상위 레벨에서 시작하여 목표 값보다 작은 노드를 따라 이동하고, 큰 값을 만나면 아래 레벨로 내려간다. 삽입: 랜덤하게 레벨을 결정하고, 해당 레벨까지 노드를 생성하여 연결한다. 삭제: 노드를 찾아 모든 레벨에서 제거한다. 구성 요소 노드: 키, 값, 여러 레벨의 다음 노드 포인터를 포함한다. 헤드 노드: 모든 레벨의 시작점 역할을 한다. 레벨: 여러 층의 연결 리스트 구조를 형성한다. 구현 방식 JavaScript를 사용한 Skip List 구현 예시:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:59:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;822 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Skip List" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/complex/skip-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Deque</h2></header><div class=entry-content><p>Deque (Double-ended Queue) Deque는 양쪽 끝에서 삽입과 삭제가 가능한 선형 데이터 구조로, 큐와 스택의 특성을 모두 가지고 있다.
Deque는 Double-ended Queue의 줄임말로, 양방향에서 데이터를 처리할 수 있는 자료구조이다.
큐의 전단(front)과 후단(rear) 모두에서 삽입과 삭제가 가능한 확장된 형태의 큐입니다.
https://www.geeksforgeeks.org/difference-between-queue-and-deque-queue-vs-deque/
특징 양방향 접근: 데이터의 앞과 뒤에서 모두 삽입과 삭제가 가능하다. 가변 크기: 필요에 따라 크기가 동적으로 조절될 수 있다. 임의 접근: 인덱스를 통해 요소에 직접 접근할 수 있다. FIFO와 LIFO: 큐와 스택의 특성을 모두 가지고 있어 유연하게 사용할 수 있다. 장점 유연성: 양쪽에서 데이터를 처리할 수 있어 다양한 상황에 적용 가능한다. 효율성: 양 끝에서의 삽입과 삭제 연산이 O(1)의 시간 복잡도를 가진다. 다목적성: 스택이나 큐로도 사용할 수 있어 다양한 알고리즘에 활용된다. 단점 구현 복잡성: 양방향 연산을 지원하기 위해 구현이 복잡할 수 있다. 메모리 사용: 동적 크기 조절을 위해 추가적인 메모리를 사용할 수 있다. 중간 삽입/삭제의 비효율성: 양 끝이 아닌 중간에서의 연산은 O(n)의 시간 복잡도를 가진다. 응용 작업 스케줄링: 운영 체제에서 프로세스 관리에 사용된다. 웹 브라우저의 방문 기록: 앞으로 가기와 뒤로 가기 기능을 구현할 때 활용된다. 실시간 데이터 처리: 양방향에서 데이터를 빠르게 추가하거나 제거해야 하는 경우에 사용된다. 팰린드롬 체크: 문자열이 앞뒤로 동일한지 확인하는 알고리즘에 활용된다. 동작 원리 삽입 연산: addFirst(): 덱의 앞쪽에 요소를 추가한다. addLast(): 덱의 뒤쪽에 요소를 추가한다. 삭제 연산: removeFirst(): 덱의 앞쪽에서 요소를 제거하고 반환한다. removeLast(): 덱의 뒤쪽에서 요소를 제거하고 반환한다. 조회 연산: getFirst(): 덱의 첫 번째 요소를 반환한다. getLast(): 덱의 마지막 요소를 반환한다. 구성 요소 데이터 저장소: 배열 또는 연결 리스트를 사용하여 요소를 저장한다. 두 개의 포인터: front와 rear 포인터로 덱의 양 끝을 가리킨다. 크기 정보: 현재 저장된 요소의 수를 추적한다. 구현 방식 Deque는 주로 두 가지 방식으로 구현된다:
...</p></div><footer class=entry-footer><span title='2024-10-08 12:53:00 +0000 UTC'>October 8, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;611 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deque" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/queue/types/deque/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Linked List vs. Array</h2></header><div class=entry-content><p>Array Vs Linked List 데이터 구조는 프로그래밍에서 데이터를 효율적으로 저장하고 관리하기 위한 방법을 제공합니다. 이 중에서도 배열과 연결 리스트는 가장 기본적이면서도 중요한 데이터 구조이다.
두 구조는 서로 다른 특성과 장단점을 가지고 있어 적절한 상황에 맞게 선택해 사용해야 한다.
배열은 인덱스를 통한 빠른 접근과 간단한 구현이 장점이지만, 크기가 고정되어 있고 중간 삽입/삭제가 비효율적이다.
반면 연결 리스트는 동적 크기 조정과 효율적인 삽입/삭제가 장점이지만, 임의 접근이 불가능하고 추가 메모리를 사용한다.
적절한 상황에 맞는 자료구조 선택은 효율적인 프로그램 개발의 핵심이다. 따라서 문제의 특성과 요구사항을 잘 분석하여 최적의 자료구조를 선택해야 한다. 때로는 두 자료구조의 장점을 결합한 하이브리드 접근 방식이나 다른 고급 자료구조를 활용하는 것이 더 나은 해결책이 될 수도 있다.
...</p></div><footer class=entry-footer><span title='2024-10-07 16:32:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1282 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Linked List vs. Array" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/linked-list/array-vs-linked-list/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>해시 (Hash)</h2></header><div class=entry-content><p>해시 (Hash) 임의의 크기를 가진 데이터를 고정된 크기의 데이터로 변환하는 과정이다.
이때 사용되는 함수를 해시 함수(Hash Function)라고 하며, 변환된 결과값을 해시값(Hash Value) 또는 해시 코드라고 한다. 그리고, 해시 테이블은 해시 함수를 사용하여 키(key)를 특정 버킷(bucket) 또는 슬롯(slot)에 매핑하는 자료구조이다.
해시 (Hash)는 임의의 크기를 가진 데이터를 고정된 크기의 값으로 변환한다. 해시 함수를 통해 생성된 해시 값에서 원래의 입력 데이터를 역으로 추적하는 것은 매우 어렵거나 불가능하다. 동일한 입력에 대해 항상 같은 해시 값을 생성한다. 이상적으로는 서로 다른 입력에 대해 다른 해시 값을 생성해야 한다. 해시의 특징 고정된 길이의 해시 값 생성 키-값 쌍으로 데이터 저장 빠른 검색 및 삽입 연산 해시 충돌 가능성 해시의 장점 빠른 검색 속도: 평균적으로 O(1)의 시간 복잡도로 데이터를 검색할 수 있다. 효율적인 메모리 사용: 키를 통해 직접 접근이 가능하므로 메모리를 효율적으로 사용한다. 데이터의 고유성 보장: 같은 키에 대해 항상 같은 해시 값을 생성한다. 해시의 단점 해시 충돌: 서로 다른 키가 같은 해시 값을 가질 수 있다. 순서 보장의 어려움: 데이터의 순서를 유지하기 어렵다. 공간 효율성 저하: 충돌 해결을 위한 추가 공간이 필요할 수 있다. 해시의 응용 데이터베이스 인덱싱 암호화 및 데이터 무결성 검증 캐싱 시스템 블록체인 기술 해시의 동작 원리 키를 입력받아 해시 함수를 통해 해시 값 생성 해시 값을 인덱스로 사용하여 데이터 저장 또는 검색 충돌 발생 시 해결 방법 적용 (체이닝 또는 개방 주소법) 해시 충돌과 해결 방법
...</p></div><footer class=entry-footer><span title='2024-10-07 01:33:00 +0000 UTC'>October 7, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;1004 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 해시 (Hash)" href=https://buenhyden.github.io/posts/computer-science/security/hashing/hash/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Callback Function (콜백 함수)</h2></header><div class=entry-content><p>Callback Function 프로그래밍에서 다른 함수의 인수로 전달되어 특정 작업이 완료된 후 호출되는 함수.
하나의 함수가 실행되는 동안, 특정 시점이나 조건이 충족되었을 때 호출될 함수를 미리 전달하는 방식.
이 개념은 동기적(synchronous) 또는 비동기적(asynchronous) 작업에서 모두 사용되며, 특히 비동기 프로그래밍에서 매우 중요하다.
간단한 예시를 통해 콜백 함수의 개념을 이해:
1 2 3 4 5 6 7 8 9 10 function greet(name, callback) { console.log('안녕하세요, ' + name + '님!'); callback(); } function sayGoodbye() { console.log('안녕히 가세요!'); } greet('홍길동', sayGoodbye); 이 예시에서 sayGoodbye 함수가 콜백 함수로 greet 함수에 전달된다. greet 함수는 인사말을 출력한 후 콜백 함수를 실행한다. 콜백 함수의 동작 원리 함수 전달: 콜백 함수는 다른 함수의 매개변수로 전달된다. 호출 시점 결정: 전달받은 함수는 호출자 함수 내부에서 특정 조건이나 작업 완료 시 호출된다. 결과 처리: 콜백 함수는 호출자 함수의 결과나 상태를 기반으로 추가 작업을 수행한다. 콜백 함수의 장점 코드의 재사용성 동일한 함수에 다른 콜백을 전달하여 다양한 동작을 구현할 수 있다. 중복 코드를 줄일 수 있다. 유연성 실행 시점에 필요한 동작을 결정할 수 있다. 프로그램의 동작을 쉽게 변경할 수 있다. 비동기 프로그래밍 지원 긴 작업을 기다리지 않고 다른 작업을 수행할 수 있다. 프로그램의 반응성을 향상시킬 수 있다. 이벤트 처리 사용자의 행동(클릭, 키보드 입력 등)에 반응하는 데 사용된다. 웹 브라우저의 이벤트 리스너가 대표적인 예시이다. 콜백 함수의 종류 동기적(Synchronous) 콜백 호출자 함수가 실행되는 동안 즉시 호출된다. 일반적으로 작업 순서가 중요할 때 사용된다. 예시: 배열 메서드(forEach, map)에서 사용되는 콜백. 1 2 3 4 const numbers = [1, 2, 3]; numbers.forEach((num) => { console.log(num); // 배열의 각 요소를 출력 }); 비동기적(Asynchronous) 콜백 호출자 함수가 실행된 후, 특정 작업이 완료되었을 때 호출된다. 주로 시간이 걸리는 작업(예: 파일 읽기, API 요청)에서 사용된다. 예시: setTimeout 또는 이벤트 리스너. 1 2 3 setTimeout(() => { console.log("3초 후에 실행됩니다."); }, 3000); 콜백 함수를 사용하는 이유 비동기 작업 처리: 시간이 걸리는 작업(API 요청, 파일 읽기 등)을 처리하는 동안 메인 프로그램 흐름을 막지 않음. 코드 유연성 증가: 특정 작업 이후 실행할 동작을 동적으로 정의 가능. 모듈화 및 재사용성 증가: 코드의 특정 동작을 분리하여 재사용 가능. 주의할 점 콜백 지옥(Callback Hell)
복잡한 비동기 작업이 중첩되어 코드 가독성이 떨어지고 유지보수가 어려워지는 현상.
해결책 Promise 사용: 비동기 작업을 체인 형태로 작성하여 가독성을 개선. Async/Await 사용: 비동기 코드를 동기 코드처럼 작성 가능. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 잘못된 방식 getData(function(a) { getMoreData(a, function(b) { getMoreData(b, function(c) { getMoreData(c, function(d) { // 콜백 지옥… }); }); }); }); // 올바른 방식 // Promise나 async/await를 사용하여 개선 async function fetchData() { const a = await getData(); const b = await getMoreData(a); const c = await getMoreData(b); const d = await getMoreData(c); // 더 깔끔하고 읽기 쉬운 코드 } 오류 처리
콜백 함수에서 발생하는 오류를 적절히 처리해야 한다.
오류 처리 콜백을 별도로 제공하는 것이 좋다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 잘못된 방식 function fetchData(callback) { // 에러 처리가 없음 callback(data); } // 올바른 방식 function fetchData(callback) { try { // 데이터 처리 callback(null, data); } catch (error) { callback(error, null); } } fetchData((error, data) => { if (error) { console.error('에러 발생:', error); return; } console.log('데이터:', data); }); 실행 순서 보장
비동기 콜백의 경우 실행 순서를 신중히 고려해야 한다.
필요한 경우 콜백 체인을 사용하여 순서를 보장할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 function processUserUnsafe(userId) { let userData; fetchUserData( userId, (user) => { userData = user; console.log("1. 사용자 데이터 받음:", userData); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); // userData가 설정되기 전에 실행될 수 있음 console.log("2. userData 사용:", userData); } // 4. 콜백 체인을 사용한 실행 순서 보장 function processUserSafe(userId) { fetchUserData( userId, (user) => { console.log("1. 사용자 데이터 받음:", user); validateUser(user, (validatedUser) => { console.log("2. 사용자 검증 완료:", validatedUser); updateUser(validatedUser, (updatedUser) => { console.log("3. 사용자 정보 업데이트 완료:", updatedUser); }, (error) => console.error("사용자 업데이트 실패:", error) ); }, (error) => console.error("사용자 검증 실패:", error) ); }, (error) => console.error("사용자 데이터 조회 실패:", error) ); } 파이썬에서의 콜백 함수 예제 파이썬에서도 함수를 매개변수로 전달하여 콜백 함수를 구현할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-10-06 12:45:00 +0000 UTC'>October 6, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;803 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Callback Function (콜백 함수)" href=https://buenhyden.github.io/posts/programming-languages/javascript/fundamentals/asynchronous-javascript/callback/callback-function/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/58/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/60/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>