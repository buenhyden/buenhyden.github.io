<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Coherence</h2></header><div class=entry-content><p>Cache Coherence Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.
멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.
캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.
멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-09-22 03:30:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;834 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Coherence" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-coherence/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Invalidation</h2></header><div class=entry-content><p>Cache Invalidation Cache Invalidation(캐시 무효화)는 캐시에 저장된 데이터가 더 이상 최신 상태가 아니거나 유효하지 않을 때, 이를 무효화하여 캐시가 최신 데이터를 제공하도록 보장하는 과정이다.
캐시 무효화는 캐싱 시스템에서 데이터 일관성을 유지하고, 잘못된 데이터를 반환하지 않도록 하기 위해 필수적인 메커니즘이다.
Cache Invalidation은 캐싱 시스템에서 필수적인 요소로, 데이터 일관성을 유지하고 잘못된 정보를 방지하기 위해 사용된다. Expiration(TTL), Active Invalidation, Validation-based Caching 등 다양한 전략을 상황에 맞게 선택해야 하며, 구현 시 성능과 복잡성을 균형 있게 고려해야 한다. 올바른 설계와 전략 선택은 시스템의 신뢰성과 효율성을 크게 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2024-09-22 03:30:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;830 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Invalidation" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-invalidation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Strategy</h2></header><div class=entry-content><p>Cache Strategy Cache Strategy(캐시 전략) 는 캐시를 효과적으로 활용하여 시스템 성능을 최적화하고 데이터 일관성을 유지하기 위한 방법론이다.
캐싱은 데이터 접근 속도를 높이고, 데이터베이스 부하를 줄이며, 사용자 경험을 향상시키는 데 중요한 역할을 한다. 캐시 전략은 데이터의 특성과 접근 패턴에 따라 적절히 선택해야 한다.
캐싱 전략은 애플리케이션의 성능 최적화와 사용자 경험 개선에 핵심적인 역할을 한다. Cache Aside, Read Through, Write Through 등 다양한 전략은 각각의 장단점과 적합한 사용 사례를 가지고 있으므로, 애플리케이션의 특성과 요구사항에 맞는 최적의 전략을 선택하는 것이 중요하다. 또한, 지속적인 모니터링과 최적화를 통해 효율적인 캐싱 시스템을 유지해야 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 03:30:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;594 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Strategy" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/cache-strategy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Caching Techniques</h2></header><div class=entry-content><p>Caching Techniques 캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.
브라우저 캐싱 (Browser Caching)
브라우저 캐싱은 웹 페이지 리소스(이미지, CSS 파일, JavaScript 파일 등)를 사용자의 기기에 로컬로 저장하는 기술이다.
사용자가 같은 웹사이트를 다시 방문할 때, 이 리소스들을 서버에서 다시 다운로드하지 않고 캐시에서 불러올 수 있어 페이지 로드 시간을 크게 줄일 수 있다.
이는 반복 방문자의 경험을 개선하고 전반적인 사용자 만족도를 높이는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-09-22 02:37:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;362 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caching Techniques" href=https://buenhyden.github.io/posts/computer-system/computer-architecture/memory-architecture/caching/caching-techniques/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KISS Principle</h2></header><div class=entry-content><p>KISS (Keep It Simple, Stupid) 원칙 시스템이나 코드의 복잡성을 최소화하라.
잘못된 예 1 2 3 4 5 6 def complex_calculation(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z): # 너무 많은 파라미터와 복잡한 로직이 포함되어 있음 result = a + b - c * d / e + f - g + h + i - j + k * l / m - n + o - p + q + r - s + t + u - v + w - x + y - z return result # 주석: 함수가 너무 복잡하고 많은 파라미터를 사용하여 KISS를 위반합니다. 잘된 예 1 2 3 4 5 def simple_calculation(a,b,c): result = a + b - c return result # 주석: 필요한 최소한의 파라미터와 간단한 로직으로 KISS를 준수합니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-22 01:00:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;123 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to KISS Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAGNI Principle</h2></header><div class=entry-content><p>YAGNI(You Ain’t Gonna Need It) Principle 당장 필요하지 않은 기능을 미리 구현하지 마라.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.loyalty_points = 0 # 아직 사용하지 않는 기능 def upgrade_to_premium(self): self.premium_member = True def add_loyalty_points(self, points): # 아직 사용하지 않는 기능 self.loyalty_points += points # 주석: 아직 사용하지 않는 loyalty_points 기능을 미리 구현하여 YAGNI 원칙을 위반합니다. # 이는 불필요한 복잡성을 추가하고, 실제로 필요하지 않을 수 있는 기능을 유지보수해야 하는 부담을 줍니다. class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.vip_status = False # 아직 필요 없는 기능 self.loyalty_points = 0 # 아직 필요 없는 기능 self.referred_users = [] # 아직 필요 없는 기능 self.last_login_history = [] # 아직 필요 없는 기능 def calculate_benefits(self): # 복잡한 혜택 계산 로직 (아직 필요 없음) pass def generate_referral_code(self): # 추천 코드 생성 로직 (아직 필요 없음) pass def track_login_history(self): # 로그인 이력 추적 로직 (아직 필요 없음) pass 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 주석: 현재 필요한 기능만 구현하여 YAGNI 원칙을 준수합니다. # 이를 통해 코드를 간결하게 유지하고, 실제로 필요한 기능이 확인될 때 추가할 수 있습니다. # YAGNI 준수 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 나중에 필요할 때 기능을 추가 class PremiumUser(User): def __init__(self, name, email): super().__init__(name, email) self.premium_member = True def get_premium_benefits(self): return ["무료 배송", "특별 할인"] 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-22 00:59:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAGNI Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle 코드 중복을 피하고 로직을 한 곳에서 관리하도록 권장하는 원칙.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = width * height perimeter = 2 * (width + height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 면적과 둘레 계산 로직이 중복되어 DRY 원칙을 위반합니다. # 계산 로직이 변경될 경우 여러 곳을 수정해야 하며, 실수의 가능성이 높아집니다. # 코드 중복 class Order: def calculate_total_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 total = total * 1.1 # 배송비 추가 if total &lt; 50: total += 10 return total class Cart: def calculate_preview_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 (중복된 로직) total = total * 1.1 # 배송비 추가 (중복된 로직) if total &lt; 50: total += 10 return total 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = calculate_rectangle_area(width, height) perimeter = calculate_rectangle_perimeter(width, height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 계산 로직을 함수로 분리하여 재사용하므로 DRY 원칙을 준수합니다. # 로직 변경 시 한 곳만 수정하면 되어 유지보수가 용이하고 일관성을 유지할 수 있습니다. # DRY 원칙 적용 class PriceCalculator: @staticmethod def calculate_price(items): total = sum(item.price for item in items) total = PriceCalculator.apply_tax(total) total = PriceCalculator.add_shipping_fee(total) return total @staticmethod def apply_tax(amount): return amount * 1.1 @staticmethod def add_shipping_fee(amount): return amount + 10 if amount &lt; 50 else amount class Order: def calculate_total_price(self, items): return PriceCalculator.calculate_price(items) class Cart: def calculate_preview_price(self, items): return PriceCalculator.calculate_price(items) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-22 00:58:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙.
단일 책임 원칙 (Single Responsibility Principle, SRP) 클래스는 단 하나의 책임만 가져야 한다.
여기서 ‘책임’이란 ‘변경의 이유’를 의미한다. 즉, 모듈은 오직 하나의 액터에 의해서만 변경되어야 한다.
이를 통해 코드의 모듈성과 유지보수성이 향상된다.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class User: def __init__(self, name): self.name = name def get_name(self): return self.name def save(self): # 데이터베이스에 사용자 정보를 저장하는 로직 pass def send_email(self, message): # 이메일을 보내는 로직 pass # 주석: 이 클래스는 사용자 정보 관리, 데이터베이스 저장, 이메일 발송 등 # 여러 책임을 가지고 있어 SRP를 위반합니다. 변경 사유가 여러 개 발생할 수 있습니다. 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class User: def __init__(self, name): self.name = name def get_name(self): return self.name class UserRepository: def save(self, user): # 데이터베이스에 사용자 정보를 저장하는 로직 pass class EmailService: def send_email(self, user, message): # 이메일을 보내는 로직 pass # 주석: 각 클래스가 단일 책임을 가지도록 분리되어 SRP를 준수합니다. # User 클래스는 사용자 정보만 관리하고, UserRepository는 저장을, # EmailService는 이메일 발송만 담당합니다. 각 기능의 변경이 다른 클래스에 영향을 주지 않습니다. 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다는 의미이다.
주로 상속이나 구성을 통해 달성되며, 안정적이고 오류가 적은 코드베이스를 만든다.
...</p></div><footer class=entry-footer><span title='2024-09-22 00:57:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;923 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동시성 프로그래밍 (Concurrency Programming)</h2></header><div class=entry-content><p>동시성 프로그래밍 (Concurrency Programming) 동시성 프로그래밍은 여러 작업을 동시에 수행할 수 있도록 프로그램을 설계하는 기법.
이는 시스템의 효율성을 높이고 처리 시간을 줄이는 데 중점을 둔다.
특징 여러 작업의 실행 흐름을 겹치게 하거나 병렬로 처리 멀티스레딩, 멀티프로세싱, 비동기 프로그래밍 등의 기법 사용 사용 사례 웹 서버: 여러 사용자의 요청을 동시에 처리 데이터베이스 시스템: 다수의 쿼리를 병렬로 처리 UI 애플리케이션: 백그라운드 작업 수행 중 사용자 인터페이스 응답성 유지 장점 시스템 자원의 효율적 사용 응답성 향상 처리량 증가 성능 최적화 단점 코드 복잡성 증가 디버깅 어려움 동기화 문제 (Race Condition, Deadlock 등) 성능 오버헤드 가능성 고려사항 동기화 메커니즘: 적절한 락(Lock) 사용 데드락 방지 공유 자원 보호 성능 최적화: 스레드 풀 크기 조정 작업 크기 최적화 메모리 사용량 관리 오류 처리: 예외 처리 전략 실패 복구 메커니즘 타임아웃 설정 구현시 주의사항 상태 관리:
...</p></div><footer class=entry-footer><span title='2024-09-21 23:42:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;800 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 프로그래밍 (Concurrency Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-09-21 12:38:00 +0000 UTC'>September 21, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;647 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/58/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/60/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>