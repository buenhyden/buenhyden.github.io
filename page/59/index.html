<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.8"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Coherence</h2></header><div class=entry-content><p>Cache Coherence Cache Coherence(캐시 일관성)는 컴퓨터 시스템에서 여러 프로세서가 각각의 로컬 캐시를 사용하면서 동일한 메모리 주소를 참조할 때, 데이터의 일관성을 유지하기 위한 메커니즘을 의미한다.
멀티코어 프로세서나 공유 메모리 시스템에서 매우 중요한 개념으로, 데이터 불일치 문제를 해결하여 시스템의 신뢰성과 성능을 보장한다.
캐시 일관성은 공유 메모리 시스템에서 여러 클라이언트(또는 프로세서)가 가진 로컬 캐시 간에 동일한 데이터가 항상 일관되게 유지되는 것을 의미한다.
멀티코어 환경에서는 각 코어가 독립적인 캐시를 사용하여 성능을 향상시킨다. 그러나 동일한 메모리 주소를 참조하는 경우, 한 프로세서가 데이터를 수정하면 다른 프로세서의 캐시에 있는 데이터는 더 이상 최신 상태가 아닐 수 있다. 이러한 데이터 불일치 문제를 해결하기 위해 캐시 일관성이 필요하다.
...</p></div><footer class=entry-footer><span title='2024-09-30 03:30:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Coherence" href=https://buenhyden.github.io/posts/systems/computer-architecture-and-organization/memory-systems/memory-hierarchy/cache-memory/coherence/cache-coherence/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Caching Techniques</h2></header><div class=entry-content><p>Caching Techniques 캐싱 기술(Caching Techniques)은 데이터 접근 속도를 높이고 시스템 성능을 개선하기 위해 사용되는 다양한 방법들을 말한다.
브라우저 캐싱 (Browser Caching)
브라우저 캐싱은 웹 페이지 리소스(이미지, CSS 파일, JavaScript 파일 등)를 사용자의 기기에 로컬로 저장하는 기술이다.
사용자가 같은 웹사이트를 다시 방문할 때, 이 리소스들을 서버에서 다시 다운로드하지 않고 캐시에서 불러올 수 있어 페이지 로드 시간을 크게 줄일 수 있다.
이는 반복 방문자의 경험을 개선하고 전반적인 사용자 만족도를 높이는 데 중요한 역할을 한다.
...</p></div><footer class=entry-footer><span title='2024-09-30 02:37:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Caching Techniques" href=https://buenhyden.github.io/posts/software-engineering/design-and-architecture/caching/types/caching-techniques/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CPU</h2></header><div class=entry-content><p>CPU CPU(중앙처리장치)는 컴퓨터 시스템의 핵심 구성요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.
CPU의 주요 구성요소 CPU는 크게 세 가지 주요 구성요소로 이루어져 있다
제어장치 (Control Unit, CU) 산술논리장치 (Arithmetic Logic Unit, ALU) 레지스터 (Registers) 제어장치 (Control Unit) 제어장치는 CPU의 ‘교통 경찰’ 역할을 한다.
주요 기능:
명령어를 순서대로 실행할 수 있도록 제어 주기억장치로부터 프로그램 명령을 순차적으로 가져와 해독 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치 등으로 전송 산술논리장치 (ALU) ALU는 CPU 내에서 실제 연산을 수행하는 부분
...</p></div><footer class=entry-footer><span title='2024-09-29 16:44:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CPU" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/cpu/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>파이프라이닝 (Pipelining)</h2></header><div class=entry-content><p>파이프라이닝 (Pipelining) 프로세서 아키텍처에서의 파이프라이닝(Pipelining)은 CPU의 성능을 향상시키는 중요한 기술이다.
파이프라이닝은 여러 명령어의 실행 단계를 중첩시켜 전체적인 처리량을 향상시키는 기술로, 여러 단계를 동시에 처리함으로써 효율성을 높인다.
현대 프로세서 설계에서 필수적인 기술이며, 대부분의 현대 CPU는 최소 2단계에서 최대 30-40단계의 파이프라인을 사용한다.
이 기술을 통해 프로세서의 전체적인 성능을 크게 향상시킬 수 있지만, 효과적인 구현을 위해서는 복잡한 설계 고려사항들을 신중히 관리해야 한다.
Source: https://www.geeksforgeeks.org/pipelined-architecture-with-its-diagram/
파이프라이닝의 작동 원리 파이프라이닝은 명령어 실행 과정을 여러 단계로 나누어 처리한다.
일반적인 파이프라인 단계는 다음과 같다:
...</p></div><footer class=entry-footer><span title='2024-09-29 02:20:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 파이프라이닝 (Pipelining)" href=https://buenhyden.github.io/posts/systems/computer-architecture-and-organization/processor-architecture/microarchitecture/pipelining/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Harvard Architecture</h2></header><div class=entry-content><p>Harvard Architecture 하버드 아키텍처(Harvard Architecture)는 프로세서 설계에서 중요한 구조로, 명령어와 데이터를 위한 별도의 메모리 및 버스 시스템을 사용하는 컴퓨터 아키텍처이다.
하버드 아키텍처는 다음과 같은 주요 특징을 가지고 있다:
메모리 분리: 프로그램(명령어) 메모리와 데이터 메모리가 물리적으로 분리되어 있다. 독립적 접근: CPU가 명령어와 데이터에 동시에 접근할 수 있어, 병렬 처리가 가능하다. 버스 구조: 명령어용 버스와 데이터용 버스가 별도로 존재한다. 성능 향상: 메모리 접근의 병렬화로 인해 처리 속도가 향상된다. 기본 구조:
1 2 3 4 5 [프로그램 메모리] [데이터 메모리] ↓ ↓ [CPU] ←→ [제어 유닛] ↓ ↓ [프로그램 버스] [데이터 버스] https://www.researchgate.net/figure/Harvard-architecture-scheme_fig6_356598013
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Harvard Architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/harvard-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Von Neumann architecture</h2></header><div class=entry-content><p>Von Neumann Architecture Von Neumann architecture는 1945년 John von Neumann이 제안한 컴퓨터 아키텍처로, 현대 대부분의 컴퓨터 시스템의 기본이 되는 설계이다.
Source: https://www.geeksforgeeks.org/computer-organization-von-neumann-architecture/
특징 순차적 실행:
명령어를 메모리에서 한 번에 하나씩 순차적으로 가져와 실행 레지스터:
프로그램 카운터 (PC): 다음 실행할 명령어의 주소 저장 명령어 레지스터 (CIR): 현재 실행 중인 명령어 저장 메모리 주소 레지스터 (MAR): 접근할 메모리 주소 저장 메모리 데이터 레지스터 (MDR): 메모리와 주고받는 데이터 저장 누산기 (Accumulator): 연산 결과 임시 저장 버스 시스템:
...</p></div><footer class=entry-footer><span title='2024-09-29 01:51:00 +0000 UTC'>September 29, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Von Neumann architecture" href=https://buenhyden.github.io/posts/computer-science-fundamentals/computer-architecture/types/von-neumann-architecture/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Observability vs. Monitoring</h2></header><div class=entry-content><p>Observability vs. Monitoring 비교 항목 Observability Monitoring 정의 시스템의 내부 상태를 외부 출력을 통해 이해하고 추론할 수 있는 능력 시스템의 동작과 성능을 지속적으로 관찰하고 추적하는 활동 목적 예측하지 못한 문제의 근본 원인을 파악하고 시스템의 동작을 심층적으로 이해 알려진 문제와 패턴을 감지하고 사전 정의된 임계값을 모니터링 데이터 수집 방식 이벤트, 로그, 트레이스, 메트릭스 등 다양한 형태의 원시 데이터 수집 주로 미리 정의된 메트릭과 상태 정보 수집 데이터 분석 방식 동적이고 탐색적인 분석, 실시간 질의 및 상관관계 분석 사전 정의된 대시보드와 알림 규칙 기반 분석 문제 해결 접근법 귀납적 접근 - 데이터를 통해 문제의 패턴과 원인을 발견 연역적 접근 - 알려진 문제 패턴에 기반한 탐지 도구의 특성 유연하고 탐색적인 도구 (예: Jaeger, OpenTelemetry) 고정된 대시보드와 알림 시스템 (예: Nagios, Prometheus) 데이터 저장 기간 일반적으로 더 긴 기간 (문제 패턴 분석을 위해) 상대적으로 짧은 기간 (실시간 모니터링 중심) 사용자 관점 개발자, SRE, 운영팀의 심층 분석 도구 운영팀의 일상적인 모니터링 도구 비용 구조 상대적으로 높은 초기 비용과 운영 비용 상대적으로 낮은 초기 비용과 예측 가능한 운영 비용 구현 복잡도 높음 (다양한 데이터 소스와 분석 도구 통합 필요) 중간 (표준화된 메트릭 수집과 알림 구성) 확장성 매우 유연한 확장성 (새로운 데이터 소스와 분석 방법 추가 가능) 제한된 확장성 (미리 정의된 메트릭과 알림 중심) 필요한 기술 수준 높은 수준의 기술적 이해와 분석 능력 필요 중간 수준의 운영 지식으로 충분 문제 감지 범위 알려지지 않은 문제까지 포함한 광범위한 감지 알려진 문제와 패턴 중심의 감지 응답 시간 상대적으로 길음 (심층 분석 필요) 즉각적 (사전 정의된 알림 기반) 주요 사용 사례 복잡한 분산 시스템의 문제 해결, 성능 최적화 시스템 상태 모니터링, SLA 준수 확인 이러한 차이점들은 각각이 서로 다른 목적과 상황에서 중요한 역할을 한다는 것을 보여준다.
Monitoring이 시스템의 기본적인 건강 상태를 확인하는 데 중점을 둔다면, Observability는 더 심층적인 시스템 이해와 문제 해결을 가능하게 한다.
...</p></div><footer class=entry-footer><span title='2024-09-28 08:23:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observability vs. Monitoring" href=https://buenhyden.github.io/posts/devops-and-infrastructure/observability/observability-vs-monitoring/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Metric</h2></header><div class=entry-content><p>Metric Metric는 시스템의 상태와 성능을 수치화하여 측정하는 중요한 관측 도구이다.
Metric는 시스템의 상태, 동작, 성능 등을 나타내는 수치화된 측정값이다.
예를 들어, 웹 서버의 응답 시간, CPU 사용률, 메모리 사용량 등이 Metric가 될 수 있다.
장점 효율적인 저장: 숫자 데이터는 저장 공간을 적게 차지한다. 빠른 쿼리: 시계열 데이터베이스를 사용하여 빠른 검색과 분석이 가능하다. 장기 추세 분석: 오랜 기간 동안의 데이터를 저장하고 분석할 수 있다. 시각화 용이성: 그래프나 대시보드로 쉽게 표현할 수 있다. 단점 초기 설정에 시간과 노력이 필요하다 너무 많은 Metric는 오히려 혼란을 줄 수 있다 저장 공간과 처리 리소스가 필요하다 Metric의 중요성 성능 모니터링: 시스템의 전반적인 성능을 지속적으로 모니터링할 수 있다. 문제 감지: 비정상적인 패턴이나 임계값 초과를 빠르게 감지할 수 있다. 용량 계획: 리소스 사용량 추세를 분석하여 미래의 용량을 계획할 수 있다. 최적화: 성능 병목 현상을 식별하고 최적화할 수 있는 기회를 제공한다. Metric의 구성 요소 일반적인 Metric는 다음 요소로 구성된다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Metric" href=https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/metrics/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Trace</h2></header><div class=entry-content><p>Trace Trace는 분산 시스템에서 요청의 흐름을 추적하고 시각화하는 데 사용된다.
Trace는 분산 시스템에서 요청이나 트랜잭션이 여러 서비스와 컴포넌트를 통과하는 전체 여정을 기록한 것이다.
각 Trace는 하나 이상의 span으로 구성되며, 첫 번째 span은 root span이라고 한다.
Trace의 목적 분산 시스템에서의 요청 흐름 이해 성능 병목 지점 식별 서비스 간 의존성 파악 오류 및 지연의 근본 원인 분석 Trace의 구성 요소 트레이스는 다음과 같은 구성 요소들로 이루어진다:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 트레이스 시작 Span rootSpan = tracer.spanBuilder("checkout-process") .setSpanKind(SpanKind.SERVER) .startSpan(); try (Scope scope = rootSpan.makeCurrent()) { // 자식 스팬 생성 Span paymentSpan = tracer.spanBuilder("process-payment") .setParent(Context.current().with(rootSpan)) .startSpan(); try { processPayment(); paymentSpan.setStatus(StatusCode.OK); } catch (Exception e) { paymentSpan.setStatus(StatusCode.ERROR, e.getMessage()); throw e; } finally { paymentSpan.end(); } } finally { rootSpan.end(); } 트레이스 구성의 핵심 요소들:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:27:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Trace" href=https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/tracing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Log</h2></header><div class=entry-content><p>Log Log는 애플리케이션 실행 시 생성되는 텍스트 기반의 기록이다. 이는 구조화된 형식(예: JSON)이나 비구조화된 텍스트 형식으로 제공될 수 있다.
문제가 발생했을 때 무슨 일이 있었는지 추적할 수 있게 해주며, 시스템의 동작을 이해하는 데 필수적인 정보를 제공한다.
로그 구조를 설계할 때는 다음과 같은 원칙들을 고려해야 한다:
일관성(Consistency): 모든 로그 항목은 동일한 구조와 형식을 따라야 한다. 이는 로그 파싱과 분석을 용이하게 만든다. 검색 가능성(Searchability): 주요 필드들은 쉽게 검색하고 필터링할 수 있는 형태여야 한다. 확장성(Extensibility): 새로운 정보를 추가할 필요가 생겼을 때 기존 구조를 해치지 않고 확장할 수 있어야 한다. 상세도 조절(Verbosity Control): 로그 레벨을 통해 필요한 상세도를 조절할 수 있어야 한다. 로그 구조를 효과적으로 설계하면 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-28 02:26:00 +0000 UTC'>September 28, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Log" href=https://buenhyden.github.io/posts/devops-and-infrastructure/observability/fundamentals/three-pillars-of-observability/logging/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/58/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/60/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>