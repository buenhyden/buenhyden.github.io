<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.142.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Template Method Pattern</h2></header><div class=entry-content><p>Template Method Pattern 알고리즘의 구조를 정의하고 일부 단계를 서브클래스에서 구현할 수 있도록 하는 행동 디자인 패턴
특징 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현할 수 있게 합니다. 공통 로직은 상위 클래스에서 정의하고, 변화가 필요한 부분만 하위 클래스에서 구현합니다. 알고리즘의 구조를 변경하지 않고 특정 단계를 재정의할 수 있습니다. 두 가지 주요 부분으로 구성된다.
추상 클래스(Abstract Class): 알고리즘의 골격을 정의하는 템플릿 메서드를 포함 서브클래스에서 구현해야 하는 추상 메서드 정의 선택적으로 오버라이드할 수 있는 훅(hook) 메서드 제공 구체 클래스(Concrete Class): 추상 클래스를 상속받아 추상 메서드를 실제로 구현 필요한 경우 훅 메서드를 오버라이드하여 알고리즘을 커스터마이즈 사용사례 프레임워크에서 기본 동작을 정의하고 사용자가 일부를 커스터마이즈해야 할 때 데이터 마이닝 작업에서 데이터 처리 파이프라인을 구현할 때 리포트 생성 시스템에서 다양한 형식의 리포트를 생성할 때 장점 코드 재사용성이 높아집니다 알고리즘의 공통 부분을 한 곳에서 관리할 수 있습니다 확장성이 좋아 새로운 변형을 쉽게 추가할 수 있습니다 단점 템플릿 메소드가 복잡해질수록 유지보수가 어려워질 수 있습니다 하위 클래스에서 상위 클래스의 메소드를 실수로 오버라이드할 수 있습니다 알고리즘 단계가 많아지면 클래스 계층 구조가 복잡해질 수 있습니다 주의사항 및 고려사항 템플릿 메소드는 final로 선언하여 하위 클래스가 override하지 못하도록 해야 합니다. Python에서는 관례적으로 메소드 이름 앞에 언더스코어를 붙여 protected임을 나타냅니다. 추상 메소드(반드시 구현해야 하는 메소드)와 훅 메소드(선택적으로 구현할 수 있는 메소드)를 명확히 구분해야 합니다. 상속 계층이 깊어지지 않도록 주의해야 합니다. 일반적으로 추상 클래스와 구체 클래스의 2단계 정도가 적절합니다. 템플릿 메소드가 너무 많은 단계를 가지지 않도록 해야 합니다. 복잡한 알고리즘은 더 작은 단위로 분리하는 것이 좋습니다. 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from abc import ABC, abstractmethod class DataMiner(ABC): """데이터 마이닝을 위한 템플릿 메소드 패턴 구현""" def mine_data(self, path: str) -> None: """템플릿 메소드: 데이터 마이닝의 전체 프로세스를 정의""" raw_data = self._read_file(path) cleaned_data = self._clean_data(raw_data) analyzed_data = self._analyze_data(cleaned_data) self._send_report(analyzed_data) @abstractmethod def _read_file(self, path: str) -> list: """파일을 읽어오는 추상 메소드""" pass def _clean_data(self, data: list) -> list: """데이터 정제를 위한 훅 메소드""" return data @abstractmethod def _analyze_data(self, data: list) -> dict: """데이터 분석을 위한 추상 메소드""" pass def _send_report(self, data: dict) -> None: """분석 결과 보고를 위한 훅 메소드""" print("기본 보고서 생성:", data) class PDFDataMiner(DataMiner): """PDF 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"PDF 파일 읽기: {path}") return ["PDF 데이터 1", "PDF 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "PDF", "results": data} def _clean_data(self, data: list) -> list: # PDF 특화 데이터 정제 로직 return [item.strip() for item in data] class CSVDataMiner(DataMiner): """CSV 파일용 데이터 마이너""" def _read_file(self, path: str) -> list: print(f"CSV 파일 읽기: {path}") return ["CSV 데이터 1", "CSV 데이터 2"] def _analyze_data(self, data: list) -> dict: return {"type": "CSV", "results": data} # 사용 예시 if __name__ == "__main__": pdf_miner = PDFDataMiner() csv_miner = CSVDataMiner() pdf_miner.mine_data("sample.pdf") csv_miner.mine_data("sample.csv") Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class BeverageMaker { /** * 음료 제조를 위한 템플릿 메소드 * @returns {void} */ prepare() { this.boilWater(); this.brew(); this.pourInCup(); if (this.customerWantsCondiments()) { this.addCondiments(); } this.serve(); } /** * 물을 끓이는 공통 메소드 * @private */ boilWater() { console.log('물을 끓입니다'); } /** * 음료를 우리는 추상 메소드 * @abstract * @private */ brew() { throw new Error('brew 메소드를 구현해야 합니다'); } /** * 컵에 따르는 공통 메소드 * @private */ pourInCup() { console.log('컵에 따릅니다'); } /** * 고객이 첨가물을 원하는지 확인하는 훅 메소드 * @returns {boolean} */ customerWantsCondiments() { return true; } /** * 첨가물을 추가하는 추상 메소드 * @abstract * @private */ addCondiments() { throw new Error('addCondiments 메소드를 구현해야 합니다'); } /** * 음료를 서빙하는 공통 메소드 * @private */ serve() { console.log('음료가 준비되었습니다'); } } class CoffeeMaker extends BeverageMaker { brew() { console.log('커피를 우립니다'); } addCondiments() { console.log('설탕과 우유를 추가합니다'); } customerWantsCondiments() { // 고객 선호도에 따라 첨가물 추가 여부 결정 return Math.random() > 0.5; } } class TeaMaker extends BeverageMaker { brew() { console.log('차를 우립니다'); } addCondiments() { console.log('레몬을 추가합니다'); } } // 사용 예시 const coffee = new CoffeeMaker(); const tea = new TeaMaker(); console.log('=== 커피 준비 ==='); coffee.prepare(); console.log('\n=== 차 준비 ==='); tea.prepare(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:17:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;786 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Template Method Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/template-method-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Observer Pattern</h2></header><div class=entry-content><p>Observer Pattern 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴
특징 객체 간 일대다 관계를 정의합니다. 주체(Subject)와 관찰자(Observer)로 구성됩니다. 느슨한 결합을 제공하여 유연성을 높입니다. 발행/구독 모델로도 알려져 있습니다. 두 가지 인터페이스로 이루어진다.
Subject
Observer들을 등록(attach)하고 제거(detach)할 수 있으며, 상태 변경 시 모든 Observer에게 알림을 보낸다. Observer
Subject로부터 받은 알림을 처리하는 update 메서드를 구현 사용사례 이벤트 처리 시스템: GUI 애플리케이션에서 버튼 클릭이나 키보드 입력 등의 이벤트 처리 뉴스 구독 서비스: 새로운 뉴스가 발행되면 구독자들에게 알림 소셜 미디어 피드: 새로운 게시물이 등록되면 팔로워들에게 알림 주식 시장 모니터링: 주식 가격 변동을 실시간으로 관심 있는 투자자들에게 알림 장점 느슨한 결합(Loose Coupling): Subject와 Observer는 서로의 구체적인 구현을 알 필요가 없음 유연한 객체 관계: 실행 시점에 동적으로 Observer를 추가하거나 제거 가능 개방-폐쇄 원칙(OCP) 준수: 기존 코드 수정 없이 새로운 Observer 추가 가능 단점 순서 보장의 어려움: 다수의 Observer에게 알림이 전달될 때 실행 순서 보장이 어려움 메모리 누수 가능성: Observer 해제를 제대로 하지 않으면 메모리 누수 발생 위험 복잡성 증가: Observer가 많아질수록 디버깅과 테스트가 어려워질 수 있음 주의사항 및 고려사항 순환 참조 방지: Observer가 Subject를 다시 업데이트하는 순환 참조 상황 주의 메모리 관리: Observer 등록 해제를 확실히 처리 상태 일관성 유지: 다수의 Observer가 있을 때 상태 일관성 보장 비동기 처리 고려: 많은 Observer가 있을 경우 비동기 처리 검토 예시 Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 from abc import ABC, abstractmethod from typing import List # Observer 인터페이스 class NewsObserver(ABC): @abstractmethod def update(self, news: str) -> None: pass # Subject(Observable) 클래스 class NewsAgency: def __init__(self): self._observers: List[NewsObserver] = [] self._latest_news: str = "" def attach(self, observer: NewsObserver) -> None: if observer not in self._observers: self._observers.append(observer) def detach(self, observer: NewsObserver) -> None: self._observers.remove(observer) def notify_observers(self) -> None: for observer in self._observers: observer.update(self._latest_news) def publish_news(self, news: str) -> None: self._latest_news = news self.notify_observers() # Concrete Observer 클래스들 class NewsChannel(NewsObserver): def __init__(self, name: str): self.name = name def update(self, news: str) -> None: print(f"{self.name} received news: {news}") class NewsApp(NewsObserver): def __init__(self, app_name: str): self.app_name = app_name def update(self, news: str) -> None: print(f"{self.app_name} pushing notification: {news}") # 사용 예시 def main(): # Subject 생성 news_agency = NewsAgency() # Observer 생성 bbc = NewsChannel("BBC") cnn = NewsChannel("CNN") news_app = NewsApp("Breaking News App") # Observer 등록 news_agency.attach(bbc) news_agency.attach(cnn) news_agency.attach(news_app) # 뉴스 발행 news_agency.publish_news("Breaking: Major tech breakthrough announced!") # Observer 제거 news_agency.detach(cnn) # 새로운 뉴스 발행 news_agency.publish_news("Update: More details on tech breakthrough…") if __name__ == "__main__": main() Javascript 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 // Observer 인터페이스 (TypeScript 스타일) interface WeatherObserver { update(temperature: number, humidity: number): void; } // Subject(Observable) 클래스 class WeatherStation { private observers: WeatherObserver[] = []; private temperature: number = 0; private humidity: number = 0; public attach(observer: WeatherObserver): void { const isExist = this.observers.includes(observer); if (!isExist) { this.observers.push(observer); } } public detach(observer: WeatherObserver): void { const observerIndex = this.observers.indexOf(observer); if (observerIndex !== -1) { this.observers.splice(observerIndex, 1); } } public notify(): void { for (const observer of this.observers) { observer.update(this.temperature, this.humidity); } } public setMeasurements(temperature: number, humidity: number): void { this.temperature = temperature; this.humidity = humidity; this.notify(); } } // Concrete Observer 클래스들 class WeatherDisplay implements WeatherObserver { private name: string; constructor(name: string) { this.name = name; } public update(temperature: number, humidity: number): void { console.log( `${this.name} Display: Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } class WeatherLogger implements WeatherObserver { public update(temperature: number, humidity: number): void { console.log( `Logging - Temperature: ${temperature}°C, Humidity: ${humidity}%` ); } } // 사용 예시 function main() { // Subject 생성 const weatherStation = new WeatherStation(); // Observer 생성 const phoneDisplay = new WeatherDisplay("Phone"); const tabletDisplay = new WeatherDisplay("Tablet"); const logger = new WeatherLogger(); // Observer 등록 weatherStation.attach(phoneDisplay); weatherStation.attach(tabletDisplay); weatherStation.attach(logger); // 날씨 정보 업데이트 console.log("First weather update:"); weatherStation.setMeasurements(24, 65); // Observer 제거 weatherStation.detach(tabletDisplay); // 새로운 날씨 정보 업데이트 console.log("\nSecond weather update:"); weatherStation.setMeasurements(27, 70); } main(); 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-24 06:16:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;779 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Observer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/behavioral-design-patterns/observer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>KISS Principle</h2></header><div class=entry-content><p>KISS (Keep It Simple, Stupid) 원칙 시스템이나 코드의 복잡성을 최소화하라.
잘못된 예 1 2 3 4 5 6 def complex_calculation(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z): # 너무 많은 파라미터와 복잡한 로직이 포함되어 있음 result = a + b - c * d / e + f - g + h + i - j + k * l / m - n + o - p + q + r - s + t + u - v + w - x + y - z return result # 주석: 함수가 너무 복잡하고 많은 파라미터를 사용하여 KISS를 위반합니다. 잘된 예 1 2 3 4 5 def simple_calculation(a,b,c): result = a + b - c return result # 주석: 필요한 최소한의 파라미터와 간단한 로직으로 KISS를 준수합니다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 01:00:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;123 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to KISS Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/kiss-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>YAGNI Principle</h2></header><div class=entry-content><p>YAGNI(You Ain’t Gonna Need It) Principle 당장 필요하지 않은 기능을 미리 구현하지 마라.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.loyalty_points = 0 # 아직 사용하지 않는 기능 def upgrade_to_premium(self): self.premium_member = True def add_loyalty_points(self, points): # 아직 사용하지 않는 기능 self.loyalty_points += points # 주석: 아직 사용하지 않는 loyalty_points 기능을 미리 구현하여 YAGNI 원칙을 위반합니다. # 이는 불필요한 복잡성을 추가하고, 실제로 필요하지 않을 수 있는 기능을 유지보수해야 하는 부담을 줍니다. class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False self.vip_status = False # 아직 필요 없는 기능 self.loyalty_points = 0 # 아직 필요 없는 기능 self.referred_users = [] # 아직 필요 없는 기능 self.last_login_history = [] # 아직 필요 없는 기능 def calculate_benefits(self): # 복잡한 혜택 계산 로직 (아직 필요 없음) pass def generate_referral_code(self): # 추천 코드 생성 로직 (아직 필요 없음) pass def track_login_history(self): # 로그인 이력 추적 로직 (아직 필요 없음) pass 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 주석: 현재 필요한 기능만 구현하여 YAGNI 원칙을 준수합니다. # 이를 통해 코드를 간결하게 유지하고, 실제로 필요한 기능이 확인될 때 추가할 수 있습니다. # YAGNI 준수 class User: def __init__(self, name, email): self.name = name self.email = email self.premium_member = False def upgrade_to_premium(self): self.premium_member = True # 나중에 필요할 때 기능을 추가 class PremiumUser(User): def __init__(self, name, email): super().__init__(name, email) self.premium_member = True def get_premium_benefits(self): return ["무료 배송", "특별 할인"] 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:59:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to YAGNI Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/yagni-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DRY Principle</h2></header><div class=entry-content><p>DRY(Don’t Repeat Yourself) Principle 코드 중복을 피하고 로직을 한 곳에서 관리하도록 권장하는 원칙.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = width * height perimeter = 2 * (width + height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 면적과 둘레 계산 로직이 중복되어 DRY 원칙을 위반합니다. # 계산 로직이 변경될 경우 여러 곳을 수정해야 하며, 실수의 가능성이 높아집니다. # 코드 중복 class Order: def calculate_total_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 total = total * 1.1 # 배송비 추가 if total &lt; 50: total += 10 return total class Cart: def calculate_preview_price(self, items): total = 0 for item in items: total += item.price # 10% 세금 추가 (중복된 로직) total = total * 1.1 # 배송비 추가 (중복된 로직) if total &lt; 50: total += 10 return total 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def calculate_rectangle_area(width, height): return width * height def calculate_rectangle_perimeter(width, height): return 2 * (width + height) def print_rectangle_info(width, height): area = calculate_rectangle_area(width, height) perimeter = calculate_rectangle_perimeter(width, height) print(f"Area: {area}, Perimeter: {perimeter}") # 주석: 계산 로직을 함수로 분리하여 재사용하므로 DRY 원칙을 준수합니다. # 로직 변경 시 한 곳만 수정하면 되어 유지보수가 용이하고 일관성을 유지할 수 있습니다. # DRY 원칙 적용 class PriceCalculator: @staticmethod def calculate_price(items): total = sum(item.price for item in items) total = PriceCalculator.apply_tax(total) total = PriceCalculator.add_shipping_fee(total) return total @staticmethod def apply_tax(amount): return amount * 1.1 @staticmethod def add_shipping_fee(amount): return amount + 10 if amount &lt; 50 else amount class Order: def calculate_total_price(self, items): return PriceCalculator.calculate_price(items) class Cart: def calculate_preview_price(self, items): return PriceCalculator.calculate_price(items) 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-23 00:58:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;351 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to DRY Principle" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/dry-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SOLID Principles</h2></header><div class=entry-content><p>SOLID Principles 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙.
단일 책임 원칙 (Single Responsibility Principle, SRP) 클래스는 단 하나의 책임만 가져야 한다.
여기서 ‘책임’이란 ‘변경의 이유’를 의미한다. 즉, 모듈은 오직 하나의 액터에 의해서만 변경되어야 한다.
이를 통해 코드의 모듈성과 유지보수성이 향상된다.
잘못된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class User: def __init__(self, name): self.name = name def get_name(self): return self.name def save(self): # 데이터베이스에 사용자 정보를 저장하는 로직 pass def send_email(self, message): # 이메일을 보내는 로직 pass # 주석: 이 클래스는 사용자 정보 관리, 데이터베이스 저장, 이메일 발송 등 # 여러 책임을 가지고 있어 SRP를 위반합니다. 변경 사유가 여러 개 발생할 수 있습니다. 잘된 예 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class User: def __init__(self, name): self.name = name def get_name(self): return self.name class UserRepository: def save(self, user): # 데이터베이스에 사용자 정보를 저장하는 로직 pass class EmailService: def send_email(self, user, message): # 이메일을 보내는 로직 pass # 주석: 각 클래스가 단일 책임을 가지도록 분리되어 SRP를 준수합니다. # User 클래스는 사용자 정보만 관리하고, UserRepository는 저장을, # EmailService는 이메일 발송만 담당합니다. 각 기능의 변경이 다른 클래스에 영향을 주지 않습니다. 개방-폐쇄 원칙 (Open-Closed Principle, OCP) 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
기존 코드를 수정하기보다는 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다는 의미이다.
주로 상속이나 구성을 통해 달성되며, 안정적이고 오류가 적은 코드베이스를 만든다.
...</p></div><footer class=entry-footer><span title='2024-09-23 00:57:00 +0000 UTC'>September 23, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;923 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SOLID Principles" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-principles/solid-principles/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동시성 프로그래밍 (Concurrency Programming)</h2></header><div class=entry-content><p>동시성 프로그래밍 (Concurrency Programming) 동시성 프로그래밍은 여러 작업을 동시에 수행할 수 있도록 프로그램을 설계하는 기법.
이는 시스템의 효율성을 높이고 처리 시간을 줄이는 데 중점을 둔다.
특징 여러 작업의 실행 흐름을 겹치게 하거나 병렬로 처리 멀티스레딩, 멀티프로세싱, 비동기 프로그래밍 등의 기법 사용 사용 사례 웹 서버: 여러 사용자의 요청을 동시에 처리 데이터베이스 시스템: 다수의 쿼리를 병렬로 처리 UI 애플리케이션: 백그라운드 작업 수행 중 사용자 인터페이스 응답성 유지 장점 시스템 자원의 효율적 사용 응답성 향상 처리량 증가 성능 최적화 단점 코드 복잡성 증가 디버깅 어려움 동기화 문제 (Race Condition, Deadlock 등) 성능 오버헤드 가능성 고려사항 동기화 메커니즘: 적절한 락(Lock) 사용 데드락 방지 공유 자원 보호 성능 최적화: 스레드 풀 크기 조정 작업 크기 최적화 메모리 사용량 관리 오류 처리: 예외 처리 전략 실패 복구 메커니즘 타임아웃 설정 구현시 주의사항 상태 관리:
...</p></div><footer class=entry-footer><span title='2024-09-22 23:42:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;800 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동시성 프로그래밍 (Concurrency Programming)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/concurrency-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Class and Instance</h2></header><div class=entry-content><p>Class and Instance 클래스(Class)
객체를 생성하기 위한 템플릿 또는 청사진 관련된 속성(변수)과 메서드(함수)를 그룹화한 것 데이터와 해당 데이터를 처리하는 메서드를 포함 인스턴스(Instance)
클래스를 기반으로 생성된 실제 객체 클래스의 속성과 메서드를 상속받아 실제로 메모리에 할당된 것 각 인스턴스는 고유한 속성값을 가질 수 있음 1 2 3 4 5 6 7 8 class Car: # 클래스 정의 def __init__(self, brand, model): self.brand = brand self.model = model # 인스턴스 생성 car1 = Car("Toyota", "Camry") # car1은 Car 클래스의 인스턴스 car2 = Car("Honda", "Civic") # car2는 Car 클래스의 인스턴스 클래스와 인스턴스의 특징 클래스의 특징 클래스 변수
...</p></div><footer class=entry-footer><span title='2024-09-22 12:38:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;647 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Class and Instance" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/class-and-instance/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>다형성 (Polymorphism)</h2></header><div class=entry-content><p>다형성 (Polymorphism) 다형성(Polymorphism)은 객체지향 프로그래밍의 핵심 특징 중 하나로, “여러 가지 형태를 가질 수 있는 능력"을 의미한다. 하나의 객체가 여러 가지 타입을 가질 수 있거나, 동일한 동작이 다양한 방식으로 실행될 수 있는 것을 말한다.
다형성의 본질은 “하나의 인터페이스, 다양한 구현"이다. 마치 리모컨이라는 하나의 인터페이스로 TV, 에어컨, 음향기기 등 다양한 기기를 제어할 수 있는 것과 같다.
실생활 예시 키보드의 Enter 키를 생각해보면 다형성을 쉽게 이해할 수 있다:
텍스트 편집기에서는 새로운 줄을 만든다 대화창에서는 메시지를 전송한다 웹 브라우저의 주소창에서는 페이지를 로드한다 같은 Enter 키지만, 상황에 따라 다른 동작을 수행하는 것이 바로 다형성의 예시이다.
...</p></div><footer class=entry-footer><span title='2024-09-22 10:25:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;784 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 다형성 (Polymorphism)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/polymorphism/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>상속 (Inheritance)</h2></header><div class=entry-content><p>상속 (Inheritance) 상속은 객체지향 프로그래밍의 핵심 특징 중 하나로, 기존 클래스의 특성을 다른 클래스가 물려받아 재사용하고 확장할 수 있게 해주는 메커니즘이다.
이를 통해 코드의 재사용성을 높이고 계층적인 관계를 구현할 수 있다.
상속을 사용할 때 가장 중요한 세 가지 원칙이 있다:
IS-A 관계 확인: 자식 클래스는 반드시 부모 클래스의 한 종류여야 한다. “고양이는 동물이다"는 성립하지만, “자동차는 엔진이다"는 성립하지 않는다. 기능의 확장: 자식 클래스는 부모 클래스의 기능을 물려받아 확장하는 것이 목적이다. 기존 기능을 제한하거나 완전히 다른 의미로 변경하는 것은 좋지 않다. 적절한 캡슐화: protected 접근 제어자를 통해 상속 관계에서만 접근 가능한 멤버를 적절히 설계해야 한다. 상속의 의미 상속을 통해 우리는 다음과 같은 이점을 얻을 수 있다:
...</p></div><footer class=entry-footer><span title='2024-09-22 10:10:00 +0000 UTC'>September 22, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;818 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 상속 (Inheritance)" href=https://buenhyden.github.io/posts/software-design-and-architecture/programming-paradigms/oop/inheritance/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/58/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/60/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>