<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.145.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.9a2bbe2d8b5afa9d4df22976abb7b72f1f7f1c467d2b30f03090108f9496ae6c.css integrity="sha256-miu+LYta+p1N8il2q7e3Lx9/HEZ9KzDwMJAQj5SWrmw=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>쿼리 최적화 (Query Optimization)</h2></header><div class=entry-content><p>쿼리 최적화 (Query Optimization) 데이터베이스 쿼리 최적화는 데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 중요한 프로세스이다.
쿼리 최적화의 목적 쿼리 응답 시간 단축 시스템 자원 사용 효율성 증대 전반적인 데이터베이스 성능 향상 사용자 경험 개선 주요 최적화 기법 인덱스 최적화 적절한 인덱스 생성 및 관리 복합 인덱스 활용 선택도가 높은 컬럼에 인덱스 생성 불필요한 인덱스 제거 1 2 3 4 5 6 7 8 9 -- 자주 사용되는 조건절에 대한 인덱스 생성 CREATE INDEX idx_orders_amount_date ON orders(total_amount, order_date); -- 위 인덱스를 활용하는 최적화된 쿼리 SELECT customers.name, orders.order_date, orders.total_amount FROM orders -- 인덱스를 가진 테이블을 먼저 참조 JOIN customers ON customers.id = orders.customer_id WHERE orders.total_amount > 1000 ORDER BY orders.order_date DESC; 쿼리 재작성 복잡한 쿼리 단순화 서브쿼리 최소화 및 조인으로 대체 WHERE 절 최적화 필요한 컬럼만 선택 (SELECT *) 테이블 조인 순서와 조인 유형을 적절히 선택 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 비효율적인 서브쿼리 SELECT * FROM customers WHERE id IN ( SELECT customer_id FROM orders WHERE total_amount > 1000 ); -- 더 효율적인 조인으로 변환 SELECT DISTINCT c.* FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.total_amount > 1000; 실행 계획 분석 쿼리 실행 계획 확인 및 분석 비효율적인 실행 계획 개선 쿼리 실행 계획은 데이터베이스가 쿼리를 어떻게 처리할지를 보여주는 로드맵과 같다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:23:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;510 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 쿼리 최적화 (Query Optimization)" href=https://buenhyden.github.io/posts/databases/rdbms/sql/indexes/query-optimization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>데이터베이스 최적화 (Database Optimization)</h2></header><div class=entry-content><p>데이터베이스 최적화 (Database Optimization) 데이터베이스 최적화(Database Optimization)는 데이터베이스 시스템의 성능을 향상시키고 효율성을 높이기 위한 다양한 기법과 프로세스를 의미한다.
데이터베이스 최적화의 목적 쿼리 응답 시간 단축 시스템 자원 사용 효율성 증대 데이터베이스의 전반적인 성능 향상 사용자 경험 개선 주요 최적화 기법 인덱스 최적화 적절한 인덱스 생성으로 데이터 검색 속도 향상 자주 사용되는 컬럼에 인덱스 적용 불필요한 인덱스 제거로 오버헤드 감소 1 2 3 4 5 -- 카디널리티가 높은 컬럼에 인덱스 생성 CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date); -- 조건절에 자주 사용되는 컬럼 조합에 대한 인덱스 CREATE INDEX idx_products_category_price ON products(category_id, price); 불필요한 인덱스 제거도 중요하다.
...</p></div><footer class=entry-footer><span title='2024-10-22 06:12:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;493 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 데이터베이스 최적화 (Database Optimization)" href=https://buenhyden.github.io/posts/databases/more-about-databases/database-optimization/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>SingleStore</h2></header><div class=entry-content><p>SingleStore https://www.singlestore.com/blog/singlestore-connect-for-real-time-enterprises/
참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-22 03:58:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to SingleStore" href=https://buenhyden.github.io/posts/databases/rdbms/singlestore/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event Broker</h2></header><div class=entry-content><p>Event Broker Event Broker는 이벤트 기반 아키텍처(Event-Driven Architecture, EDA)의 핵심 구성 요소로, 이벤트 생성자(Producer)와 이벤트 소비자(Consumer) 사이에서 중개자 역할을 수행한다.
Source: https://developer.confluent.io/patterns/event-stream/event-broker/
주요 기능 이벤트 수집 및 라우팅: 이벤트 생성자로부터 이벤트를 수집하고, 적절한 이벤트 소비자에게 전달한다. 이벤트 저장: 수신한 이벤트를 영구적으로 저장하여, 필요시 재처리나 분석이 가능하도록 한다. 실시간 처리: 대규모의 이벤트 데이터를 실시간으로 처리할 수 있는 능력을 제공한다. 순서 보장: 이벤트의 발생 순서를 유지하여 처리할 수 있도록 지원한다. 확장성 제공: 시스템의 확장에 따라 유연하게 대응할 수 있는 구조를 제공한다. Event Broker의 장점 시스템 분리 (Decoupling)
...</p></div><footer class=entry-footer><span title='2024-10-21 06:28:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;532 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/event-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Message Broker</h2></header><div class=entry-content><p>Message Broker Message Broker는 소프트웨어 애플리케이션, 시스템 및 서비스 간의 통신을 가능하게 하는 중간 소프트웨어 모듈.
애플리케이션 간 통신을 중재하여 상호 의존성을 최소화한다.
Message Broker는 현대적인 분산 시스템과 마이크로서비스 아키텍처에서 중요한 역할을 하며, 시스템 간 효율적인 통신과 데이터 교환을 가능하게 한다.
Source: https://ademcatamak.medium.com/what-is-message-broker-4f6698c73089
주요 기능 메시지 라우팅: 하나 이상의 목적지로 메시지를 전달합니다. 메시지 변환: 다른 형식으로 메시지를 변환합니다. 메시지 집계 및 분해: 여러 메시지를 하나로 결합하거나 하나의 메시지를 여러 개로 분할합니다. 외부 저장소와 상호 작용: 메시지 저장 또는 보강을 위해 외부 저장소를 사용합니다. 웹 서비스 호출: 데이터 검색을 위해 웹 서비스를 호출합니다. 이벤트 및 오류 응답: 특정 이벤트나 오류에 대응합니다. 장점 서비스 간 결합도 감소: 애플리케이션 간 직접적인 의존성을 줄입니다. 확장성 향상: 새로운 서비스나 기능을 쉽게 추가할 수 있습니다. 신뢰성 제공: 메시지 지속성과 보장된 전달을 제공합니다. 비동기 통신 지원: 송신자가 수신자의 응답을 기다릴 필요가 없습니다. 유형 점대점(Point-to-Point) 브로커 메시지가 하나의 생산자에서 하나의 소비자로 직접 전달되는 방식
...</p></div><footer class=entry-footer><span title='2024-10-21 05:38:00 +0000 UTC'>October 21, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1096 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Message Broker" href=https://buenhyden.github.io/posts/backend/event-broker-and-message-broker/message-broker/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>폴링(Polling)</h2></header><div class=entry-content><p>폴링(Polling) 폴링(Polling)은 소프트웨어 개발에서 중요한 통신 기법으로, 클라이언트가 주기적으로 서버에 데이터나 상태 변경을 요청하는 방식이다.
이 방법은 실시간 또는 준실시간 업데이트가 필요한 애플리케이션에서 자주 사용된다.
폴링의 작동 원리 클라이언트가 서버에 주기적으로 요청을 보낸다. 서버는 요청을 받아 처리하고 응답을 반환한다. 클라이언트는 응답을 받아 필요한 작업을 수행한다. 일정 시간 후 클라이언트는 다시 요청을 보낸다. 이 과정은 지속적으로 반복된다.
폴링의 장점 구현의 용이성: 폴링은 상대적으로 간단하게 구현할 수 있다. 호환성: 대부분의 환경과 기술에서 사용 가능하다. 요청 빈도 제어: 개발자가 요청 주기를 조절할 수 있어 유연성이 높다. 비실시간 업데이트에 적합: 즉각적인 업데이트가 필요하지 않은 경우에 효과적이다. 폴링의 단점 서버 부하: 불필요한 요청으로 인해 서버에 부담을 줄 수 있다. 실시간성 부족: 폴링 주기에 따라 실시간 업데이트가 지연될 수 있다. 리소스 낭비: 변경사항이 없어도 지속적으로 요청을 보내므로 리소스가 낭비될 수 있다. 폴링의 사용 사례 이메일 클라이언트: 새 메일 확인을 위해 주기적으로 서버에 요청을 보낸다. 주식 시세 모니터링: 일정 간격으로 최신 주가 정보를 요청한다. 소셜 미디어 피드: 새로운 게시물이나 알림을 확인하기 위해 사용된다. IoT 디바이스 모니터링: 센서 데이터를 주기적으로 확인한다. 폴링의 구현 폴링은 주로 JavaScript의 setInterval() 함수나 setTimeout() 함수를 사용하여 구현한다.
예를 들어:
...</p></div><footer class=entry-footer><span title='2024-10-20 16:50:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;245 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 폴링(Polling)" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/webhooks-vs-polling/polling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AMQP</h2></header><div class=entry-content><p>AMQP(Advanced Message Queuing Protocol) AMQP(Advanced Message Queuing Protocol)는 메시지 지향 미들웨어를 위한 개방형 표준 응용 계층 프로토콜이다.
이 프로토콜은 클라이언트와 미들웨어 브로커 간의 데이터 교환을 위해 설계되었다.
주요 기능으로는 메시지 지향, 큐잉, 라우팅(포인트-투-포인트 및 발행-구독), 신뢰성, 보안 등을 포함한다.
AMQP는 2003년 런던의 JP모간 체이스에서 John O’Hara에 의해 시작되었다. 메시지 지향 미들웨어의 표준화를 통해 시스템 간 통신을 개선하려는 목표로 개발되었으며, 이후 오픈 소스 프로젝트로 전환되어 다양한 시스템과 플랫폼에서 사용되고 있다.
https://www.linkedin.com/pulse/advanced-message-queuing-protocol-amqp-%CA%8Cs%C6%95raf-%CA%8C%C9%AF%C9%AFa%C8%A1-/
...</p></div><footer class=entry-footer><span title='2024-10-20 05:01:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;398 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to AMQP" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/messaging-protocol/amqp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MQTT</h2></header><div class=entry-content><p>MQTT(Message Queuing Telemetry transport) MQTT(Message Queuing Telemetry Transport)는 IoT 환경에서 널리 사용되는 경량 메시징 프로토콜이다.
1999년 IBM의 Andy Stanford-Clark와 Arlen Nipper에 의해 원격 유전의 SCADA 시스템 모니터링을 위해 처음 개발되었으며, 현재는 OASIS 표준 및 ISO/IEC 20922로 지정되어 있다.
주요 특징 경량성: 작은 코드 공간과 최소한의 네트워크 대역폭을 사용한다. 발행/구독(Publish/Subscribe) 모델: 메시지 브로커를 통해 발행자와 구독자 간 통신을 중개한다. QoS(Quality of Service): 세 가지 수준의 메시지 전달 품질을 제공한다. QoS 0: 최대 1회 전송 (Fire and Forget) QoS 1: 최소 1회 전송 QoS 2: 정확히 1회 전송 토픽 기반 통신: 계층적 구조의 토픽을 사용하여 효율적인 메시지 라우팅을 지원한다. 연결 유지(Keep-Alive): 클라이언트 상태를 모니터링하고 비정상 연결 해제를 감지할 수 있다. MQTT 구성 요소 브로커(Broker): 메시지를 중계하는 서버 역할을 한다. 발행자(Publisher): 특정 토픽으로 메시지를 발행한다. 구독자(Subscriber): 관심 있는 토픽의 메시지를 구독한다. MQTT의 동작 원리 연결 수립: 클라이언트는 브로커와 TCP/IP를 통해 연결을 설정한다. 메시지 발행: 발행자(Publisher)는 특정 주제에 메시지를 발행한다. 메시지 전달: 브로커는 해당 주제를 구독한 모든 구독자(Subscriber)에게 메시지를 전달한다. 연결 종료: 클라이언트는 필요에 따라 브로커와의 연결을 종료할 수 있다. MQTT 브로커 종류 Mosquitto: 경량, 오픈소스, 다양한 플랫폼 지원 EMQ: 분산 아키텍처, 높은 확장성, 대규모 연결 지원 HiveMQ: 높은 성능, 클러스터링 지원, 엔터프라이즈 환경에 적합 RabbitMQ: AMQP와 MQTT 모두 지원, 다양한 플러그인 제공 MQTT의 활용 분야 MQTT는 경량성과 효율성으로 인해 IoT, 모바일 애플리케이션, 센서 네트워크, 원격 모니터링 등 다양한 분야에서 활용되고 있다. 특히 제한된 대역폭과 전력 자원을 가진 환경에서의 통신에 적합하다.
...</p></div><footer class=entry-footer><span title='2024-10-20 04:46:00 +0000 UTC'>October 20, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;230 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to MQTT" href=https://buenhyden.github.io/posts/networking-knowledge/network-protocols/messaging-protocol/mqtt/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HATEOAS (Hypermedia As The Engine Of Application State)</h2></header><div class=entry-content><p>HATEOAS (Hypermedia As The Engine Of Application State) 서버가 클라이언트에게 하이퍼 미디어를 통해 정보를 동적으로 제공해주는 것을 말한다.
RESTful API 설계의 중요한 개념으로, 클라이언트와 서버 간의 동적이고 유연한 상호작용을 가능하게 하는 방식.
하이퍼미디어를 애플리케이션의 상태를 관리하기 위한 메커니즘으로 사용한다. 이는 클라이언트가 서버와 동적으로 상호작용할 수 있도록 하며, API 응답에 관련 리소스에 대한 링크를 포함시키는 방식으로 구현된다.
전통적인 API와 HATEOAS API의 차이점 기존 API:
1 2 3 4 5 { "orderId": "123", "total": 100, "status": "pending" } HATEOAS API:
...</p></div><footer class=entry-footer><span title='2024-10-19 07:35:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;698 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to HATEOAS (Hypermedia As The Engine Of Application State)" href=https://buenhyden.github.io/posts/backend/api-design/api-styles/restful-api/hateoas/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>웹훅 (Webhook)</h2></header><div class=entry-content><p>웹훅 (Webhook) 웹훅은 웹 애플리케이션에서 특정 이벤트가 발생했을 때 다른 애플리케이션에 실시간으로 정보를 전달하는 방법이다.
쉽게 말해, 어떤 일이 일어났을 때 자동으로 알림을 보내는 시스템이라고 생각하면 된다.
웹훅의 작동 원리 애플리케이션 A가 특정 URL(콜백 URL)을 애플리케이션 B에 등록한다. 애플리케이션 B에서 중요한 이벤트가 발생한다. 애플리케이션 B는 등록된 URL로 HTTP POST 요청을 보낸다. 애플리케이션 A는 이 요청을 받아 필요한 작업을 수행한다. 웹훅의 장점 실시간 업데이트: 이벤트 발생 즉시 알림을 받을 수 있다. 효율성: 필요할 때만 통신하므로 리소스 사용이 적다. 자동화: 이벤트에 따른 작업을 자동으로 처리할 수 있다. 웹훅의 단점 보안 문제: 콜백 URL이 노출될 경우 악의적인 요청을 받을 수 있다. 신뢰성: 네트워크 문제로 알림이 손실될 수 있다. 단방향 통신: 서버에서 클라이언트로의 통신만 가능하다. 웹훅의 사용 사례 결제 시스템: 결제 완료 시 즉시 알림 소셜 미디어: 새 게시물 작성 시 연동 서비스에 알림 버전 관리 시스템: 코드 변경 시 자동 빌드 시작 IoT: 센서 데이터가 특정 값을 초과할 때 알림 웹훅 구현 시 주의사항 보안: 요청의 출처를 반드시 확인해야 한다. 에러 처리: 네트워크 문제 등으로 인한 실패에 대비해야 한다. 재시도 메커니즘: 전송 실패 시 재시도 로직을 구현해야 한다. 참고 및 출처</p></div><footer class=entry-footer><span title='2024-10-19 06:46:00 +0000 UTC'>October 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;178 words&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 웹훅 (Webhook)" href=https://buenhyden.github.io/posts/backend/api-design/api-integration-patterns/webhooks-vs-polling/webhook/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/47/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/49/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>