<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Spanning Tree</h2></header><div class=entry-content><p>스패닝 트리(Spanning Tree) 스패닝 트리(Spanning Tree) 는 무방향 그래프(Undirected Graph)의 모든 정점을 포함하면서, 사이클 없이 연결된 부분 그래프이다. 다시 말해, 원래 그래프의 모든 정점을 최소한의 간선으로 연결한 트리 구조이다.
신장 트리는 그래프 이론의 핵심 개념으로, 다양한 실제 문제 해결에 활용된다.
최소 신장 트리 알고리즘인 크루스칼, 프림, 보로프카는 각각 다른 상황에서 최적의 성능을 보이며, 알고리즘 선택은 그래프의 특성과 문제 요구사항에 따라 달라진다.
신장 트리의 응용은 네트워크 설계, 클러스터링, 이미지 처리 등 다양한 분야에 걸쳐 있으며, 그 변형과 확장은 더 복잡한 문제를 해결하는 데 도움이 된다. 최적화 기법과 효율적인 자료구조를 활용하면 대규모 그래프에서도 신장 트리를 효과적으로 계산할 수 있다.
...</p></div><footer class=entry-footer><span title='2025-01-18 03:05:00 +0000 UTC'>January 18, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Spanning Tree" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/trees/overview/spanning-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>무방향 그래프(Undirected Graph)</h2></header><div class=entry-content><p>무방향 그래프(Undirected Graph) 무방향 그래프(Undirected Graph) 는 각 간선(Edge)에 방향성이 없는 그래프이다.
즉, 정점 A와 정점 B가 간선으로 연결되어 있으면, A에서 B로 가는 것과 B에서 A로 가는 것이 동일하다.
무방향 그래프 특징 간선이 양방향(↔)으로 연결됨 정점 간 이동에 방향성이 없음 정점의 차수(Degree)는 해당 정점과 연결된 간선의 개수 DFS(깊이 우선 탐색), BFS(너비 우선 탐색) 등의 알고리즘이 적용 가능 연결 그래프(Connected Graph)와 비연결 그래프(Disconnected Graph) 개념 적용 가능 무방향 그래프의 표현 방법 1 2 3 A — B | | C — D A - B (A와 B는 서로 연결됨) A - C (A와 C는 서로 연결됨) B - D (B와 D는 서로 연결됨) C - D (C와 D는 서로 연결됨) 무방향 그래프의 인접 행렬(Adjacency Matrix) 표현 A B C D A 0 1 1 0 B 1 0 0 1 C 1 0 0 1 D 0 1 1 0 설명
...</p></div><footer class=entry-footer><span title='2025-01-18 03:05:00 +0000 UTC'>January 18, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 무방향 그래프(Undirected Graph)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/graphs/graph-types/directed-undirected/undirected-graph/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>방향 그래프(Directed Graph)</h2></header><div class=entry-content><p>방향 그래프(Directed Graph) 방향 그래프(Directed Graph, Digraph) 는 각 간선(Edge)에 방향성이 부여된 그래프이다.
즉, 간선이 단방향이므로 A → B 는 이동할 수 있지만 B → A 로는 이동할 수 없다.
방향 그래프는 일방향 관계가 있는 다양한 시스템을 모델링할 수 있다.
웹, 사회 연결망, 컴퓨터 시스템, 생물학적 네트워크 등 다양한 분야에서 방향 그래프를 활용한 알고리즘과 모델이 개발되고 있다.
방향 그래프 특징 간선이 한 방향(→)으로만 연결됨 단방향 관계를 표현할 때 사용 (예: 팔로우 관계, 웹 페이지 링크) 진입 차수(In-degree)와 진출 차수(Out-degree) 개념이 존재 진입 차수(In-degree): 해당 정점으로 들어오는 간선의 개수 진출 차수(Out-degree): 해당 정점에서 나가는 간선의 개수 방향 그래프의 표현 방법 방향 그래프 예시
...</p></div><footer class=entry-footer><span title='2025-01-18 03:05:00 +0000 UTC'>January 18, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 방향 그래프(Directed Graph)" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/data-structures/non-linear-structures/graphs/graph-types/directed-undirected/directed-graph/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Modin</h2></header><div class=entry-content><p>Modin Modin은 pandas를 대체할 수 있는 고성능 데이터프레임 라이브러리.
주요 특징 Pandas API 호환성: pandas와 거의 동일한 API를 제공하여 기존 코드를 쉽게 마이그레이션할 수 있다. 병렬 처리: 다중 코어를 활용하여 데이터 처리 속도를 크게 향상시킨다. 분산 컴퓨팅: Ray, Dask, Unidist 등 다양한 백엔드를 지원하여 분산 환경에서 실행할 수 있다. 대용량 데이터 처리: 메모리 크기를 초과하는 대규모 데이터셋도 효율적으로 처리할 수 있다. 쉬운 사용법: pandas import 문을 modin으로 변경하는 것만으로 사용 가능하다. 성능 향상 4코어 노트북에서 최대 4배 속도 향상 대규모 데이터셋(~1TB+)에서도 효율적으로 작동 메모리 사용량 최적화로 pandas보다 2-4배 적은 RAM 사용 사용 예시 1 2 3 4 import modin.pandas as pd df = pd.read_csv("large_dataset.csv") result = df.groupby("column").mean() 장점 간편한 사용: pandas 코드를 그대로 사용 가능 확장성: 단일 머신에서 클러스터까지 확장 가능 메모리 효율성: 대용량 데이터 처리에 적합 다양한 백엔드 지원: Ray, Dask, MPI 등 선택 가능 제한사항 pandas API의 90% 정도만 지원 (지속적으로 확장 중) 일부 고급 기능에서는 pandas로 폴백되어 성능 저하 가능성 Modin은 대규모 데이터 분석, 머신러닝 파이프라인, 데이터 전처리 등 다양한 분야에서 활용될 수 있으며, pandas의 성능 한계를 극복하고자 하는 데이터 과학자들에게 유용한 도구이다.
...</p></div><footer class=entry-footer><span title='2025-01-17 07:13:00 +0000 UTC'>January 17, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Modin" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/library/data-analysis/modin/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dask</h2></header><div class=entry-content><p>Dask Dask는 파이썬을 위한 유연한 병렬 컴퓨팅 라이브러리.
대규모 데이터 처리와 복잡한 계산을 효율적으로 수행할 수 있도록 설계되었다.
주요 특징 대규모 데이터셋 처리: Dask는 메모리에 들어가지 않는 매우 큰 데이터셋을 처리할 수 있다. 병렬 및 분산 컴퓨팅: 복잡한 병렬 알고리즘을 쉽게 작성할 수 있으며, 여러 머신에 걸쳐 작업을 분산시킬 수 있다. 지연 실행(lazy execution): 작업을 즉시 실행하지 않고, 계산 그래프를 구성하여 최적화하고 효율적으로 실행한다. NumPy, Pandas, Scikit-Learn과의 호환성: 이러한 라이브러리들의 대규모 데이터셋에 대한 확장된 버전을 제공한다. 동적 작업 스케줄링: 계산 작업을 동적으로 스케줄링하여 리소스 사용을 최적화한다. 장점 pandas와 유사한 API로 사용이 쉬움 대용량 데이터 처리에 효율적 병렬 처리를 통한 빠른 연산 속도 단점 복잡한 연산 시.compute() 함수 사용으로 인한 시간 소요 일부 고급 기능에서는 제한적일 수 있음 Dask의 구성 Dask는 크게 세 부분으로 구성되어 있다:
...</p></div><footer class=entry-footer><span title='2025-01-17 07:12:00 +0000 UTC'>January 17, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Dask" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/library/data-analysis/dask/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Polars</h2></header><div class=entry-content><p>Polars Polars는 고성능 데이터 처리를 위해 설계된 파이썬 DataFrame 라이브러리.
Rust로 작성된 핵심 엔진을 기반으로 하여 빠른 속도와 효율성을 제공한다.
주요 특징 높은 성능: Rust로 작성되어 메모리 최적화와 병렬 처리를 통해 대규모 데이터셋을 빠르게 처리한다. 직관적인 API: 사용자 친화적인 문법으로 데이터 조작 작업을 쉽게 수행할 수 있다. 지연 평가(Lazy Evaluation): 쿼리 최적화를 통해 효율적인 실행 계획을 수립한다. Apache Arrow 기반: 컬럼 기반 데이터 형식을 사용하여 벡터화된 쿼리 처리가 가능하다. GPU 지원: NVIDIA GPU를 활용한 고성능 in-memory 작업을 지원한다. 장점 속도: pandas보다 10-100배 빠른 성능을 보여준다. 메모리 효율성: pandas에 비해 2-4배 적은 RAM을 사용한다. 확장성: 대규모 데이터셋 처리에 적합하다. 병렬 처리: 여러 CPU 코어를 자동으로 활용한다. 유연한 실행 모드: 즉시 실행(eager execution)과 지연 실행(lazy execution)을 모두 지원한다. 사용 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 import polars as pl # DataFrame 생성 df = pl.DataFrame({ "A": [1, 2, 3, 4, 5], "B": ["a", "b", "c", "d", "e"] }) # 데이터 필터링 filtered_df = df.filter(pl.col("A") > 2) # 그룹화 및 집계 result = df.groupby("B").agg(pl.col("A").sum()) Polars는 대규모 데이터 처리, 고성능 분석 작업, 그리고 실시간 데이터 처리가 필요한 프로젝트에 특히 적합하다.
pandas와 유사한 문법을 제공하면서도 더 나은 성능을 제공하여, 데이터 과학자들과 분석가들 사이에서 인기를 얻고 있다.
...</p></div><footer class=entry-footer><span title='2025-01-17 07:12:00 +0000 UTC'>January 17, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Polars" href=https://buenhyden.github.io/posts/programming-and-development/programming-languages/core-languages/python/library/data-analysis/polars/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Greedy Algorithm vs. Divide and Conquer</h2></header><div class=entry-content><p>Divide and Conquer vs. Greedy Algorithm “Divide and Conquer"와 “Greedy Algorithm"은 문제 해결을 위한 두 가지 중요한 알고리즘 패러다임이다.
분할 정복은 문제를 더 작은 하위 문제로 나누어 해결하는 체계적인 접근 방식인 반면, 탐욕 알고리즘은 각 단계에서 지역적 최적 선택을 통해 문제를 해결하는 직관적인 접근 방식이다.
분할 정복은 정확한 최적해를 보장하지만 구현이 복잡할 수 있고, 탐욕 알고리즘은 구현이 간단하고 효율적이지만 항상 최적해를 보장하지는 않는다. 문제의 특성을 잘 이해하고 적절한 알고리즘을 선택하는 것이 중요하다.
...</p></div><footer class=entry-footer><span title='2024-12-28 10:55:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Greedy Algorithm vs. Divide and Conquer" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/problem-solving-techniques/fundamental-paradigms/greedy-algorithm/greedy-algorithm-vs-divide-and-conquer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Deterministic vs. Nondeterministic computation</h2></header><div class=entry-content><p>Deterministic vs. Nondeterministic Computation 결정론적 계산과 비결정론적 계산은 계산 이론의 두 가지 근본적인 접근 방식을 나타낸다.
결정론적 계산은 현대 컴퓨터의 기반이 되는 예측 가능하고 명확한 모델을 제공하는 반면, 비결정론적 계산은 이론적으로 더 강력한 계산 모델의 가능성을 탐구한다.
이론적으로는 결정론적 튜링 기계와 비결정론적 튜링 기계가 동일한 문제들을 해결할 수 있지만, 효율성 측면에서는 큰 차이가 있을 수 있다.
P = NP 문제는 이러한 효율성 차이가 본질적인 것인지, 아니면 단지 현재 알고리즘의 한계인지를 묻는 근본적인 질문이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Deterministic vs. Nondeterministic computation" href=https://buenhyden.github.io/posts/data-structures-and-algorithms/fundamentals/basic-concepts/computational-models/deterministic-vs-nondeterministic-computation/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>P vs NP problem</h2></header><div class=entry-content><p>P vs. NP Problem P vs NP 문제는 컴퓨터 과학, 특히 계산 복잡도 이론에서 가장 중요한 미해결 문제 중 하나이다.
이 문제는 단순히 이론적인 호기심을 넘어, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미치는 근본적인 질문이다.
P vs NP 문제는 단순히 이론적인 호기심을 넘어 컴퓨터 과학의 근본적인 문제이며, 암호학, 최적화, 인공지능 등 다양한 분야에 깊은 영향을 미친다. 이 문제가 해결되면(어느 쪽으로든) 컴퓨터 과학에 혁명적인 변화를 가져올 것이다.
P ≠ NP로 증명된다면, 이는 많은 중요한 문제들이 본질적으로 효율적인 알고리즘이 존재하지 않음을 의미하며, 따라서 근사 알고리즘, 휴리스틱, 특수 케이스 등의 중요성이 더욱 커질 것이다.
...</p></div><footer class=entry-footer><span title='2024-12-27 08:29:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to P vs NP problem" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/p-vs-np-problem/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Non-deterministic Polynomial Time vs. Polynomial Time</h2></header><div class=entry-content><p>Non-deterministic Polynomial Time vs. Polynomial Time 계산 복잡도 이론에서 P와 NP는 가장 중요한 복잡도 클래스 중 두 가지로, 문제의 계산적 어려움을 분류하는 근본적인 개념이다.
이 두 클래스는 컴퓨터 과학의 발전 방향을 결정했으며, 현대 암호학과 알고리즘 설계의 이론적 토대를 형성했다.
P와 NP 클래스의 구분은 계산 복잡도 이론의 근간을 이루며, 어떤 문제가 효율적으로 해결 가능한지에 대한 근본적인 이해를 제공한다.
P 클래스 문제는 표준 컴퓨터로 효율적으로 해결할 수 있지만, NP 클래스의 많은 문제들(특히 NP-완전 문제들)은 현재 알려진 알고리즘으로는 효율적으로 해결할 수 없다.
...</p></div><footer class=entry-footer><span title='2024-12-27 01:03:00 +0000 UTC'>December 27, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Non-deterministic Polynomial Time vs. Polynomial Time" href=https://buenhyden.github.io/posts/computer-science-fundamentals/theoretical-foundations/computational-complexity/complexity-classes/classes/np-time/non-deterministic-polynomial-time-vs-polynomial-time/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/20/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/22/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>