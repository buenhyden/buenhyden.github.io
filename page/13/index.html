<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CCE vs CVE vs CWE</h2></header><div class=entry-content><p>CCE vs. CVE vs. CWE CCE, CVE, CWE는 모두 컴퓨터 시스템과 소프트웨어의 보안 취약점을 식별하고 분류하기 위한 표준화된 체계이다.
이 세 가지 개념은 각각 다른 측면의 보안 취약점을 다루고 있다.
구분 CCE (Common Configuration Enumeration) CVE (Common Vulnerabilities and Exposures) CWE (Common Weakness Enumeration) 정의 시스템 보안 구성 문제를 식별하고 추적하기 위한 표준 명명 체계 공개된 사이버 보안 취약점에 대한 표준 식별자 시스템 소프트웨어/하드웨어 보안 취약점의 유형을 분류하는 표준 목록 주요 목적 보안 구성 설정의 표준화된 참조 제공 특정 보안 취약점의 고유한 식별과 추적 취약점의 유형과 원인에 대한 분류 체계 제공 식별자 형식 CCE-XXXX-X CVE-YYYY-NNNNN CWE-XXX 사용 범위 시스템 구성 및 설정 특정 제품의 구체적 취약점 취약점의 유형과 분류 주요 내용 - 구성 매개변수
- 권장 설정 값
- 구성 지침 - 취약점 설명
- 영향받는 시스템
- 해결 방안 - 취약점 유형
- 원인과 결과
- 완화 방법 구조 특징 - 플랫폼별 구성 항목
- 기술적 메커니즘
- 검증 기준 - 타임라인 기반
- 영향도 평가
- 참조 정보 - 계층적 구조
- 다중 뷰
- 관계 정의 주요 활용 - 보안 구성 관리
- 컴플라이언스 점검
- 시스템 강화 - 취약점 관리
- 패치 관리
- 위험 평가 - 보안 설계
- 코드 리뷰
- 취약점 분석 관리 주체 NIST MITRE MITRE 업데이트 주기 새로운 구성 항목 발견 시 새로운 취약점 발견 시 정기적 업데이트 연관 표준 - SCAP
XCCDF
OVAL - CVSS
NVD
SCAP - CVE
CAPEC
SANS Top 25 주요 이점 - 구성 표준화
- 자동화 지원
- 감사 효율성 - 취약점 추적
- 명확한 의사소통
- 위험 관리 - 체계적 분류
- 원인 분석
- 예방 가이드 한계점 - 플랫폼 의존성
- 구성 복잡성
- 업데이트 지연 - 공개된 취약점만 포함
- 시간 지연
- 상세도 차이 - 추상적 성격
- 복잡한 분류
- 실제 적용 어려움 이러한 세 가지 표준은 각각 다른 관점에서 보안 취약점을 다루며, 서로 보완적인 관계를 가지고 있다.
...</p></div><footer class=entry-footer><span title='2024-11-07 07:53:00 +0000 UTC'>November 7, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to CCE vs CVE vs CWE" href=https://buenhyden.github.io/posts/security-engineering/security-attacks/security-vulnerability/management-frameworks/cce-vs-cve-vs-cwe/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ETL vs ELT</h2></header><div class=entry-content><p>ETL vs. ELT ELT(Extract, Load, Transform)와 ETL(Extract, Transform, Load)은 데이터 통합 및 처리를 위한 두 가지 주요 접근 방식이다. 각각의 단계 순서와 처리 방식에 차이가 있다.
https://www.striim.com/blog/etl-vs-elt-differences/
ETL (Extract, Transform, Load) ETL(Extract, Transform, Load)은 데이터 통합 및 처리를 위한 중요한 프로세스이다.
이 프로세스는 다양한 소스에서 데이터를 추출하고, 변환한 후 목표 시스템에 로드하는 세 단계로 구성된다.
ETL의 주요 단계 추출(Extract)
다양한 소스(데이터베이스, API, 로그 파일 등)에서 원시 데이터를 추출한다. 데이터는 구조화, 반구조화, 비구조화된 형태일 수 있다. 변환(Transform)
...</p></div><footer class=entry-footer><span title='2024-10-26 07:04:00 +0000 UTC'>October 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ETL vs ELT" href=https://buenhyden.github.io/posts/data-engineering/etl-and-elt-processes/etl-fundamentals/etl-vs-elt/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Software Architecture pattern vs Software Design Pattern</h2></header><div class=entry-content><p>Software Architecture Pattern and Software Design Pattern Software Architecture Pattern과 Software Design Pattern은 소프트웨어 개발에서 반복적으로 발생하는 문제들에 대한 검증된 해결책을 제공하는 개념이다.
이 두 패턴은 서로 다른 수준의 추상화와 범위를 다루고 있다.
비교 항목 Software Architecture Pattern Software Design Pattern 정의 소프트웨어 시스템의 전체적인 구조와 주요 컴포넌트 간의 관계를 정의하는 패턴 특정 설계 문제에 대한 일반적이고 재사용 가능한 해결책을 제공하는 패턴 범위 시스템 전체 또는 대규모 하위 시스템 개별 컴포넌트나 모듈 수준 추상화 수준 높은 수준의 추상화 상대적으로 낮은 수준의 추상화 목적 시스템의 전반적인 구조와 상호작용 정의 특정 설계 문제에 대한 해결책 제공 영향 전체 시스템의 성능, 확장성, 유지보수성에 영향 코드의 구조, 품질, 재사용성에 영향 예시 마이크로서비스, 레이어드 아키텍처, 이벤트 드리븐 아키텍처 싱글톤, 팩토리, 옵저버, 전략 패턴 적용 시점 시스템 설계 초기 단계 상세 설계 및 구현 단계 유연성 시스템 수준의 변경에 대한 유연성 제공 컴포넌트 수준의 변경에 대한 유연성 제공 재사용성 전체 시스템 구조의 재사용 특정 문제 해결 방식의 재사용 복잡성 시스템 전체의 복잡성 관리 특정 설계 문제의 복잡성 관리 문서화 시스템 아키텍처 다이어그램, 컴포넌트 명세 클래스 다이어그램, 시퀀스 다이어그램 주요 고려사항 확장성, 성능, 보안, 유지보수성 코드 재사용, 유연성, 결합도, 응집도 아키텍처 패턴은 시스템 전체의 구조와 관련된 더 큰 규모의 결정을 다루는 반면, 디자인 패턴은 특정 코드 수준의 문제를 해결하는 데 중점을 둔다.
...</p></div><footer class=entry-footer><span title='2024-09-27 08:19:00 +0000 UTC'>September 27, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Software Architecture pattern vs Software Design Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/software-architecture-pattern-vs-software-design-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>WCS(Warehouse Control System)</h2></header><div class=entry-content><p>WCS(Warehouse Control System) WCS(Warehouse Control System)는 물류 창고의 자동화 설비를 실시간으로 제어하고 관리하는 시스템이다.
WCS의 기본 개념을 먼저 이해해보면, 이는 마치 물류 창고의 ‘신경계’와 같은 역할을 한다.
컨베이어, 자동 적재 장비, 분류기 등 다양한 자동화 설비들을 통합적으로 제어하여 물류의 흐름을 원활하게 만든다.
WCS의 도입은 여러 가지 긍정적인 효과를 가져온다.
가장 큰 이점은 작업 효율성의 극대화이다.
자동화 설비들이 최적의 상태로 운영되므로, 물류 처리 속도가 빨라지고 오류가 줄어든다.
또한 실시간 모니터링을 통해 문제 상황에 신속하게 대응할 수 있어 다운타임을 최소화할 수 있다.
...</p></div><footer class=entry-footer><span title='2024-12-03 06:57:00 +0000 UTC'>December 3, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to WCS(Warehouse Control System)" href=https://buenhyden.github.io/posts/system-design/case-studies/warehouse-control-system/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Decompose by Business Capability vs Decompose by Subdomain</h2></header><div class=entry-content><p>Decompose by Business Capability vs. Decompose by Subdomain Decompose by Business Capability
정의: 비즈니스의 기능적 역량을 중심으로 시스템을 분해하는 방식으로, 조직의 주요 기능(예: 판매, 마케팅, 고객 서비스 등)에 따라 모듈을 나누는 방법. 특징: 비즈니스의 주요 역량을 중심으로 서비스나 모듈을 설계. 시스템의 경계가 기능적인 책임(Functional Responsibility)에 맞춰 설정됨. 기술적으로 독립적이고 명확한 책임 분리가 가능. 조직 구조와 자연스럽게 연계되므로 비즈니스와 IT의 연계성이 높아짐. 비즈니스의 장기적 확장성과 변화를 쉽게 수용할 수 있음. 예시: 주문 관리 시스템(Order Management System), 재고 관리 시스템(Inventory Management System) 등으로 분할. Decompose by Subdomain
...</p></div><footer class=entry-footer><span title='2024-11-13 01:13:00 +0000 UTC'>November 13, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Decompose by Business Capability vs Decompose by Subdomain" href=https://buenhyden.github.io/posts/software-design-and-architecture/architectural-patterns/microservices/decomposition/decompose-by-business-capability-vs-decompose-by-subdomain/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ER(Entity-Relationship) 모델링</h2></header><div class=entry-content><p>ER(Entity-Relationship) 모델링 ER 모델링은 현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현하여 데이터베이스의 구조를 설계하는 방법.
이를 통해 복잡한 데이터 구조를 시각적으로 표현하고 이해하기 쉽게 만든다.
![An entity–attribute-relationship diagram for an MMORPG using Chen’s notation](1024px-ER_Diagram_MMORPG.png “https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model#/media/File:ER_Diagram_MMORPG.png_
주요 구성 요소 개체(Entity)
개체는 데이터베이스에 저장하고자 하는 실제 대상을 나타낸다.
예를 들어, ‘학생’, ‘강좌’, ‘교수’ 등이 개체가 될 수 있다. 개체는 보통 사각형으로 표현된다.
예시:
학생 개체의 경우: 실체: 개별 학생들 표현: ‘학생’ 이라는 개체로 모델링 속성: 학번, 이름, 학과, 연락처 등 속성(Attribute)
속성은 개체의 특성이나 성질을 나타낸다.
타원형으로 표현되며, 개체와 선으로 연결된다.
속성의 종류: 단일값 속성: 하나의 값만 가지는 속성 (예: 학번) 다중값 속성: 여러 값을 가질 수 있는 속성 (예: 전화번호) 유도 속성: 다른 속성으로부터 계산되는 속성 (예: 나이) 키 속성: 개체를 유일하게 식별하는 속성 (예: 학번) 관계(Relationship)
관계는 개체들 간의 연관성을 나타낸다.
마름모 형태로 표현되며, 관련된 개체들과 선으로 연결된다.
관계의 종류: 일대일(1:1) 관계: 각 개체가 상대 개체와 최대 하나씩 연결 일대다(1:N) 관계: 한 개체가 여러 개의 다른 개체와 연결 다대다(N:M) 관계: 양쪽 개체 모두 여러 개의 상대 개체와 연결
관계 표현 예시: 1 2 3 4 5 [학생] ----&lt; 수강 >---- [강좌] | | (학번) (과목코드) (이름) (과목명) (학과) (학점) ER 모델링의 단계 요구사항 분석
시스템에서 필요한 데이터와 기능을 파악한다.
예: “대학 수강신청 시스템을 만들어야 한다. 학생들은 여러 강좌를 수강할 수 있으며…”
...</p></div><footer class=entry-footer><span title='2024-10-25 02:06:00 +0000 UTC'>October 25, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to ER(Entity-Relationship) 모델링" href=https://buenhyden.github.io/posts/backend-development/databases/fundamentals/data-modeling/entity-relationship/entity-relationship-modeling/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Mediator Pattern vs Observer Pattern</h2></header><div class=entry-content><p>Mediator Pattern Vs Observer Pattern Mediator 패턴과 Observer 패턴은 객체 간 통신을 관리하는 디자인 패턴이지만, 그 접근 방식과 용도에 차이가 있다.
Mediator 패턴:
객체 간의 복잡한 상호작용을 캡슐화하여 중재자 객체를 통해 간접적으로 통신하게 하는 패턴 객체 간 결합도를 낮추고 상호작용을 중앙 집중화함 복잡한 다대다 관계를 단순화하는 데 유용 Observer 패턴:
객체의 상태 변화를 관찰하는 관찰자들에게 자동으로 알리는 패턴 주체 객체와 다수의 관찰자 객체 간의 일대다 관계를 정의함 상태 변경에 대한 효율적인 알림 메커니즘을 제공 Mediator 패턴은 객체 간 복잡한 상호작용을 중재자를 통해 관리하여 객체 간의 결합도를 줄이고 상호작용 로직을 집중시키는 데 적합하다. Observer 패턴은 상태 변화에 따른 자동 알림 및 실시간 동기화를 구현할 때 적합하며, 이벤트 기반 시스템에 자주 사용된다. 두 패턴 모두 객체 간의 결합도를 낮추는 데 기여하지만, Mediator는 상호작용을 캡슐화하고 Observer는 상태 변경에 반응하는 방식으로 목적과 활용 분야가 다르다.
...</p></div><footer class=entry-footer><span title='2024-09-24 00:49:00 +0000 UTC'>September 24, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Mediator Pattern vs Observer Pattern" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns/mediator-pattern-vs-observer-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>System Test vs End-to-End Test</h2></header><div class=entry-content><p>System Test vs. End-to-End Test System Testing과 End-to-End Testing은 소프트웨어 테스팅 과정에서 사용되는 두 가지 중요한 테스트 방법이다. 이 두 방법은 소프트웨어의 품질을 보장하기 위해 사용되지만, 그 범위와 목적에 차이가 있다.
비교 항목 System Test End-to-End Test 정의 전체 시스템이 요구사항 명세서에 따라 정상적으로 동작하는지 검증하는 테스트 실제 사용자의 시나리오에 따라 처음부터 끝까지의 전체 비즈니스 프로세스를 검증하는 테스트 테스트 범위 시스템의 기능적/비기능적 요구사항 전체 사용자 관점에서의 전체 비즈니스 프로세스 흐름 수행 시점 통합 테스트 완료 후, 인수 테스트 전 모든 하위 단계 테스트 완료 후 최종 단계 테스트 환경 테스트 환경 (실제 환경과 유사하게 구성) 실제 운영 환경과 동일한 환경 테스트 주체 QA 팀, 테스트 엔지니어 QA 팀, 비즈니스 분석가, 때로는 실제 최종 사용자 검증 대상 시스템의 모든 기능, 성능, 보안 등 실제 사용자의 업무 흐름과 시나리오 테스트 데이터 테스트용 데이터 실제 운영 데이터와 유사한 데이터 테스트 관점 기술적 관점과 비즈니스 관점 모두 포함 순수하게 비즈니스 관점, 사용자 경험 중심 자동화 수준 중간~높음 낮음~중간 테스트 케이스 작성 기준 요구사항 명세서 기반 사용자 시나리오 기반 결함 발견 초점 시스템 내부의 기술적 결함 비즈니스 프로세스 상의 결함 테스트 비용 중간 높음 실행 시간 비교적 짧음 길음 (전체 프로세스 수행) 유지보수 복잡도 중간 높음 테스트 준비 사항 테스트 환경, 테스트 데이터, 테스트 케이스 전체 시스템 구성, 외부 시스템 연동, 실제 데이터 주요 목적 시스템의 완전성과 정확성 검증 비즈니스 프로세스의 정상 작동 검증 피드백 대상 개발팀, QA 팀 비즈니스 팀, 최종 사용자 커버리지 중점 기능 커버리지 비즈니스 프로세스 커버리지 이러한 차이점들은 각각의 테스트가 서로 다른 목적과 관점에서 수행되면서도 상호 보완적인 역할을 한다는 것을 보여준다.
System Test가 시스템의 기술적인 완성도를 검증하는 데 중점을 둔다면, End-to-End Test는 실제 사용자의 관점에서 전체 비즈니스 프로세스가 정상적으로 작동하는지를 검증하는 데 초점을 맞춘다.
...</p></div><footer class=entry-footer><span title='2024-11-05 02:11:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to System Test vs End-to-End Test" href=https://buenhyden.github.io/posts/quality-assurance/testing-techniques/system-test-vs-end-to-end-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>동적테스트(Dynamic Test) vs 정적테스트(Static Test)</h2></header><div class=entry-content><p>동적테스트(Dynamic Test)와 정적테스트(Static Test) 동적테스트 (Dynamic Test)과 정적테스트(Static Test)
소프트웨어 테스팅은 프로그램의 품질을 확인하고 오류를 찾아내는 과정.
이는 크게 정적 테스팅과 동적 테스팅으로 나눌 수 있다.
효과적인 테스팅을 위해서는 두 방식을 적절히 조합하여 사용하는 것이 중요하다.
예를 들어:
개발 초기 단계: 정적 테스팅으로 기본적인 문제 해결 코드 리뷰로 설계 문제 조기 발견 개발 중기: 단위 테스트로 개별 기능 검증 통합 테스트로 모듈 간 상호작용 확인 개발 후기: 시스템 테스트로 전체 기능 검증 성능 테스트로 실제 환경 적합성 확인 동적 테스트 (Dynamic Test) 소프트웨어 테스트 기법 중 하나로, 프로그램을 실제로 실행하면서 소프트웨어의 동작을 분석하고 평가하는 방법.
소프트웨어의 코드를 직접 실행시키며 수행하는 테스트 유형의 총칭.
소프트웨어의 런타임 동작을 관찰하고 평가하여 기능, 성능, 안정성 등을 검증한다.
...</p></div><footer class=entry-footer><span title='2024-11-05 02:35:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to 동적테스트(Dynamic Test) vs 정적테스트(Static Test)" href=https://buenhyden.github.io/posts/quality-assurance/dynamic-test-vs-static-test/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns</h2></header><div class=entry-content><p>Behavioral Design Patterns vs. Creational Design Patterns vs. Structural Design Patterns 참고 및 출처</p></div><footer class=entry-footer><span title='2024-09-25 08:30:00 +0000 UTC'>September 25, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Behavioral Design Patterns vs Creational Design Patterns vs Structural Design Patterns" href=https://buenhyden.github.io/posts/software-design-and-architecture/software-design-patterns/gof/behavioral-design-patterns-vs-creational-design-patterns-vs-structural-design-patterns/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/12/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/14/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>