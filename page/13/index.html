<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.147.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="기록하고 기억하고 적용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.8762af4fa9ee176c57f72565b721f234162fc7a9c882a271e0a1f68c4e89fb34.css integrity="sha256-h2KvT6nuF2xX9yVltyHyNBYvx6nIgqJx4KH2jE6J+zQ=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 적용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 적용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 적용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>import vs require</h2></header><div class=entry-content><p>Import vs. Require 참고 및 출처</p></div><footer class=entry-footer><span title='2024-11-23 03:21:00 +0000 UTC'>November 23, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to import vs require" href=https://buenhyden.github.io/posts/programming-languages/javascript-and-typescript/javascript/core-concepts/modules/import-vs-require/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Web Application Server (WAS) vs. Web Server</h2></header><div class=entry-content><p>Web Application Server (WAS) vs. Web Server Web Server와 Application Server는 모두 클라이언트 요청을 처리하고 응답을 반환하는 서버이지만, 역할과 기능에서 중요한 차이가 있다. 이 두 서버는 종종 함께 사용되며, 서로 보완적인 관계를 형성한다.
정의 및 주요 역할 Web Server 주로 정적 콘텐츠(HTML, CSS, JavaScript, 이미지 등)를 제공하는 서버이다. HTTP 프로토콜을 기반으로 클라이언트 요청에 응답한다. 정적 리소스를 빠르게 처리하며, 동적 요청은 Application Server로 전달하는 역할도 수행한다. Application Server 동적 콘텐츠를 생성하고 비즈니스 로직을 처리하는 서버이다. 데이터베이스와 상호작용하거나 애플리케이션 로직을 실행하여 클라이언트 요청에 따라 맞춤형 데이터를 반환한다. 동적 콘텐츠를 처리하기 때문에 복잡한 트랜잭션 관리 및 비즈니스 로직 수행이 가능하다. 기능 Web Server 정적 콘텐츠 제공: HTML, CSS, 이미지 파일 등. 요청 전달: 동적 콘텐츠 요청은 Application Server로 전달. 캐싱 및 로드 밸런싱: 웹사이트 성능 최적화를 위한 기능 제공. Application Server 동적 콘텐츠 생성: 클라이언트 요청에 따라 실시간으로 데이터를 생성. 비즈니스 로직 처리: 데이터베이스와 통신하거나 복잡한 연산 수행. 트랜잭션 관리: 다중 사용자 환경에서 데이터 일관성을 유지. 사용 사례 Web Server
...</p></div><footer class=entry-footer><span title='2024-10-22 07:36:00 +0000 UTC'>October 22, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Web Application Server (WAS) vs. Web Server" href=https://buenhyden.github.io/posts/backend/web-infrastructure/web-application-servers/web-application-server-vs-web-server/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cache Strategy vs Cache Policy</h2></header><div class=entry-content><p>Cache Strategy vs. Cache Policy 캐시 전략(Cache Strategy)과 캐시 정책(Cache Policy)은 컴퓨터 아키텍처에서 캐시 메모리의 효율적 운영을 위한 핵심 개념이다.
이 둘은 상호보완적이지만 명확한 차이가 있다.
캐시 전략(Cache Strategy) 캐시 전략은 시스템 전체의 캐시 사용 방식을 결정하는 상위 레벨의 설계 접근법을 의미한다.
주로 다음과 같은 요소를 포함한다:
계층적 구조: L1, L2, L3 캐시로 이어지는 메모리 계층 구조 설계 분산 캐시: 여러 서버에 캐시를 분산하여 처리 능력 확장 데이터 프리페칭: 프로세서가 필요로 할 데이터를 미리 예측하여 캐시에 로드 클라이언트 측 캐싱: 사용자 브라우저에 데이터 저장으로 서버 부하 감소 예시: 멀티코어 프로세서에서 L3 캐시를 공유하여 코어 간 데이터 일관성 유지
...</p></div><footer class=entry-footer><span title='2024-09-30 15:24:00 +0000 UTC'>September 30, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Cache Strategy vs Cache Policy" href=https://buenhyden.github.io/posts/system-design/caching/cache-strategy-vs-cache-policy/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>QA vs QC vs Testing</h2></header><div class=entry-content><p>Quality Assurance (QA) and Quality Control (QC) and Testing Quality Assurance (QA)는 제품이나 서비스의 품질을 보장하기 위한 계획적이고 체계적인 활동들의 집합이다.
QA는 프로세스 중심적이며, 품질 문제가 발생하기 전에 예방하는 것을 목표로 한다.
전체 개발 수명주기에 걸쳐 품질 기준과 절차를 수립하고 관리한다.
Quality Control (QC)는 개발된 제품이나 서비스가 정해진 품질 기준을 충족하는지 확인하는 활동이다.
QC는 제품 중심적이며, 실제 결과물을 검사하고 결함을 찾아내는 데 중점을 둔다.
주로 테스트와 검토를 통해 이루어진다.
Testing은 소프트웨어가 예상대로 작동하는지 확인하는 구체적인 실행 활동이다.
버그를 찾아내고, 시스템의 기능성과 성능을 검증하는 것이 주요 목적이다.
QC의 중요한 하위 활동으로 볼 수 있다.
...</p></div><footer class=entry-footer><span title='2024-11-05 07:13:00 +0000 UTC'>November 5, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to QA vs QC vs Testing" href=https://buenhyden.github.io/posts/quality-assurance/quality-assurance-vs-quality-control-vs-testing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Event-driven APIs vs. Pub and Sub APIs</h2></header><div class=entry-content><p>Event-driven APIs vs. Pub and Sub APIs 핵심 개념 요약 구분 Pub/Sub APIs Event-Driven APIs 정의 토픽 기반 메시지 브로커 시스템 상태 변화/이벤트 발생 시 신호 전달 시스템 주요 목적 생산자-소비자 간 비동기 메시징 실시간 이벤트 기반 시스템 반응성 향상 표준 구현 예시 Google Cloud Pub/Sub, Apache Kafka AWS EventBridge, Webhook, MQTT Pub/Sub API (발행-구독 API) Pub/Sub 패턴은 메시지 발행자(Publisher)와 구독자(Subscriber) 사이의 느슨한 결합을 제공하는 메시징 패러다임이다. 발행자는 특정 주제(Topic)에 메시지를 발행하고, 해당 주제를 구독한 모든 구독자는 이 메시지를 수신한다. 이 과정에서 발행자와 구독자는 서로에 대해 직접적인 정보를 알 필요가 없다.
...</p></div><footer class=entry-footer><span title='2025-04-04 06:02:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Event-driven APIs vs. Pub and Sub APIs" href=https://buenhyden.github.io/posts/backend/event-and-message-brokers/event-driven-apis-vs-pub-and-sub-apis/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Load Shifting vs. Load Balancing</h2></header><div class=entry-content><p>Load Shifting vs. Load Balancing 네트워크와 시스템 관리에서 부하 관리는 시스템의 안정성과 효율성을 유지하는 핵심 요소이다. 특히 로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.
로드 밸런싱(Load Balancing) 로드 밸런싱은 네트워크 트래픽이나 작업 부하를 여러 서버나 리소스에 고르게 분산시키는 기술이다. 이는 주로 실시간으로 이루어지며, 시스템의 전체적인 성능과 가용성을 향상시키는 것이 목적이다.
주요 특징 목적: 시스템 성능 최적화, 가용성 향상, 응답 시간 개선 타이밍: 실시간 또는 거의 실시간으로 작동 분배 방식: 여러 리소스에 작업을 균등하게 분산 적용 사례: 웹 서버 클러스터, 데이터베이스 클러스터, 컴퓨팅 그리드 로드 밸런싱 알고리즘 라운드 로빈(Round Robin): 순차적으로 각 서버에 요청을 할당한다.
...</p></div><footer class=entry-footer><span title='2025-04-04 02:45:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Shifting vs. Load Balancing" href=https://buenhyden.github.io/posts/system-design/migration-strategies/load-shifting/load-shifting-vs-load-balancing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OAuth 2.0 vs. OpenID Connect</h2></header><div class=entry-content><p>OAuth 2.0 vs. OpenID Connect 개요 및 역사적 배경 OAuth 2.0 OAuth 2.0은 2012년에 IETF(Internet Engineering Task Force)에서 RFC 6749로 표준화된 인가(Authorization) 프레임워크이다. 이는 2007년에 발표된 OAuth 1.0의 후속 버전으로, 더 단순하고 확장 가능한 구현을 목표로 개발되었다. OAuth 2.0은 애플리케이션이 사용자 데이터에 접근할 수 있는 권한을 안전하게 위임하는 메커니즘을 제공한다.
OpenID Connect OpenID Connect(OIDC)는 2014년 OpenID Foundation에서 공식 발표한 OAuth 2.0 위에 구축된 ID 인증 레이어이다. OAuth 2.0이 주로 인가에 초점을 맞추고 있는 반면, OpenID Connect는 인증(Authentication)과 신원 확인 기능을 추가했다. OIDC는 이전 버전인 OpenID 2.0의 복잡성을 해결하고, OAuth 2.0과의 호환성을 제공하기 위해 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-03 14:02:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth 2.0 vs. OpenID Connect" href=https://buenhyden.github.io/posts/security/access-control/authentication/protocols/oauth/oauth-20-vs-openid-connect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OAuth 2.0</h2></header><div class=entry-content><p>JWT vs. OAuth 2.0 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 컴팩트하고 자체 완결적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0
OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다. 주요 목적과 용도 JWT의 목적
...</p></div><footer class=entry-footer><span title='2025-04-03 07:30:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OAuth 2.0" href=https://buenhyden.github.io/posts/security/access-control/authentication/implementations/token-based-authentication/jwt/jwt-vs-oauth-20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. SAML</h2></header><div class=entry-content><p>Token Authentication vs. SAML 토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(보통 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후 요청에서 인증을 처리하는 방식이다.
기본 개념 및 작동 원리 인증 흐름: 사용자가 로그인 정보(ID/비밀번호)를 제출한다. 서버는 이를 검증하고 서명된 토큰을 생성한다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킨다. 서버는 토큰의 서명과 내용을 검증하여 사용자를 인증한다. 토큰 형식: 가장 일반적인 형식은 JWT(JSON Web Token)이다. JWT는 헤더, 페이로드, 서명의 세 부분으로 구성된다. 토큰은 Base64Url로 인코딩되어 HTTP 헤더로 전송된다. 주요 특징 무상태(Stateless): 서버는 세션 상태를 저장할 필요가 없다. 확장성: 서버 간에 세션 정보를 공유할 필요가 없어 수평적 확장이 용이한다. 클라이언트 중심: 토큰은 클라이언트에 저장되고 관리된다. 다양한 플랫폼 지원: 웹, 모바일, API 등 다양한 환경에서 사용 가능하다. 자체 포함적(Self-contained): 토큰 자체에 사용자 정보와 권한이 포함될 수 있다. SAML(Security Assertion Markup Language) SAML은 서로 다른 도메인 간에 인증 및 권한 부여 데이터를 교환하기 위한 XML 기반 표준이다. 주로 엔터프라이즈 환경에서 SSO(Single Sign-On)를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:23:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. SAML" href=https://buenhyden.github.io/posts/security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-saml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. JWT</h2></header><div class=entry-content><p>Token Authentication vs. JWT 토큰 인증과 JWT는 모두 현대적인 웹 애플리케이션에서 사용자 인증을 관리하는 방법이지만, 이 둘 사이에는 중요한 차이점이 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다.
기본 개념 및 특징 일반적 작동 방식: 사용자가 자격 증명(username/password)을 제출한다. 서버는 이를 검증하고 고유한 토큰을 생성한다. 클라이언트는 이 토큰을 저장하고 향후 요청 시 제시한다. 서버는 토큰을 검증하여 사용자를 식별한다. 토큰 형태: 단순 무작위 문자열(UUID 등) 해시된 값 인코딩된 데이터 구조(JWT, SAML 등) 암호화된 페이로드 서버 측 저장: 대부분의 전통적인 토큰 시스템은 서버 측 저장소(데이터베이스, 캐시 등)에 토큰 정보를 보관한다. 토큰 자체는 단순한 식별자 역할을 하며, 관련 정보는 서버에서 조회한다. 토큰 관리: 서버가 발급한 토큰의 유효성을 관리한다. 만료, 폐기, 갱신 등의 작업이 서버 측에서 제어된다. JWT(JSON Web Token) JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다. JWT는 RFC 7519에 정의된 개방형 표준이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. JWT" href=https://buenhyden.github.io/posts/security/access-control/authentication/implementations/token-based-authentication/token-based-authentication-vs-jwt/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/12/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/14/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>