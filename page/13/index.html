<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.148.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>hyunyoun's Blog</title><meta name=keywords content="Blog,Portfolio"><meta name=description content="기록하고 기억하고 활용하자."><meta name=author content="Me"><link rel=canonical href=https://buenhyden.github.io/><meta name=google-site-verification content="googlee06938ebbfcbac49.html"><link crossorigin=anonymous href=/assets/css/stylesheet.a9863521b3bd3c240bc506f46b95e3c06ccef2ae37f529d5f99bdaef442bccce.css integrity="sha256-qYY1IbO9PCQLxQb0a5XjwGzO8q439SnV+Zva70QrzM4=" rel="preload stylesheet" as=style><link rel=icon href=https://buenhyden.github.io/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://buenhyden.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://buenhyden.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://buenhyden.github.io/favicons/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://buenhyden.github.io/index.xml><link rel=alternate type=application/json href=https://buenhyden.github.io/index.json><link rel=alternate hreflang=en href=https://buenhyden.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3156423099418350" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-W8XTMYPTLC"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-W8XTMYPTLC")}</script><meta property="og:url" content="https://buenhyden.github.io/"><meta property="og:site_name" content="hyunyoun's Blog"><meta property="og:title" content="Hyunyoun's 개발 블로그"><meta property="og:description" content="기록하고 기억하고 활용하자."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://buenhyden.github.io/images"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://buenhyden.github.io/images"><meta name=twitter:title content="Hyunyoun's 개발 블로그"><meta name=twitter:description content="기록하고 기억하고 활용하자."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"hyunyoun's Blog","url":"https://buenhyden.github.io/","description":"기록하고 기억하고 활용하자.","logo":"https://buenhyden.github.io/favicons/favicon.ico","sameAs":["https://github.com/buenhyden","https://www.linkedin.com/in/hyunyoun-jo-9ba782164/","mailto:chochyjj@gmail.com"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://buenhyden.github.io/ accesskey=h title="Hy's Blog (Alt + H)"><img src=https://buenhyden.github.io/favicons/apple-touch-icon.png alt aria-label=logo height=35>Hy's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://buenhyden.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://buenhyden.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://buenhyden.github.io/til/ title="Today I Learned"><span>Today I Learned</span></a></li><li><a href=https://buenhyden.github.io/coding-test/ title="Coding Test"><span>Coding Test</span></a></li><li><a href=https://buenhyden.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://buenhyden.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://buenhyden.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GRASP vs. SOLID</h2></header><div class=entry-content><p>GRASP vs. SOLID GRASP 와 SOLID 는 상호 보완적인 객체지향 설계 원칙으로, GRASP 는 " 누가 무엇을 해야 하는가 " 에 대한 구체적인 책임 할당 패턴을 제공하고, SOLID 는 " 어떻게 설계해야 하는가 " 에 대한 포괄적인 설계 원칙을 제시한다. 두 원칙 모두 낮은 결합도, 높은 응집도, 확장성, 유지보수성을 목표로 하며, 현대 소프트웨어 개발에서 필수적인 설계 가이드라인이다.
핵심 개념 구분 항목 정의/설명 설계 목적 및 효과 GRASP 정의 객체지향 설계에서 책임 할당과 객체 간 협력을 효과적으로 하기 위한 9 가지 설계 패턴 세트 책임 분산, 구조적 안정성 확보, 결합도 최소화 핵심 패턴 - Information Expert
- Creator
- Controller
- Low Coupling
- High Cohesion
- Polymorphism
- Pure Fabrication
- Indirection
- Protected Variations 객체 간 책임 할당 원칙, 협력 방식 정의 주요 설계 방향 객체에 적절한 책임 부여, 변화에 강한 유연한 구조 설계 응집도 ↑, 결합도 ↓, 변경 영향 최소화 SOLID 정의 객체지향 설계에서 유지보수성과 확장성을 높이기 위한 5 가지 원칙을 나타내는 약어 확장 가능하고 견고한 소프트웨어 구조 확립 핵심 원칙 - SRP (단일 책임 원칙)
- OCP (개방 - 폐쇄 원칙)
- LSP (리스코프 치환 원칙)
- ISP (인터페이스 분리 원칙)
- DIP (의존 역전 원칙) 클래스와 모듈 단위의 구조 품질 향상 주요 설계 방향 변화에 유연한 클래스 설계, 테스트 용이성 강화, 인터페이스 기반 추상화 유지보수성 ↑, 재사용성 ↑, 확장성 ↑ GRASP vs. SOLID 비교 GRASP 와 SOLID 는 객체지향 설계에서 서로 다른 측면을 강조한다. GRASP 는 객체에 책임을 어떻게 할당할지를 중심으로 하며, SOLID 는 클래스 설계의 원칙을 통해 코드의 유연성과 유지보수성을 강조한다.
...</p></div><footer class=entry-footer><span title='2025-06-03 03:02:00 +0000 UTC'>June 3, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to GRASP vs. SOLID" href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/design-principles/grasp/grasp-vs-solid/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Failback vs. Fail Over</h2></header><div class=entry-content><p>Failback vs. Fail Over Failover 와 Failback 은 고가용성과 재해 복구 전략에서 중요한 이중 절차이다. 페일오버 (Failover) 는 Active-Passive/Active-Active 구성에서 장애 감지 후 트래픽 전환을 수행하며, AWS ELB, Kubernetes Pod 재배치 등에 적용된다. 페일백 (Failback) 은 데이터 동기화 검증 후 점진적 복구를 수행하며, DB 복제본 재동기화, 클라우드 리전 복구 시나리오에서 활용된다.
설계 방식에 따라 RTO(Recovery Time Objective) 와 RPO(Recovery Point Objective) 에 큰 영향을 미친다.
2025 년 현재 AI 기반 자동 전환 알고리즘과 블록체인 검증 기술이 접목되는 추세이다.
...</p></div><footer class=entry-footer><span title='2025-05-18 12:46:00 +0000 UTC'>May 18, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Failback vs. Fail Over" href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture-patterns/resilience-and-reliability/fault-tolerance/failure-recovery/failback-patterns/failback-vs-fail-over/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Availability in Numbers</h2></header><div class=entry-content><p>Availability in Numbers “Availability in Numbers” 는 분산 시스템에서 서비스의 지속적인 접근성을 수치로 표현하고 설계하는 방법론이다. 가용성은 업타임 대 전체 운영 시간의 비율로 계산되며, 일반적으로 ‘9 의 개수 ‘(예: 99.9%, 99.999%) 로 표현된다. 이 수치는 허용 가능한 연간, 월간, 일간 다운타임을 결정하며, 시스템 설계 시 중복성 구현, 장애 감지 및 복구 메커니즘, 분산 아키텍처 패턴 등을 통해 달성된다. 가용성 설계는 시스템의 중요성, 비용, 성능 간의 균형을 고려하여 비즈니스 요구에 맞게 조정되어야 하며, 다양한 가용성 패턴을 적용해 단일 장애점을 제거하는 것이 핵심이다.
...</p></div><footer class=entry-footer><span title='2025-05-15 05:00:00 +0000 UTC'>May 15, 2025</span>&nbsp;·&nbsp;30 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Availability in Numbers" href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture/quality-attributes/run-time-reliability-and-efficiency/availability/availability-in-numbers/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Messaging Systems</h2></header><div class=entry-content><p>Messaging Systems 메시징 시스템 (Messaging Systems) 은 애플리케이션 또는 서비스 간 메시지를 안전하게 송수신하는 미들웨어로, 비동기 통신, 결합도 감소, 확장성, 장애 복원력, 실시간 데이터 처리 등 백엔드 시스템의 핵심 요구사항을 충족한다. 대표적으로 메시지 큐, 이벤트 스트리밍 플랫폼, 태스크 큐 등이 있으며, 각각 작업 분산, 실시간 이벤트 처리, 대규모 데이터 파이프라인 등 다양한 시나리오에 활용된다. 현대 분산 시스템과 마이크로서비스 아키텍처에서 메시징 시스템은 필수적이다.
핵심 개념 메시징 시스템 (Messaging Systems) 은 독립적인 소프트웨어 구성 요소 간의 비동기 통신을 가능하게 하는 인프라이다. 이를 통해 시스템의 결합도를 낮추고, 확장성과 장애 허용성을 향상시킬 수 있다.
...</p></div><footer class=entry-footer><span title='2025-04-22 13:59:00 +0000 UTC'>April 22, 2025</span>&nbsp;·&nbsp;35 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Messaging Systems" href=https://buenhyden.github.io/posts/system-design/message-oriented-systems/message-processing-systems/messaging-systems/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Queue vs. Topic</h2></header><div class=entry-content><p>Queue vs. Topic Queue 와 Topic 은 메시지 기반 시스템에서 데이터 전달 구조의 핵심 요소로, 시스템 아키텍처와 소비자 처리 방식에 따라 선택된다. Queue 는 Point-to-Point 방식으로 하나의 소비자에게 메시지를 전달하며 작업 분산에 유리하다. 반면 Topic 은 Publish-Subscribe 모델로, 다수의 구독자가 동일한 메시지를 수신할 수 있어 이벤트 브로드캐스팅이나 실시간 알림에 적합하다. 각 방식은 메시지 순서, 중복 수신, 확장성 등 다양한 구현 요소에서 차이를 가지며, 적절한 선택이 시스템 안정성과 확장성에 큰 영향을 미친다.
...</p></div><footer class=entry-footer><span title='2025-04-22 13:39:00 +0000 UTC'>April 22, 2025</span>&nbsp;·&nbsp;32 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Queue vs. Topic" href=https://buenhyden.github.io/posts/system-design/message-oriented-systems/messaging-fundamentals/queue-vs-topic/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Load Shifting vs. Load Balancing</h2></header><div class=entry-content><p>Load Shifting vs. Load Balancing 네트워크와 시스템 관리에서 부하 관리는 시스템의 안정성과 효율성을 유지하는 핵심 요소이다. 특히 로드 시프팅과 로드 밸런싱은 자주 혼동되지만 실제로는 매우 다른 개념과 목적을 가지고 있다. 두 기술 모두 시스템 자원을 최적화하는 데 사용되지만, 접근 방식과 적용 시나리오가 다르다.
로드 밸런싱(Load Balancing) 로드 밸런싱은 네트워크 트래픽이나 작업 부하를 여러 서버나 리소스에 고르게 분산시키는 기술이다. 이는 주로 실시간으로 이루어지며, 시스템의 전체적인 성능과 가용성을 향상시키는 것이 목적이다.
주요 특징 목적: 시스템 성능 최적화, 가용성 향상, 응답 시간 개선 타이밍: 실시간 또는 거의 실시간으로 작동 분배 방식: 여러 리소스에 작업을 균등하게 분산 적용 사례: 웹 서버 클러스터, 데이터베이스 클러스터, 컴퓨팅 그리드 로드 밸런싱 알고리즘 라운드 로빈(Round Robin): 순차적으로 각 서버에 요청을 할당한다.
...</p></div><footer class=entry-footer><span title='2025-04-04 02:45:00 +0000 UTC'>April 4, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Load Shifting vs. Load Balancing" href=https://buenhyden.github.io/posts/software-engineering/software-design-and-architecture/architecture-patterns/performance-and-scalability/load-management/load-shifting/load-shifting-vs-load-balancing/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>OAuth 2.0 vs. OpenID Connect</h2></header><div class=entry-content><p>OAuth 2.0 vs. OpenID Connect 개요 및 역사적 배경 OAuth 2.0 OAuth 2.0은 2012년에 IETF(Internet Engineering Task Force)에서 RFC 6749로 표준화된 인가(Authorization) 프레임워크이다. 이는 2007년에 발표된 OAuth 1.0의 후속 버전으로, 더 단순하고 확장 가능한 구현을 목표로 개발되었다. OAuth 2.0은 애플리케이션이 사용자 데이터에 접근할 수 있는 권한을 안전하게 위임하는 메커니즘을 제공한다.
OpenID Connect OpenID Connect(OIDC)는 2014년 OpenID Foundation에서 공식 발표한 OAuth 2.0 위에 구축된 ID 인증 레이어이다. OAuth 2.0이 주로 인가에 초점을 맞추고 있는 반면, OpenID Connect는 인증(Authentication)과 신원 확인 기능을 추가했다. OIDC는 이전 버전인 OpenID 2.0의 복잡성을 해결하고, OAuth 2.0과의 호환성을 제공하기 위해 개발되었다.
...</p></div><footer class=entry-footer><span title='2025-04-03 14:02:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to OAuth 2.0 vs. OpenID Connect" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/authentication-protocols/oauth-2.0/oauth-20-vs-openid-connect/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>JWT vs. OAuth 2.0</h2></header><div class=entry-content><p>JWT vs. OAuth 2.0 기본 개념 JWT (JSON Web Token)
JWT는 당사자 간에 안전하게 정보를 JSON 객체로 전송하기 위한 컴팩트하고 자체 완결적인 방식이다. 이 정보는 디지털 서명되어 있어 신뢰할 수 있다. JWT는 주로 인증(Authentication)과 정보 교환을 위해 사용된다. OAuth 2.0
OAuth 2.0은 사용자가 자신의 정보에 대한 접근 권한을 제3자 애플리케이션에 부여할 수 있게 해주는 인가(Authorization) 프레임워크이다. 사용자가 비밀번호를 공유하지 않고도 제한된 접근 권한을 제3자에게 제공할 수 있다. 주요 목적과 용도 JWT의 목적
...</p></div><footer class=entry-footer><span title='2025-04-03 07:30:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to JWT vs. OAuth 2.0" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/jwt/jwt-vs-oauth-20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. SAML</h2></header><div class=entry-content><p>Token Authentication vs. SAML 토큰 인증(Token Authentication) 토큰 인증은 사용자의 자격 증명(보통 사용자 이름과 비밀번호)을 검증한 후, 서버가 발급한 토큰을 통해 이후 요청에서 인증을 처리하는 방식이다.
기본 개념 및 작동 원리 인증 흐름: 사용자가 로그인 정보(ID/비밀번호)를 제출한다. 서버는 이를 검증하고 서명된 토큰을 생성한다. 클라이언트는 토큰을 저장하고 이후 요청에 포함시킨다. 서버는 토큰의 서명과 내용을 검증하여 사용자를 인증한다. 토큰 형식: 가장 일반적인 형식은 JWT(JSON Web Token)이다. JWT는 헤더, 페이로드, 서명의 세 부분으로 구성된다. 토큰은 Base64Url로 인코딩되어 HTTP 헤더로 전송된다. 주요 특징 무상태(Stateless): 서버는 세션 상태를 저장할 필요가 없다. 확장성: 서버 간에 세션 정보를 공유할 필요가 없어 수평적 확장이 용이한다. 클라이언트 중심: 토큰은 클라이언트에 저장되고 관리된다. 다양한 플랫폼 지원: 웹, 모바일, API 등 다양한 환경에서 사용 가능하다. 자체 포함적(Self-contained): 토큰 자체에 사용자 정보와 권한이 포함될 수 있다. SAML(Security Assertion Markup Language) SAML은 서로 다른 도메인 간에 인증 및 권한 부여 데이터를 교환하기 위한 XML 기반 표준이다. 주로 엔터프라이즈 환경에서 SSO(Single Sign-On)를 구현하는 데 사용된다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:23:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. SAML" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-saml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Token Authentication vs. JWT</h2></header><div class=entry-content><p>Token Authentication vs. JWT 토큰 인증과 JWT는 모두 현대적인 웹 애플리케이션에서 사용자 인증을 관리하는 방법이지만, 이 둘 사이에는 중요한 차이점이 있다.
토큰 인증(Token Authentication) 토큰 인증은 사용자의 인증 정보를 검증한 후 서버가 고유한 토큰을 발급하고, 클라이언트가 이후 요청 시 이 토큰을 제시하여 자신을 인증하는 광범위한 인증 패러다임이다.
기본 개념 및 특징 일반적 작동 방식: 사용자가 자격 증명(username/password)을 제출한다. 서버는 이를 검증하고 고유한 토큰을 생성한다. 클라이언트는 이 토큰을 저장하고 향후 요청 시 제시한다. 서버는 토큰을 검증하여 사용자를 식별한다. 토큰 형태: 단순 무작위 문자열(UUID 등) 해시된 값 인코딩된 데이터 구조(JWT, SAML 등) 암호화된 페이로드 서버 측 저장: 대부분의 전통적인 토큰 시스템은 서버 측 저장소(데이터베이스, 캐시 등)에 토큰 정보를 보관한다. 토큰 자체는 단순한 식별자 역할을 하며, 관련 정보는 서버에서 조회한다. 토큰 관리: 서버가 발급한 토큰의 유효성을 관리한다. 만료, 폐기, 갱신 등의 작업이 서버 측에서 제어된다. JWT(JSON Web Token) JWT는 토큰 인증의 한 형태로, 정보를 안전하게 전송하기 위한 컴팩트하고 자체 포함적인(self-contained) JSON 객체이다. JWT는 RFC 7519에 정의된 개방형 표준이다.
...</p></div><footer class=entry-footer><span title='2025-04-03 07:22:00 +0000 UTC'>April 3, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Me</footer><a class=entry-link aria-label="post link to Token Authentication vs. JWT" href=https://buenhyden.github.io/posts/cybersecurity-and-information-security/identity-and-access-management/authentication-systems/session-and-token-management/token-based-authentication/token-based-authentication-vs-jwt/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://buenhyden.github.io/page/12/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://buenhyden.github.io/page/14/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://buenhyden.github.io/>hyunyoun's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>